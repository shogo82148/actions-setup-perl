@rem = '--*-Perl-*--
@set "ErrorLevel="
@if "%OS%" == "Windows_NT" @goto WinNT
@perl -x -S "%0" %1 %2 %3 %4 %5 %6 %7 %8 %9
@set ErrorLevel=%ErrorLevel%
@goto endofperl
:WinNT
@perl -x -S %0 %*
@set ErrorLevel=%ErrorLevel%
@if NOT "%COMSPEC%" == "%SystemRoot%\system32\cmd.exe" @goto endofperl
@if %ErrorLevel% == 9009 @echo You do not have Perl in your PATH.
@goto endofperl
@rem ';
#!/usr/bin/env perl
#line 16
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"CPAN/Common/Index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index;our$VERSION='0.010';use Carp ();use Class::Tiny;sub index_age {time}sub refresh_index {1}sub attributes {{}}sub validate_attributes {1}1;
CPAN_COMMON_INDEX

$fatpacked{"CPAN/Common/Index/LocalPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_LOCALPACKAGE';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::LocalPackage;our$VERSION='0.010';use parent 'CPAN::Common::Index::Mirror';use Class::Tiny qw/source/;use Carp;use File::Basename ();use File::Copy ();use File::Spec;use File::stat ();sub BUILD {my$self=shift;my$file=$self->source;if (!defined$file){Carp::croak("'source' parameter must be provided")}elsif (!-f $file){Carp::croak("index file '$file' does not exist")}return}sub cached_package {my ($self)=@_;my$package=File::Spec->catfile($self->cache,File::Basename::basename($self->source));$package =~ s/\.gz$//;$self->refresh_index unless -r $package;return$package}sub refresh_index {my ($self)=@_;my$source=$self->source;my$basename=File::Basename::basename($source);if ($source =~ /\.gz$/){Carp::croak "can't load gz source files without IO::Uncompress::Gunzip\n" unless$CPAN::Common::Index::Mirror::HAS_IO_UNCOMPRESS_GUNZIP;(my$uncompressed=$basename)=~ s/\.gz$//;$uncompressed=File::Spec->catfile($self->cache,$uncompressed);if (!-f $uncompressed or File::stat::stat($source)->mtime > File::stat::stat($uncompressed)->mtime){no warnings 'once';IO::Uncompress::Gunzip::gunzip(map {"$_"}$source,$uncompressed)or Carp::croak "gunzip failed: $IO::Uncompress::Gunzip::GunzipError\n"}}else {my$dest=File::Spec->catfile($self->cache,$basename);File::Copy::copy($source,$dest)if!-e $dest || File::stat::stat($source)->mtime > File::stat::stat($dest)->mtime}return 1}sub search_authors {return};1;
CPAN_COMMON_INDEX_LOCALPACKAGE

$fatpacked{"CPAN/Common/Index/MetaDB.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_METADB';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::MetaDB;our$VERSION='0.010';use parent 'CPAN::Common::Index';use Class::Tiny qw/uri/;use Carp;use CPAN::Meta::YAML;use HTTP::Tiny;sub BUILD {my$self=shift;my$uri=$self->uri;$uri="http://cpanmetadb.plackperl.org/v1.0/" unless defined$uri;$uri =~ s{/?$}{/};$self->uri($uri);return}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';return unless keys %$args==1 && exists$args->{package}&& ref$args->{package}eq '';my$mod=$args->{package};my$res=HTTP::Tiny->new->get($self->uri ."package/$mod");return unless$res->{success};if (my$yaml=CPAN::Meta::YAML->read_string($res->{content})){my$meta=$yaml->[0];if ($meta && $meta->{distfile}){my$file=$meta->{distfile};$file =~ s{^./../}{};return {package=>$mod,version=>$meta->{version},uri=>"cpan:///distfile/$file",}}}return}sub index_age {return time};sub search_authors {return};1;
CPAN_COMMON_INDEX_METADB

$fatpacked{"CPAN/Common/Index/Mirror.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_MIRROR';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::Mirror;our$VERSION='0.010';use parent 'CPAN::Common::Index';use Class::Tiny qw/cache mirror/;use Carp;use CPAN::DistnameInfo;use File::Basename ();use File::Fetch;use File::Temp 0.19;use Search::Dict 1.07;use Tie::Handle::SkipHeader;use URI;our$HAS_IO_UNCOMPRESS_GUNZIP=eval {require IO::Uncompress::Gunzip};sub BUILD {my$self=shift;my$cache=$self->cache;$cache=File::Temp->newdir unless defined$cache;if (!-d $cache){Carp::croak("Cache directory '$cache' does not exist")}$self->cache($cache);my$mirror=$self->mirror;$mirror="http://www.cpan.org/" unless defined$mirror;$mirror =~ s{/?$}{/};$self->mirror($mirror);return}my%INDICES=(mailrc=>'authors/01mailrc.txt.gz',packages=>'modules/02packages.details.txt.gz',);my%TEST_GENERATORS=(regexp_nocase=>sub {my$arg=shift;my$re=ref$arg eq 'Regexp' ? $arg : qr/\A\Q$arg\E\z/i;return sub {$_[0]=~ $re}},regexp=>sub {my$arg=shift;my$re=ref$arg eq 'Regexp' ? $arg : qr/\A\Q$arg\E\z/;return sub {$_[0]=~ $re}},version=>sub {my$arg=shift;my$v=version->parse($arg);return sub {eval {version->parse($_[0])==$v}}},);my%QUERY_TYPES=(package=>'regexp',version=>'version',dist=>'regexp',id=>'regexp_nocase',fullname=>'regexp_nocase',email=>'regexp_nocase',);sub cached_package {my ($self)=@_;my$package=File::Spec->catfile($self->cache,File::Basename::basename($INDICES{packages}));$package =~ s/\.gz$//;$self->refresh_index unless -r $package;return$package}sub cached_mailrc {my ($self)=@_;my$mailrc=File::Spec->catfile($self->cache,File::Basename::basename($INDICES{mailrc}));$mailrc =~ s/\.gz$//;$self->refresh_index unless -r $mailrc;return$mailrc}sub refresh_index {my ($self)=@_;for my$file (values%INDICES){my$remote=URI->new_abs($file,$self->mirror);$remote =~ s/\.gz$// unless$HAS_IO_UNCOMPRESS_GUNZIP;my$ff=File::Fetch->new(uri=>$remote);my$where=$ff->fetch(to=>$self->cache)or Carp::croak($ff->error);if ($HAS_IO_UNCOMPRESS_GUNZIP){(my$uncompressed=$where)=~ s/\.gz$//;no warnings 'once';IO::Uncompress::Gunzip::gunzip($where,$uncompressed)or Carp::croak "gunzip failed: $IO::Uncompress::Gunzip::GunzipError\n"}}return 1}sub index_age {my ($self)=@_;my$package=$self->cached_package;return (-r $package ? (stat($package))[9]: 0)}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';my$index_path=$self->cached_package;die "Can't read $index_path" unless -r $index_path;my$fh=IO::Handle->new;tie *$fh,'Tie::Handle::SkipHeader',"<",$index_path or die "Can't tie $index_path: $!";my$rules;while (my ($k,$v)=each %$args){$rules->{$k}=_rulify($k,$v)}my@found;if ($args->{package}and ref$args->{package}eq ''){my$pos=look$fh,$args->{package},{xfrm=>\&_xform_package,fold=>1 };return if$pos==-1;LINE: while (my$line=<$fh>){last unless$line =~ /\A\Q$args->{package}\E\s+/i;push@found,_match_package_line($line,$rules)}}else {LINE: while (my$line=<$fh>){push@found,_match_package_line($line,$rules)}}return wantarray ? @found : $found[0]}sub search_authors {my ($self,$args)=@_;Carp::croak("Argument to search_authors must be hash reference")unless ref$args eq 'HASH';my$index_path=$self->cached_mailrc;die "Can't read $index_path" unless -r $index_path;open my$fh,$index_path or die "Can't open $index_path: $!";my$rules;while (my ($k,$v)=each %$args){$rules->{$k}=_rulify($k,$v)}my@found;if ($args->{id}and ref$args->{id}eq ''){my$pos=look$fh,$args->{id},{xfrm=>\&_xform_mailrc,fold=>1 };return if$pos==-1;my$line=<$fh>;push@found,_match_mailrc_line($line,$rules)}else {LINE: while (my$line=<$fh>){push@found,_match_mailrc_line($line,$rules)}}return wantarray ? @found : $found[0]}sub _rulify {my ($key,$arg)=@_;return$arg if ref($arg)eq 'CODE';return$TEST_GENERATORS{$QUERY_TYPES{$key}}->($arg)}sub _xform_package {my@fields=split " ",$_[0],2;return$fields[0]}sub _xform_mailrc {my@fields=split " ",$_[0],3;return$fields[1]}sub _match_package_line {my ($line,$rules)=@_;return unless defined$line;my ($mod,$version,$dist,$comment)=split " ",$line,4;if ($rules->{package}){return unless$rules->{package}->($mod)}if ($rules->{version}){return unless$rules->{version}->($version)}if ($rules->{dist}){return unless$rules->{dist}->($dist)}$dist =~ s{\A./../}{};return {package=>$mod,version=>$version,uri=>"cpan:///distfile/$dist",}}sub _match_mailrc_line {my ($line,$rules)=@_;return unless defined$line;my ($id,$address)=$line =~ m{\Aalias\s+(\S+)\s+"(.*)"};my ($fullname,$email)=$address =~ m{([^<]+)<([^>]+)>};$fullname =~ s/\s*$//;if ($rules->{id}){return unless$rules->{id}->($id)}if ($rules->{fullname}){return unless$rules->{fullname}->($fullname)}if ($rules->{email}){return unless$rules->{email}->($email)}return {id=>$id,fullname=>$fullname,email=>$email,}}1;
CPAN_COMMON_INDEX_MIRROR

$fatpacked{"CPAN/Common/Index/Mux/Ordered.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_MUX_ORDERED';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::Mux::Ordered;our$VERSION='0.010';use parent 'CPAN::Common::Index';use Class::Tiny qw/resolvers/;use Module::Load ();sub BUILD {my$self=shift;my$resolvers=$self->resolvers;$resolvers=[]unless defined$resolvers;if (ref$resolvers ne 'ARRAY'){Carp::croak("The 'resolvers' argument must be an array reference")}for my$r (@$resolvers){if (!eval {$r->isa("CPAN::Common::Index")}){Carp::croak("Resolver '$r' is not a CPAN::Common::Index object")}}$self->resolvers($resolvers);return}sub assemble {my ($class,@backends)=@_;my@resolvers;while (@backends){my ($subclass,$config)=splice@backends,0,2;my$full_class="CPAN::Common::Index::${subclass}";eval {Module::Load::load($full_class);1}or Carp::croak($@);my$object=$full_class->new($config);push@resolvers,$object}return$class->new({resolvers=>\@resolvers })}sub validate_attributes {my ($self)=@_;my$resolvers=$self->resolvers;return 1}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';my@found;if ($args->{name}and ref$args->{name}eq ''){for my$source (@{$self->resolvers}){if (my@result=$source->search_packages($args)){push@found,@result;last}}}else {my%seen;for my$source (@{$self->resolvers}){my@result=$source->search_packages($args);push@found,grep {!$seen{$_->{package}}++}@result}}return wantarray ? @found : $found[0]}sub search_authors {my ($self,$args)=@_;Carp::croak("Argument to search_authors must be hash reference")unless ref$args eq 'HASH';my@found;if ($args->{name}and ref$args->{name}eq ''){for my$source (@{$self->resolvers}){if (my@result=$source->search_authors($args)){push@found,@result;last}}}else {my%seen;for my$source (@{$self->resolvers}){my@result=$source->search_authors($args);push@found,grep {!$seen{$_->{package}}++}@result}}return wantarray ? @found : $found[0]}1;
CPAN_COMMON_INDEX_MUX_ORDERED

$fatpacked{"CPAN/DistnameInfo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_DISTNAMEINFO';
  package CPAN::DistnameInfo;$VERSION="0.12";use strict;sub distname_info {my$file=shift or return;my ($dist,$version)=$file =~ /^
      ((?:[-+.]*(?:[A-Za-z0-9]+|(?<=\D)_|_(?=\D))*
       (?:
  	[A-Za-z](?=[^A-Za-z]|$)
  	|
  	\d(?=-)
       )(?<![._-][vV])
      )+)(.*)
    $/xs or return ($file,undef,undef);if ($dist =~ /-undef\z/ and!length$version){$dist =~ s/-undef\z//}$version =~ s/-withoutworldwriteables$//;if ($version =~ /^(-[Vv].*)-(\d.*)/){$dist .= $1;$version=$2}if ($version =~ /(.+_.*)-(\d.*)/){$dist .= $1;$version=$2}$dist =~ s{\.pm$}{};$version=$1 if!length$version and $dist =~ s/-(\d+\w)$//;$version=$1 .$version if$version =~ /^\d+$/ and $dist =~ s/-(\w+)$//;if ($version =~ /\d\.\d/){$version =~ s/^[-_.]+//}else {$version =~ s/^[-_]+//}my$dev;if (length$version){if ($file =~ /^perl-?\d+\.(\d+)(?:\D(\d+))?(-(?:TRIAL|RC)\d+)?$/){$dev=1 if (($1 > 6 and $1 & 1)or ($2 and $2 >= 50))or $3}elsif ($version =~ /\d\D\d+_\d/ or $version =~ /-TRIAL/){$dev=1}}else {$version=undef}($dist,$version,$dev)}sub new {my$class=shift;my$distfile=shift;$distfile =~ s,//+,/,g;my%info=(pathname=>$distfile);($info{filename}=$distfile)=~ s,^(((.*?/)?authors/)?id/)?([A-Z])/(\4[A-Z])/(\5[-A-Z0-9]*)/,, and $info{cpanid}=$6;if ($distfile =~ m,([^/]+)\.(tar\.(?:g?z|bz2)|zip|tgz)$,i){$info{distvname}=$1;$info{extension}=$2}@info{qw(dist version beta)}=distname_info($info{distvname});$info{maturity}=delete$info{beta}? 'developer' : 'released';return bless \%info,$class}sub dist {shift->{dist}}sub version {shift->{version}}sub maturity {shift->{maturity}}sub filename {shift->{filename}}sub cpanid {shift->{cpanid}}sub distvname {shift->{distvname}}sub extension {shift->{extension}}sub pathname {shift->{pathname}}sub properties {%{$_[0]}}1;
CPAN_DISTNAMEINFO

$fatpacked{"CPAN/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META';
  use 5.006;use strict;use warnings;package CPAN::Meta;our$VERSION='2.150010';use Carp qw(carp croak);use CPAN::Meta::Feature;use CPAN::Meta::Prereqs;use CPAN::Meta::Converter;use CPAN::Meta::Validator;use Parse::CPAN::Meta 1.4414 ();BEGIN {*_dclone=\&CPAN::Meta::Converter::_dclone}BEGIN {my@STRING_READERS=qw(abstract description dynamic_config generated_by name release_status version);no strict 'refs';for my$attr (@STRING_READERS){*$attr=sub {$_[0]{$attr }}}}BEGIN {my@LIST_READERS=qw(author keywords license);no strict 'refs';for my$attr (@LIST_READERS){*$attr=sub {my$value=$_[0]{$attr };croak "$attr must be called in list context" unless wantarray;return @{_dclone($value)}if ref$value;return$value}}}sub authors {$_[0]->author}sub licenses {$_[0]->license}BEGIN {my@MAP_READERS=qw(meta-spec resources provides no_index prereqs optional_features);no strict 'refs';for my$attr (@MAP_READERS){(my$subname=$attr)=~ s/-/_/;*$subname=sub {my$value=$_[0]{$attr };return _dclone($value)if$value;return {}}}}sub custom_keys {return grep {/^x_/i}keys %{$_[0]}}sub custom {my ($self,$attr)=@_;my$value=$self->{$attr};return _dclone($value)if ref$value;return$value}sub _new {my ($class,$struct,$options)=@_;my$self;if ($options->{lazy_validation}){my$cmc=CPAN::Meta::Converter->new($struct);$self=$cmc->convert(version=>2);return bless$self,$class}else {my$cmv=CPAN::Meta::Validator->new($struct);unless ($cmv->is_valid){die "Invalid metadata structure. Errors: " .join(", ",$cmv->errors)."\n"}}my$version=$struct->{'meta-spec'}{version}|| '1.0';if ($version==2){$self=$struct}else {my$cmc=CPAN::Meta::Converter->new($struct);$self=$cmc->convert(version=>2)}return bless$self,$class}sub new {my ($class,$struct,$options)=@_;my$self=eval {$class->_new($struct,$options)};croak($@)if $@;return$self}sub create {my ($class,$struct,$options)=@_;my$version=__PACKAGE__->VERSION || 2;$struct->{generated_by}||= __PACKAGE__ ." version $version" ;$struct->{'meta-spec'}{version}||= int($version);my$self=eval {$class->_new($struct,$options)};croak ($@)if $@;return$self}sub load_file {my ($class,$file,$options)=@_;$options->{lazy_validation}=1 unless exists$options->{lazy_validation};croak "load_file() requires a valid, readable filename" unless -r $file;my$self;eval {my$struct=Parse::CPAN::Meta->load_file($file);$self=$class->_new($struct,$options)};croak($@)if $@;return$self}sub load_yaml_string {my ($class,$yaml,$options)=@_;$options->{lazy_validation}=1 unless exists$options->{lazy_validation};my$self;eval {my ($struct)=Parse::CPAN::Meta->load_yaml_string($yaml);$self=$class->_new($struct,$options)};croak($@)if $@;return$self}sub load_json_string {my ($class,$json,$options)=@_;$options->{lazy_validation}=1 unless exists$options->{lazy_validation};my$self;eval {my$struct=Parse::CPAN::Meta->load_json_string($json);$self=$class->_new($struct,$options)};croak($@)if $@;return$self}sub load_string {my ($class,$string,$options)=@_;$options->{lazy_validation}=1 unless exists$options->{lazy_validation};my$self;eval {my$struct=Parse::CPAN::Meta->load_string($string);$self=$class->_new($struct,$options)};croak($@)if $@;return$self}sub save {my ($self,$file,$options)=@_;my$version=$options->{version}|| '2';my$layer=$] ge '5.008001' ? ':utf8' : '';if ($version ge '2'){carp "'$file' should end in '.json'" unless$file =~ m{\.json$}}else {carp "'$file' should end in '.yml'" unless$file =~ m{\.yml$}}my$data=$self->as_string($options);open my$fh,">$layer",$file or die "Error opening '$file' for writing: $!\n";print {$fh}$data;close$fh or die "Error closing '$file': $!\n";return 1}sub meta_spec_version {my ($self)=@_;return$self->meta_spec->{version}}sub effective_prereqs {my ($self,$features)=@_;$features ||= [];my$prereq=CPAN::Meta::Prereqs->new($self->prereqs);return$prereq unless @$features;my@other=map {;$self->feature($_)->prereqs}@$features;return$prereq->with_merged_prereqs(\@other)}sub should_index_file {my ($self,$filename)=@_;for my$no_index_file (@{$self->no_index->{file}|| []}){return if$filename eq $no_index_file}for my$no_index_dir (@{$self->no_index->{directory}}){$no_index_dir =~ s{$}{/} unless$no_index_dir =~ m{/\z};return if index($filename,$no_index_dir)==0}return 1}sub should_index_package {my ($self,$package)=@_;for my$no_index_pkg (@{$self->no_index->{package}|| []}){return if$package eq $no_index_pkg}for my$no_index_ns (@{$self->no_index->{namespace}}){return if index($package,"${no_index_ns}::")==0}return 1}sub features {my ($self)=@_;my$opt_f=$self->optional_features;my@features=map {;CPAN::Meta::Feature->new($_=>$opt_f->{$_ })}keys %$opt_f;return@features}sub feature {my ($self,$ident)=@_;croak "no feature named $ident" unless my$f=$self->optional_features->{$ident };return CPAN::Meta::Feature->new($ident,$f)}sub as_struct {my ($self,$options)=@_;my$struct=_dclone($self);if ($options->{version}){my$cmc=CPAN::Meta::Converter->new($struct);$struct=$cmc->convert(version=>$options->{version})}return$struct}sub as_string {my ($self,$options)=@_;my$version=$options->{version}|| '2';my$struct;if ($self->meta_spec_version ne $version){my$cmc=CPAN::Meta::Converter->new($self->as_struct);$struct=$cmc->convert(version=>$version)}else {$struct=$self->as_struct}my ($data,$backend);if ($version ge '2'){$backend=Parse::CPAN::Meta->json_backend();local$struct->{x_serialization_backend}=sprintf '%s version %s',$backend,$backend->VERSION;$data=$backend->new->pretty->canonical->encode($struct)}else {$backend=Parse::CPAN::Meta->yaml_backend();local$struct->{x_serialization_backend}=sprintf '%s version %s',$backend,$backend->VERSION;$data=eval {no strict 'refs';&{"$backend\::Dump"}($struct)};if ($@){croak$backend->can('errstr')? $backend->errstr : $@}}return$data}sub TO_JSON {return {%{$_[0]}}}1;
CPAN_META

$fatpacked{"CPAN/Meta/Check.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_CHECK';
  package CPAN::Meta::Check;$CPAN::Meta::Check::VERSION='0.014';use strict;use warnings;use base 'Exporter';our@EXPORT=qw//;our@EXPORT_OK=qw/check_requirements requirements_for verify_dependencies/;our%EXPORT_TAGS=(all=>[@EXPORT,@EXPORT_OK ]);use CPAN::Meta::Prereqs '2.132830';use CPAN::Meta::Requirements 2.121;use Module::Metadata 1.000023;sub _check_dep {my ($reqs,$module,$dirs)=@_;$module eq 'perl' and return ($reqs->accepts_module($module,$])? (): sprintf "Your Perl (%s) is not in the range '%s'",$],$reqs->requirements_for_module($module));my$metadata=Module::Metadata->new_from_module($module,inc=>$dirs);return "Module '$module' is not installed" if not defined$metadata;my$version=eval {$metadata->version};return sprintf 'Installed version (%s) of %s is not in range \'%s\'',(defined$version ? $version : 'undef'),$module,$reqs->requirements_for_module($module)if not $reqs->accepts_module($module,$version || 0);return}sub _check_conflict {my ($reqs,$module,$dirs)=@_;my$metadata=Module::Metadata->new_from_module($module,inc=>$dirs);return if not defined$metadata;my$version=eval {$metadata->version};return sprintf 'Installed version (%s) of %s is in range \'%s\'',(defined$version ? $version : 'undef'),$module,$reqs->requirements_for_module($module)if$reqs->accepts_module($module,$version);return}sub requirements_for {my ($meta,$phases,$type)=@_;my$prereqs=ref($meta)eq 'CPAN::Meta' ? $meta->effective_prereqs : $meta;return$prereqs->merged_requirements(ref($phases)? $phases : [$phases ],[$type ])}sub check_requirements {my ($reqs,$type,$dirs)=@_;return +{map {$_=>$type ne 'conflicts' ? scalar _check_dep($reqs,$_,$dirs): scalar _check_conflict($reqs,$_,$dirs)}$reqs->required_modules }}sub verify_dependencies {my ($meta,$phases,$type,$dirs)=@_;my$reqs=requirements_for($meta,$phases,$type);my$issues=check_requirements($reqs,$type,$dirs);return grep {defined}values %{$issues}}1;
CPAN_META_CHECK

$fatpacked{"CPAN/Meta/Converter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_CONVERTER';
  use 5.006;use strict;use warnings;package CPAN::Meta::Converter;our$VERSION='2.150010';use CPAN::Meta::Validator;use CPAN::Meta::Requirements;use Parse::CPAN::Meta 1.4400 ();BEGIN {eval "use version ()";if (my$err=$@){eval "use ExtUtils::MakeMaker::version" or die$err}}*_is_qv=version->can('is_qv')? sub {$_[0]->is_qv}: sub {exists $_[0]->{qv}};our$DCLONE_MAXDEPTH=1024;our$_CLONE_DEPTH;sub _dclone {my ($ref)=@_;return$ref unless my$reftype=ref$ref;local$_CLONE_DEPTH=defined$_CLONE_DEPTH ? $_CLONE_DEPTH - 1 : $DCLONE_MAXDEPTH;die "Depth Limit $DCLONE_MAXDEPTH Exceeded" if$_CLONE_DEPTH==0;return [map {_dclone($_)}@{$ref}]if 'ARRAY' eq $reftype;return {map {$_=>_dclone($ref->{$_})}keys %{$ref}}if 'HASH' eq $reftype;if ('SCALAR' eq $reftype){my$new=_dclone(${$ref});return \$new}if (eval {$ref->can('TO_JSON')}){my$data=$ref->TO_JSON;return ref$data ? _dclone($data): $data}return "$ref"}my%known_specs=('2'=>'http://search.cpan.org/perldoc?CPAN::Meta::Spec','1.4'=>'http://module-build.sourceforge.net/META-spec-v1.4.html','1.3'=>'http://module-build.sourceforge.net/META-spec-v1.3.html','1.2'=>'http://module-build.sourceforge.net/META-spec-v1.2.html','1.1'=>'http://module-build.sourceforge.net/META-spec-v1.1.html','1.0'=>'http://module-build.sourceforge.net/META-spec-v1.0.html');my@spec_list=sort {$a <=> $b}keys%known_specs;my ($LOWEST,$HIGHEST)=@spec_list[0,-1];sub _keep {$_[0]}sub _keep_or_one {defined($_[0])? $_[0]: 1}sub _keep_or_zero {defined($_[0])? $_[0]: 0}sub _keep_or_unknown {defined($_[0])&& length($_[0])? $_[0]: "unknown"}sub _generated_by {my$gen=shift;my$sig=__PACKAGE__ ." version " .(__PACKAGE__->VERSION || "<dev>");return$sig unless defined$gen and length$gen;return$gen if$gen =~ /\Q$sig/;return "$gen, $sig"}sub _listify {!defined $_[0]? undef : ref $_[0]eq 'ARRAY' ? $_[0]: [$_[0]]}sub _prefix_custom {my$key=shift;$key =~ s/^(?!x_)   # Unless it already starts with x_
               (?:x-?)? # Remove leading x- or x (if present)
             /x_/ix;return$key}sub _ucfirst_custom {my$key=shift;$key=ucfirst$key unless$key =~ /[A-Z]/;return$key}sub _no_prefix_ucfirst_custom {my$key=shift;$key =~ s/^x_//;return _ucfirst_custom($key)}sub _change_meta_spec {my ($element,undef,undef,$version)=@_;return {version=>$version,url=>$known_specs{$version},}}my@open_source=('perl','gpl','apache','artistic','artistic_2','lgpl','bsd','gpl','mit','mozilla','open_source',);my%is_open_source=map {;$_=>1}@open_source;my@valid_licenses_1=(@open_source,'unrestricted','restrictive','unknown',);my%license_map_1=((map {$_=>$_}@valid_licenses_1),artistic2=>'artistic_2',);sub _license_1 {my ($element)=@_;return 'unknown' unless defined$element;if ($license_map_1{lc$element}){return$license_map_1{lc$element}}else {return 'unknown'}}my@valid_licenses_2=qw(agpl_3 apache_1_1 apache_2_0 artistic_1 artistic_2 bsd freebsd gfdl_1_2 gfdl_1_3 gpl_1 gpl_2 gpl_3 lgpl_2_1 lgpl_3_0 mit mozilla_1_0 mozilla_1_1 openssl perl_5 qpl_1_0 ssleay sun zlib open_source restricted unrestricted unknown);my%license_map_2=((map {$_=>$_}@valid_licenses_2),apache=>'apache_2_0',artistic=>'artistic_1',artistic2=>'artistic_2',gpl=>'open_source',lgpl=>'open_source',mozilla=>'open_source',perl=>'perl_5',restrictive=>'restricted',);sub _license_2 {my ($element)=@_;return ['unknown' ]unless defined$element;$element=[$element ]unless ref$element eq 'ARRAY';my@new_list;for my$lic (@$element){next unless defined$lic;if (my$new=$license_map_2{lc$lic}){push@new_list,$new}}return@new_list ? \@new_list : ['unknown' ]}my%license_downgrade_map=qw(agpl_3 open_source apache_1_1 apache apache_2_0 apache artistic_1 artistic artistic_2 artistic_2 bsd bsd freebsd open_source gfdl_1_2 open_source gfdl_1_3 open_source gpl_1 gpl gpl_2 gpl gpl_3 gpl lgpl_2_1 lgpl lgpl_3_0 lgpl mit mit mozilla_1_0 mozilla mozilla_1_1 mozilla openssl open_source perl_5 perl qpl_1_0 open_source ssleay open_source sun open_source zlib open_source open_source open_source restricted restrictive unrestricted unrestricted unknown unknown);sub _downgrade_license {my ($element)=@_;if (!defined$element){return "unknown"}elsif(ref$element eq 'ARRAY'){if (@$element > 1){if (grep {!$is_open_source{$license_downgrade_map{lc $_}|| 'unknown' }}@$element){return 'unknown'}else {return 'open_source'}}elsif (@$element==1){return$license_downgrade_map{lc$element->[0]}|| "unknown"}}elsif (!ref$element){return$license_downgrade_map{lc$element}|| "unknown"}return "unknown"}my$no_index_spec_1_2={'file'=>\&_listify,'dir'=>\&_listify,'package'=>\&_listify,'namespace'=>\&_listify,};my$no_index_spec_1_3={'file'=>\&_listify,'directory'=>\&_listify,'package'=>\&_listify,'namespace'=>\&_listify,};my$no_index_spec_2={'file'=>\&_listify,'directory'=>\&_listify,'package'=>\&_listify,'namespace'=>\&_listify,':custom'=>\&_prefix_custom,};sub _no_index_1_2 {my (undef,undef,$meta)=@_;my$no_index=$meta->{no_index}|| $meta->{private};return unless$no_index;if (!ref$no_index){my$item=$no_index;$no_index={dir=>[$item ],file=>[$item ]}}elsif (ref$no_index eq 'ARRAY'){my$list=$no_index;$no_index={dir=>[@$list ],file=>[@$list ]}}if (exists$no_index->{files}){$no_index->{file}=delete$no_index->{files}}if (exists$no_index->{modules}){$no_index->{module}=delete$no_index->{modules}}return _convert($no_index,$no_index_spec_1_2)}sub _no_index_directory {my ($element,$key,$meta,$version)=@_;return unless$element;if (!ref$element){my$item=$element;$element={directory=>[$item ],file=>[$item ]}}elsif (ref$element eq 'ARRAY'){my$list=$element;$element={directory=>[@$list ],file=>[@$list ]}}if (exists$element->{dir}){$element->{directory}=delete$element->{dir}}if (exists$element->{files}){$element->{file}=delete$element->{files}}if (exists$element->{modules}){$element->{module}=delete$element->{modules}}my$spec=$version==2 ? $no_index_spec_2 : $no_index_spec_1_3;return _convert($element,$spec)}sub _is_module_name {my$mod=shift;return unless defined$mod && length$mod;return$mod =~ m{^[A-Za-z][A-Za-z0-9_]*(?:::[A-Za-z0-9_]+)*$}}sub _clean_version {my ($element)=@_;return 0 if!defined$element;$element =~ s{^\s*}{};$element =~ s{\s*$}{};$element =~ s{^\.}{0.};return 0 if!length$element;return 0 if ($element eq 'undef' || $element eq '<undef>');my$v=eval {version->new($element)};if (defined$v){return _is_qv($v)? $v->normal : $element}else {return 0}}sub _bad_version_hook {my ($v)=@_;$v =~ s{^\s*}{};$v =~ s{\s*$}{};$v =~ s{[a-z]+$}{};my$vobj=eval {version->new($v)};return defined($vobj)? $vobj : version->new(0)}sub _version_map {my ($element)=@_;return unless defined$element;if (ref$element eq 'HASH'){my$new_map=CPAN::Meta::Requirements->new({bad_version_hook=>\&_bad_version_hook });while (my ($k,$v)=each %$element){next unless _is_module_name($k);if (!defined($v)||!length($v)|| $v eq 'undef' || $v eq '<undef>'){$v=0}if (_is_module_name($v)&&!version::is_lax($v)){$new_map->add_minimum($k=>0);$new_map->add_minimum($v=>0)}$new_map->add_string_requirement($k=>$v)}return$new_map->as_string_hash}elsif (ref$element eq 'ARRAY'){my$hashref={map {$_=>0}@$element };return _version_map($hashref)}elsif (ref$element eq '' && length$element){return {$element=>0 }}return}sub _prereqs_from_1 {my (undef,undef,$meta)=@_;my$prereqs={};for my$phase (qw/build configure/){my$key="${phase}_requires";$prereqs->{$phase}{requires}=_version_map($meta->{$key})if$meta->{$key}}for my$rel (qw/requires recommends conflicts/){$prereqs->{runtime}{$rel}=_version_map($meta->{$rel})if$meta->{$rel}}return$prereqs}my$prereqs_spec={configure=>\&_prereqs_rel,build=>\&_prereqs_rel,test=>\&_prereqs_rel,runtime=>\&_prereqs_rel,develop=>\&_prereqs_rel,':custom'=>\&_prefix_custom,};my$relation_spec={requires=>\&_version_map,recommends=>\&_version_map,suggests=>\&_version_map,conflicts=>\&_version_map,':custom'=>\&_prefix_custom,};sub _cleanup_prereqs {my ($prereqs,$key,$meta,$to_version)=@_;return unless$prereqs && ref$prereqs eq 'HASH';return _convert($prereqs,$prereqs_spec,$to_version)}sub _prereqs_rel {my ($relation,$key,$meta,$to_version)=@_;return unless$relation && ref$relation eq 'HASH';return _convert($relation,$relation_spec,$to_version)}BEGIN {my@old_prereqs=qw(requires configure_requires recommends conflicts);for (@old_prereqs){my$sub="_get_$_";my ($phase,$type)=split qr/_/,$_;if (!defined$type){$type=$phase;$phase='runtime'}no strict 'refs';*{$sub}=sub {_extract_prereqs($_[2]->{prereqs},$phase,$type)}}}sub _get_build_requires {my ($data,$key,$meta)=@_;my$test_h=_extract_prereqs($_[2]->{prereqs},qw(test requires))|| {};my$build_h=_extract_prereqs($_[2]->{prereqs},qw(build requires))|| {};my$test_req=CPAN::Meta::Requirements->from_string_hash($test_h);my$build_req=CPAN::Meta::Requirements->from_string_hash($build_h);$test_req->add_requirements($build_req)->as_string_hash}sub _extract_prereqs {my ($prereqs,$phase,$type)=@_;return unless ref$prereqs eq 'HASH';return scalar _version_map($prereqs->{$phase}{$type})}sub _downgrade_optional_features {my (undef,undef,$meta)=@_;return unless exists$meta->{optional_features};my$origin=$meta->{optional_features};my$features={};for my$name (keys %$origin){$features->{$name}={description=>$origin->{$name}{description},requires=>_extract_prereqs($origin->{$name}{prereqs},'runtime','requires'),configure_requires=>_extract_prereqs($origin->{$name}{prereqs},'runtime','configure_requires'),build_requires=>_extract_prereqs($origin->{$name}{prereqs},'runtime','build_requires'),recommends=>_extract_prereqs($origin->{$name}{prereqs},'runtime','recommends'),conflicts=>_extract_prereqs($origin->{$name}{prereqs},'runtime','conflicts'),};for my$k (keys %{$features->{$name}}){delete$features->{$name}{$k}unless defined$features->{$name}{$k}}}return$features}sub _upgrade_optional_features {my (undef,undef,$meta)=@_;return unless exists$meta->{optional_features};my$origin=$meta->{optional_features};my$features={};for my$name (keys %$origin){$features->{$name}={description=>$origin->{$name}{description},prereqs=>_prereqs_from_1(undef,undef,$origin->{$name}),};delete$features->{$name}{prereqs}{configure}}return$features}my$optional_features_2_spec={description=>\&_keep,prereqs=>\&_cleanup_prereqs,':custom'=>\&_prefix_custom,};sub _feature_2 {my ($element,$key,$meta,$to_version)=@_;return unless$element && ref$element eq 'HASH';_convert($element,$optional_features_2_spec,$to_version)}sub _cleanup_optional_features_2 {my ($element,$key,$meta,$to_version)=@_;return unless$element && ref$element eq 'HASH';my$new_data={};for my$k (keys %$element){$new_data->{$k}=_feature_2($element->{$k},$k,$meta,$to_version)}return unless keys %$new_data;return$new_data}sub _optional_features_1_4 {my ($element)=@_;return unless$element;$element=_optional_features_as_map($element);for my$name (keys %$element){for my$drop (qw/requires_packages requires_os excluded_os/){delete$element->{$name}{$drop}}}return$element}sub _optional_features_as_map {my ($element)=@_;return unless$element;if (ref$element eq 'ARRAY'){my%map;for my$feature (@$element){my (@parts)=%$feature;$map{$parts[0]}=$parts[1]}$element=\%map}return$element}sub _is_urlish {defined $_[0]&& $_[0]=~ m{\A[-+.a-z0-9]+:.+}i}sub _url_or_drop {my ($element)=@_;return$element if _is_urlish($element);return}sub _url_list {my ($element)=@_;return unless$element;$element=_listify($element);$element=[grep {_is_urlish($_)}@$element ];return unless @$element;return$element}sub _author_list {my ($element)=@_;return ['unknown' ]unless$element;$element=_listify($element);$element=[map {defined $_ && length $_ ? $_ : 'unknown'}@$element ];return ['unknown' ]unless @$element;return$element}my$resource2_upgrade={license=>sub {return _is_urlish($_[0])? _listify($_[0]): undef},homepage=>\&_url_or_drop,bugtracker=>sub {my ($item)=@_;return unless$item;if ($item =~ m{^mailto:(.*)$}){return {mailto=>$1 }}elsif(_is_urlish($item)){return {web=>$item }}else {return}},repository=>sub {return _is_urlish($_[0])? {url=>$_[0]}: undef},':custom'=>\&_prefix_custom,};sub _upgrade_resources_2 {my (undef,undef,$meta,$version)=@_;return unless exists$meta->{resources};return _convert($meta->{resources},$resource2_upgrade)}my$bugtracker2_spec={web=>\&_url_or_drop,mailto=>\&_keep,':custom'=>\&_prefix_custom,};sub _repo_type {my ($element,$key,$meta,$to_version)=@_;return$element if defined$element;return unless exists$meta->{url};my$repo_url=$meta->{url};for my$type (qw/git svn/){return$type if$repo_url =~ m{\A$type}}return}my$repository2_spec={web=>\&_url_or_drop,url=>\&_url_or_drop,type=>\&_repo_type,':custom'=>\&_prefix_custom,};my$resources2_cleanup={license=>\&_url_list,homepage=>\&_url_or_drop,bugtracker=>sub {ref $_[0]? _convert($_[0],$bugtracker2_spec): undef},repository=>sub {my$data=shift;ref$data ? _convert($data,$repository2_spec): undef},':custom'=>\&_prefix_custom,};sub _cleanup_resources_2 {my ($resources,$key,$meta,$to_version)=@_;return unless$resources && ref$resources eq 'HASH';return _convert($resources,$resources2_cleanup,$to_version)}my$resource1_spec={license=>\&_url_or_drop,homepage=>\&_url_or_drop,bugtracker=>\&_url_or_drop,repository=>\&_url_or_drop,':custom'=>\&_keep,};sub _resources_1_3 {my (undef,undef,$meta,$version)=@_;return unless exists$meta->{resources};return _convert($meta->{resources},$resource1_spec)}*_resources_1_4=*_resources_1_3;sub _resources_1_2 {my (undef,undef,$meta)=@_;my$resources=$meta->{resources}|| {};if ($meta->{license_url}&&!$resources->{license}){$resources->{license}=$meta->{license_url}if _is_urlish($meta->{license_url})}return unless keys %$resources;return _convert($resources,$resource1_spec)}my$resource_downgrade_spec={license=>sub {return ref $_[0]? $_[0]->[0]: $_[0]},homepage=>\&_url_or_drop,bugtracker=>sub {return $_[0]->{web}},repository=>sub {return $_[0]->{url}|| $_[0]->{web}},':custom'=>\&_no_prefix_ucfirst_custom,};sub _downgrade_resources {my (undef,undef,$meta,$version)=@_;return unless exists$meta->{resources};return _convert($meta->{resources},$resource_downgrade_spec)}sub _release_status {my ($element,undef,$meta)=@_;return$element if$element && $element =~ m{\A(?:stable|testing|unstable)\z};return _release_status_from_version(undef,undef,$meta)}sub _release_status_from_version {my (undef,undef,$meta)=@_;my$version=$meta->{version}|| '';return ($version =~ /_/)? 'testing' : 'stable'}my$provides_spec={file=>\&_keep,version=>\&_keep,};my$provides_spec_2={file=>\&_keep,version=>\&_keep,':custom'=>\&_prefix_custom,};sub _provides {my ($element,$key,$meta,$to_version)=@_;return unless defined$element && ref$element eq 'HASH';my$spec=$to_version==2 ? $provides_spec_2 : $provides_spec;my$new_data={};for my$k (keys %$element){$new_data->{$k}=_convert($element->{$k},$spec,$to_version);$new_data->{$k}{version}=_clean_version($element->{$k}{version})if exists$element->{$k}{version}}return$new_data}sub _convert {my ($data,$spec,$to_version,$is_fragment)=@_;my$new_data={};for my$key (keys %$spec){next if$key eq ':custom' || $key eq ':drop';next unless my$fcn=$spec->{$key};if ($is_fragment && $key eq 'generated_by'){$fcn=\&_keep}die "spec for '$key' is not a coderef" unless ref$fcn && ref$fcn eq 'CODE';my$new_value=$fcn->($data->{$key},$key,$data,$to_version);$new_data->{$key}=$new_value if defined$new_value}my$drop_list=$spec->{':drop'};my$customizer=$spec->{':custom'}|| \&_keep;for my$key (keys %$data){next if$drop_list && grep {$key eq $_}@$drop_list;next if exists$spec->{$key};$new_data->{$customizer->($key)}=$data->{$key}}return$new_data}my%up_convert=('2-from-1.4'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_2,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'release_status'=>\&_release_status,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_upgrade_optional_features,'provides'=>\&_provides,'resources'=>\&_upgrade_resources_2,'description'=>\&_keep,'prereqs'=>\&_prereqs_from_1,':drop'=>[qw(build_requires configure_requires conflicts distribution_type license_url private recommends requires) ],':custom'=>\&_prefix_custom,},'1.4-from-1.3'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_1_4,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_4,'configure_requires'=>\&_keep,':drop'=>[qw(license_url private)],':custom'=>\&_keep },'1.3-from-1.2'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_3,':drop'=>[qw(license_url private)],':custom'=>\&_keep },'1.2-from-1.1'=>{'version'=>\&_keep,'license'=>\&_license_1,'name'=>\&_keep,'generated_by'=>\&_generated_by,'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'meta-spec'=>\&_change_meta_spec,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'recommends'=>\&_version_map,'requires'=>\&_version_map,'keywords'=>\&_keep,'no_index'=>\&_no_index_1_2,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'resources'=>\&_resources_1_2,':drop'=>[qw(license_url private)],':custom'=>\&_keep },'1.1-from-1.0'=>{'version'=>\&_keep,'name'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'recommends'=>\&_version_map,'requires'=>\&_version_map,'license_url'=>\&_url_or_drop,'private'=>\&_keep,':custom'=>\&_keep },);my%down_convert=('1.4-from-2'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_downgrade_license,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_get_build_requires,'configure_requires'=>\&_get_configure_requires,'conflicts'=>\&_get_conflicts,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_downgrade_optional_features,'provides'=>\&_provides,'recommends'=>\&_get_recommends,'requires'=>\&_get_requires,'resources'=>\&_downgrade_resources,':drop'=>[qw(description prereqs release_status)],':custom'=>\&_keep },'1.3-from-1.4'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_3,':drop'=>[qw(configure_requires)],':custom'=>\&_keep,},'1.2-from-1.3'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_1_2,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_3,':custom'=>\&_keep,},'1.1-from-1.2'=>{'version'=>\&_keep,'name'=>\&_keep,'meta-spec'=>\&_change_meta_spec,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'private'=>\&_keep,'recommends'=>\&_version_map,'requires'=>\&_version_map,':drop'=>[qw(abstract author provides no_index keywords resources)],':custom'=>\&_keep,},'1.0-from-1.1'=>{'name'=>\&_keep,'meta-spec'=>\&_change_meta_spec,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'recommends'=>\&_version_map,'requires'=>\&_version_map,':custom'=>\&_keep,},);my%cleanup=('2'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_2,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'release_status'=>\&_release_status,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_cleanup_optional_features_2,'provides'=>\&_provides,'resources'=>\&_cleanup_resources_2,'description'=>\&_keep,'prereqs'=>\&_cleanup_prereqs,':drop'=>[qw(build_requires configure_requires conflicts distribution_type license_url private recommends requires) ],':custom'=>\&_prefix_custom,},'1.4'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_1_4,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_4,'configure_requires'=>\&_keep,':custom'=>\&_keep },'1.3'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_3,':custom'=>\&_keep },'1.2'=>{'version'=>\&_keep,'license'=>\&_license_1,'name'=>\&_keep,'generated_by'=>\&_generated_by,'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'meta-spec'=>\&_change_meta_spec,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'recommends'=>\&_version_map,'requires'=>\&_version_map,'keywords'=>\&_keep,'no_index'=>\&_no_index_1_2,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'resources'=>\&_resources_1_2,':custom'=>\&_keep },'1.1'=>{'version'=>\&_keep,'name'=>\&_keep,'meta-spec'=>\&_change_meta_spec,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'recommends'=>\&_version_map,'requires'=>\&_version_map,'license_url'=>\&_url_or_drop,'private'=>\&_keep,':custom'=>\&_keep },'1.0'=>{'name'=>\&_keep,'meta-spec'=>\&_change_meta_spec,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'recommends'=>\&_version_map,'requires'=>\&_version_map,':custom'=>\&_keep,},);my%fragments_generate=('2'=>{'abstract'=>'abstract','author'=>'author','generated_by'=>'generated_by','license'=>'license','name'=>'name','version'=>'version','dynamic_config'=>'dynamic_config','release_status'=>'release_status','keywords'=>'keywords','no_index'=>'no_index','optional_features'=>'optional_features','provides'=>'provides','resources'=>'resources','description'=>'description','prereqs'=>'prereqs',},'1.4'=>{'abstract'=>'abstract','author'=>'author','generated_by'=>'generated_by','license'=>'license','name'=>'name','version'=>'version','build_requires'=>'prereqs','conflicts'=>'prereqs','distribution_type'=>'distribution_type','dynamic_config'=>'dynamic_config','keywords'=>'keywords','no_index'=>'no_index','optional_features'=>'optional_features','provides'=>'provides','recommends'=>'prereqs','requires'=>'prereqs','resources'=>'resources','configure_requires'=>'prereqs',},);$fragments_generate{$_}=$fragments_generate{'1.4'}for qw/1.3 1.2 1.1 1.0/;sub new {my ($class,$data,%args)=@_;my$self={'data'=>$data,'spec'=>_extract_spec_version($data,$args{default_version}),};return bless$self,$class}sub _extract_spec_version {my ($data,$default)=@_;my$spec=$data->{'meta-spec'};return($default || "1.0")unless defined$spec && ref$spec eq 'HASH';my$v=$spec->{version};if (defined$v && $v =~ /^\d+(?:\.\d+)?$/){return$v if defined$v && grep {$v eq $_}keys%known_specs;return$v+0 if defined$v && grep {$v==$_}keys%known_specs}return "2" if exists$data->{prereqs};return "1.4" if exists$data->{configure_requires};return($default || "1.2")}sub convert {my ($self,%args)=@_;my$args={%args };my$new_version=$args->{version}|| $HIGHEST;my$is_fragment=$args->{is_fragment};my ($old_version)=$self->{spec};my$converted=_dclone($self->{data});if ($old_version==$new_version){$converted=_convert($converted,$cleanup{$old_version},$old_version,$is_fragment);unless ($args->{is_fragment}){my$cmv=CPAN::Meta::Validator->new($converted);unless ($cmv->is_valid){my$errs=join("\n",$cmv->errors);die "Failed to clean-up $old_version metadata. Errors:\n$errs\n"}}return$converted}elsif ($old_version > $new_version){my@vers=sort {$b <=> $a}keys%known_specs;for my$i (0 .. $#vers-1){next if$vers[$i]> $old_version;last if$vers[$i+1]< $new_version;my$spec_string="$vers[$i+1]-from-$vers[$i]";$converted=_convert($converted,$down_convert{$spec_string},$vers[$i+1],$is_fragment);unless ($args->{is_fragment}){my$cmv=CPAN::Meta::Validator->new($converted);unless ($cmv->is_valid){my$errs=join("\n",$cmv->errors);die "Failed to downconvert metadata to $vers[$i+1]. Errors:\n$errs\n"}}}return$converted}else {my@vers=sort {$a <=> $b}keys%known_specs;for my$i (0 .. $#vers-1){next if$vers[$i]< $old_version;last if$vers[$i+1]> $new_version;my$spec_string="$vers[$i+1]-from-$vers[$i]";$converted=_convert($converted,$up_convert{$spec_string},$vers[$i+1],$is_fragment);unless ($args->{is_fragment}){my$cmv=CPAN::Meta::Validator->new($converted);unless ($cmv->is_valid){my$errs=join("\n",$cmv->errors);die "Failed to upconvert metadata to $vers[$i+1]. Errors:\n$errs\n"}}}return$converted}}sub upgrade_fragment {my ($self)=@_;my ($old_version)=$self->{spec};my%expected=map {;$_=>1}grep {defined}map {$fragments_generate{$old_version}{$_}}keys %{$self->{data}};my$converted=$self->convert(version=>$HIGHEST,is_fragment=>1);for my$key (keys %$converted){next if$key =~ /^x_/i || $key eq 'meta-spec';delete$converted->{$key}unless$expected{$key}}return$converted}1;
CPAN_META_CONVERTER

$fatpacked{"CPAN/Meta/Feature.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_FEATURE';
  use 5.006;use strict;use warnings;package CPAN::Meta::Feature;our$VERSION='2.150010';use CPAN::Meta::Prereqs;sub new {my ($class,$identifier,$spec)=@_;my%guts=(identifier=>$identifier,description=>$spec->{description},prereqs=>CPAN::Meta::Prereqs->new($spec->{prereqs}),);bless \%guts=>$class}sub identifier {$_[0]{identifier}}sub description {$_[0]{description}}sub prereqs {$_[0]{prereqs}}1;
CPAN_META_FEATURE

$fatpacked{"CPAN/Meta/History.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_HISTORY';
  use 5.006;use strict;use warnings;package CPAN::Meta::History;our$VERSION='2.150010';1;
CPAN_META_HISTORY

$fatpacked{"CPAN/Meta/Merge.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_MERGE';
  use strict;use warnings;package CPAN::Meta::Merge;our$VERSION='2.150010';use Carp qw/croak/;use Scalar::Util qw/blessed/;use CPAN::Meta::Converter 2.141170;sub _is_identical {my ($left,$right)=@_;return (not defined$left and not defined$right)|| (defined$left and defined$right and $left eq $right)}sub _identical {my ($left,$right,$path)=@_;croak sprintf "Can't merge attribute %s: '%s' does not equal '%s'",join('.',@{$path}),$left,$right unless _is_identical($left,$right);return$left}sub _merge {my ($current,$next,$mergers,$path)=@_;for my$key (keys %{$next}){if (not exists$current->{$key}){$current->{$key}=$next->{$key}}elsif (my$merger=$mergers->{$key}){$current->{$key}=$merger->($current->{$key},$next->{$key},[@{$path},$key ])}elsif ($merger=$mergers->{':default'}){$current->{$key}=$merger->($current->{$key},$next->{$key},[@{$path},$key ])}else {croak sprintf "Can't merge unknown attribute '%s'",join '.',@{$path},$key}}return$current}sub _uniq {my%seen=();return grep {not $seen{$_}++}@_}sub _set_addition {my ($left,$right)=@_;return [+_uniq(@{$left},@{$right})]}sub _uniq_map {my ($left,$right,$path)=@_;for my$key (keys %{$right}){if (not exists$left->{$key}){$left->{$key}=$right->{$key}}elsif (_is_identical($left->{$key},$right->{$key})){1}elsif (ref$left->{$key}eq 'HASH' and ref$right->{$key}eq 'HASH'){$left->{$key}=_uniq_map($left->{$key},$right->{$key},[@{$path},$key ])}else {croak 'Duplication of element ' .join '.',@{$path},$key}}return$left}sub _improvise {my ($left,$right,$path)=@_;my ($name)=reverse @{$path};if ($name =~ /^x_/){if (ref($left)eq 'ARRAY'){return _set_addition($left,$right,$path)}elsif (ref($left)eq 'HASH'){return _uniq_map($left,$right,$path)}else {return _identical($left,$right,$path)}}croak sprintf "Can't merge '%s'",join '.',@{$path}}sub _optional_features {my ($left,$right,$path)=@_;for my$key (keys %{$right}){if (not exists$left->{$key}){$left->{$key}=$right->{$key}}else {for my$subkey (keys %{$right->{$key}}){next if$subkey eq 'prereqs';if (not exists$left->{$key}{$subkey}){$left->{$key}{$subkey}=$right->{$key}{$subkey}}else {Carp::croak "Cannot merge two optional_features named '$key' with different '$subkey' values" if do {no warnings 'uninitialized';$left->{$key}{$subkey}ne $right->{$key}{$subkey}}}}require CPAN::Meta::Prereqs;$left->{$key}{prereqs}=CPAN::Meta::Prereqs->new($left->{$key}{prereqs})->with_merged_prereqs(CPAN::Meta::Prereqs->new($right->{$key}{prereqs}))->as_string_hash}}return$left}my%default=(abstract=>\&_identical,author=>\&_set_addition,dynamic_config=>sub {my ($left,$right)=@_;return$left || $right},generated_by=>sub {my ($left,$right)=@_;return join ', ',_uniq(split(/, /,$left),split(/, /,$right))},license=>\&_set_addition,'meta-spec'=>{version=>\&_identical,url=>\&_identical },name=>\&_identical,release_status=>\&_identical,version=>\&_identical,description=>\&_identical,keywords=>\&_set_addition,no_index=>{map {($_=>\&_set_addition)}qw/file directory package namespace/ },optional_features=>\&_optional_features,prereqs=>sub {require CPAN::Meta::Prereqs;my ($left,$right)=map {CPAN::Meta::Prereqs->new($_)}@_[0,1];return$left->with_merged_prereqs($right)->as_string_hash},provides=>\&_uniq_map,resources=>{license=>\&_set_addition,homepage=>\&_identical,bugtracker=>\&_uniq_map,repository=>\&_uniq_map,':default'=>\&_improvise,},':default'=>\&_improvise,);sub new {my ($class,%arguments)=@_;croak 'default version required' if not exists$arguments{default_version};my%mapping=%default;my%extra=%{$arguments{extra_mappings}|| {}};for my$key (keys%extra){if (ref($mapping{$key})eq 'HASH'){$mapping{$key}={%{$mapping{$key}},%{$extra{$key}}}}else {$mapping{$key}=$extra{$key}}}return bless {default_version=>$arguments{default_version},mapping=>_coerce_mapping(\%mapping,[]),},$class}my%coderef_for=(set_addition=>\&_set_addition,uniq_map=>\&_uniq_map,identical=>\&_identical,improvise=>\&_improvise,improvize=>\&_improvise,);sub _coerce_mapping {my ($orig,$map_path)=@_;my%ret;for my$key (keys %{$orig}){my$value=$orig->{$key};if (ref($orig->{$key})eq 'CODE'){$ret{$key}=$value}elsif (ref($value)eq 'HASH'){my$mapping=_coerce_mapping($value,[@{$map_path},$key ]);$ret{$key}=sub {my ($left,$right,$path)=@_;return _merge($left,$right,$mapping,[@{$path}])}}elsif ($coderef_for{$value}){$ret{$key}=$coderef_for{$value}}else {croak "Don't know what to do with " .join '.',@{$map_path},$key}}return \%ret}sub merge {my ($self,@items)=@_;my$current={};for my$next (@items){if (blessed($next)&& $next->isa('CPAN::Meta')){$next=$next->as_struct}elsif (ref($next)eq 'HASH'){my$cmc=CPAN::Meta::Converter->new($next,default_version=>$self->{default_version});$next=$cmc->upgrade_fragment}else {croak "Don't know how to merge '$next'"}$current=_merge($current,$next,$self->{mapping},[])}return$current}1;
CPAN_META_MERGE

$fatpacked{"CPAN/Meta/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_PREREQS';
  use 5.006;use strict;use warnings;package CPAN::Meta::Prereqs;our$VERSION='2.150010';use Carp qw(confess);use Scalar::Util qw(blessed);use CPAN::Meta::Requirements 2.121;sub __legal_phases {qw(configure build test runtime develop)}sub __legal_types {qw(requires recommends suggests conflicts)}sub new {my ($class,$prereq_spec)=@_;$prereq_spec ||= {};my%is_legal_phase=map {;$_=>1}$class->__legal_phases;my%is_legal_type=map {;$_=>1}$class->__legal_types;my%guts;PHASE: for my$phase (keys %$prereq_spec){next PHASE unless$phase =~ /\Ax_/i or $is_legal_phase{$phase};my$phase_spec=$prereq_spec->{$phase };next PHASE unless keys %$phase_spec;TYPE: for my$type (keys %$phase_spec){next TYPE unless$type =~ /\Ax_/i or $is_legal_type{$type};my$spec=$phase_spec->{$type };next TYPE unless keys %$spec;$guts{prereqs}{$phase}{$type}=CPAN::Meta::Requirements->from_string_hash($spec)}}return bless \%guts=>$class}sub requirements_for {my ($self,$phase,$type)=@_;confess "requirements_for called without phase" unless defined$phase;confess "requirements_for called without type" unless defined$type;unless ($phase =~ /\Ax_/i or grep {$phase eq $_}$self->__legal_phases){confess "requested requirements for unknown phase: $phase"}unless ($type =~ /\Ax_/i or grep {$type eq $_}$self->__legal_types){confess "requested requirements for unknown type: $type"}my$req=($self->{prereqs}{$phase}{$type}||= CPAN::Meta::Requirements->new);$req->finalize if$self->is_finalized;return$req}sub phases {my ($self)=@_;my%is_legal_phase=map {;$_=>1}$self->__legal_phases;grep {/\Ax_/i or $is_legal_phase{$_}}keys %{$self->{prereqs}}}sub types_in {my ($self,$phase)=@_;return unless$phase =~ /\Ax_/i or grep {$phase eq $_}$self->__legal_phases;my%is_legal_type=map {;$_=>1}$self->__legal_types;grep {/\Ax_/i or $is_legal_type{$_}}keys %{$self->{prereqs}{$phase}}}sub with_merged_prereqs {my ($self,$other)=@_;my@other=blessed($other)? $other : @$other;my@prereq_objs=($self,@other);my%new_arg;for my$phase (__uniq(map {$_->phases}@prereq_objs)){for my$type (__uniq(map {$_->types_in($phase)}@prereq_objs)){my$req=CPAN::Meta::Requirements->new;for my$prereq (@prereq_objs){my$this_req=$prereq->requirements_for($phase,$type);next unless$this_req->required_modules;$req->add_requirements($this_req)}next unless$req->required_modules;$new_arg{$phase }{$type }=$req->as_string_hash}}return (ref$self)->new(\%new_arg)}sub merged_requirements {my ($self,$phases,$types)=@_;$phases=[qw/runtime build test/]unless defined$phases;$types=[qw/requires recommends/]unless defined$types;confess "merged_requirements phases argument must be an arrayref" unless ref$phases eq 'ARRAY';confess "merged_requirements types argument must be an arrayref" unless ref$types eq 'ARRAY';my$req=CPAN::Meta::Requirements->new;for my$phase (@$phases){unless ($phase =~ /\Ax_/i or grep {$phase eq $_}$self->__legal_phases){confess "requested requirements for unknown phase: $phase"}for my$type (@$types){unless ($type =~ /\Ax_/i or grep {$type eq $_}$self->__legal_types){confess "requested requirements for unknown type: $type"}$req->add_requirements($self->requirements_for($phase,$type))}}$req->finalize if$self->is_finalized;return$req}sub as_string_hash {my ($self)=@_;my%hash;for my$phase ($self->phases){for my$type ($self->types_in($phase)){my$req=$self->requirements_for($phase,$type);next unless$req->required_modules;$hash{$phase }{$type }=$req->as_string_hash}}return \%hash}sub is_finalized {$_[0]{finalized}}sub finalize {my ($self)=@_;$self->{finalized}=1;for my$phase (keys %{$self->{prereqs}}){$_->finalize for values %{$self->{prereqs}{$phase}}}}sub clone {my ($self)=@_;my$clone=(ref$self)->new($self->as_string_hash)}sub __uniq {my (%s,$u);grep {defined($_)?!$s{$_}++ :!$u++}@_}1;
CPAN_META_PREREQS

$fatpacked{"CPAN/Meta/Requirements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_REQUIREMENTS';
  use 5.006;use strict;use warnings;package CPAN::Meta::Requirements;our$VERSION='2.140';use Carp ();BEGIN {eval "use version ()";if (my$err=$@){eval "use ExtUtils::MakeMaker::version" or die$err}}*_is_qv=version->can('is_qv')? sub {$_[0]->is_qv}: sub {exists $_[0]->{qv}};my$V0=version->new(0);my@valid_options=qw(bad_version_hook);sub new {my ($class,$options)=@_;$options ||= {};Carp::croak "Argument to $class\->new() must be a hash reference" unless ref$options eq 'HASH';my%self=map {;$_=>$options->{$_}}@valid_options;return bless \%self=>$class}sub _find_magic_vstring {my$value=shift;my$tvalue='';require B;my$sv=B::svref_2object(\$value);my$magic=ref($sv)eq 'B::PVMG' ? $sv->MAGIC : undef;while ($magic){if ($magic->TYPE eq 'V'){$tvalue=$magic->PTR;$tvalue =~ s/^v?(.+)$/v$1/;last}else {$magic=$magic->MOREMAGIC}}return$tvalue}sub _isa_version {UNIVERSAL::isa($_[0],'UNIVERSAL')&& $_[0]->isa('version')}sub _version_object {my ($self,$module,$version)=@_;my ($vobj,$err);if (not defined$version or (!ref($version)&& $version eq '0')){return$V0}elsif (ref($version)eq 'version' || (ref($version)&& _isa_version($version))){$vobj=$version}else {if ($INC{'version/vpp.pm'}|| $INC{'ExtUtils/MakeMaker/version/vpp.pm'}){my$magic=_find_magic_vstring($version);$version=$magic if length$magic}if ($] < 5.008001 && $version !~ /\A[0-9]/ && substr($version,0,1)ne 'v' && length($version)< 3){$version .= "\0" x (3 - length($version))}eval {local$SIG{__WARN__}=sub {die "Invalid version: $_[0]"};die "Invalid version: $version" if$version eq 'version';$vobj=version->new($version)};if (my$err=$@){my$hook=$self->{bad_version_hook};$vobj=eval {$hook->($version,$module)}if ref$hook eq 'CODE';unless (eval {$vobj->isa("version")}){$err =~ s{ at .* line \d+.*$}{};die "Can't convert '$version': $err"}}}if ($vobj =~ m{\A\.}){$vobj=version->new("0$vobj")}if (_is_qv($vobj)){$vobj=version->new($vobj->normal)}return$vobj}BEGIN {for my$type (qw(maximum exclusion exact_version)){my$method="with_$type";my$to_add=$type eq 'exact_version' ? $type : "add_$type";my$code=sub {my ($self,$name,$version)=@_;$version=$self->_version_object($name,$version);$self->__modify_entry_for($name,$method,$version);return$self};no strict 'refs';*$to_add=$code}}sub add_minimum {my ($self,$name,$version)=@_;if (not defined$version or "$version" eq '0'){return$self if$self->__entry_for($name);Carp::confess("can't add new requirements to finalized requirements")if$self->is_finalized;$self->{requirements}{$name }=CPAN::Meta::Requirements::_Range::Range->with_minimum($V0,$name)}else {$version=$self->_version_object($name,$version);$self->__modify_entry_for($name,'with_minimum',$version)}return$self}sub add_requirements {my ($self,$req)=@_;for my$module ($req->required_modules){my$modifiers=$req->__entry_for($module)->as_modifiers;for my$modifier (@$modifiers){my ($method,@args)=@$modifier;$self->$method($module=>@args)}}return$self}sub accepts_module {my ($self,$module,$version)=@_;$version=$self->_version_object($module,$version);return 1 unless my$range=$self->__entry_for($module);return$range->_accepts($version)}sub clear_requirement {my ($self,$module)=@_;return$self unless$self->__entry_for($module);Carp::confess("can't clear requirements on finalized requirements")if$self->is_finalized;delete$self->{requirements}{$module };return$self}sub requirements_for_module {my ($self,$module)=@_;my$entry=$self->__entry_for($module);return unless$entry;return$entry->as_string}sub structured_requirements_for_module {my ($self,$module)=@_;my$entry=$self->__entry_for($module);return unless$entry;return$entry->as_struct}sub required_modules {keys %{$_[0]{requirements}}}sub clone {my ($self)=@_;my$new=(ref$self)->new;return$new->add_requirements($self)}sub __entry_for {$_[0]{requirements}{$_[1]}}sub __modify_entry_for {my ($self,$name,$method,$version)=@_;my$fin=$self->is_finalized;my$old=$self->__entry_for($name);Carp::confess("can't add new requirements to finalized requirements")if$fin and not $old;my$new=($old || 'CPAN::Meta::Requirements::_Range::Range')->$method($version,$name);Carp::confess("can't modify finalized requirements")if$fin and $old->as_string ne $new->as_string;$self->{requirements}{$name }=$new}sub is_simple {my ($self)=@_;for my$module ($self->required_modules){return if$self->__entry_for($module)->as_string =~ /\s/}return 1}sub is_finalized {$_[0]{finalized}}sub finalize {$_[0]{finalized}=1}sub as_string_hash {my ($self)=@_;my%hash=map {;$_=>$self->{requirements}{$_}->as_string}$self->required_modules;return \%hash}my%methods_for_op=('=='=>[qw(exact_version) ],'!='=>[qw(add_exclusion) ],'>='=>[qw(add_minimum) ],'<='=>[qw(add_maximum) ],'>'=>[qw(add_minimum add_exclusion) ],'<'=>[qw(add_maximum add_exclusion) ],);sub add_string_requirement {my ($self,$module,$req)=@_;unless (defined$req && length$req){$req=0;$self->_blank_carp($module)}my$magic=_find_magic_vstring($req);if (length$magic){$self->add_minimum($module=>$magic);return}my@parts=split qr{\s*,\s*},$req;for my$part (@parts){my ($op,$ver)=$part =~ m{\A\s*(==|>=|>|<=|<|!=)\s*(.*)\z};if (!defined$op){$self->add_minimum($module=>$part)}else {Carp::confess("illegal requirement string: $req")unless my$methods=$methods_for_op{$op };$self->$_($module=>$ver)for @$methods}}}sub _blank_carp {my ($self,$module)=@_;Carp::carp("Undefined requirement for $module treated as '0'")}sub from_string_hash {my ($class,$hash,$options)=@_;my$self=$class->new($options);for my$module (keys %$hash){my$req=$hash->{$module};unless (defined$req && length$req){$req=0;$class->_blank_carp($module)}$self->add_string_requirement($module,$req)}return$self}{package CPAN::Meta::Requirements::_Range::Exact;sub _new {bless {version=>$_[1]}=>$_[0]}sub _accepts {return $_[0]{version}==$_[1]}sub as_string {return "== $_[0]{version}"}sub as_struct {return [['==',"$_[0]{version}" ]]}sub as_modifiers {return [[exact_version=>$_[0]{version}]]}sub _reject_requirements {my ($self,$module,$error)=@_;Carp::confess("illegal requirements for $module: $error")}sub _clone {(ref $_[0])->_new(version->new($_[0]{version}))}sub with_exact_version {my ($self,$version,$module)=@_;$module='module' unless defined$module;return$self->_clone if$self->_accepts($version);$self->_reject_requirements($module,"can't be exactly $version when exact requirement is already $self->{version}",)}sub with_minimum {my ($self,$minimum,$module)=@_;$module='module' unless defined$module;return$self->_clone if$self->{version}>= $minimum;$self->_reject_requirements($module,"minimum $minimum exceeds exact specification $self->{version}",)}sub with_maximum {my ($self,$maximum,$module)=@_;$module='module' unless defined$module;return$self->_clone if$self->{version}<= $maximum;$self->_reject_requirements($module,"maximum $maximum below exact specification $self->{version}",)}sub with_exclusion {my ($self,$exclusion,$module)=@_;$module='module' unless defined$module;return$self->_clone unless$exclusion==$self->{version};$self->_reject_requirements($module,"tried to exclude $exclusion, which is already exactly specified",)}}{package CPAN::Meta::Requirements::_Range::Range;sub _self {ref($_[0])? $_[0]: (bless {}=>$_[0])}sub _clone {return (bless {}=>$_[0])unless ref $_[0];my ($s)=@_;my%guts=((exists$s->{minimum}? (minimum=>version->new($s->{minimum})): ()),(exists$s->{maximum}? (maximum=>version->new($s->{maximum})): ()),(exists$s->{exclusions}? (exclusions=>[map {version->new($_)}@{$s->{exclusions}}]): ()),);bless \%guts=>ref($s)}sub as_modifiers {my ($self)=@_;my@mods;push@mods,[add_minimum=>$self->{minimum}]if exists$self->{minimum};push@mods,[add_maximum=>$self->{maximum}]if exists$self->{maximum};push@mods,map {;[add_exclusion=>$_ ]}@{$self->{exclusions}|| []};return \@mods}sub as_struct {my ($self)=@_;return 0 if!keys %$self;my@exclusions=@{$self->{exclusions}|| []};my@parts;for my$tuple ([qw(>= > minimum) ],[qw(<= < maximum) ],){my ($op,$e_op,$k)=@$tuple;if (exists$self->{$k}){my@new_exclusions=grep {$_!=$self->{$k }}@exclusions;if (@new_exclusions==@exclusions){push@parts,[$op,"$self->{ $k }" ]}else {push@parts,[$e_op,"$self->{ $k }" ];@exclusions=@new_exclusions}}}push@parts,map {;["!=","$_" ]}@exclusions;return \@parts}sub as_string {my ($self)=@_;my@parts=@{$self->as_struct};return$parts[0][1]if@parts==1 and $parts[0][0]eq '>=';return join q{, },map {;join q{ },@$_}@parts}sub _reject_requirements {my ($self,$module,$error)=@_;Carp::confess("illegal requirements for $module: $error")}sub with_exact_version {my ($self,$version,$module)=@_;$module='module' unless defined$module;$self=$self->_clone;unless ($self->_accepts($version)){$self->_reject_requirements($module,"exact specification $version outside of range " .$self->as_string)}return CPAN::Meta::Requirements::_Range::Exact->_new($version)}sub _simplify {my ($self,$module)=@_;if (defined$self->{minimum}and defined$self->{maximum}){if ($self->{minimum}==$self->{maximum}){if (grep {$_==$self->{minimum}}@{$self->{exclusions}|| []}){$self->_reject_requirements($module,"minimum and maximum are both $self->{minimum}, which is excluded",)}return CPAN::Meta::Requirements::_Range::Exact->_new($self->{minimum})}if ($self->{minimum}> $self->{maximum}){$self->_reject_requirements($module,"minimum $self->{minimum} exceeds maximum $self->{maximum}",)}}if ($self->{exclusions}){my%seen;@{$self->{exclusions}}=grep {(!defined$self->{minimum}or $_ >= $self->{minimum})and (!defined$self->{maximum}or $_ <= $self->{maximum})and !$seen{$_}++}@{$self->{exclusions}}}return$self}sub with_minimum {my ($self,$minimum,$module)=@_;$module='module' unless defined$module;$self=$self->_clone;if (defined (my$old_min=$self->{minimum})){$self->{minimum}=(sort {$b cmp $a}($minimum,$old_min))[0]}else {$self->{minimum}=$minimum}return$self->_simplify($module)}sub with_maximum {my ($self,$maximum,$module)=@_;$module='module' unless defined$module;$self=$self->_clone;if (defined (my$old_max=$self->{maximum})){$self->{maximum}=(sort {$a cmp $b}($maximum,$old_max))[0]}else {$self->{maximum}=$maximum}return$self->_simplify($module)}sub with_exclusion {my ($self,$exclusion,$module)=@_;$module='module' unless defined$module;$self=$self->_clone;push @{$self->{exclusions}||= []},$exclusion;return$self->_simplify($module)}sub _accepts {my ($self,$version)=@_;return if defined$self->{minimum}and $version < $self->{minimum};return if defined$self->{maximum}and $version > $self->{maximum};return if defined$self->{exclusions}and grep {$version==$_}@{$self->{exclusions}};return 1}}1;
CPAN_META_REQUIREMENTS

$fatpacked{"CPAN/Meta/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_SPEC';
  use 5.006;use strict;use warnings;package CPAN::Meta::Spec;our$VERSION='2.150010';1;
CPAN_META_SPEC

$fatpacked{"CPAN/Meta/Validator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_VALIDATOR';
  use 5.006;use strict;use warnings;package CPAN::Meta::Validator;our$VERSION='2.150010';my%known_specs=('1.4'=>'http://module-build.sourceforge.net/META-spec-v1.4.html','1.3'=>'http://module-build.sourceforge.net/META-spec-v1.3.html','1.2'=>'http://module-build.sourceforge.net/META-spec-v1.2.html','1.1'=>'http://module-build.sourceforge.net/META-spec-v1.1.html','1.0'=>'http://module-build.sourceforge.net/META-spec-v1.0.html');my%known_urls=map {$known_specs{$_}=>$_}keys%known_specs;my$module_map1={'map'=>{':key'=>{name=>\&module,value=>\&exversion }}};my$module_map2={'map'=>{':key'=>{name=>\&module,value=>\&version }}};my$no_index_2={'map'=>{file=>{list=>{value=>\&string }},directory=>{list=>{value=>\&string }},'package'=>{list=>{value=>\&string }},namespace=>{list=>{value=>\&string }},':key'=>{name=>\&custom_2,value=>\&anything },}};my$no_index_1_3={'map'=>{file=>{list=>{value=>\&string }},directory=>{list=>{value=>\&string }},'package'=>{list=>{value=>\&string }},namespace=>{list=>{value=>\&string }},':key'=>{name=>\&string,value=>\&anything },}};my$no_index_1_2={'map'=>{file=>{list=>{value=>\&string }},dir=>{list=>{value=>\&string }},'package'=>{list=>{value=>\&string }},namespace=>{list=>{value=>\&string }},':key'=>{name=>\&string,value=>\&anything },}};my$no_index_1_1={'map'=>{':key'=>{name=>\&string,list=>{value=>\&string }},}};my$prereq_map={map=>{':key'=>{name=>\&phase,'map'=>{':key'=>{name=>\&relation,%$module_map1,},},}},};my%definitions=('2'=>{'abstract'=>{mandatory=>1,value=>\&string },'author'=>{mandatory=>1,list=>{value=>\&string }},'dynamic_config'=>{mandatory=>1,value=>\&boolean },'generated_by'=>{mandatory=>1,value=>\&string },'license'=>{mandatory=>1,list=>{value=>\&license }},'meta-spec'=>{mandatory=>1,'map'=>{version=>{mandatory=>1,value=>\&version},url=>{value=>\&url },':key'=>{name=>\&custom_2,value=>\&anything },}},'name'=>{mandatory=>1,value=>\&string },'release_status'=>{mandatory=>1,value=>\&release_status },'version'=>{mandatory=>1,value=>\&version },'description'=>{value=>\&string },'keywords'=>{list=>{value=>\&string }},'no_index'=>$no_index_2,'optional_features'=>{'map'=>{':key'=>{name=>\&string,'map'=>{description=>{value=>\&string },prereqs=>$prereq_map,':key'=>{name=>\&custom_2,value=>\&anything },}}}},'prereqs'=>$prereq_map,'provides'=>{'map'=>{':key'=>{name=>\&module,'map'=>{file=>{mandatory=>1,value=>\&file },version=>{value=>\&version },':key'=>{name=>\&custom_2,value=>\&anything },}}}},'resources'=>{'map'=>{license=>{list=>{value=>\&url }},homepage=>{value=>\&url },bugtracker=>{'map'=>{web=>{value=>\&url },mailto=>{value=>\&string},':key'=>{name=>\&custom_2,value=>\&anything },}},repository=>{'map'=>{web=>{value=>\&url },url=>{value=>\&url },type=>{value=>\&string },':key'=>{name=>\&custom_2,value=>\&anything },}},':key'=>{value=>\&string,name=>\&custom_2 },}},':key'=>{name=>\&custom_2,value=>\&anything },},'1.4'=>{'meta-spec'=>{mandatory=>1,'map'=>{version=>{mandatory=>1,value=>\&version},url=>{mandatory=>1,value=>\&urlspec },':key'=>{name=>\&string,value=>\&anything },},},'name'=>{mandatory=>1,value=>\&string },'version'=>{mandatory=>1,value=>\&version },'abstract'=>{mandatory=>1,value=>\&string },'author'=>{mandatory=>1,list=>{value=>\&string }},'license'=>{mandatory=>1,value=>\&license },'generated_by'=>{mandatory=>1,value=>\&string },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'configure_requires'=>$module_map1,'conflicts'=>$module_map2,'optional_features'=>{'map'=>{':key'=>{name=>\&string,'map'=>{description=>{value=>\&string },requires=>$module_map1,recommends=>$module_map1,build_requires=>$module_map1,conflicts=>$module_map2,':key'=>{name=>\&string,value=>\&anything },}}}},'provides'=>{'map'=>{':key'=>{name=>\&module,'map'=>{file=>{mandatory=>1,value=>\&file },version=>{value=>\&version },':key'=>{name=>\&string,value=>\&anything },}}}},'no_index'=>$no_index_1_3,'private'=>$no_index_1_3,'keywords'=>{list=>{value=>\&string }},'resources'=>{'map'=>{license=>{value=>\&url },homepage=>{value=>\&url },bugtracker=>{value=>\&url },repository=>{value=>\&url },':key'=>{value=>\&string,name=>\&custom_1 },}},':key'=>{name=>\&string,value=>\&anything },},'1.3'=>{'meta-spec'=>{mandatory=>1,'map'=>{version=>{mandatory=>1,value=>\&version},url=>{mandatory=>1,value=>\&urlspec },':key'=>{name=>\&string,value=>\&anything },},},'name'=>{mandatory=>1,value=>\&string },'version'=>{mandatory=>1,value=>\&version },'abstract'=>{mandatory=>1,value=>\&string },'author'=>{mandatory=>1,list=>{value=>\&string }},'license'=>{mandatory=>1,value=>\&license },'generated_by'=>{mandatory=>1,value=>\&string },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'conflicts'=>$module_map2,'optional_features'=>{'map'=>{':key'=>{name=>\&string,'map'=>{description=>{value=>\&string },requires=>$module_map1,recommends=>$module_map1,build_requires=>$module_map1,conflicts=>$module_map2,':key'=>{name=>\&string,value=>\&anything },}}}},'provides'=>{'map'=>{':key'=>{name=>\&module,'map'=>{file=>{mandatory=>1,value=>\&file },version=>{value=>\&version },':key'=>{name=>\&string,value=>\&anything },}}}},'no_index'=>$no_index_1_3,'private'=>$no_index_1_3,'keywords'=>{list=>{value=>\&string }},'resources'=>{'map'=>{license=>{value=>\&url },homepage=>{value=>\&url },bugtracker=>{value=>\&url },repository=>{value=>\&url },':key'=>{value=>\&string,name=>\&custom_1 },}},':key'=>{name=>\&string,value=>\&anything },},'1.2'=>{'meta-spec'=>{mandatory=>1,'map'=>{version=>{mandatory=>1,value=>\&version},url=>{mandatory=>1,value=>\&urlspec },':key'=>{name=>\&string,value=>\&anything },},},'name'=>{mandatory=>1,value=>\&string },'version'=>{mandatory=>1,value=>\&version },'license'=>{mandatory=>1,value=>\&license },'generated_by'=>{mandatory=>1,value=>\&string },'author'=>{mandatory=>1,list=>{value=>\&string }},'abstract'=>{mandatory=>1,value=>\&string },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'keywords'=>{list=>{value=>\&string }},'private'=>$no_index_1_2,'$no_index'=>$no_index_1_2,'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'conflicts'=>$module_map2,'optional_features'=>{'map'=>{':key'=>{name=>\&string,'map'=>{description=>{value=>\&string },requires=>$module_map1,recommends=>$module_map1,build_requires=>$module_map1,conflicts=>$module_map2,':key'=>{name=>\&string,value=>\&anything },}}}},'provides'=>{'map'=>{':key'=>{name=>\&module,'map'=>{file=>{mandatory=>1,value=>\&file },version=>{value=>\&version },':key'=>{name=>\&string,value=>\&anything },}}}},'resources'=>{'map'=>{license=>{value=>\&url },homepage=>{value=>\&url },bugtracker=>{value=>\&url },repository=>{value=>\&url },':key'=>{value=>\&string,name=>\&custom_1 },}},':key'=>{name=>\&string,value=>\&anything },},'1.1'=>{'name'=>{value=>\&string },'version'=>{mandatory=>1,value=>\&version },'license'=>{value=>\&license },'generated_by'=>{value=>\&string },'license_uri'=>{value=>\&url },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'private'=>$no_index_1_1,'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'conflicts'=>$module_map2,':key'=>{name=>\&string,value=>\&anything },},'1.0'=>{'name'=>{value=>\&string },'version'=>{mandatory=>1,value=>\&version },'license'=>{value=>\&license },'generated_by'=>{value=>\&string },'license_uri'=>{value=>\&url },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'conflicts'=>$module_map2,':key'=>{name=>\&string,value=>\&anything },},);sub new {my ($class,$data)=@_;my$self={'data'=>$data,'spec'=>eval {$data->{'meta-spec'}{'version'}}|| "1.0",'errors'=>undef,};return bless$self,$class}sub is_valid {my$self=shift;my$data=$self->{data};my$spec_version=$self->{spec};$self->check_map($definitions{$spec_version},$data);return!$self->errors}sub errors {my$self=shift;return ()unless(defined$self->{errors});return @{$self->{errors}}}my$spec_error="Missing validation action in specification. " ."Must be one of 'map', 'list', or 'value'";sub check_map {my ($self,$spec,$data)=@_;if(ref($spec)ne 'HASH'){$self->_error("Unknown META specification, cannot validate.");return}if(ref($data)ne 'HASH'){$self->_error("Expected a map structure from string or file.");return}for my$key (keys %$spec){next unless($spec->{$key}->{mandatory});next if(defined$data->{$key});push @{$self->{stack}},$key;$self->_error("Missing mandatory field, '$key'");pop @{$self->{stack}}}for my$key (keys %$data){push @{$self->{stack}},$key;if($spec->{$key}){if($spec->{$key}{value}){$spec->{$key}{value}->($self,$key,$data->{$key})}elsif($spec->{$key}{'map'}){$self->check_map($spec->{$key}{'map'},$data->{$key})}elsif($spec->{$key}{'list'}){$self->check_list($spec->{$key}{'list'},$data->{$key})}else {$self->_error("$spec_error for '$key'")}}elsif ($spec->{':key'}){$spec->{':key'}{name}->($self,$key,$key);if($spec->{':key'}{value}){$spec->{':key'}{value}->($self,$key,$data->{$key})}elsif($spec->{':key'}{'map'}){$self->check_map($spec->{':key'}{'map'},$data->{$key})}elsif($spec->{':key'}{'list'}){$self->check_list($spec->{':key'}{'list'},$data->{$key})}else {$self->_error("$spec_error for ':key'")}}else {$self->_error("Unknown key, '$key', found in map structure")}pop @{$self->{stack}}}}sub check_list {my ($self,$spec,$data)=@_;if(ref($data)ne 'ARRAY'){$self->_error("Expected a list structure");return}if(defined$spec->{mandatory}){if(!defined$data->[0]){$self->_error("Missing entries from mandatory list")}}for my$value (@$data){push @{$self->{stack}},$value || "<undef>";if(defined$spec->{value}){$spec->{value}->($self,'list',$value)}elsif(defined$spec->{'map'}){$self->check_map($spec->{'map'},$value)}elsif(defined$spec->{'list'}){$self->check_list($spec->{'list'},$value)}elsif ($spec->{':key'}){$self->check_map($spec,$value)}else {$self->_error("$spec_error associated with '$self->{stack}[-2]'")}pop @{$self->{stack}}}}sub header {my ($self,$key,$value)=@_;if(defined$value){return 1 if($value && $value =~ /^--- #YAML:1.0/)}$self->_error("file does not have a valid YAML header.");return 0}sub release_status {my ($self,$key,$value)=@_;if(defined$value){my$version=$self->{data}{version}|| '';if ($version =~ /_/){return 1 if ($value =~ /\A(?:testing|unstable)\z/);$self->_error("'$value' for '$key' is invalid for version '$version'")}else {return 1 if ($value =~ /\A(?:stable|testing|unstable)\z/);$self->_error("'$value' for '$key' is invalid")}}else {$self->_error("'$key' is not defined")}return 0}sub _uri_split {return $_[0]=~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,}sub url {my ($self,$key,$value)=@_;if(defined$value){my ($scheme,$auth,$path,$query,$frag)=_uri_split($value);unless (defined$scheme && length$scheme){$self->_error("'$value' for '$key' does not have a URL scheme");return 0}unless (defined$auth && length$auth){$self->_error("'$value' for '$key' does not have a URL authority");return 0}return 1}$value ||= '';$self->_error("'$value' for '$key' is not a valid URL.");return 0}sub urlspec {my ($self,$key,$value)=@_;if(defined$value){return 1 if($value && $known_specs{$self->{spec}}eq $value);if($value && $known_urls{$value}){$self->_error('META specification URL does not match version');return 0}}$self->_error('Unknown META specification');return 0}sub anything {return 1}sub string {my ($self,$key,$value)=@_;if(defined$value){return 1 if($value || $value =~ /^0$/)}$self->_error("value is an undefined string");return 0}sub string_or_undef {my ($self,$key,$value)=@_;return 1 unless(defined$value);return 1 if($value || $value =~ /^0$/);$self->_error("No string defined for '$key'");return 0}sub file {my ($self,$key,$value)=@_;return 1 if(defined$value);$self->_error("No file defined for '$key'");return 0}sub exversion {my ($self,$key,$value)=@_;if(defined$value && ($value || $value =~ /0/)){my$pass=1;for(split(",",$value)){$self->version($key,$_)or ($pass=0)}return$pass}$value='<undef>' unless(defined$value);$self->_error("'$value' for '$key' is not a valid version.");return 0}sub version {my ($self,$key,$value)=@_;if(defined$value){return 0 unless($value || $value =~ /0/);return 1 if($value =~ /^\s*((<|<=|>=|>|!=|==)\s*)?v?\d+((\.\d+((_|\.)\d+)?)?)/)}else {$value='<undef>'}$self->_error("'$value' for '$key' is not a valid version.");return 0}sub boolean {my ($self,$key,$value)=@_;if(defined$value){return 1 if($value =~ /^(0|1)$/)}else {$value='<undef>'}$self->_error("'$value' for '$key' is not a boolean value.");return 0}my%v1_licenses=('perl'=>'http://dev.perl.org/licenses/','gpl'=>'http://www.opensource.org/licenses/gpl-license.php','apache'=>'http://apache.org/licenses/LICENSE-2.0','artistic'=>'http://opensource.org/licenses/artistic-license.php','artistic_2'=>'http://opensource.org/licenses/artistic-license-2.0.php','lgpl'=>'http://www.opensource.org/licenses/lgpl-license.php','bsd'=>'http://www.opensource.org/licenses/bsd-license.php','gpl'=>'http://www.opensource.org/licenses/gpl-license.php','mit'=>'http://opensource.org/licenses/mit-license.php','mozilla'=>'http://opensource.org/licenses/mozilla1.1.php','open_source'=>undef,'unrestricted'=>undef,'restrictive'=>undef,'unknown'=>undef,);my%v2_licenses=map {$_=>1}qw(agpl_3 apache_1_1 apache_2_0 artistic_1 artistic_2 bsd freebsd gfdl_1_2 gfdl_1_3 gpl_1 gpl_2 gpl_3 lgpl_2_1 lgpl_3_0 mit mozilla_1_0 mozilla_1_1 openssl perl_5 qpl_1_0 ssleay sun zlib open_source restricted unrestricted unknown);sub license {my ($self,$key,$value)=@_;my$licenses=$self->{spec}< 2 ? \%v1_licenses : \%v2_licenses;if(defined$value){return 1 if($value && exists$licenses->{$value})}else {$value='<undef>'}$self->_error("License '$value' is invalid");return 0}sub custom_1 {my ($self,$key)=@_;if(defined$key){return 1 if($key && $key =~ /^[_a-z]+$/i && $key =~ /[A-Z]/)}else {$key='<undef>'}$self->_error("Custom resource '$key' must be in CamelCase.");return 0}sub custom_2 {my ($self,$key)=@_;if(defined$key){return 1 if($key && $key =~ /^x_/i)}else {$key='<undef>'}$self->_error("Custom key '$key' must begin with 'x_' or 'X_'.");return 0}sub identifier {my ($self,$key)=@_;if(defined$key){return 1 if($key && $key =~ /^([a-z][_a-z]+)$/i)}else {$key='<undef>'}$self->_error("Key '$key' is not a legal identifier.");return 0}sub module {my ($self,$key)=@_;if(defined$key){return 1 if($key && $key =~ /^[A-Za-z0-9_]+(::[A-Za-z0-9_]+)*$/)}else {$key='<undef>'}$self->_error("Key '$key' is not a legal module name.");return 0}my@valid_phases=qw/configure build test runtime develop/;sub phase {my ($self,$key)=@_;if(defined$key){return 1 if(length$key && grep {$key eq $_}@valid_phases);return 1 if$key =~ /x_/i}else {$key='<undef>'}$self->_error("Key '$key' is not a legal phase.");return 0}my@valid_relations=qw/requires recommends suggests conflicts/;sub relation {my ($self,$key)=@_;if(defined$key){return 1 if(length$key && grep {$key eq $_}@valid_relations);return 1 if$key =~ /x_/i}else {$key='<undef>'}$self->_error("Key '$key' is not a legal prereq relationship.");return 0}sub _error {my$self=shift;my$mess=shift;$mess .= ' ('.join(' -> ',@{$self->{stack}}).')' if($self->{stack});$mess .= " [Validation: $self->{spec}]";push @{$self->{errors}},$mess}1;
CPAN_META_VALIDATOR

$fatpacked{"CPAN/Meta/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_YAML';
  use 5.008001;use strict;use warnings;package CPAN::Meta::YAML;$CPAN::Meta::YAML::VERSION='0.018';;use Exporter;our@ISA=qw{Exporter};our@EXPORT=qw{Load Dump};our@EXPORT_OK=qw{LoadFile DumpFile freeze thaw};sub Dump {return CPAN::Meta::YAML->new(@_)->_dump_string}sub Load {my$self=CPAN::Meta::YAML->_load_string(@_);if (wantarray){return @$self}else {return$self->[-1]}}BEGIN {*freeze=\&Dump;*thaw=\&Load}sub DumpFile {my$file=shift;return CPAN::Meta::YAML->new(@_)->_dump_file($file)}sub LoadFile {my$file=shift;my$self=CPAN::Meta::YAML->_load_file($file);if (wantarray){return @$self}else {return$self->[-1]}}sub new {my$class=shift;bless [@_ ],$class}sub read_string {my$self=shift;$self->_load_string(@_)}sub write_string {my$self=shift;$self->_dump_string(@_)}sub read {my$self=shift;$self->_load_file(@_)}sub write {my$self=shift;$self->_dump_file(@_)}my@UNPRINTABLE=qw(0 x01 x02 x03 x04 x05 x06 a b t n v f r x0E x0F x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x1A e x1C x1D x1E x1F);my%UNESCAPES=(0=>"\x00",z=>"\x00",N=>"\x85",a=>"\x07",b=>"\x08",t=>"\x09",n=>"\x0a",v=>"\x0b",f=>"\x0c",r=>"\x0d",e=>"\x1b",'\\'=>'\\',);my%QUOTE=map {$_=>1}qw{null true false};my$re_capture_double_quoted=qr/\"([^\\"]*(?:\\.[^\\"]*)*)\"/;my$re_capture_single_quoted=qr/\'([^\']*(?:\'\'[^\']*)*)\'/;my$re_capture_unquoted_key=qr/([^:]+(?::+\S(?:[^:]*|.*?(?=:)))*)(?=\s*\:(?:\s+|$))/;my$re_trailing_comment=qr/(?:\s+\#.*)?/;my$re_key_value_separator=qr/\s*:(?:\s+(?:\#.*)?|$)/;sub _load_file {my$class=ref $_[0]? ref shift : shift;my$file=shift or $class->_error('You did not specify a file name');$class->_error("File '$file' does not exist")unless -e $file;$class->_error("'$file' is a directory, not a file")unless -f _;$class->_error("Insufficient permissions to read '$file'")unless -r _;open(my$fh,"<:unix:encoding(UTF-8)",$file);unless ($fh){$class->_error("Failed to open file '$file': $!")}if (_can_flock()){flock($fh,Fcntl::LOCK_SH())or warn "Couldn't lock '$file' for reading: $!"}my$contents=eval {use warnings FATAL=>'utf8';local $/;<$fh>};if (my$err=$@){$class->_error("Error reading from file '$file': $err")}unless (close$fh){$class->_error("Failed to close file '$file': $!")}$class->_load_string($contents)}sub _load_string {my$class=ref $_[0]? ref shift : shift;my$self=bless [],$class;my$string=$_[0];eval {unless (defined$string){die \"Did not provide a string to load"}if (utf8::is_utf8($string)&&!utf8::valid($string)){die \<<'...'}utf8::upgrade($string);$string =~ s/^\x{FEFF}//;return$self unless length$string;my@lines=grep {!/^\s*(?:\#.*)?\z/}split /(?:\015{1,2}\012|\015|\012)/,$string;@lines and $lines[0]=~ /^\%YAML[: ][\d\.]+.*\z/ and shift@lines;my$in_document=0;while (@lines){if ($lines[0]=~ /^---\s*(?:(.+)\s*)?\z/){shift@lines;if (defined $1 and $1 !~ /^(?:\#.+|\%YAML[: ][\d\.]+)\z/){push @$self,$self->_load_scalar("$1",[undef ],\@lines);next}$in_document=1}if (!@lines or $lines[0]=~ /^(?:---|\.\.\.)/){push @$self,undef;while (@lines and $lines[0]!~ /^---/){shift@lines}$in_document=0}elsif (!$in_document && @$self){die \"CPAN::Meta::YAML failed to classify the line '$lines[0]'"}elsif ($lines[0]=~ /^\s*\-(?:\s|$|-+$)/){my$document=[];push @$self,$document;$self->_load_array($document,[0 ],\@lines)}elsif ($lines[0]=~ /^(\s*)\S/){my$document={};push @$self,$document;$self->_load_hash($document,[length($1)],\@lines)}else {die \"CPAN::Meta::YAML failed to classify the line '$lines[0]'"}}};my$err=$@;if (ref$err eq 'SCALAR'){$self->_error(${$err})}elsif ($err){$self->_error($err)}return$self}sub _unquote_single {my ($self,$string)=@_;return '' unless length$string;$string =~ s/\'\'/\'/g;return$string}sub _unquote_double {my ($self,$string)=@_;return '' unless length$string;$string =~ s/\\"/"/g;$string =~ s{\\([Nnever\\fartz0b]|x([0-9a-fA-F]{2}))}
  Read an invalid UTF-8 string (maybe mixed UTF-8 and 8-bit character set).
  Did you decode with lax ":utf8" instead of strict ":encoding(UTF-8)"?
  ...
           {(length($1)>1)?pack("H2",$2):$UNESCAPES{$1}}gex;return$string}sub _load_scalar {my ($self,$string,$indent,$lines)=@_;$string =~ s/\s*\z//;return undef if$string eq '~';if ($string =~ /^$re_capture_single_quoted$re_trailing_comment\z/){return$self->_unquote_single($1)}if ($string =~ /^$re_capture_double_quoted$re_trailing_comment\z/){return$self->_unquote_double($1)}if ($string =~ /^[\'\"!&]/){die \"CPAN::Meta::YAML does not support a feature in line '$string'"}return {}if$string =~ /^{}(?:\s+\#.*)?\z/;return []if$string =~ /^\[\](?:\s+\#.*)?\z/;if ($string !~ /^[>|]/){die \"CPAN::Meta::YAML found illegal characters in plain scalar: '$string'" if$string =~ /^(?:-(?:\s|$)|[\@\%\`])/ or $string =~ /:(?:\s|$)/;$string =~ s/\s+#.*\z//;return$string}die \"CPAN::Meta::YAML failed to find multi-line scalar content" unless @$lines;$lines->[0]=~ /^(\s*)/;$indent->[-1]=length("$1");if (defined$indent->[-2]and $indent->[-1]<= $indent->[-2]){die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'"}my@multiline=();while (@$lines){$lines->[0]=~ /^(\s*)/;last unless length($1)>= $indent->[-1];push@multiline,substr(shift(@$lines),length($1))}my$j=(substr($string,0,1)eq '>')? ' ' : "\n";my$t=(substr($string,1,1)eq '-')? '' : "\n";return join($j,@multiline).$t}sub _load_array {my ($self,$array,$indent,$lines)=@_;while (@$lines){if ($lines->[0]=~ /^(?:---|\.\.\.)/){while (@$lines and $lines->[0]!~ /^---/){shift @$lines}return 1}$lines->[0]=~ /^(\s*)/;if (length($1)< $indent->[-1]){return 1}elsif (length($1)> $indent->[-1]){die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'"}if ($lines->[0]=~ /^(\s*\-\s+)[^\'\"]\S*\s*:(?:\s+|$)/){my$indent2=length("$1");$lines->[0]=~ s/-/ /;push @$array,{};$self->_load_hash($array->[-1],[@$indent,$indent2 ],$lines)}elsif ($lines->[0]=~ /^\s*\-\s*\z/){shift @$lines;unless (@$lines){push @$array,undef;return 1}if ($lines->[0]=~ /^(\s*)\-/){my$indent2=length("$1");if ($indent->[-1]==$indent2){push @$array,undef}else {push @$array,[];$self->_load_array($array->[-1],[@$indent,$indent2 ],$lines)}}elsif ($lines->[0]=~ /^(\s*)\S/){push @$array,{};$self->_load_hash($array->[-1],[@$indent,length("$1")],$lines)}else {die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'"}}elsif ($lines->[0]=~ /^\s*\-(\s*)(.+?)\s*\z/){shift @$lines;push @$array,$self->_load_scalar("$2",[@$indent,undef ],$lines)}elsif (defined$indent->[-2]and $indent->[-1]==$indent->[-2]){return 1}else {die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'"}}return 1}sub _load_hash {my ($self,$hash,$indent,$lines)=@_;while (@$lines){if ($lines->[0]=~ /^(?:---|\.\.\.)/){while (@$lines and $lines->[0]!~ /^---/){shift @$lines}return 1}$lines->[0]=~ /^(\s*)/;if (length($1)< $indent->[-1]){return 1}elsif (length($1)> $indent->[-1]){die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'"}my$key;if ($lines->[0]=~ s/^\s*$re_capture_single_quoted$re_key_value_separator//){$key=$self->_unquote_single($1)}elsif ($lines->[0]=~ s/^\s*$re_capture_double_quoted$re_key_value_separator//){$key=$self->_unquote_double($1)}elsif ($lines->[0]=~ s/^\s*$re_capture_unquoted_key$re_key_value_separator//){$key=$1;$key =~ s/\s+$//}elsif ($lines->[0]=~ /^\s*\?/){die \"CPAN::Meta::YAML does not support a feature in line '$lines->[0]'"}else {die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'"}if (exists$hash->{$key}){warn "CPAN::Meta::YAML found a duplicate key '$key' in line '$lines->[0]'"}if (length$lines->[0]){$hash->{$key}=$self->_load_scalar(shift(@$lines),[@$indent,undef ],$lines)}else {shift @$lines;unless (@$lines){$hash->{$key}=undef;return 1}if ($lines->[0]=~ /^(\s*)-/){$hash->{$key}=[];$self->_load_array($hash->{$key},[@$indent,length($1)],$lines)}elsif ($lines->[0]=~ /^(\s*)./){my$indent2=length("$1");if ($indent->[-1]>= $indent2){$hash->{$key}=undef}else {$hash->{$key}={};$self->_load_hash($hash->{$key},[@$indent,length($1)],$lines)}}}}return 1}sub _dump_file {my$self=shift;require Fcntl;my$file=shift or $self->_error('You did not specify a file name');my$fh;if (_can_flock()){my$flags=Fcntl::O_WRONLY()|Fcntl::O_CREAT();sysopen($fh,$file,$flags);unless ($fh){$self->_error("Failed to open file '$file' for writing: $!")}binmode($fh,":raw:encoding(UTF-8)");flock($fh,Fcntl::LOCK_EX())or warn "Couldn't lock '$file' for reading: $!";truncate$fh,0;seek$fh,0,0}else {open$fh,">:unix:encoding(UTF-8)",$file}print {$fh}$self->_dump_string;unless (close$fh){$self->_error("Failed to close file '$file': $!")}return 1}sub _dump_string {my$self=shift;return '' unless ref$self && @$self;my$indent=0;my@lines=();eval {for my$cursor (@$self){push@lines,'---';if (!defined$cursor){}elsif (!ref$cursor){$lines[-1].= ' ' .$self->_dump_scalar($cursor)}elsif (ref$cursor eq 'ARRAY'){unless (@$cursor){$lines[-1].= ' []';next}push@lines,$self->_dump_array($cursor,$indent,{})}elsif (ref$cursor eq 'HASH'){unless (%$cursor){$lines[-1].= ' {}';next}push@lines,$self->_dump_hash($cursor,$indent,{})}else {die \("Cannot serialize " .ref($cursor))}}};if (ref $@ eq 'SCALAR'){$self->_error(${$@})}elsif ($@){$self->_error($@)}join '',map {"$_\n"}@lines}sub _has_internal_string_value {my$value=shift;my$b_obj=B::svref_2object(\$value);return$b_obj->FLAGS & B::SVf_POK()}sub _dump_scalar {my$string=$_[1];my$is_key=$_[2];my$has_string_flag=_has_internal_string_value($string);return '~' unless defined$string;return "''" unless length$string;if (Scalar::Util::looks_like_number($string)){if ($is_key || $has_string_flag){return qq['$string']}else {return$string}}if ($string =~ /[\x00-\x09\x0b-\x0d\x0e-\x1f\x7f-\x9f\'\n]/){$string =~ s/\\/\\\\/g;$string =~ s/"/\\"/g;$string =~ s/\n/\\n/g;$string =~ s/[\x85]/\\N/g;$string =~ s/([\x00-\x1f])/\\$UNPRINTABLE[ord($1)]/g;$string =~ s/([\x7f-\x9f])/'\x' . sprintf("%X",ord($1))/ge;return qq|"$string"|}if ($string =~ /(?:^[~!@#%&*|>?:,'"`{}\[\]]|^-+$|\s|:\z)/ or $QUOTE{$string}){return "'$string'"}return$string}sub _dump_array {my ($self,$array,$indent,$seen)=@_;if ($seen->{refaddr($array)}++){die \"CPAN::Meta::YAML does not support circular references"}my@lines=();for my$el (@$array){my$line=('  ' x $indent).'-';my$type=ref$el;if (!$type){$line .= ' ' .$self->_dump_scalar($el);push@lines,$line}elsif ($type eq 'ARRAY'){if (@$el){push@lines,$line;push@lines,$self->_dump_array($el,$indent + 1,$seen)}else {$line .= ' []';push@lines,$line}}elsif ($type eq 'HASH'){if (keys %$el){push@lines,$line;push@lines,$self->_dump_hash($el,$indent + 1,$seen)}else {$line .= ' {}';push@lines,$line}}else {die \"CPAN::Meta::YAML does not support $type references"}}@lines}sub _dump_hash {my ($self,$hash,$indent,$seen)=@_;if ($seen->{refaddr($hash)}++){die \"CPAN::Meta::YAML does not support circular references"}my@lines=();for my$name (sort keys %$hash){my$el=$hash->{$name};my$line=('  ' x $indent).$self->_dump_scalar($name,1).":";my$type=ref$el;if (!$type){$line .= ' ' .$self->_dump_scalar($el);push@lines,$line}elsif ($type eq 'ARRAY'){if (@$el){push@lines,$line;push@lines,$self->_dump_array($el,$indent + 1,$seen)}else {$line .= ' []';push@lines,$line}}elsif ($type eq 'HASH'){if (keys %$el){push@lines,$line;push@lines,$self->_dump_hash($el,$indent + 1,$seen)}else {$line .= ' {}';push@lines,$line}}else {die \"CPAN::Meta::YAML does not support $type references"}}@lines}our$errstr='';sub _error {require Carp;$errstr=$_[1];$errstr =~ s/ at \S+ line \d+.*//;Carp::croak($errstr)}my$errstr_warned;sub errstr {require Carp;Carp::carp("CPAN::Meta::YAML->errstr and \$CPAN::Meta::YAML::errstr is deprecated")unless$errstr_warned++;$errstr}use B;my$HAS_FLOCK;sub _can_flock {if (defined$HAS_FLOCK){return$HAS_FLOCK}else {require Config;my$c=\%Config::Config;$HAS_FLOCK=grep {$c->{$_}}qw/d_flock d_fcntl_can_lock d_lockf/;require Fcntl if$HAS_FLOCK;return$HAS_FLOCK}}use Scalar::Util ();BEGIN {local $@;if (eval {Scalar::Util->VERSION(1.18)}){*refaddr=*Scalar::Util::refaddr}else {eval <<'END_PERL'}}delete$CPAN::Meta::YAML::{refaddr};1;
  # Scalar::Util failed to load or too old
  sub refaddr {
      my $pkg = ref($_[0]) or return undef;
      if ( !! UNIVERSAL::can($_[0], 'can') ) {
          bless $_[0], 'Scalar::Util::Fake';
      } else {
          $pkg = undef;
      }
      "$_[0]" =~ /0x(\w+)/;
      my $i = do { no warnings 'portable'; hex $1 };
      bless $_[0], $pkg if defined $pkg;
      $i;
  }
  END_PERL
CPAN_META_YAML

$fatpacked{"Capture/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CAPTURE_TINY';
  use 5.006;use strict;use warnings;package Capture::Tiny;our$VERSION='0.48';use Carp ();use Exporter ();use IO::Handle ();use File::Spec ();use File::Temp qw/tempfile tmpnam/;use Scalar::Util qw/reftype blessed/;BEGIN {local $@;eval {require PerlIO;PerlIO->can('get_layers')}or *PerlIO::get_layers=sub {return ()}}my%api=(capture=>[1,1,0,0],capture_stdout=>[1,0,0,0],capture_stderr=>[0,1,0,0],capture_merged=>[1,1,1,0],tee=>[1,1,0,1],tee_stdout=>[1,0,0,1],tee_stderr=>[0,1,0,1],tee_merged=>[1,1,1,1],);for my$sub (keys%api){my$args=join q{, },@{$api{$sub}};eval "sub $sub(&;@) {unshift \@_, $args; goto \\&_capture_tee;}"}our@ISA=qw/Exporter/;our@EXPORT_OK=keys%api;our%EXPORT_TAGS=('all'=>\@EXPORT_OK);my$IS_WIN32=$^O eq 'MSWin32';our$TIMEOUT=30;my@cmd=($^X,'-C0','-e',<<'HERE');sub _relayer {my ($fh,$apply_layers)=@_;binmode($fh,":raw");while (1 < (my$layers=()=PerlIO::get_layers($fh,output=>1))){binmode($fh,":pop")}my@to_apply=@$apply_layers;shift@to_apply;binmode($fh,":" .join(":",@to_apply))}sub _name {my$glob=shift;no strict 'refs';return *{$glob}{NAME}}sub _open {open $_[0],$_[1]or Carp::confess "Error from open(" .join(q{, },@_)."): $!"}sub _close {close $_[0]or Carp::confess "Error from close(" .join(q{, },@_)."): $!"}my%dup;my%proxy_count;sub _proxy_std {my%proxies;if (!defined fileno STDIN){$proxy_count{stdin}++;if (defined$dup{stdin}){_open \*STDIN,"<&=" .fileno($dup{stdin})}else {_open \*STDIN,"<" .File::Spec->devnull;_open$dup{stdin}=IO::Handle->new,"<&=STDIN"}$proxies{stdin}=\*STDIN;binmode(STDIN,':utf8')if $] >= 5.008}if (!defined fileno STDOUT){$proxy_count{stdout}++;if (defined$dup{stdout}){_open \*STDOUT,">&=" .fileno($dup{stdout})}else {_open \*STDOUT,">" .File::Spec->devnull;_open$dup{stdout}=IO::Handle->new,">&=STDOUT"}$proxies{stdout}=\*STDOUT;binmode(STDOUT,':utf8')if $] >= 5.008}if (!defined fileno STDERR){$proxy_count{stderr}++;if (defined$dup{stderr}){_open \*STDERR,">&=" .fileno($dup{stderr})}else {_open \*STDERR,">" .File::Spec->devnull;_open$dup{stderr}=IO::Handle->new,">&=STDERR"}$proxies{stderr}=\*STDERR;binmode(STDERR,':utf8')if $] >= 5.008}return%proxies}sub _unproxy {my (%proxies)=@_;for my$p (keys%proxies){$proxy_count{$p}--;if (!$proxy_count{$p}){_close$proxies{$p};_close$dup{$p}unless $] < 5.008;delete$dup{$p}}}}sub _copy_std {my%handles;for my$h (qw/stdout stderr stdin/){next if$h eq 'stdin' &&!$IS_WIN32;my$redir=$h eq 'stdin' ? "<&" : ">&";_open$handles{$h}=IO::Handle->new(),$redir .uc($h)}return \%handles}sub _open_std {my ($handles)=@_;_open \*STDIN,"<&" .fileno$handles->{stdin}if defined$handles->{stdin};_open \*STDOUT,">&" .fileno$handles->{stdout}if defined$handles->{stdout};_open \*STDERR,">&" .fileno$handles->{stderr}if defined$handles->{stderr}}sub _start_tee {my ($which,$stash)=@_;$stash->{$_}{$which}=IO::Handle->new for qw/tee reader/;pipe$stash->{reader}{$which},$stash->{tee}{$which};select((select($stash->{tee}{$which}),$|=1)[0]);$stash->{new}{$which}=$stash->{tee}{$which};$stash->{child}{$which}={stdin=>$stash->{reader}{$which},stdout=>$stash->{old}{$which},stderr=>$stash->{capture}{$which},};$stash->{flag_files}{$which}=scalar(tmpnam()).$$;if ($IS_WIN32){my$old_eval_err=$@;undef $@;eval "use Win32API::File qw/GetOsFHandle SetHandleInformation fileLastError HANDLE_FLAG_INHERIT INVALID_HANDLE_VALUE/ ";my$os_fhandle=GetOsFHandle($stash->{tee}{$which});my$result=SetHandleInformation($os_fhandle,HANDLE_FLAG_INHERIT(),0);_open_std($stash->{child}{$which});$stash->{pid}{$which}=system(1,@cmd,$stash->{flag_files}{$which});$@=$old_eval_err}else {_fork_exec($which,$stash)}}sub _fork_exec {my ($which,$stash)=@_;my$pid=fork;if (not defined$pid){Carp::confess "Couldn't fork(): $!"}elsif ($pid==0){untie*STDIN;untie*STDOUT;untie*STDERR;_close$stash->{tee}{$which};_open_std($stash->{child}{$which});exec@cmd,$stash->{flag_files}{$which}}$stash->{pid}{$which}=$pid}my$have_usleep=eval "use Time::HiRes 'usleep'; 1";sub _files_exist {return 1 if @_==grep {-f}@_;Time::HiRes::usleep(1000)if$have_usleep;return 0}sub _wait_for_tees {my ($stash)=@_;my$start=time;my@files=values %{$stash->{flag_files}};my$timeout=defined$ENV{PERL_CAPTURE_TINY_TIMEOUT}? $ENV{PERL_CAPTURE_TINY_TIMEOUT}: $TIMEOUT;1 until _files_exist(@files)|| ($timeout && (time - $start > $timeout));Carp::confess "Timed out waiting for subprocesses to start" if!_files_exist(@files);unlink $_ for@files}sub _kill_tees {my ($stash)=@_;if ($IS_WIN32){close($_)for values %{$stash->{tee}};my$start=time;1 until wait==-1 || (time - $start > 30)}else {_close $_ for values %{$stash->{tee}};waitpid $_,0 for values %{$stash->{pid}}}}sub _slurp {my ($name,$stash)=@_;my ($fh,$pos)=map {$stash->{$_}{$name}}qw/capture pos/;seek($fh,$pos,0)or die "Couldn't seek on capture handle for $name\n";my$text=do {local $/;scalar readline$fh};return defined($text)? $text : ""}sub _capture_tee {my ($do_stdout,$do_stderr,$do_merge,$do_tee,$code,@opts)=@_;my%do=($do_stdout ? (stdout=>1): (),$do_stderr ? (stderr=>1): ());Carp::confess("Custom capture options must be given as key/value pairs\n")unless@opts % 2==0;my$stash={capture=>{@opts }};for (keys %{$stash->{capture}}){my$fh=$stash->{capture}{$_};Carp::confess "Custom handle for $_ must be seekable\n" unless ref($fh)eq 'GLOB' || (blessed($fh)&& $fh->isa("IO::Seekable"))}local*CT_ORIG_STDIN=*STDIN ;local*CT_ORIG_STDOUT=*STDOUT;local*CT_ORIG_STDERR=*STDERR;my%layers=(stdin=>[PerlIO::get_layers(\*STDIN)],stdout=>[PerlIO::get_layers(\*STDOUT,output=>1)],stderr=>[PerlIO::get_layers(\*STDERR,output=>1)],);$layers{stdout}=[PerlIO::get_layers(tied*STDOUT)]if tied(*STDOUT)&& (reftype tied*STDOUT eq 'GLOB');$layers{stderr}=[PerlIO::get_layers(tied*STDERR)]if tied(*STDERR)&& (reftype tied*STDERR eq 'GLOB');my%localize;$localize{stdin}++,local(*STDIN)if grep {$_ eq 'scalar'}@{$layers{stdin}};$localize{stdout}++,local(*STDOUT)if$do_stdout && grep {$_ eq 'scalar'}@{$layers{stdout}};$localize{stderr}++,local(*STDERR)if ($do_stderr || $do_merge)&& grep {$_ eq 'scalar'}@{$layers{stderr}};$localize{stdin}++,local(*STDIN),_open(\*STDIN,"<&=0")if tied*STDIN && $] >= 5.008;$localize{stdout}++,local(*STDOUT),_open(\*STDOUT,">&=1")if$do_stdout && tied*STDOUT && $] >= 5.008;$localize{stderr}++,local(*STDERR),_open(\*STDERR,">&=2")if ($do_stderr || $do_merge)&& tied*STDERR && $] >= 5.008;my%proxy_std=_proxy_std();$layers{stdout}=[PerlIO::get_layers(\*STDOUT,output=>1)]if$proxy_std{stdout};$layers{stderr}=[PerlIO::get_layers(\*STDERR,output=>1)]if$proxy_std{stderr};$stash->{old}=_copy_std();$stash->{new}={%{$stash->{old}}};for (keys%do){$stash->{new}{$_}=($stash->{capture}{$_}||= File::Temp->new);seek($stash->{capture}{$_},0,2)or die "Could not seek on capture handle for $_\n";$stash->{pos}{$_}=tell$stash->{capture}{$_};_start_tee($_=>$stash)if$do_tee}_wait_for_tees($stash)if$do_tee;$stash->{new}{stderr}=$stash->{new}{stdout}if$do_merge;_open_std($stash->{new});my ($exit_code,$inner_error,$outer_error,$orig_pid,@result);{$orig_pid=$$;local*STDIN=*CT_ORIG_STDIN if$localize{stdin};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;my$old_eval_err=$@;undef $@;eval {@result=$code->();$inner_error=$@};$exit_code=$?;$outer_error=$@;STDOUT->flush if$do_stdout;STDERR->flush if$do_stderr;$@=$old_eval_err}_open_std($stash->{old});_close($_)for values %{$stash->{old}};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;_unproxy(%proxy_std);_kill_tees($stash)if$do_tee;my%got;if ($orig_pid==$$ and (defined wantarray or ($do_tee && keys%localize))){for (keys%do){_relayer($stash->{capture}{$_},$layers{$_});$got{$_}=_slurp($_,$stash)}print CT_ORIG_STDOUT$got{stdout}if$do_stdout && $do_tee && $localize{stdout};print CT_ORIG_STDERR$got{stderr}if$do_stderr && $do_tee && $localize{stderr}}$?=$exit_code;$@=$inner_error if$inner_error;die$outer_error if$outer_error;return unless defined wantarray;my@return;push@return,$got{stdout}if$do_stdout;push@return,$got{stderr}if$do_stderr &&!$do_merge;push@return,@result;return wantarray ? @return : $return[0]}1;
  use Fcntl;
  $SIG{HUP}=sub{exit};
  if ( my $fn=shift ) {
      sysopen(my $fh, qq{$fn}, O_WRONLY|O_CREAT|O_EXCL) or die $!;
      print {$fh} $$;
      close $fh;
  }
  my $buf; while (sysread(STDIN, $buf, 2048)) {
      syswrite(STDOUT, $buf); syswrite(STDERR, $buf);
  }
  HERE
CAPTURE_TINY

$fatpacked{"Carp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARP';
  package Carp;{use 5.006}use strict;use warnings;BEGIN {if(!defined($warnings::VERSION)|| eval($warnings::VERSION)< 1.06){${^WARNING_BITS}=""}else {"warnings"->unimport("utf8")}}sub _fetch_sub {my($pack,$sub)=@_;$pack .= '::';return unless exists($::{$pack});for ($::{$pack}){return unless ref \$_ eq 'GLOB' && *$_{HASH}&& exists $$_{$sub};for ($$_{$sub}){return ref \$_ eq 'GLOB' ? *$_{CODE}: undef}}}BEGIN {if("$]" < 5.013011){*UTF8_REGEXP_PROBLEM=sub () {1}}else {*UTF8_REGEXP_PROBLEM=sub () {0}}}BEGIN {if(defined(my$sub=_fetch_sub utf8=>'is_utf8')){*is_utf8=$sub}else {*is_utf8=sub {unpack("C","\xaa".$_[0])!=170}}}BEGIN {if(defined(my$sub=_fetch_sub utf8=>'downgrade')){*downgrade=\&{"utf8::downgrade"}}else {*downgrade=sub {my$r="";my$l=length($_[0]);for(my$i=0;$i!=$l;$i++){my$o=ord(substr($_[0],$i,1));return if$o > 255;$r .= chr($o)}$_[0]=$r}}}BEGIN {*is_safe_printable_codepoint="$]" >= 5.007_003 ? eval(q(sub ($) {
  		my $u = utf8::native_to_unicode($_[0]);
  		$u >= 0x20 && $u <= 0x7e;
  	    })): ord("A")==65 ? sub ($) {$_[0]>= 0x20 && $_[0]<= 0x7e}: sub ($) {$_[0]>= ord(" ")&& $_[0]<= 0xff && $_[0]!=(ord ("^")==106 ? 0x5f : 0xff)}}sub _univ_mod_loaded {return 0 unless exists($::{"UNIVERSAL::"});for ($::{"UNIVERSAL::"}){return 0 unless ref \$_ eq "GLOB" && *$_{HASH}&& exists $$_{"$_[0]::"};for ($$_{"$_[0]::"}){return 0 unless ref \$_ eq "GLOB" && *$_{HASH}&& exists $$_{"VERSION"};for ($$_{"VERSION"}){return 0 unless ref \$_ eq "GLOB";return ${*$_{SCALAR}}}}}}my$isa;BEGIN {if (_univ_mod_loaded('isa')){*_maybe_isa=sub {1}}else {*_maybe_isa=$isa=_fetch_sub(UNIVERSAL=>"isa")}}BEGIN {if (eval {require "overloading.pm"}){*_StrVal=eval 'sub { no overloading; "$_[0]" }'}else {*_mycan=_univ_mod_loaded('can')? do {require "overload.pm";_fetch_sub overload=>'mycan'}: \&UNIVERSAL::can;*_blessed=$isa ? sub {&$isa($_[0],"UNIVERSAL")}: sub {my$probe="UNIVERSAL::Carp_probe_" .rand;no strict 'refs';local *$probe=sub {"unlikely string"};local $@;local$SIG{__DIE__}=sub{};(eval {$_[0]->$probe}|| '')eq 'unlikely string'};*_StrVal=sub {my$pack=ref $_[0];return "$_[0]" unless _mycan($pack,"()");return "$_[0]" if not _blessed($_[0]);bless $_[0],"Carp";my$str="$_[0]";bless $_[0],$pack;$pack .substr$str,index$str,"="}}}our$VERSION='1.50';$VERSION =~ tr/_//d;our$MaxEvalLen=0;our$Verbose=0;our$CarpLevel=0;our$MaxArgLen=64;our$MaxArgNums=8;our$RefArgFormatter=undef;require Exporter;our@ISA=('Exporter');our@EXPORT=qw(confess croak carp);our@EXPORT_OK=qw(cluck verbose longmess shortmess);our@EXPORT_FAIL=qw(verbose);our%CarpInternal;our%Internal;$CarpInternal{Carp}++;$CarpInternal{warnings}++;$Internal{Exporter}++;$Internal{'Exporter::Heavy'}++;sub export_fail {shift;$Verbose=shift if $_[0]eq 'verbose';@_}sub _cgc {no strict 'refs';return \&{"CORE::GLOBAL::caller"}if defined &{"CORE::GLOBAL::caller"};return}sub longmess {local($!,$^E);my$cgc=_cgc();my$call_pack=$cgc ? $cgc->(): caller();if ($Internal{$call_pack}or $CarpInternal{$call_pack}){return longmess_heavy(@_)}else {local$CarpLevel=$CarpLevel + 1;return longmess_heavy(@_)}}our@CARP_NOT;sub shortmess {local($!,$^E);my$cgc=_cgc();local@CARP_NOT=$cgc ? $cgc->(): caller();shortmess_heavy(@_)}sub croak {die shortmess @_}sub confess {die longmess @_}sub carp {warn shortmess @_}sub cluck {warn longmess @_}BEGIN {if("$]" >= 5.015002 || ("$]" >= 5.014002 && "$]" < 5.015)|| ("$]" >= 5.012005 && "$]" < 5.013)){*CALLER_OVERRIDE_CHECK_OK=sub () {1}}else {*CALLER_OVERRIDE_CHECK_OK=sub () {0}}}sub caller_info {my$i=shift(@_)+ 1;my%call_info;my$cgc=_cgc();{@DB::args=\$i if CALLER_OVERRIDE_CHECK_OK;package DB;@call_info{qw(pack file line sub has_args wantarray evaltext is_require) }=$cgc ? $cgc->($i): caller($i)}unless (defined$call_info{file}){return ()}my$sub_name=Carp::get_subname(\%call_info);if ($call_info{has_args}){my@args=map {my$arg;local $@=$@;eval {$arg=$_;1}or do {$arg='** argument not available anymore **'};$arg}@DB::args;if (CALLER_OVERRIDE_CHECK_OK && @args==1 && ref$args[0]eq ref \$i && $args[0]==\$i){@args=();local $@;my$where=eval {my$func=$cgc or return '';my$gv=(_fetch_sub B=>'svref_2object' or return '')->($func)->GV;my$package=$gv->STASH->NAME;my$subname=$gv->NAME;return unless defined$package && defined$subname;return if$package eq 'CORE::GLOBAL' && $subname eq 'caller';" in &${package}::$subname"}|| '';@args ="** Incomplete caller override detected$where; \@DB::args were not set **"}else {my$overflow;if ($MaxArgNums and @args > $MaxArgNums){$#args=$MaxArgNums - 1;$overflow=1}@args=map {Carp::format_arg($_)}@args;if ($overflow){push@args,'...'}}$sub_name .= '(' .join(', ',@args).')'}$call_info{sub_name}=$sub_name;return wantarray()? %call_info : \%call_info}our$in_recurse;sub format_arg {my$arg=shift;if (my$pack=ref($arg)){if (!$in_recurse && _maybe_isa($arg,'UNIVERSAL')&& do {local $@;local$in_recurse=1;local$SIG{__DIE__}=sub{};eval {$arg->can('CARP_TRACE')}}){return$arg->CARP_TRACE()}elsif (!$in_recurse && defined($RefArgFormatter)&& do {local $@;local$in_recurse=1;local$SIG{__DIE__}=sub{};eval {$arg=$RefArgFormatter->($arg);1}}){return$arg}else {return _StrVal$arg}}return "undef" if!defined($arg);downgrade($arg,1);return$arg if!(UTF8_REGEXP_PROBLEM && is_utf8($arg))&& $arg =~ /\A-?[0-9]+(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?\z/;my$suffix="";if (2 < $MaxArgLen and $MaxArgLen < length($arg)){substr ($arg,$MaxArgLen - 3)="";$suffix="..."}if(UTF8_REGEXP_PROBLEM && is_utf8($arg)){for(my$i=length($arg);$i--;){my$c=substr($arg,$i,1);my$x=substr($arg,0,0);if($c eq "\"" || $c eq "\\" || $c eq "\$" || $c eq "\@"){substr$arg,$i,0,"\\";next}my$o=ord($c);substr$arg,$i,1,sprintf("\\x{%x}",$o)unless is_safe_printable_codepoint($o)}}else {$arg =~ s/([\"\\\$\@])/\\$1/g;$arg =~ s/([^ !"#\$\%\&'()*+,\-.\/0123456789:;<=>?\@ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\\\]^_`abcdefghijklmnopqrstuvwxyz\{|}~])/sprintf("\\x{%x}",ord($1))/eg}downgrade($arg,1);return "\"".$arg."\"".$suffix}sub Regexp::CARP_TRACE {my$arg="$_[0]";downgrade($arg,1);if(UTF8_REGEXP_PROBLEM && is_utf8($arg)){for(my$i=length($arg);$i--;){my$o=ord(substr($arg,$i,1));my$x=substr($arg,0,0);substr$arg,$i,1,sprintf("\\x{%x}",$o)unless is_safe_printable_codepoint($o)}}else {$arg =~ s/([^ !"#\$\%\&'()*+,\-.\/0123456789:;<=>?\@ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\\\]^_`abcdefghijklmnopqrstuvwxyz\{|}~])/sprintf("\\x{%x}",ord($1))/eg}downgrade($arg,1);my$suffix="";if($arg =~ /\A\(\?\^?([a-z]*)(?:-[a-z]*)?:(.*)\)\z/s){($suffix,$arg)=($1,$2)}if (2 < $MaxArgLen and $MaxArgLen < length($arg)){substr ($arg,$MaxArgLen - 3)="";$suffix="...".$suffix}return "qr($arg)$suffix"}sub get_status {my$cache=shift;my$pkg=shift;$cache->{$pkg}||= [{$pkg=>$pkg },[trusts_directly($pkg)]];return @{$cache->{$pkg}}}sub get_subname {my$info=shift;if (defined($info->{evaltext})){my$eval=$info->{evaltext};if ($info->{is_require}){return "require $eval"}else {$eval =~ s/([\\\'])/\\$1/g;return "eval '" .str_len_trim($eval,$MaxEvalLen)."'"}}if (!defined($info->{sub})){return '__ANON__::__ANON__'}return ($info->{sub}eq '(eval)')? 'eval {...}' : $info->{sub}}sub long_error_loc {my$i;my$lvl=$CarpLevel;{++$i;my$cgc=_cgc();my@caller=$cgc ? $cgc->($i): caller($i);my$pkg=$caller[0];unless (defined($pkg)){if (%Internal){local%Internal;$i=long_error_loc();last}elsif (defined$caller[2]){redo unless 0 > --$lvl;last}else {return 2}}redo if$CarpInternal{$pkg};redo unless 0 > --$lvl;redo if$Internal{$pkg}}return$i - 1}sub longmess_heavy {if (ref($_[0])){return wantarray ? @_ : $_[0]}my$i=long_error_loc();return ret_backtrace($i,@_)}BEGIN {if("$]" >= 5.017004){$Carp::{LAST_FH}=\eval '\${^LAST_FH}'}else {eval '*LAST_FH = sub () { 0 }'}}sub ret_backtrace {my ($i,@error)=@_;my$mess;my$err=join '',@error;$i++;my$tid_msg='';if (defined&threads::tid){my$tid=threads->tid;$tid_msg=" thread $tid" if$tid}my%i=caller_info($i);$mess="$err at $i{file} line $i{line}$tid_msg";if($.){if (LAST_FH){if (${+LAST_FH}){$mess .= sprintf ", <%s> %s %d",*${+LAST_FH}{NAME},($/ eq "\n" ? "line" : "chunk"),$.}}else {local $@='';local$SIG{__DIE__};eval {CORE::die};if($@ =~ /^Died at .*(, <.*?> (?:line|chunk) \d+).$/){$mess .= $1}}}$mess .= "\.\n";while (my%i=caller_info(++$i)){$mess .= "\t$i{sub_name} called at $i{file} line $i{line}$tid_msg\n"}return$mess}sub ret_summary {my ($i,@error)=@_;my$err=join '',@error;$i++;my$tid_msg='';if (defined&threads::tid){my$tid=threads->tid;$tid_msg=" thread $tid" if$tid}my%i=caller_info($i);return "$err at $i{file} line $i{line}$tid_msg\.\n"}sub short_error_loc {my$cache={};my$i=1;my$lvl=$CarpLevel;{my$cgc=_cgc();my$called=$cgc ? $cgc->($i): caller($i);$i++;my$caller=$cgc ? $cgc->($i): caller($i);if (!defined($caller)){my@caller=$cgc ? $cgc->($i): caller($i);if (@caller){redo if defined($called)&& $CarpInternal{$called};redo unless 0 > --$lvl;last}else {return 0}}redo if$Internal{$caller};redo if$CarpInternal{$caller};redo if$CarpInternal{$called};redo if trusts($called,$caller,$cache);redo if trusts($caller,$called,$cache);redo unless 0 > --$lvl}return$i - 1}sub shortmess_heavy {return longmess_heavy(@_)if$Verbose;return @_ if ref($_[0]);my$i=short_error_loc();if ($i){ret_summary($i,@_)}else {longmess_heavy(@_)}}sub str_len_trim {my$str=shift;my$max=shift || 0;if (2 < $max and $max < length($str)){substr($str,$max - 3)='...'}return$str}sub trusts {my$child=shift;my$parent=shift;my$cache=shift;my ($known,$partial)=get_status($cache,$child);while (@$partial and not exists$known->{$parent}){my$anc=shift @$partial;next if exists$known->{$anc};$known->{$anc}++;my ($anc_knows,$anc_partial)=get_status($cache,$anc);my@found=keys %$anc_knows;@$known{@found}=();push @$partial,@$anc_partial}return exists$known->{$parent}}sub trusts_directly {my$class=shift;no strict 'refs';my$stash=\%{"$class\::"};for my$var (qw/CARP_NOT ISA/){if ($stash->{$var}&& ref \$stash->{$var}eq 'GLOB' && *{$stash->{$var}}{ARRAY}&& @{$stash->{$var}}){return @{$stash->{$var}}}}return}if(!defined($warnings::VERSION)|| do {no warnings "numeric";$warnings::VERSION < 1.03}){no strict "refs";*{"warnings::$_"}=\&$_ foreach@EXPORT}1;
CARP

$fatpacked{"Carp/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARP_HEAVY';
  package Carp::Heavy;use Carp ();our$VERSION='1.50';$VERSION =~ tr/_//d;if(($Carp::VERSION || 0)< 1.12){my$cv=defined($Carp::VERSION)? $Carp::VERSION : "undef";die "Version mismatch between Carp $cv ($INC{q(Carp.pm)}) and Carp::Heavy $VERSION ($INC{q(Carp/Heavy.pm)}).  Did you alter \@INC after Carp was loaded?\n"}1;
CARP_HEAVY

$fatpacked{"Class/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_TINY';
  use 5.006;use strict;no strict 'refs';use warnings;package Class::Tiny;our$VERSION='1.006';use Carp ();require($] >= 5.010 ? "mro.pm" : "MRO/Compat.pm");my%CLASS_ATTRIBUTES;sub import {my$class=shift;my$pkg=caller;$class->prepare_class($pkg);$class->create_attributes($pkg,@_)if @_}sub prepare_class {my ($class,$pkg)=@_;@{"${pkg}::ISA"}="Class::Tiny::Object" unless @{"${pkg}::ISA"}}sub create_attributes {my ($class,$pkg,@spec)=@_;my%defaults=map {ref $_ eq 'HASH' ? %$_ : ($_=>undef)}@spec;my@attr=grep {defined and!ref and /^[^\W\d]\w*$/s or Carp::croak "Invalid accessor name '$_'"}keys%defaults;$CLASS_ATTRIBUTES{$pkg}{$_}=$defaults{$_}for@attr;$class->_gen_accessor($pkg,$_)for grep {!*{"$pkg\::$_"}{CODE}}@attr;Carp::croak("Failed to generate attributes for $pkg: $@\n")if $@}sub _gen_accessor {my ($class,$pkg,$name)=@_;my$outer_default=$CLASS_ATTRIBUTES{$pkg}{$name};my$sub=$class->__gen_sub_body($name,defined($outer_default),ref($outer_default));eval "package $pkg; my \$default=\$outer_default; $sub";Carp::croak("Failed to generate attributes for $pkg: $@\n")if $@}sub __gen_sub_body {my ($self,$name,$has_default,$default_type)=@_;if ($has_default && $default_type eq 'CODE'){return << "HERE"}elsif ($has_default){return << "HERE"}else {return << "HERE"}}sub get_all_attributes_for {my ($class,$pkg)=@_;my%attr=map {$_=>undef}map {keys %{$CLASS_ATTRIBUTES{$_}|| {}}}@{mro::get_linear_isa($pkg)};return keys%attr}sub get_all_attribute_defaults_for {my ($class,$pkg)=@_;my$defaults={};for my$p (reverse @{mro::get_linear_isa($pkg)}){while (my ($k,$v)=each %{$CLASS_ATTRIBUTES{$p}|| {}}){$defaults->{$k}=$v}}return$defaults}package Class::Tiny::Object;our$VERSION='1.006';my (%HAS_BUILDARGS,%BUILD_CACHE,%DEMOLISH_CACHE,%ATTR_CACHE);my$_PRECACHE=sub {no warnings 'once';my ($class)=@_;my$linear_isa=@{"$class\::ISA"}==1 && ${"$class\::ISA"}[0]eq "Class::Tiny::Object" ? [$class]: mro::get_linear_isa($class);$DEMOLISH_CACHE{$class}=[map {(*{$_}{CODE})? (*{$_}{CODE}): ()}map {"$_\::DEMOLISH"}@$linear_isa ];$BUILD_CACHE{$class}=[map {(*{$_}{CODE})? (*{$_}{CODE}): ()}map {"$_\::BUILD"}reverse @$linear_isa ];$HAS_BUILDARGS{$class}=$class->can("BUILDARGS");return$ATTR_CACHE{$class}={map {$_=>1}Class::Tiny->get_all_attributes_for($class)}};sub new {my$class=shift;my$valid_attrs=$ATTR_CACHE{$class}|| $_PRECACHE->($class);my$args;if ($HAS_BUILDARGS{$class}){$args=$class->BUILDARGS(@_)}else {if (@_==1 && ref $_[0]){my%copy=eval {%{$_[0]}};Carp::croak("Argument to $class->new() could not be dereferenced as a hash")if $@;$args=\%copy}elsif (@_ % 2==0){$args={@_}}else {Carp::croak("$class->new() got an odd number of elements")}}my$self=bless {map {$_=>$args->{$_}}grep {exists$valid_attrs->{$_}}keys %$args },$class;$self->BUILDALL($args)if!delete$args->{__no_BUILD__}&& @{$BUILD_CACHE{$class}};return$self}sub BUILDALL {$_->(@_)for @{$BUILD_CACHE{ref $_[0]}}}require Devel::GlobalDestruction unless defined ${^GLOBAL_PHASE};sub DESTROY {my$self=shift;my$class=ref$self;my$in_global_destruction=defined ${^GLOBAL_PHASE} ? ${^GLOBAL_PHASE} eq 'DESTRUCT' : Devel::GlobalDestruction::in_global_destruction();for my$demolisher (@{$DEMOLISH_CACHE{$class}}){my$e=do {local ($?,$@);eval {$demolisher->($self,$in_global_destruction)};$@};no warnings 'misc';die$e if$e}}1;
  sub $name {
      return (
            ( \@_ == 1 && exists \$_[0]{$name} )
          ? ( \$_[0]{$name} )
          : ( \$_[0]{$name} = ( \@_ == 2 ) ? \$_[1] : \$default->( \$_[0] ) )
      );
  }
  HERE
  sub $name {
      return (
            ( \@_ == 1 && exists \$_[0]{$name} )
          ? ( \$_[0]{$name} )
          : ( \$_[0]{$name} = ( \@_ == 2 ) ? \$_[1] : \$default )
      );
  }
  HERE
  sub $name {
      return \@_ == 1 ? \$_[0]{$name} : ( \$_[0]{$name} =  \$_[1] );
  }
  HERE
CLASS_TINY

$fatpacked{"Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER';
  package Exporter;require 5.006;our$Debug=0;our$ExportLevel=0;our$Verbose ||= 0;our$VERSION='5.73';our (%Cache);sub as_heavy {require Exporter::Heavy;my$c=(caller(1))[3];$c =~ s/.*:://;\&{"Exporter::Heavy::heavy_$c"}}sub export {goto &{as_heavy()}}sub import {my$pkg=shift;my$callpkg=caller($ExportLevel);if ($pkg eq "Exporter" and @_ and $_[0]eq "import"){*{$callpkg."::import"}=\&import;return}my$exports=\@{"$pkg\::EXPORT"};my$fail=${$pkg .'::'}{EXPORT_FAIL}&& \@{"$pkg\::EXPORT_FAIL"};return export$pkg,$callpkg,@_ if$Verbose or $Debug or $fail && @$fail > 1;my$export_cache=($Cache{$pkg}||= {});my$args=@_ or @_=@$exports;if ($args and not %$export_cache){s/^&//,$export_cache->{$_}=1 foreach (@$exports,@{"$pkg\::EXPORT_OK"})}my$heavy;if ($args or $fail){($heavy=(/\W/ or $args and not exists$export_cache->{$_}or $fail and @$fail and $_ eq $fail->[0]))and last foreach (@_)}else {($heavy=/\W/)and last foreach (@_)}return export$pkg,$callpkg,($args ? @_ : ())if$heavy;local$SIG{__WARN__}=sub {require Carp;&Carp::carp}if not $SIG{__WARN__};*{"$callpkg\::$_"}=\&{"$pkg\::$_"}foreach @_}sub export_fail {my$self=shift;@_}sub export_to_level {goto &{as_heavy()}}sub export_tags {goto &{as_heavy()}}sub export_ok_tags {goto &{as_heavy()}}sub require_version {goto &{as_heavy()}}1;
EXPORTER

$fatpacked{"Exporter/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_HEAVY';
  package Exporter::Heavy;use strict;no strict 'refs';require Exporter;our$VERSION=$Exporter::VERSION;sub _rebuild_cache {my ($pkg,$exports,$cache)=@_;s/^&// foreach @$exports;@{$cache}{@$exports}=(1)x @$exports;my$ok=\@{"${pkg}::EXPORT_OK"};if (@$ok){s/^&// foreach @$ok;@{$cache}{@$ok}=(1)x @$ok}}sub heavy_export {my$oldwarn=$SIG{__WARN__};local$SIG{__WARN__}=sub {local$SIG{__WARN__}=$oldwarn;my$text=shift;if ($text =~ s/ at \S*Exporter\S*.pm line \d+.*\n//){require Carp;local$Carp::CarpLevel=1;Carp::carp($text)}else {warn$text}};local$SIG{__DIE__}=sub {require Carp;local$Carp::CarpLevel=1;Carp::croak("$_[0]Illegal null symbol in \@${1}::EXPORT")if $_[0]=~ /^Unable to create sub named "(.*?)::"/};my($pkg,$callpkg,@imports)=@_;my($type,$sym,$cache_is_current,$oops);my($exports,$export_cache)=(\@{"${pkg}::EXPORT"},$Exporter::Cache{$pkg}||= {});if (@imports){if (!%$export_cache){_rebuild_cache ($pkg,$exports,$export_cache);$cache_is_current=1}if (grep m{^[/!:]},@imports){my$tagsref=\%{"${pkg}::EXPORT_TAGS"};my$tagdata;my%imports;my($remove,$spec,@names,@allexports);unshift@imports,':DEFAULT' if$imports[0]=~ m/^!/;for$spec (@imports){$remove=$spec =~ s/^!//;if ($spec =~ s/^://){if ($spec eq 'DEFAULT'){@names=@$exports}elsif ($tagdata=$tagsref->{$spec}){@names=@$tagdata}else {warn qq["$spec" is not defined in %${pkg}::EXPORT_TAGS];++$oops;next}}elsif ($spec =~ m:^/(.*)/$:){my$patn=$1;@allexports=keys %$export_cache unless@allexports;@names=grep(/$patn/,@allexports)}else {@names=($spec)}warn "Import ".($remove ? "del":"add").": @names " if$Exporter::Verbose;if ($remove){for$sym (@names){delete$imports{$sym}}}else {@imports{@names}=(1)x @names}}@imports=keys%imports}my@carp;for$sym (@imports){if (!$export_cache->{$sym}){if ($sym =~ m/^\d/){$pkg->VERSION($sym);if (@imports==1){@imports=@$exports;last}if (@imports==2 and!$imports[1]){@imports=();last}}elsif ($sym !~ s/^&// ||!$export_cache->{$sym}){unless ($cache_is_current){%$export_cache=();_rebuild_cache ($pkg,$exports,$export_cache);$cache_is_current=1}if (!$export_cache->{$sym}){push@carp,qq["$sym" is not exported by the $pkg module\n];$oops++}}}}if ($oops){require Carp;Carp::croak("@{carp}Can't continue after import errors")}}else {@imports=@$exports}my($fail,$fail_cache)=(\@{"${pkg}::EXPORT_FAIL"},$Exporter::FailCache{$pkg}||= {});if (@$fail){if (!%$fail_cache){my@expanded=map {/^\w/ ? ($_,'&'.$_): $_}@$fail;warn "${pkg}::EXPORT_FAIL cached: @expanded" if$Exporter::Verbose;@{$fail_cache}{@expanded}=(1)x @expanded}my@failed;for$sym (@imports){push(@failed,$sym)if$fail_cache->{$sym}}if (@failed){@failed=$pkg->export_fail(@failed);for$sym (@failed){require Carp;Carp::carp(qq["$sym" is not implemented by the $pkg module ],"on this architecture")}if (@failed){require Carp;Carp::croak("Can't continue after import errors")}}}warn "Importing into $callpkg from $pkg: ",join(", ",sort@imports)if$Exporter::Verbose;for$sym (@imports){(*{"${callpkg}::$sym"}=\&{"${pkg}::$sym"},next)unless$sym =~ s/^(\W)//;$type=$1;no warnings 'once';*{"${callpkg}::$sym"}=$type eq '&' ? \&{"${pkg}::$sym"}: $type eq '$' ? \${"${pkg}::$sym"}: $type eq '@' ? \@{"${pkg}::$sym"}: $type eq '%' ? \%{"${pkg}::$sym"}: $type eq '*' ? *{"${pkg}::$sym"}: do {require Carp;Carp::croak("Can't export symbol: $type$sym")}}}sub heavy_export_to_level {my$pkg=shift;my$level=shift;(undef)=shift;my$callpkg=caller($level);$pkg->export($callpkg,@_)}sub _push_tags {my($pkg,$var,$syms)=@_;my@nontag=();my$export_tags=\%{"${pkg}::EXPORT_TAGS"};push(@{"${pkg}::$var"},map {$export_tags->{$_}? @{$export_tags->{$_}}: scalar(push(@nontag,$_),$_)}(@$syms)? @$syms : keys %$export_tags);if (@nontag and $^W){require Carp;Carp::carp(join(", ",@nontag)." are not tags of $pkg")}}sub heavy_require_version {my($self,$wanted)=@_;my$pkg=ref$self || $self;return ${pkg}->VERSION($wanted)}sub heavy_export_tags {_push_tags((caller)[0],"EXPORT",\@_)}sub heavy_export_ok_tags {_push_tags((caller)[0],"EXPORT_OK",\@_)}1;
EXPORTER_HEAVY

$fatpacked{"ExtUtils/CBuilder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CBUILDER';
  package ExtUtils::CBuilder;use File::Spec ();use File::Path ();use File::Basename ();use Perl::OSType qw/os_type/;use warnings;use strict;our$VERSION='0.280231';our@ISA;my$load=sub {my$mod=shift;eval "use $mod";die $@ if $@;@ISA=($mod)};{my@package=split /::/,__PACKAGE__;my$ostype=os_type();if (grep {-e File::Spec->catfile($_,@package,'Platform',$^O).'.pm'}@INC){$load->(__PACKAGE__ ."::Platform::$^O")}elsif ($ostype && grep {-e File::Spec->catfile($_,@package,'Platform',$ostype).'.pm'}@INC){$load->(__PACKAGE__ ."::Platform::$ostype")}else {$load->(__PACKAGE__ ."::Base")}}1;
EXTUTILS_CBUILDER

$fatpacked{"ExtUtils/CBuilder/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CBUILDER_BASE';
  package ExtUtils::CBuilder::Base;use strict;use warnings;use File::Spec;use File::Basename;use Cwd ();use Config;use Text::ParseWords;use IPC::Cmd qw(can_run);use File::Temp qw(tempfile);our$VERSION='0.280231';my%cc2cxx=(cc=>['c++','CC','aCC','cxx',],gcc=>['g++' ],xlc=>['xlC' ],xlc_r=>['xlC_r' ],cl=>['cl' ],);sub new {my$class=shift;my$self=bless {@_},$class;$self->{properties}{perl}=$class->find_perl_interpreter or warn "Warning: Can't locate your perl binary";while (my ($k,$v)=each%Config){$self->{config}{$k}=$v unless exists$self->{config}{$k}}$self->{config}{cc}=$ENV{CC}if defined$ENV{CC};$self->{config}{ccflags}=join(" ",$self->{config}{ccflags},$ENV{CFLAGS})if defined$ENV{CFLAGS};$self->{config}{cxx}=$ENV{CXX}if defined$ENV{CXX};$self->{config}{cxxflags}=$ENV{CXXFLAGS}if defined$ENV{CXXFLAGS};$self->{config}{ld}=$ENV{LD}if defined$ENV{LD};$self->{config}{ldflags}=join(" ",$self->{config}{ldflags},$ENV{LDFLAGS})if defined$ENV{LDFLAGS};unless (exists$self->{config}{cxx}){my ($ccbase,$ccpath,$ccsfx)=fileparse($self->{config}{cc},qr/\.[^.]*/);$ccpath="" if$self->{config}{cc}=~ /^\Q$ccbase$ccsfx\E$/;for my$cxx (@{$cc2cxx{$ccbase}}){my$cxx1=File::Spec->catfile($ccpath,$cxx .$ccsfx);if(can_run($cxx1)){$self->{config}{cxx}=$cxx1;last}my$cxx2=$cxx .$ccsfx;if(can_run($cxx2)){$self->{config}{cxx}=$cxx2;last}if(can_run($cxx)){$self->{config}{cxx}=$cxx;last}}unless (exists$self->{config}{cxx}){$self->{config}{cxx}=$self->{config}{cc};my$cflags=$self->{config}{ccflags};$self->{config}{cxxflags}='-x c++';$self->{config}{cxxflags}.= " $cflags" if defined$cflags}}return$self}sub find_perl_interpreter {my$perl;File::Spec->file_name_is_absolute($perl=$^X)or -f ($perl=$Config::Config{perlpath})or ($perl=$^X);return$perl}sub add_to_cleanup {my$self=shift;for (@_){$self->{files_to_clean}{$_}=1}}sub cleanup {my$self=shift;for my$file (keys %{$self->{files_to_clean}}){unlink$file}}sub get_config {return %{$_[0]->{config}}}sub object_file {my ($self,$filename)=@_;(my$file_base=$filename)=~ s/\.[^.]+$//;return "$file_base$self->{config}{obj_ext}"}sub arg_include_dirs {my$self=shift;return map {"-I$_"}@_}sub arg_nolink {'-c'}sub arg_object_file {my ($self,$file)=@_;return ('-o',$file)}sub arg_share_object_file {my ($self,$file)=@_;return ($self->split_like_shell($self->{config}{lddlflags}),'-o',$file)}sub arg_exec_file {my ($self,$file)=@_;return ('-o',$file)}sub arg_defines {my ($self,%args)=@_;return map "-D$_=$args{$_}",sort keys%args}sub compile {my ($self,%args)=@_;die "Missing 'source' argument to compile()" unless defined$args{source};my$cf=$self->{config};my$object_file=$args{object_file}? $args{object_file}: $self->object_file($args{source});my$include_dirs_ref=(exists($args{include_dirs})&& ref($args{include_dirs})ne "ARRAY")? [$args{include_dirs}]: $args{include_dirs};my@include_dirs=$self->arg_include_dirs(@{$include_dirs_ref || []},$self->perl_inc(),);my@defines=$self->arg_defines(%{$args{defines}|| {}});my@extra_compiler_flags=$self->split_like_shell($args{extra_compiler_flags});my@cccdlflags=$self->split_like_shell($cf->{cccdlflags});my@ccflags=$self->split_like_shell($args{'C++'}? $cf->{cxxflags}: $cf->{ccflags});my@optimize=$self->split_like_shell($cf->{optimize});my@flags=(@include_dirs,@defines,@cccdlflags,@extra_compiler_flags,$self->arg_nolink,@ccflags,@optimize,$self->arg_object_file($object_file),);my@cc=$self->split_like_shell($args{'C++'}? $cf->{cxx}: $cf->{cc});$self->do_system(@cc,@flags,$args{source})or die "error building $object_file from '$args{source}'";return$object_file}sub have_compiler {my ($self,$is_cplusplus)=@_;my$have_compiler_flag=$is_cplusplus ? "have_cxx" : "have_cc";my$suffix=$is_cplusplus ? ".cc" : ".c";return$self->{$have_compiler_flag}if defined$self->{$have_compiler_flag};my$result;my$attempts=3;my ($FH,$tmpfile)=tempfile("compilet-XXXXX",SUFFIX=>$suffix);binmode$FH;if ($is_cplusplus){print$FH "class Bogus { public: int boot_compilet() { return 1; } };\n"}else {print$FH "int boot_compilet() { return 1; }\n"}close$FH;my ($obj_file,@lib_files);eval {local $^W=0;local$self->{quiet}=1;$obj_file=$self->compile('C++'=>$is_cplusplus,source=>$tmpfile);@lib_files=$self->link(objects=>$obj_file,module_name=>'compilet')};$result=$@ ? 0 : 1;for (grep defined,$tmpfile,$obj_file,@lib_files){1 while unlink}return$self->{$have_compiler_flag}=$result}sub have_cplusplus {push @_,1;goto&have_compiler}sub lib_file {my ($self,$dl_file,%args)=@_;$dl_file =~ s/\.[^.]+$//;$dl_file =~ tr/"//d;if (defined$args{module_name}and length$args{module_name}){require DynaLoader;if (defined&DynaLoader::mod2fname){my$lib=DynaLoader::mod2fname([split /::/,$args{module_name}]);my ($dev,$lib_dir,undef)=File::Spec->splitpath($dl_file);$dl_file=File::Spec->catpath($dev,$lib_dir,$lib)}}$dl_file .= ".$self->{config}{dlext}";return$dl_file}sub exe_file {my ($self,$dl_file)=@_;$dl_file =~ s/\.[^.]+$//;$dl_file =~ tr/"//d;return "$dl_file$self->{config}{_exe}"}sub need_prelink {0}sub extra_link_args_after_prelink {return}sub prelink {my ($self,%args)=@_;my ($dl_file_out,$mksymlists_args)=_prepare_mksymlists_args(\%args);require ExtUtils::Mksymlists;ExtUtils::Mksymlists::Mksymlists(%{$mksymlists_args});return grep -e,map "$dl_file_out.$_",qw(ext def opt)}sub _prepare_mksymlists_args {my$args=shift;($args->{dl_file}=$args->{dl_name})=~ s/.*::// unless$args->{dl_file};my%mksymlists_args=(DL_VARS=>$args->{dl_vars}|| [],DL_FUNCS=>$args->{dl_funcs}|| {},FUNCLIST=>$args->{dl_func_list}|| [],IMPORTS=>$args->{dl_imports}|| {},NAME=>$args->{dl_name},DLBASE=>$args->{dl_base},FILE=>$args->{dl_file},VERSION=>(defined$args->{dl_version}? $args->{dl_version}: '0.0'),);return ($args->{dl_file},\%mksymlists_args)}sub link {my ($self,%args)=@_;return$self->_do_link('lib_file',lddl=>1,%args)}sub link_executable {my ($self,%args)=@_;return$self->_do_link('exe_file',lddl=>0,%args)}sub _do_link {my ($self,$type,%args)=@_;my$cf=$self->{config};my$objects=delete$args{objects};$objects=[$objects]unless ref$objects;my$out=$args{$type}|| $self->$type($objects->[0],%args);my@temp_files;@temp_files=$self->prelink(%args,dl_name=>$args{module_name})if$args{lddl}&& $self->need_prelink;my@linker_flags=($self->split_like_shell($args{extra_linker_flags}),$self->extra_link_args_after_prelink(%args,dl_name=>$args{module_name},prelink_res=>\@temp_files));my@output=$args{lddl}? $self->arg_share_object_file($out): $self->arg_exec_file($out);my@shrp=$self->split_like_shell($cf->{shrpenv});my@ld=$self->split_like_shell($cf->{ld});$self->do_system(@shrp,@ld,@output,@$objects,@linker_flags)or die "error building $out from @$objects";return wantarray ? ($out,@temp_files): $out}sub do_system {my ($self,@cmd)=@_;print "@cmd\n" if!$self->{quiet};return!system(@cmd)}sub split_like_shell {my ($self,$string)=@_;return ()unless defined($string);return @$string if UNIVERSAL::isa($string,'ARRAY');$string =~ s/^\s+|\s+$//g;return ()unless length($string);$string =~ s@\\@/@g if $^O eq 'MSWin32';return Text::ParseWords::shellwords($string)}sub perl_src {return unless$ENV{PERL_CORE};my$Updir=File::Spec->updir;my$dir=File::Spec->curdir;for (0..10){if (-f File::Spec->catfile($dir,"config_h.SH")&& -f File::Spec->catfile($dir,"perl.h")&& -f File::Spec->catfile($dir,"lib","Exporter.pm")){return Cwd::realpath($dir)}$dir=File::Spec->catdir($dir,$Updir)}warn "PERL_CORE is set but I can't find your perl source!\n";return ''}sub perl_inc {my$self=shift;$self->perl_src()|| File::Spec->catdir($self->{config}{archlibexp},"CORE")}sub DESTROY {my$self=shift;local($.,$@,$!,$^E,$?);$self->cleanup()}1;
EXTUTILS_CBUILDER_BASE

$fatpacked{"ExtUtils/CBuilder/Platform/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CBUILDER_PLATFORM_UNIX';
  package ExtUtils::CBuilder::Platform::Unix;use warnings;use strict;use ExtUtils::CBuilder::Base;our$VERSION='0.280231';our@ISA=qw(ExtUtils::CBuilder::Base);sub link_executable {my$self=shift;local$self->{config}{ld}=$self->{config}{cc}." " .$self->{config}{ldflags};return$self->SUPER::link_executable(@_)}sub link {my$self=shift;my$cf=$self->{config};local$cf->{ld}=$cf->{ld};if (ref$cf->{ld}){unshift @{$cf->{ld}},'env' if$cf->{ld}[0]=~ /^\s*\w+=/}else {$cf->{ld}=~ s/^(\s*\w+=)/env $1/}return$self->SUPER::link(@_)}1;
EXTUTILS_CBUILDER_PLATFORM_UNIX

$fatpacked{"ExtUtils/CBuilder/Platform/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CBUILDER_PLATFORM_VMS';
  package ExtUtils::CBuilder::Platform::VMS;use warnings;use strict;use ExtUtils::CBuilder::Base;our$VERSION='0.280231';our@ISA=qw(ExtUtils::CBuilder::Base);use File::Spec::Functions qw(catfile catdir);use Config;sub need_prelink {0}sub arg_defines {my ($self,%args)=@_;s/"/""/g foreach values%args;my@config_defines;if ($self->{config}{ccflags}=~ s{/  def[^=]+  =+  \(?  ([^\/\)]*)  } {}ix){push@config_defines,$1}return '' unless keys(%args)|| @config_defines;return ('/define=(' .join(',',@config_defines,map "\"$_" .(length($args{$_})? "=$args{$_}" : '')."\"",sort keys%args).')')}sub arg_include_dirs {my ($self,@dirs)=@_;if ($self->{config}{ccflags}=~ s{/inc[^=]+(?:=)+(?:\()?([^\/\)]*)} {}i){unshift@dirs,$1}return unless@dirs;return ('/include=(' .join(',',@dirs).')')}sub compile {my ($self,%args)=@_;$self->{config}{ccflags}=$Config{ccflags};$self->{config}{ccflags}=$ENV{CFLAGS}if defined$ENV{CFLAGS};return$self->SUPER::compile(%args)}sub _do_link {my ($self,$type,%args)=@_;my$objects=delete$args{objects};$objects=[$objects]unless ref$objects;if ($args{lddl}){my@temp_files=$self->prelink(%args,dl_name=>$args{module_name});my@optlibs=$self->_liblist_ext($args{'libs'});my$optfile='sys$disk:[]' .$temp_files[0];open my$opt_fh,'>>',$optfile or die "_do_link: Unable to open $optfile: $!";for my$lib (@optlibs){print$opt_fh "$lib\n" if length$lib}close$opt_fh;$objects->[-1].= ',';push @$objects,$optfile .'/OPTIONS,';push @$objects,$self->perl_inc().'perlshr_attr.opt/OPTIONS'}return$self->SUPER::_do_link($type,%args,objects=>$objects)}sub arg_nolink {return}sub arg_object_file {my ($self,$file)=@_;return "/obj=$file"}sub arg_exec_file {my ($self,$file)=@_;return ("/exe=$file")}sub arg_share_object_file {my ($self,$file)=@_;return ("$self->{config}{lddlflags}=$file")}sub _liblist_ext {my($self,$potential_libs,$verbose,$give_libs)=@_;$verbose ||= 0;my(@crtls,$crtlstr);@crtls=(($self->{'config'}{'ldflags'}=~ m-/Debug-i ? $self->{'config'}{'dbgprefix'}: '').'PerlShr/Share');push(@crtls,grep {not /\(/}split /\s+/,$self->{'config'}{'perllibs'});push(@crtls,grep {not /\(/}split /\s+/,$self->{'config'}{'libc'});if ($self->perl_src){my($lib,$locspec,$type);for$lib (@crtls){if (($locspec,$type)=$lib =~ m{^([\w\$-]+)(/\w+)?} and $locspec =~ /perl/i){if (lc$type eq '/share'){$locspec .= $self->{'config'}{'exe_ext'}}elsif (lc$type eq '/library'){$locspec .= $self->{'config'}{'lib_ext'}}else {$locspec .= $self->{'config'}{'obj_ext'}}$locspec=catfile($self->perl_src,$locspec);$lib="$locspec$type" if -e $locspec}}}$crtlstr=@crtls ? join(' ',@crtls): '';unless ($potential_libs){warn "Result:\n\tEXTRALIBS: \n\tLDLOADLIBS: $crtlstr\n" if$verbose;return ('','',$crtlstr,'',($give_libs ? []: ()))}my(@dirs,@libs,$dir,$lib,%found,@fndlibs,$ldlib);my$cwd=cwd();my($so,$lib_ext,$obj_ext)=@{$self->{'config'}}{'so','lib_ext','obj_ext'};my(@flibs,%libs_seen);my%libmap=('m'=>'','f77'=>'','F77'=>'','V77'=>'','c'=>'','malloc'=>'','crypt'=>'','resolv'=>'','c_s'=>'','socket'=>'','X11'=>'DECW$XLIBSHR','Xt'=>'DECW$XTSHR','Xm'=>'DECW$XMLIBSHR','Xmu'=>'DECW$XMULIBSHR');warn "Potential libraries are '$potential_libs'\n" if$verbose;for$lib (split ' ',$potential_libs){push(@dirs,$1),next if$lib =~ /^-L(.*)/;push(@dirs,$lib),next if$lib =~ /[:>\]]$/;push(@dirs,$lib),next if -d $lib;push(@libs,$1),next if$lib =~ /^-l(.*)/;push(@libs,$lib)}push(@dirs,split(' ',$self->{'config'}{'libpth'}));for$dir (@dirs){unless (-d $dir){warn "Skipping nonexistent Directory $dir\n" if$verbose > 1;$dir='';next}warn "Resolving directory $dir\n" if$verbose;if (!File::Spec->file_name_is_absolute($dir)){$dir=catdir($cwd,$dir)}}@dirs=grep {length($_)}@dirs;unshift(@dirs,'');LIB: foreach$lib (@libs){if (exists$libmap{$lib}){next unless length$libmap{$lib};$lib=$libmap{$lib}}my(@variants,$variant,$cand);my($ctype)='';if ($lib !~ /\.[^:>\]]*$/){push(@variants,"${lib}shr","${lib}rtl","${lib}lib");push(@variants,"lib$lib")if$lib !~ /[:>\]]/}push(@variants,$lib);warn "Looking for $lib\n" if$verbose;for$variant (@variants){my($fullname,$name);for$dir (@dirs){my($type);$name="$dir$variant";warn "\tChecking $name\n" if$verbose > 2;$fullname=VMS::Filespec::rmsexpand($name);if (defined$fullname and -f $fullname){if ($fullname =~ /(?:$so|exe)$/i){$type='SHR'}elsif ($fullname =~ /(?:$lib_ext|olb)$/i){$type='OLB'}elsif ($fullname =~ /(?:$obj_ext|obj)$/i){warn "Note (probably harmless): " ."Plain object file $fullname found in library list\n";$type='OBJ'}else {warn "Note (probably harmless): " ."Unknown library type for $fullname; assuming shared\n";$type='SHR'}}elsif (-f ($fullname=VMS::Filespec::rmsexpand($name,$so))or -f ($fullname=VMS::Filespec::rmsexpand($name,'.exe'))){$type='SHR';$name=$fullname unless$fullname =~ /exe;?\d*$/i}elsif (not length($ctype)and (-f ($fullname=VMS::Filespec::rmsexpand($name,$lib_ext))or -f ($fullname=VMS::Filespec::rmsexpand($name,'.olb')))){$type='OLB';$name=$fullname unless$fullname =~ /olb;?\d*$/i}elsif (not length($ctype)and (-f ($fullname=VMS::Filespec::rmsexpand($name,$obj_ext))or -f ($fullname=VMS::Filespec::rmsexpand($name,'.obj')))){warn "Note (probably harmless): " ."Plain object file $fullname found in library list\n";$type='OBJ';$name=$fullname unless$fullname =~ /obj;?\d*$/i}if (defined$type){$ctype=$type;$cand=$name;last if$ctype eq 'SHR'}}if ($ctype){push @{$found{$ctype}},$cand;warn "\tFound as $cand (really $fullname), type $ctype\n" if$verbose > 1;push@flibs,$name unless$libs_seen{$fullname}++;next LIB}}warn "Note (probably harmless): " ."No library found for $lib\n"}push@fndlibs,@{$found{OBJ}}if exists$found{OBJ};push@fndlibs,map {"$_/Library"}@{$found{OLB}}if exists$found{OLB};push@fndlibs,map {"$_/Share"}@{$found{SHR}}if exists$found{SHR};$lib=join(' ',@fndlibs);$ldlib=$crtlstr ? "$lib $crtlstr" : $lib;warn "Result:\n\tEXTRALIBS: $lib\n\tLDLOADLIBS: $ldlib\n" if$verbose;wantarray ? ($lib,'',$ldlib,'',($give_libs ? \@flibs : ())): $lib}1;
EXTUTILS_CBUILDER_PLATFORM_VMS

$fatpacked{"ExtUtils/CBuilder/Platform/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CBUILDER_PLATFORM_WINDOWS';
  package ExtUtils::CBuilder::Platform::Windows;use strict;use warnings;use File::Basename;use File::Spec;use ExtUtils::CBuilder::Base;use IO::File;our$VERSION='0.280231';our@ISA=qw(ExtUtils::CBuilder::Base);sub new {my$class=shift;my$self=$class->SUPER::new(@_);my$cf=$self->{config};my$driver="ExtUtils::CBuilder::Platform::Windows::" .$self->_compiler_type;eval "require $driver" or die "Could not load compiler driver: $@";unshift@ISA,$driver;return$self}sub _compiler_type {my$self=shift;my$cc=$self->{config}{cc};return ($cc =~ /cl(\.exe)?$/ ? 'MSVC' : $cc =~ /bcc32(\.exe)?$/ ? 'BCC' : 'GCC')}sub split_like_shell {(my$self,local $_)=@_;return @$_ if defined()&& UNIVERSAL::isa($_,'ARRAY');return unless defined()&& length();return ($_)}sub do_system {my$self=shift;my$cmd=join(" ",grep length,map {$a=$_;$a=~s/\t/ /g;$a=~s/^\s+|\s+$//;$a}grep defined,@_);return$self->SUPER::do_system($cmd)}sub arg_defines {my ($self,%args)=@_;s/"/\\"/g foreach values%args;return map qq{"-D$_=$args{$_}"},sort keys%args}sub compile {my ($self,%args)=@_;my$cf=$self->{config};die "Missing 'source' argument to compile()" unless defined$args{source};$args{include_dirs}=[$args{include_dirs}]if exists($args{include_dirs})&& ref($args{include_dirs})ne "ARRAY";my ($basename,$srcdir)=(File::Basename::fileparse($args{source},'\.[^.]+$'))[0,1];$srcdir ||= File::Spec->curdir();my@defines=$self->arg_defines(%{$args{defines}|| {}});my%spec=(srcdir=>$srcdir,builddir=>$srcdir,basename=>$basename,source=>$args{source},output=>$args{object_file}|| File::Spec->catfile($srcdir,$basename).$cf->{obj_ext},cc=>$cf->{cc},cflags=>[$self->split_like_shell($cf->{ccflags}),$self->split_like_shell($cf->{cccdlflags}),$self->split_like_shell($args{extra_compiler_flags}),],optimize=>[$self->split_like_shell($cf->{optimize})],defines=>\@defines,includes=>[@{$args{include_dirs}|| []}],perlinc=>[$self->perl_inc(),$self->split_like_shell($cf->{incpath}),],use_scripts=>1,);$self->normalize_filespecs(\$spec{source},\$spec{output},$spec{includes},$spec{perlinc},);my@cmds=$self->format_compiler_cmd(%spec);while (my$cmd=shift@cmds){$self->do_system(@$cmd)or die "error building $cf->{dlext} file from '$args{source}'"}(my$out=$spec{output})=~ tr/'"//d;return$out}sub need_prelink {1}sub link {my ($self,%args)=@_;my$cf=$self->{config};my@objects=(ref$args{objects}eq 'ARRAY' ? @{$args{objects}}: $args{objects});my$to=join '',(File::Spec->splitpath($objects[0]))[0,1];$to ||= File::Spec->curdir();(my$file_base=$args{module_name})=~ s/.*:://;my$output=$args{lib_file}|| File::Spec->catfile($to,"$file_base.$cf->{dlext}");my$lddlflags=$cf->{lddlflags};my$perl_src=$self->perl_src();$lddlflags =~ s{\Q$cf->{archlibexp}\E[\\/]CORE}{$perl_src/lib/CORE} if$perl_src;my%spec=(srcdir=>$to,builddir=>$to,startup=>[],objects=>\@objects,libs=>[],output=>$output,ld=>$cf->{ld},libperl=>$cf->{libperl},perllibs=>[$self->split_like_shell($cf->{perllibs})],libpath=>[$self->split_like_shell($cf->{libpth})],lddlflags=>[$self->split_like_shell($lddlflags)],other_ldflags=>[$self->split_like_shell($args{extra_linker_flags}|| '')],use_scripts=>1,);unless ($spec{basename}){($spec{basename}=$args{module_name})=~ s/.*:://}$spec{srcdir}=File::Spec->canonpath($spec{srcdir});$spec{builddir}=File::Spec->canonpath($spec{builddir});$spec{output}||= File::Spec->catfile($spec{builddir},$spec{basename}.'.'.$cf->{dlext});$spec{manifest}||= $spec{output}.'.manifest';$spec{implib}||= File::Spec->catfile($spec{builddir},$spec{basename}.$cf->{lib_ext});$spec{explib}||= File::Spec->catfile($spec{builddir},$spec{basename}.'.exp');if ($cf->{cc}eq 'cl'){$spec{dbg_file}||= File::Spec->catfile($spec{builddir},$spec{basename}.'.pdb')}elsif ($cf->{cc}eq 'bcc32'){$spec{dbg_file}||= File::Spec->catfile($spec{builddir},$spec{basename}.'.tds')}$spec{def_file}||= File::Spec->catfile($spec{srcdir},$spec{basename}.'.def');$spec{base_file}||= File::Spec->catfile($spec{srcdir},$spec{basename}.'.base');$self->add_to_cleanup(grep defined,@{[@spec{qw(manifest implib explib dbg_file def_file base_file map_file)}]});for my$opt (qw(output manifest implib explib dbg_file def_file map_file base_file)){$self->normalize_filespecs(\$spec{$opt})}for my$opt (qw(libpath startup objects)){$self->normalize_filespecs($spec{$opt})}(my$def_base=$spec{def_file})=~ tr/'"//d;$def_base =~ s/\.def$//;$self->prelink(%args,dl_name=>$args{module_name},dl_file=>$def_base,dl_base=>$spec{basename});my@cmds=$self->format_linker_cmd(%spec);while (my$cmd=shift@cmds){$self->do_system(@$cmd)}$spec{output}=~ tr/'"//d;return wantarray ? grep defined,@spec{qw[output manifest implib explib dbg_file def_file map_file base_file]}: $spec{output}}sub normalize_filespecs {my ($self,@specs)=@_;for my$spec (grep defined,@specs){if (ref$spec eq 'ARRAY'){$self->normalize_filespecs(map {\$_}grep defined,@$spec)}elsif (ref$spec eq 'SCALAR'){$$spec =~ tr/"//d if $$spec;next unless $$spec;$$spec='"' .File::Spec->canonpath($$spec).'"'}elsif (ref$spec eq ''){$spec='"' .File::Spec->canonpath($spec).'"'}else {die "Don't know how to normalize " .(ref$spec || $spec)."\n"}}}sub perl_inc {my$self=shift;my$perl_src=$self->perl_src();if ($perl_src){File::Spec->catdir($perl_src,"lib","CORE")}else {File::Spec->catdir($self->{config}{archlibexp},"CORE")}}1;
EXTUTILS_CBUILDER_PLATFORM_WINDOWS

$fatpacked{"ExtUtils/CBuilder/Platform/Windows/BCC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CBUILDER_PLATFORM_WINDOWS_BCC';
  package ExtUtils::CBuilder::Platform::Windows::BCC;our$VERSION='0.280231';use strict;use warnings;sub format_compiler_cmd {my ($self,%spec)=@_;for my$path (@{$spec{includes}|| []},@{$spec{perlinc}|| []}){$path='-I' .$path}%spec=$self->write_compiler_script(%spec)if$spec{use_scripts};return [grep {defined && length}($spec{cc},'-c',@{$spec{includes}},@{$spec{cflags}},@{$spec{optimize}},@{$spec{defines}},@{$spec{perlinc}},"-o$spec{output}",$spec{source},)]}sub write_compiler_script {my ($self,%spec)=@_;my$script=File::Spec->catfile($spec{srcdir},$spec{basename}.'.ccs');$self->add_to_cleanup($script);print "Generating script '$script'\n" if!$self->{quiet};my$SCRIPT=IO::File->new(">$script")or die("Could not create script '$script': $!");print$SCRIPT join("\n",map {ref $_ ? @{$_}: $_}grep defined,delete(@spec{qw(includes cflags optimize perlinc) }));push @{$spec{includes}},'@"' .$script .'"';return%spec}sub format_linker_cmd {my ($self,%spec)=@_;for my$path (@{$spec{libpath}}){$path="-L$path"}push(@{$spec{startup}},'c0d32.obj')unless ($spec{startup}&& @{$spec{startup}});%spec=$self->write_linker_script(%spec)if$spec{use_scripts};return [grep {defined && length}($spec{ld},@{$spec{lddlflags}},@{$spec{libpath}},@{$spec{other_ldflags}},@{$spec{startup}},@{$spec{objects}},',',$spec{output},',',$spec{map_file},',',$spec{libperl},@{$spec{perllibs}},',',$spec{def_file})]}sub write_linker_script {my ($self,%spec)=@_;my$ld_script=File::Spec->catfile($spec{srcdir},$spec{basename}.'.lds');my$ld_libs=File::Spec->catfile($spec{srcdir},$spec{basename}.'.lbs');$self->add_to_cleanup($ld_script,$ld_libs);print "Generating scripts '$ld_script' and '$ld_libs'.\n" if!$self->{quiet};my$LD_SCRIPT=IO::File->new(">$ld_script")or die("Could not create linker script '$ld_script': $!");print$LD_SCRIPT join(" +\n",map {@{$_}}grep defined,delete(@spec{qw(lddlflags libpath other_ldflags startup objects) }));my$LD_LIBS=IO::File->new(">$ld_libs")or die("Could not create linker script '$ld_libs': $!");print$LD_LIBS join(" +\n",(delete$spec{libperl}|| ''),@{delete$spec{perllibs}|| []},);push @{$spec{lddlflags}},'@"' .$ld_script .'"';push @{$spec{perllibs}},'@"' .$ld_libs .'"';return%spec}1;
EXTUTILS_CBUILDER_PLATFORM_WINDOWS_BCC

$fatpacked{"ExtUtils/CBuilder/Platform/Windows/GCC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CBUILDER_PLATFORM_WINDOWS_GCC';
  package ExtUtils::CBuilder::Platform::Windows::GCC;our$VERSION='0.280231';use warnings;use strict;sub format_compiler_cmd {my ($self,%spec)=@_;for my$path (@{$spec{includes}|| []},@{$spec{perlinc}|| []}){$path='-I' .$path}my@cc=split / (?=-)/,$spec{cc};return [grep {defined && length}(@cc,'-c',@{$spec{includes}},@{$spec{cflags}},@{$spec{optimize}},@{$spec{defines}},@{$spec{perlinc}},'-o',$spec{output},$spec{source},)]}sub format_linker_cmd {my ($self,%spec)=@_;my$cf=$self->{config};$spec{libperl}=~ s/^(?:lib)?([^.]+).*$/-l$1/;unshift(@{$spec{other_ldflags}},'-nostartfiles')if ($spec{startup}&& @{$spec{startup}});File::Basename::basename($spec{output})=~ /(....)(.{0,4})/;$spec{image_base}=sprintf("0x%x0000",unpack('n',$1 ^ $2));%spec=$self->write_linker_script(%spec)if$spec{use_scripts};for my$path (@{$spec{libpath}}){$path="-L$path"}my@cmds;my$DLLTOOL=$cf->{dlltool}|| 'dlltool';push@cmds,[$DLLTOOL,'--def',$spec{def_file},'--output-exp',$spec{explib}];my@ld=split / (?=-)/,$spec{ld};push@cmds,[grep {defined && length}(@ld,'-o',$spec{output},"-Wl,--base-file,$spec{base_file}","-Wl,--image-base,$spec{image_base}",@{$spec{lddlflags}},@{$spec{libpath}},@{$spec{startup}},@{$spec{objects}},@{$spec{other_ldflags}},$spec{libperl},@{$spec{perllibs}},$spec{explib},$spec{map_file}? ('-Map',$spec{map_file}): '')];push@cmds,[$DLLTOOL,'--def',$spec{def_file},'--output-exp',$spec{explib},'--base-file',$spec{base_file}];push@cmds,[grep {defined && length}(@ld,'-o',$spec{output},"-Wl,--image-base,$spec{image_base}",@{$spec{lddlflags}},@{$spec{libpath}},@{$spec{startup}},@{$spec{objects}},@{$spec{other_ldflags}},$spec{libperl},@{$spec{perllibs}},$spec{explib},$spec{map_file}? ('-Map',$spec{map_file}): '')];return@cmds}sub write_linker_script {my ($self,%spec)=@_;my$script=File::Spec->catfile($spec{srcdir},$spec{basename}.'.lds');$self->add_to_cleanup($script);print "Generating script '$script'\n" if!$self->{quiet};my$SCRIPT=IO::File->new(">$script")or die("Could not create script '$script': $!");print$SCRIPT ('SEARCH_DIR(' .$_ .")\n")for @{delete$spec{libpath}|| []};if ($spec{startup}&& @{$spec{startup}}){print$SCRIPT 'STARTUP(' .shift(@{$spec{startup}}).")\n";unshift @{$spec{objects}},@{delete$spec{startup}|| []}}print$SCRIPT 'INPUT(' .join(',',@{delete$spec{objects}|| []}).")\n";print$SCRIPT 'INPUT(' .join(' ',(delete$spec{libperl}|| ''),@{delete$spec{perllibs}|| []},).")\n";unshift @{$spec{other_ldflags}},'"' .$script .'"';return%spec}1;
EXTUTILS_CBUILDER_PLATFORM_WINDOWS_GCC

$fatpacked{"ExtUtils/CBuilder/Platform/Windows/MSVC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CBUILDER_PLATFORM_WINDOWS_MSVC';
  package ExtUtils::CBuilder::Platform::Windows::MSVC;our$VERSION='0.280231';use warnings;use strict;sub arg_exec_file {my ($self,$file)=@_;return "/OUT:$file"}sub format_compiler_cmd {my ($self,%spec)=@_;for my$path (@{$spec{includes}|| []},@{$spec{perlinc}|| []}){$path='-I' .$path}%spec=$self->write_compiler_script(%spec)if$spec{use_scripts};return [grep {defined && length}($spec{cc},'-nologo','-c',@{$spec{includes}},@{$spec{cflags}},@{$spec{optimize}},@{$spec{defines}},@{$spec{perlinc}},"-Fo$spec{output}",$spec{source},)]}sub write_compiler_script {my ($self,%spec)=@_;my$script=File::Spec->catfile($spec{srcdir},$spec{basename}.'.ccs');$self->add_to_cleanup($script);print "Generating script '$script'\n" if!$self->{quiet};my$SCRIPT=IO::File->new(">$script")or die("Could not create script '$script': $!");print$SCRIPT join("\n",map {ref $_ ? @{$_}: $_}grep defined,delete(@spec{qw(includes cflags optimize defines perlinc) }));push @{$spec{includes}},'@"' .$script .'"';return%spec}sub format_linker_cmd {my ($self,%spec)=@_;my$cf=$self->{config};for my$path (@{$spec{libpath}}){$path="-libpath:$path"}my$output=$spec{output};my$manifest=$spec{manifest};$spec{def_file}&&= '-def:' .$spec{def_file};$spec{output}&&= '-out:' .$spec{output};$spec{manifest}&&= '-manifest ' .$spec{manifest};$spec{implib}&&= '-implib:' .$spec{implib};$spec{map_file}&&= '-map:' .$spec{map_file};%spec=$self->write_linker_script(%spec)if$spec{use_scripts};my@cmds;push@cmds,[grep {defined && length}($spec{ld},@{$spec{lddlflags}},@{$spec{libpath}},@{$spec{other_ldflags}},@{$spec{startup}},@{$spec{objects}},$spec{map_file},$spec{libperl},@{$spec{perllibs}},$spec{def_file},$spec{implib},$spec{output},)];push@cmds,['if','exist',$manifest,'mt','-nologo',$spec{manifest},'-outputresource:' ."$output;2" ];return@cmds}sub write_linker_script {my ($self,%spec)=@_;my$script=File::Spec->catfile($spec{srcdir},$spec{basename}.'.lds');$self->add_to_cleanup($script);print "Generating script '$script'\n" if!$self->{quiet};my$SCRIPT=IO::File->new(">$script")or die("Could not create script '$script': $!");print$SCRIPT join("\n",map {ref $_ ? @{$_}: $_}grep defined,delete(@spec{qw(lddlflags libpath other_ldflags startup objects libperl perllibs def_file implib map_file) }));push @{$spec{lddlflags}},'@"' .$script .'"';return%spec}1;
EXTUTILS_CBUILDER_PLATFORM_WINDOWS_MSVC

$fatpacked{"ExtUtils/CBuilder/Platform/aix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CBUILDER_PLATFORM_AIX';
  package ExtUtils::CBuilder::Platform::aix;use warnings;use strict;use ExtUtils::CBuilder::Platform::Unix;use File::Spec;our$VERSION='0.280231';our@ISA=qw(ExtUtils::CBuilder::Platform::Unix);sub need_prelink {1}sub link {my ($self,%args)=@_;my$cf=$self->{config};(my$baseext=$args{module_name})=~ s/.*:://;my$perl_inc=$self->perl_inc();local$cf->{lddlflags}=$cf->{lddlflags};for ($cf->{lddlflags}){s/\Q$(BASEEXT)\E/$baseext/;s/\Q$(PERL_INC)\E/$perl_inc/}return$self->SUPER::link(%args)}1;
EXTUTILS_CBUILDER_PLATFORM_AIX

$fatpacked{"ExtUtils/CBuilder/Platform/android.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CBUILDER_PLATFORM_ANDROID';
  package ExtUtils::CBuilder::Platform::android;use warnings;use strict;use File::Spec;use ExtUtils::CBuilder::Platform::Unix;use Config;our$VERSION='0.280231';our@ISA=qw(ExtUtils::CBuilder::Platform::Unix);sub link {my ($self,%args)=@_;if ($self->{config}{useshrplib}eq 'true'){$args{extra_linker_flags}=[$self->split_like_shell($args{extra_linker_flags}),'-L' .$self->perl_inc(),'-lperl',$self->split_like_shell($Config{perllibs}),]}my($so_file,@so_tmps)=$self->SUPER::link(%args);$so_file=File::Spec->rel2abs($so_file);return wantarray ? ($so_file,@so_tmps): $so_file}1;
EXTUTILS_CBUILDER_PLATFORM_ANDROID

$fatpacked{"ExtUtils/CBuilder/Platform/cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CBUILDER_PLATFORM_CYGWIN';
  package ExtUtils::CBuilder::Platform::cygwin;use warnings;use strict;use File::Spec;use ExtUtils::CBuilder::Platform::Unix;our$VERSION='0.280231';our@ISA=qw(ExtUtils::CBuilder::Platform::Unix);sub link_executable {my$self=shift;return$self->SUPER::link_executable(@_)}sub link {my ($self,%args)=@_;my$lib=$self->{config}{useshrplib}? 'libperl.dll.a' : 'libperl.a';$args{extra_linker_flags}=[File::Spec->catfile($self->perl_inc(),$lib),$self->split_like_shell($args{extra_linker_flags})];return$self->SUPER::link(%args)}1;
EXTUTILS_CBUILDER_PLATFORM_CYGWIN

$fatpacked{"ExtUtils/CBuilder/Platform/darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CBUILDER_PLATFORM_DARWIN';
  package ExtUtils::CBuilder::Platform::darwin;use warnings;use strict;use ExtUtils::CBuilder::Platform::Unix;our$VERSION='0.280231';our@ISA=qw(ExtUtils::CBuilder::Platform::Unix);sub compile {my$self=shift;my$cf=$self->{config};local$cf->{ccflags}=$cf->{ccflags};$cf->{ccflags}=~ s/-flat_namespace//;$self->SUPER::compile(@_)}1;
EXTUTILS_CBUILDER_PLATFORM_DARWIN

$fatpacked{"ExtUtils/CBuilder/Platform/dec_osf.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CBUILDER_PLATFORM_DEC_OSF';
  package ExtUtils::CBuilder::Platform::dec_osf;use warnings;use strict;use ExtUtils::CBuilder::Platform::Unix;use File::Spec;our$VERSION='0.280231';our@ISA=qw(ExtUtils::CBuilder::Platform::Unix);sub link_executable {my$self=shift;local$self->{config}{ld}=$self->{config}{cc};return$self->SUPER::link_executable(@_)}1;
EXTUTILS_CBUILDER_PLATFORM_DEC_OSF

$fatpacked{"ExtUtils/CBuilder/Platform/os2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CBUILDER_PLATFORM_OS2';
  package ExtUtils::CBuilder::Platform::os2;use warnings;use strict;use ExtUtils::CBuilder::Platform::Unix;our$VERSION='0.280231';our@ISA=qw(ExtUtils::CBuilder::Platform::Unix);sub need_prelink {1}sub prelink {my$self=shift;my%args=@_;my@res=$self->SUPER::prelink(%args);die "Unexpected number of DEF files" unless@res==1;die "Can't find DEF file in the output" unless$res[0]=~ m,^(.*)\.def$,si;my$libname="$1$self->{config}{lib_ext}";$self->do_system('emximp','-o',$libname,$res[0])or die "emxexp: res=$?";return (@res,$libname)}sub _do_link {my$self=shift;my ($how,%args)=@_;if ($how eq 'lib_file' and (defined$args{module_name}and length$args{module_name})){my$objs=((ref$args{objects})? $args{objects}: [$args{objects}]);my$near_obj=$self->lib_file(@$objs);my$exp_dir=($near_obj =~ m,(.*)[/\\],s ? "$1/" : '');$args{dl_file}=$1 if$near_obj =~ m,(.*)\.,s;push @$objs,$self->perl_inc()."/libperl$self->{config}{lib_ext}";$args{objects}=$objs}local$self->{config}{shrpenv}='';return$self->SUPER::_do_link($how,%args)}sub extra_link_args_after_prelink {my ($self,%args)=@_;my@DEF=grep /\.def$/i,@{$args{prelink_res}};die "More than one .def files created by 'prelink' stage" if@DEF > 1;die "No .def file created by 'prelink' stage" unless@DEF or not @{$args{prelink_res}};my@after_libs=($OS2::is_aout ? (): $self->perl_inc()."/libperl_override$self->{config}{lib_ext}");(@after_libs,@DEF)}sub link_executable {my$self=shift;local$self->{config}{ldflags}=$self->{config}{ldflags};$self->{config}{ldflags}=~ s/(?<!\S)-Zexe(?!\S)//;return$self->SUPER::link_executable(@_)}1;
EXTUTILS_CBUILDER_PLATFORM_OS2

$fatpacked{"ExtUtils/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_COMMAND';
  package ExtUtils::Command;use 5.00503;use strict;require Exporter;use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);@ISA=qw(Exporter);@EXPORT=qw(cp rm_f rm_rf mv cat eqtime mkpath touch test_f test_d chmod dos2unix);$VERSION='7.38';$VERSION =~ tr/_//d;my$Is_VMS=$^O eq 'VMS';my$Is_VMS_mode=$Is_VMS;my$Is_VMS_noefs=$Is_VMS;my$Is_Win32=$^O eq 'MSWin32';if($Is_VMS){my$vms_unix_rpt;my$vms_efs;my$vms_case;if (eval {local$SIG{__DIE__};local@INC=@INC;pop@INC if$INC[-1]eq '.';require VMS::Feature}){$vms_unix_rpt=VMS::Feature::current("filename_unix_report");$vms_efs=VMS::Feature::current("efs_charset");$vms_case=VMS::Feature::current("efs_case_preserve")}else {my$unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';my$efs_charset=$ENV{'DECC$EFS_CHARSET'}|| '';my$efs_case=$ENV{'DECC$EFS_CASE_PRESERVE'}|| '';$vms_unix_rpt=$unix_rpt =~ /^[ET1]/i;$vms_efs=$efs_charset =~ /^[ET1]/i;$vms_case=$efs_case =~ /^[ET1]/i}$Is_VMS_mode=0 if$vms_unix_rpt;$Is_VMS_noefs=0 if ($vms_efs)}my$wild_regex=$Is_VMS ? '*%' : '*?';sub expand_wildcards {@ARGV=map(/[$wild_regex]/o ? glob($_): $_,@ARGV)}sub cat () {expand_wildcards();print while (<>)}sub eqtime {my ($src,$dst)=@ARGV;local@ARGV=($dst);touch();utime((stat($src))[8,9],$dst)}sub rm_rf {expand_wildcards();require File::Path;File::Path::rmtree([grep -e $_,@ARGV],0,0)}sub rm_f {expand_wildcards();for my$file (@ARGV){next unless -f $file;next if _unlink($file);chmod(0777,$file);next if _unlink($file);require Carp;Carp::carp("Cannot delete $file: $!")}}sub _unlink {my$files_unlinked=0;for my$file (@_){my$delete_count=0;$delete_count++ while unlink$file;$files_unlinked++ if$delete_count}return$files_unlinked}sub touch {my$t=time;expand_wildcards();for my$file (@ARGV){open(FILE,">>$file")|| die "Cannot write $file:$!";close(FILE);utime($t,$t,$file)}}sub mv {expand_wildcards();my@src=@ARGV;my$dst=pop@src;if (@src > 1 &&!-d $dst){require Carp;Carp::croak("Too many arguments")}require File::Copy;my$nok=0;for my$src (@src){$nok ||=!File::Copy::move($src,$dst)}return!$nok}sub cp {expand_wildcards();my@src=@ARGV;my$dst=pop@src;if (@src > 1 &&!-d $dst){require Carp;Carp::croak("Too many arguments")}require File::Copy;my$nok=0;for my$src (@src){$nok ||=!File::Copy::copy($src,$dst);utime(time,time,$dst)if$Is_Win32}return$nok}sub chmod {local@ARGV=@ARGV;my$mode=shift(@ARGV);expand_wildcards();if($Is_VMS_mode && $Is_VMS_noefs){require File::Spec;for my$idx (0..$#ARGV){my$path=$ARGV[$idx];next unless -d $path;my@dirs=File::Spec->splitdir($path);$dirs[-1].= '.dir';$path=File::Spec->catfile(@dirs);$ARGV[$idx]=$path}}chmod(oct$mode,@ARGV)|| die "Cannot chmod ".join(' ',$mode,@ARGV).":$!"}sub mkpath {expand_wildcards();require File::Path;File::Path::mkpath([@ARGV],0,0777)}sub test_f {exit(-f $ARGV[0]? 0 : 1)}sub test_d {exit(-d $ARGV[0]? 0 : 1)}sub dos2unix {require File::Find;File::Find::find(sub {return if -d;return unless -w _;return unless -r _;return if -B _;local $\;my$orig=$_;my$temp='.dos2unix_tmp';open ORIG,$_ or do {warn "dos2unix can't open $_: $!";return};open TEMP,">$temp" or do {warn "dos2unix can't create .dos2unix_tmp: $!";return};binmode ORIG;binmode TEMP;while (my$line=<ORIG>){$line =~ s/\015\012/\012/g;print TEMP$line}close ORIG;close TEMP;rename$temp,$orig},@ARGV)}
EXTUTILS_COMMAND

$fatpacked{"ExtUtils/Command/MM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_COMMAND_MM';
  package ExtUtils::Command::MM;require 5.006;use strict;use warnings;require Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(test_harness pod2man perllocal_install uninstall warn_if_old_packlist test_s cp_nonempty);our$VERSION='7.38';$VERSION =~ tr/_//d;my$Is_VMS=$^O eq 'VMS';sub mtime {no warnings 'redefine';local $@;*mtime=(eval {require Time::HiRes}&& defined&Time::HiRes::stat)? sub {(Time::HiRes::stat($_[0]))[9]}: sub {(stat($_[0]))[9]};goto&mtime}sub test_harness {require Test::Harness;require File::Spec;$Test::Harness::verbose=shift;require ExtUtils::Command;my@argv=ExtUtils::Command::expand_wildcards(@ARGV);local@INC=@INC;unshift@INC,map {File::Spec->rel2abs($_)}@_;Test::Harness::runtests(sort {lc$a cmp lc$b}@argv)}sub pod2man {local@ARGV=@_ ? @_ : @ARGV;{local $@;if(!eval {require Pod::Man}){warn "Pod::Man is not available: $@"."Man pages will not be generated during this install.\n";return 0}}require Getopt::Long;my%options=();Getopt::Long::config ('bundling_override');Getopt::Long::GetOptions (\%options,'section|s=s','release|r=s','center|c=s','date|d=s','fixed=s','fixedbold=s','fixeditalic=s','fixedbolditalic=s','official|o','quotes|q=s','lax|l','name|n=s','perm_rw=i','utf8|u');delete$options{utf8}unless$Pod::Man::VERSION >= 2.17;return 0 unless@ARGV;if ($options{official}&&!defined$options{center}){$options{center}=q[Perl Programmer's Reference Guide]}delete$options{lax};my$count=scalar@ARGV / 2;my$plural=$count==1 ? 'document' : 'documents';print "Manifying $count pod $plural\n";do {{my ($pod,$man)=splice(@ARGV,0,2);next if ((-e $man)&& (mtime($man)> mtime($pod))&& (mtime($man)> mtime("Makefile")));my$parser=Pod::Man->new(%options);$parser->parse_from_file($pod,$man)or do {warn("Could not install $man\n");next};if (exists$options{perm_rw}){chmod(oct($options{perm_rw}),$man)or do {warn("chmod $options{perm_rw} $man: $!\n");next}}}}while@ARGV;return 1}sub warn_if_old_packlist {my$packlist=$ARGV[0];return unless -f $packlist;print <<"PACKLIST_WARNING"}sub perllocal_install {my($type,$name)=splice(@ARGV,0,2);my@mod_info=$Is_VMS ? split /\|/,<STDIN> : @ARGV;my$pod;my$time=gmtime($ENV{SOURCE_DATE_EPOCH}|| time);$pod=sprintf <<'POD',scalar($time),$type,$name,$name;do {my($key,$val)=splice(@mod_info,0,2);$pod .= <<POD}while(@mod_info);$pod .= "=back\n\n";$pod =~ s/^ //mg;print$pod;return 1}sub uninstall {my($packlist)=shift@ARGV;require ExtUtils::Install;print <<'WARNING';ExtUtils::Install::uninstall($packlist,1,1);print <<'WARNING'}sub test_s {exit(-s $ARGV[0]? 0 : 1)}sub cp_nonempty {my@args=@ARGV;return 0 unless -s $args[0];require ExtUtils::Command;{local@ARGV=@args[0,1];ExtUtils::Command::cp(@ARGV)}{local@ARGV=@args[2,1];ExtUtils::Command::chmod(@ARGV)}}1;
  WARNING: I have found an old package in
      $packlist.
  Please make sure the two installations are not conflicting
  PACKLIST_WARNING
   =head2 %s: C<%s> L<%s|%s>
  
   =over 4
  
  POD
   =item *
  
   C<$key: $val>
  
  POD
  
  Uninstall is unsafe and deprecated, the uninstallation was not performed.
  We will show what would have been done.
  
  WARNING
  
  Uninstall is unsafe and deprecated, the uninstallation was not performed.
  Please check the list above carefully, there may be errors.
  Remove the appropriate files manually.
  Sorry for the inconvenience.
  
  WARNING
EXTUTILS_COMMAND_MM

$fatpacked{"ExtUtils/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CONFIG';
  package ExtUtils::Config;$ExtUtils::Config::VERSION='0.008';use strict;use warnings;use Config;use Data::Dumper ();sub new {my ($pack,$args)=@_;return bless {values=>($args ? {%$args }: {}),},$pack}sub get {my ($self,$key)=@_;return exists$self->{values}{$key}? $self->{values}{$key}: $Config{$key}}sub exists {my ($self,$key)=@_;return exists$self->{values}{$key}|| exists$Config{$key}}sub values_set {my$self=shift;return {%{$self->{values}}}}sub all_config {my$self=shift;return {%Config,%{$self->{values}}}}sub serialize {my$self=shift;return$self->{serialized}||= Data::Dumper->new([$self->values_set])->Terse(1)->Sortkeys(1)->Dump}1;
EXTUTILS_CONFIG

$fatpacked{"ExtUtils/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS';
  package ExtUtils::Helpers;$ExtUtils::Helpers::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';use Config;use File::Basename qw/basename/;use File::Spec::Functions qw/splitpath canonpath abs2rel splitdir/;use Text::ParseWords 3.24 ();our@EXPORT_OK=qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;BEGIN {my%impl_for=(MSWin32=>'Windows',VMS=>'VMS');my$package='ExtUtils::Helpers::' .($impl_for{$^O}|| 'Unix');my$impl=$impl_for{$^O}|| 'Unix';require "ExtUtils/Helpers/$impl.pm";"ExtUtils::Helpers::$impl"->import()}sub split_like_shell {my ($string)=@_;return if not defined$string;$string =~ s/^\s+|\s+$//g;return if not length$string;return Text::ParseWords::shellwords($string)}sub man1_pagename {my$filename=shift;return basename($filename).".$Config{man1ext}"}my%separator=(MSWin32=>'.',VMS=>'__',os2=>'.',cygwin=>'.',);my$separator=$separator{$^O}|| '::';sub man3_pagename {my ($filename,$base)=@_;$base ||= 'lib';my ($vols,$dirs,$file)=splitpath(canonpath(abs2rel($filename,$base)));$file=basename($file,qw/.pm .pod/);my@dirs=grep {length}splitdir($dirs);return join$separator,@dirs,"$file.$Config{man3ext}"}1;
EXTUTILS_HELPERS

$fatpacked{"ExtUtils/Helpers/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_UNIX';
  package ExtUtils::Helpers::Unix;$ExtUtils::Helpers::Unix::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Carp qw/croak/;use Config;my$layer=$] >= 5.008001 ? ":raw" : "";sub make_executable {my$filename=shift;my$current_mode=(stat$filename)[2]+ 0;if (-T $filename){open my$fh,"<$layer",$filename;my@lines=<$fh>;if (@lines and $lines[0]=~ s{ \A \#! \s* (?:/\S+/)? perl \b (.*) \z }{$Config{startperl}$1}xms){open my$out,">$layer","$filename.new" or croak "Couldn't open $filename.new: $!";print$out @lines;close$out;rename$filename,"$filename.bak" or croak "Couldn't rename $filename to $filename.bak";rename "$filename.new",$filename or croak "Couldn't rename $filename.new to $filename";unlink "$filename.bak"}}chmod$current_mode | oct(111),$filename;return}sub detildefy {my$value=shift;for ($value){s{ ^ ~ (?= /|$)}          [ $ENV{HOME} || (getpwuid $>)[7] ]ex or s{ ^ ~ ([^/]+) (?= /|$) } { (getpwnam $1)[7] || "~$1" }ex}return$value}1;
EXTUTILS_HELPERS_UNIX

$fatpacked{"ExtUtils/Helpers/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_VMS';
  package ExtUtils::Helpers::VMS;$ExtUtils::Helpers::VMS::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use File::Copy qw/copy/;sub make_executable {my$filename=shift;my$batchname="$filename.com";copy($filename,$batchname);ExtUtils::Helpers::Unix::make_executable($batchname);return}sub detildefy {my$arg=shift;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}
EXTUTILS_HELPERS_VMS

$fatpacked{"ExtUtils/Helpers/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_WINDOWS';
  package ExtUtils::Helpers::Windows;$ExtUtils::Helpers::Windows::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Config;use Carp qw/carp croak/;use ExtUtils::PL2Bat 'pl2bat';sub make_executable {my$script=shift;if (-T $script && $script !~ / \. (?:bat|cmd) $ /x){pl2bat(in=>$script,update=>1)}return}sub detildefy {my$value=shift;$value =~ s{ ^ ~ (?= [/\\] | $ ) }[$ENV{USERPROFILE}]x if$ENV{USERPROFILE};return$value}1;
EXTUTILS_HELPERS_WINDOWS

$fatpacked{"ExtUtils/Install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALL';
  package ExtUtils::Install;use strict;use Config qw(%Config);use Cwd qw(cwd);use Exporter ();use File::Basename qw(dirname);use File::Copy;use File::Path;use File::Spec;our@ISA=('Exporter');our@EXPORT=('install','uninstall','pm_to_blib','install_default');our$MUST_REBOOT;our$VERSION='2.14';$VERSION=eval$VERSION;BEGIN {*Is_VMS=$^O eq 'VMS' ? sub(){1}: sub(){0};*Is_Win32=$^O eq 'MSWin32' ? sub(){1}: sub(){0};*Is_cygwin=$^O eq 'cygwin' ? sub(){1}: sub(){0};*CanMoveAtBoot=($^O eq 'MSWin32' || $^O eq 'cygwin')? sub(){1}: sub(){0}}my$Inc_uninstall_warn_handler;my$INSTALL_ROOT=$ENV{PERL_INSTALL_ROOT};my$INSTALL_QUIET=$ENV{PERL_INSTALL_QUIET};$INSTALL_QUIET=1 if (!exists$ENV{PERL_INSTALL_QUIET}and defined$ENV{MAKEFLAGS}and $ENV{MAKEFLAGS}=~ /\b(s|silent|quiet)\b/);my$Curdir=File::Spec->curdir;sub _estr(@) {return join "\n",'!' x 72,@_,'!' x 72,''}{my%warned;sub _warnonce(@) {my$first=shift;my$msg=_estr "WARNING: $first",@_;warn$msg unless$warned{$msg}++}}sub _choke(@) {my$first=shift;my$msg=_estr "ERROR: $first",@_;require Carp;Carp::croak($msg)}sub _croak {require Carp;Carp::croak(@_)}sub _confess {require Carp;Carp::confess(@_)}sub _compare {require File::Compare;File::Compare::compare(@_)}sub _chmod($$;$) {my ($mode,$item,$verbose)=@_;$verbose ||= 0;if (chmod$mode,$item){printf "chmod(0%o, %s)\n",$mode,$item if$verbose > 1}else {my$err="$!";_warnonce sprintf "WARNING: Failed chmod(0%o, %s): %s\n",$mode,$item,$err if -e $item}}{my$Has_Win32API_File;sub _move_file_at_boot {my ($file,$target,$moan)=@_;_confess("Panic: Can't _move_file_at_boot on this platform!")unless CanMoveAtBoot;my$descr=ref$target ? "'$file' for deletion" : "'$file' for installation as '$target'";$Has_Win32API_File=(Is_Win32 || Is_cygwin)? (eval {require Win32API::File;1}|| 0): 0 unless defined$Has_Win32API_File;if (!$Has_Win32API_File){my@msg=("Cannot schedule $descr at reboot.","Try installing Win32API::File to allow operations on locked files","to be scheduled during reboot. Or try to perform the operation by","hand yourself. (You may need to close other perl processes first)");if ($moan){_warnonce(@msg)}else {_choke(@msg)}return 0}my$opts=Win32API::File::MOVEFILE_DELAY_UNTIL_REBOOT();$opts=$opts | Win32API::File::MOVEFILE_REPLACE_EXISTING()unless ref$target;_chmod(0666,$file);_chmod(0666,$target)unless ref$target;if (Win32API::File::MoveFileEx($file,$target,$opts)){$MUST_REBOOT ||= ref$target ? 0 : 1;return 1}else {my@msg=("MoveFileEx $descr at reboot failed: $^E","You may try to perform the operation by hand yourself. ","(You may need to close other perl processes first).",);if ($moan){_warnonce(@msg)}else {_choke(@msg)}}return 0}}sub _unlink_or_rename {my ($file,$tryhard,$installing)=@_;if ($^O =~ /^(dos|os2|MSWin32|VMS)$/){_chmod(0666,$file)}my$unlink_count=0;while (unlink$file){$unlink_count++}return$file if$unlink_count > 0;my$error="$!";_choke("Cannot unlink '$file': $!")unless CanMoveAtBoot && $tryhard;my$tmp="AAA";++$tmp while -e "$file.$tmp";$tmp="$file.$tmp";warn "WARNING: Unable to unlink '$file': $error\n","Going to try to rename it to '$tmp'.\n";if (rename$file,$tmp){warn "Rename successful. Scheduling '$tmp'\nfor deletion at reboot.\n";_move_file_at_boot($tmp,[],$installing);return$file}elsif ($installing){_warnonce("Rename failed: $!. Scheduling '$tmp'\nfor"." installation as '$file' at reboot.\n");_move_file_at_boot($tmp,$file);return$tmp}else {_choke("Rename failed:$!","Cannot proceed.")}}sub _get_install_skip {my ($skip,$verbose)=@_;if ($ENV{EU_INSTALL_IGNORE_SKIP}){print "EU_INSTALL_IGNORE_SKIP is set, ignore skipfile settings\n" if$verbose>2;return []}if (!defined$skip){print "Looking for install skip list\n" if$verbose>2;for my$file ('INSTALL.SKIP',$ENV{EU_INSTALL_SITE_SKIPFILE}){next unless$file;print "\tChecking for $file\n" if$verbose>2;if (-e $file){$skip=$file;last}}}if ($skip &&!ref$skip){print "Reading skip patterns from '$skip'.\n" if$verbose;if (open my$fh,$skip){my@patterns;while (<$fh>){chomp;next if /^\s*(?:#|$)/;print "\tSkip pattern: $_\n" if$verbose>3;push@patterns,$_}$skip=\@patterns}else {warn "Can't read skip file:'$skip':$!\n";$skip=[]}}elsif (UNIVERSAL::isa($skip,'ARRAY')){print "Using array for skip list\n" if$verbose>2}elsif ($verbose){print "No skip list found.\n" if$verbose>1;$skip=[]}warn "Got @{[0+@$skip]} skip patterns.\n" if$verbose>3;return$skip}{my$has_posix;sub _have_write_access {my$dir=shift;unless (defined$has_posix){$has_posix=(!Is_cygwin &&!Is_Win32 && eval {local $^W;require POSIX;1})|| 0}if ($has_posix){return POSIX::access($dir,POSIX::W_OK())}else {return -w $dir}}}sub _can_write_dir {my$dir=shift;return unless defined$dir and length$dir;my ($vol,$dirs,$file)=File::Spec->splitpath($dir,1);my@dirs=File::Spec->splitdir($dirs);unshift@dirs,File::Spec->curdir unless File::Spec->file_name_is_absolute($dir);my$path='';my@make;while (@dirs){if (Is_VMS){$dir=File::Spec->catdir($vol,@dirs)}else {$dir=File::Spec->catdir(@dirs);$dir=File::Spec->catpath($vol,$dir,'')if defined$vol and length$vol}next if ($dir eq $path);if (!-e $dir){unshift@make,$dir;next}if (_have_write_access($dir)){return 1,$dir,@make}else {return 0,$dir,@make}}continue {pop@dirs}return 0}sub _mkpath {my ($dir,$show,$mode,$verbose,$dry_run)=@_;if ($verbose && $verbose > 1 &&!-d $dir){$show=1;printf "mkpath(%s,%d,%#o)\n",$dir,$show,$mode}if (!$dry_run){if (!eval {File::Path::mkpath($dir,$show,$mode);1}){_choke("Can't create '$dir'","$@")}}my ($can,$root,@make)=_can_write_dir($dir);if (!$can){my@msg=("Can't create '$dir'",$root ? "Do not have write permissions on '$root'" : "Unknown Error");if ($dry_run){_warnonce@msg}else {_choke@msg}}elsif ($show and $dry_run){print "$_\n" for@make}}sub _copy {my ($from,$to,$verbose,$dry_run)=@_;if ($verbose && $verbose>1){printf "copy(%s,%s)\n",$from,$to}if (!$dry_run){File::Copy::copy($from,$to)or _croak(_estr "ERROR: Cannot copy '$from' to '$to': $!")}}sub _chdir {my ($dir)=@_;my$ret;if (defined wantarray){$ret=cwd}chdir$dir or _choke("Couldn't chdir to '$dir': $!");return$ret}sub install {my($from_to,$verbose,$dry_run,$uninstall_shadows,$skip,$always_copy,$result)=@_;if (@_==1 and eval {1+@$from_to}){my%opts=@$from_to;$from_to=$opts{from_to}or _confess("from_to is a mandatory parameter");$verbose=$opts{verbose};$dry_run=$opts{dry_run};$uninstall_shadows=$opts{uninstall_shadows};$skip=$opts{skip};$always_copy=$opts{always_copy};$result=$opts{result}}$result ||= {};$verbose ||= 0;$dry_run ||= 0;$skip=_get_install_skip($skip,$verbose);$always_copy=$ENV{EU_INSTALL_ALWAYS_COPY}|| $ENV{EU_ALWAYS_COPY}|| 0 unless defined$always_copy;my(%from_to)=%$from_to;my(%pack,$dir,%warned);require ExtUtils::Packlist;my($packlist)=ExtUtils::Packlist->new();local(*DIR);for (qw/read write/){$pack{$_}=$from_to{$_};delete$from_to{$_}}my$tmpfile=install_rooted_file($pack{"read"});$packlist->read($tmpfile)if (-f $tmpfile);my$cwd=cwd();my@found_files;my%check_dirs;require File::Find;my$blib_lib=File::Spec->catdir('blib','lib');my$blib_arch=File::Spec->catdir('blib','arch');my$current_directory=$^O eq 'MacOS' ? $Curdir : '.';MOD_INSTALL: foreach my$source (sort keys%from_to){my$targetroot=install_rooted_dir($from_to{$source});if ($source eq $blib_lib and exists$from_to{$blib_arch}and directory_not_empty($blib_arch)){$targetroot=install_rooted_dir($from_to{$blib_arch});print "Files found in $blib_arch: installing files in $blib_lib into architecture dependent library tree\n"}next unless -d $source;_chdir($source);File::Find::find(sub {my ($mode,$size,$atime,$mtime)=(stat)[2,7,8,9];return if!-f _;my$origfile=$_;return if$origfile eq ".exists";my$targetdir=File::Spec->catdir($targetroot,$File::Find::dir);my$targetfile=File::Spec->catfile($targetdir,$origfile);my$sourcedir=File::Spec->catdir($source,$File::Find::dir);my$sourcefile=File::Spec->catfile($sourcedir,$origfile);for my$pat (@$skip){if ($sourcefile=~/$pat/){print "Skipping $targetfile (filtered)\n" if$verbose>1;$result->{install_filtered}{$sourcefile}=$pat;return}}my$save_cwd=_chdir($cwd);my$diff=0;if ($always_copy or!-f $targetfile or -s $targetfile!=$size){$diff++}else {$diff=_compare($sourcefile,$targetfile)}$check_dirs{$targetdir}++ unless -w $targetfile;push@found_files,[$diff,$File::Find::dir,$origfile,$mode,$size,$atime,$mtime,$targetdir,$targetfile,$sourcedir,$sourcefile,];_chdir($save_cwd)},$current_directory);_chdir($cwd)}for my$targetdir (sort keys%check_dirs){_mkpath($targetdir,0,0755,$verbose,$dry_run)}for my$found (@found_files){my ($diff,$ffd,$origfile,$mode,$size,$atime,$mtime,$targetdir,$targetfile,$sourcedir,$sourcefile)=@$found;my$realtarget=$targetfile;if ($diff){eval {if (-f $targetfile){print "_unlink_or_rename($targetfile)\n" if$verbose>1;$targetfile=_unlink_or_rename($targetfile,'tryhard','install')unless$dry_run}elsif (!-d $targetdir){_mkpath($targetdir,0,0755,$verbose,$dry_run)}print "Installing $targetfile\n";_copy($sourcefile,$targetfile,$verbose,$dry_run,);print "utime($atime,$mtime,$targetfile)\n" if$verbose>1;utime($atime,$mtime + Is_VMS,$targetfile)unless$dry_run>1;$mode=0444 | ($mode & 0111 ? 0111 : 0);$mode=$mode | 0222 if$realtarget ne $targetfile;_chmod($mode,$targetfile,$verbose);$result->{install}{$targetfile}=$sourcefile;1}or do {$result->{install_fail}{$targetfile}=$sourcefile;die $@}}else {$result->{install_unchanged}{$targetfile}=$sourcefile;print "Skipping $targetfile (unchanged)\n" if$verbose}if ($uninstall_shadows){inc_uninstall($sourcefile,$ffd,$verbose,$dry_run,$realtarget ne $targetfile ? $realtarget : "",$result)}$packlist->{$targetfile}++}if ($pack{'write'}){$dir=install_rooted_dir(dirname($pack{'write'}));_mkpath($dir,0,0755,$verbose,$dry_run);print "Writing $pack{'write'}\n" if$verbose;$packlist->write(install_rooted_file($pack{'write'}))unless$dry_run}_do_cleanup($verbose);return$result}sub _do_cleanup {my ($verbose)=@_;if ($MUST_REBOOT){die _estr "Operation not completed! ","You must reboot to complete the installation.","Sorry."}elsif (defined$MUST_REBOOT & $verbose){warn _estr "Installation will be completed at the next reboot.\n","However it is not necessary to reboot immediately.\n"}}sub install_rooted_file {if (defined$INSTALL_ROOT){File::Spec->catfile($INSTALL_ROOT,$_[0])}else {$_[0]}}sub install_rooted_dir {if (defined$INSTALL_ROOT){File::Spec->catdir($INSTALL_ROOT,$_[0])}else {$_[0]}}sub forceunlink {my ($file,$tryhard)=@_;_unlink_or_rename($file,$tryhard,not("installing"))}sub directory_not_empty ($) {my($dir)=@_;my$files=0;require File::Find;File::Find::find(sub {return if $_ eq ".exists";if (-f){$File::Find::prune++;$files=1}},$dir);return$files}sub install_default {@_ < 2 or _croak("install_default should be called with 0 or 1 argument");my$FULLEXT=@_ ? shift : $ARGV[0];defined$FULLEXT or die "Do not know to where to write install log";my$INST_LIB=File::Spec->catdir($Curdir,"blib","lib");my$INST_ARCHLIB=File::Spec->catdir($Curdir,"blib","arch");my$INST_BIN=File::Spec->catdir($Curdir,'blib','bin');my$INST_SCRIPT=File::Spec->catdir($Curdir,'blib','script');my$INST_MAN1DIR=File::Spec->catdir($Curdir,'blib','man1');my$INST_MAN3DIR=File::Spec->catdir($Curdir,'blib','man3');my@INST_HTML;if($Config{installhtmldir}){my$INST_HTMLDIR=File::Spec->catdir($Curdir,'blib','html');@INST_HTML=($INST_HTMLDIR=>$Config{installhtmldir})}install({read=>"$Config{sitearchexp}/auto/$FULLEXT/.packlist",write=>"$Config{installsitearch}/auto/$FULLEXT/.packlist",$INST_LIB=>(directory_not_empty($INST_ARCHLIB))? $Config{installsitearch}: $Config{installsitelib},$INST_ARCHLIB=>$Config{installsitearch},$INST_BIN=>$Config{installbin},$INST_SCRIPT=>$Config{installscript},$INST_MAN1DIR=>$Config{installman1dir},$INST_MAN3DIR=>$Config{installman3dir},@INST_HTML,},1,0,0)}sub uninstall {my($fil,$verbose,$dry_run)=@_;$verbose ||= 0;$dry_run ||= 0;die _estr "ERROR: no packlist file found: '$fil'" unless -f $fil;require ExtUtils::Packlist;my ($packlist)=ExtUtils::Packlist->new($fil);for (sort(keys(%$packlist))){chomp;print "unlink $_\n" if$verbose;forceunlink($_,'tryhard')unless$dry_run}print "unlink $fil\n" if$verbose;forceunlink($fil,'tryhard')unless$dry_run;_do_cleanup($verbose)}sub inc_uninstall {my($filepath,$libdir,$verbose,$dry_run,$ignore,$results)=@_;my($dir);$ignore||="";my$file=(File::Spec->splitpath($filepath))[2];my%seen_dir=();my@PERL_ENV_LIB=split$Config{path_sep},defined$ENV{'PERL5LIB'}? $ENV{'PERL5LIB'}: $ENV{'PERLLIB'}|| '';my@dirs=(@PERL_ENV_LIB,@INC,@Config{qw(archlibexp privlibexp sitearchexp sitelibexp)});my$seen_ours;for$dir (@dirs){my$canonpath=Is_VMS ? $dir : File::Spec->canonpath($dir);next if$canonpath eq $Curdir;next if$seen_dir{$canonpath}++;my$targetfile=File::Spec->catfile($canonpath,$libdir,$file);next unless -f $targetfile;my$diff=0;if (-f $targetfile && -s _==-s $filepath){$diff=_compare($filepath,$targetfile)}else {$diff++}print "#$file and $targetfile differ\n" if$diff && $verbose > 1;if (!$diff or $targetfile eq $ignore){$seen_ours=1;next}if ($dry_run){$results->{uninstall}{$targetfile}=$filepath;if ($verbose){$Inc_uninstall_warn_handler ||= ExtUtils::Install::Warn->new();$libdir =~ s|^\./||s ;$Inc_uninstall_warn_handler->add(File::Spec->catfile($libdir,$file),$targetfile)}}else {print "Unlinking $targetfile (shadowing?)\n" if$verbose;eval {die "Fake die for testing" if$ExtUtils::Install::Testing and ucase(File::Spec->canonpath($ExtUtils::Install::Testing))eq ucase($targetfile);forceunlink($targetfile,'tryhard');$results->{uninstall}{$targetfile}=$filepath;1}or do {$results->{fail_uninstall}{$targetfile}=$filepath;if ($seen_ours){warn "Failed to remove probably harmless shadow file '$targetfile'\n"}else {die "$@\n"}}}}}sub run_filter {my ($cmd,$src,$dest)=@_;local(*CMD,*SRC);open(CMD,"|$cmd >$dest")|| die "Cannot fork: $!";open(SRC,$src)|| die "Cannot open $src: $!";my$buf;my$sz=1024;while (my$len=sysread(SRC,$buf,$sz)){syswrite(CMD,$buf,$len)}close SRC;close CMD or die "Filter command '$cmd' failed for $src"}sub pm_to_blib {my($fromto,$autodir,$pm_filter)=@_;_mkpath($autodir,0,0755)if defined$autodir;while(my($from,$to)=each %$fromto){if(-f $to && -s $from==-s $to && -M $to < -M $from){print "Skip $to (unchanged)\n" unless$INSTALL_QUIET;next}my$need_filtering=defined$pm_filter && length$pm_filter && $from =~ /\.pm$/;if (!$need_filtering && 0==_compare($from,$to)){print "Skip $to (unchanged)\n" unless$INSTALL_QUIET;next}if (-f $to){forceunlink($to)}else {_mkpath(dirname($to),0,0755)}if ($need_filtering){run_filter($pm_filter,$from,$to);print "$pm_filter <$from >$to\n"}else {_copy($from,$to);print "cp $from $to\n" unless$INSTALL_QUIET}my($mode,$atime,$mtime)=(stat$from)[2,8,9];utime($atime,$mtime+Is_VMS,$to);_chmod(0444 | ($mode & 0111 ? 0111 : 0),$to);next unless$from =~ /\.pm$/;_autosplit($to,$autodir)if defined$autodir}}sub _autosplit {require AutoSplit;my$retval=AutoSplit::autosplit(@_);close*AutoSplit::IN if defined*AutoSplit::IN{IO};return$retval}package ExtUtils::Install::Warn;sub new {bless {},shift}sub add {my($self,$file,$targetfile)=@_;push @{$self->{$file}},$targetfile}sub DESTROY {unless(defined$INSTALL_ROOT){my$self=shift;my($file,$i,$plural);for$file (sort keys %$self){$plural=@{$self->{$file}}> 1 ? "s" : "";print "## Differing version$plural of $file found. You might like to\n";for (0..$#{$self->{$file}}){print "rm ",$self->{$file}[$_],"\n";$i++}}$plural=$i>1 ? "all those files" : "this file";my$inst=(_invokant()eq 'ExtUtils::MakeMaker')? ($Config::Config{make}|| 'make').' install' .(ExtUtils::Install::Is_VMS ? '/MACRO="UNINST"=1' : ' UNINST=1'): './Build install uninst=1';print "## Running '$inst' will unlink $plural for you.\n"}}sub _invokant {my@stack;my$frame=0;while (my$file=(caller($frame++))[1]){push@stack,(File::Spec->splitpath($file))[2]}my$builder;my$top=pop@stack;if ($top =~ /^Build/i || exists($INC{'Module/Build.pm'})){$builder='Module::Build'}else {$builder='ExtUtils::MakeMaker'}return$builder}1;
EXTUTILS_INSTALL

$fatpacked{"ExtUtils/InstallPaths.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLPATHS';
  package ExtUtils::InstallPaths;$ExtUtils::InstallPaths::VERSION='0.012';use 5.006;use strict;use warnings;use File::Spec ();use Carp ();use ExtUtils::Config 0.002;my%complex_accessors=map {$_=>1}qw/prefix_relpaths install_sets/;my%hash_accessors=map {$_=>1}qw/install_path install_base_relpaths original_prefix/;my%defaults=(installdirs=>'site',install_base=>undef,prefix=>undef,verbose=>0,create_packlist=>1,dist_name=>undef,module_name=>undef,destdir=>undef,install_path=>sub {{}},install_sets=>\&_default_install_sets,original_prefix=>\&_default_original_prefix,install_base_relpaths=>\&_default_base_relpaths,prefix_relpaths=>\&_default_prefix_relpaths,);sub _merge_shallow {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);$filter->($_)for grep$filter,values %$override;return {%$defaults,%$override }}}sub _merge_deep {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);my$pair_for=sub {my$key=shift;my%override=%{$override->{$key}|| {}};$filter && $filter->($_)for values%override;return$key=>{%{$defaults->{$key}},%override }};return {map {$pair_for->($_)}keys %$defaults }}}my%allowed_installdir=map {$_=>1}qw/core site vendor/;my$must_be_relative=sub {Carp::croak('Value must be a relative path')if File::Spec->file_name_is_absolute($_[0])};my%deep_filter=map {$_=>$must_be_relative}qw/install_base_relpaths prefix_relpaths/;my%filter=(installdirs=>sub {my$value=shift;$value='core',Carp::carp('Perhaps you meant installdirs to be "core" rather than "perl"?')if$value eq 'perl';Carp::croak('installdirs must be one of "core", "site", or "vendor"')if not $allowed_installdir{$value};return$value},(map {$_=>_merge_shallow($_,$deep_filter{$_})}qw/original_prefix install_base_relpaths/),(map {$_=>_merge_deep($_,$deep_filter{$_})}qw/install_sets prefix_relpaths/),);sub new {my ($class,%args)=@_;my$config=$args{config}|| ExtUtils::Config->new;my%self=(config=>$config,map {$_=>exists$args{$_}? $filter{$_}? $filter{$_}->($args{$_},$config): $args{$_}: ref$defaults{$_}? $defaults{$_}->($config): $defaults{$_}}keys%defaults,);$self{module_name}||= do {my$module_name=$self{dist_name};$module_name =~ s/-/::/g;$module_name}if defined$self{dist_name};return bless \%self,$class}for my$attribute (keys%defaults){no strict qw/refs/;*{$attribute}=$hash_accessors{$attribute}? sub {my ($self,$key)=@_;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$key}}: $complex_accessors{$attribute}? sub {my ($self,$installdirs,$key)=@_;Carp::confess("$attribute needs installdir")if not defined$installdirs;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$installdirs}{$key}}: sub {my$self=shift;return$self->{$attribute}}}my$script=$] > 5.008000 ? 'script' : 'bin';my@install_sets_keys=qw/lib arch bin script bindoc libdoc binhtml libhtml/;my@install_sets_tail=('bin',$script,qw/man1dir man3dir html1dir html3dir/);my%install_sets_values=(core=>[qw/privlib archlib/,@install_sets_tail ],site=>[map {"site$_"}qw/lib arch/,@install_sets_tail ],vendor=>[map {"vendor$_"}qw/lib arch/,@install_sets_tail ],);sub _default_install_sets {my$c=shift;my%ret;for my$installdir (qw/core site vendor/){@{$ret{$installdir}}{@install_sets_keys}=map {$c->get("install$_")}@{$install_sets_values{$installdir}}}return \%ret}sub _default_base_relpaths {my$config=shift;return {lib=>['lib','perl5'],arch=>['lib','perl5',$config->get('archname')],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],}}my%common_prefix_relpaths=(bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],);sub _default_prefix_relpaths {my$c=shift;my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');return {core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],%common_prefix_relpaths,},}}sub _default_original_prefix {my$c=shift;my%ret=(core=>$c->get('installprefixexp'),site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',);return \%ret}sub _log_verbose {my$self=shift;print @_ if$self->verbose;return}sub is_default_installable {my$self=shift;my$type=shift;my$installable=$self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs,$type));return$installable ? 1 : 0}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->_log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return File::Spec->catdir(@{$default})}}sub _prefixify_novms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m{/$};$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined$path && length$path;if (not defined$path or length$path==0){$self->_log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->_log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->_log_verbose("    now $path in $rprefix\n");return$path}sub _catprefix_vms {my ($self,$rprefix,$default)=@_;my ($rvol,$rdirs)=File::Spec->splitpath($rprefix);if ($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify_vms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n");require VMS::Filespec;$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->_log_verbose("  rprefix translated to $rprefix\n  sprefix translated to $sprefix\n");if (length($path)==0){$self->_log_verbose("  no path to prefixify.\n")}elsif (!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("	path is relative, not prefixifying.\n")}elsif ($sprefix eq $rprefix){$self->_log_verbose("  no new prefix.\n")}else {my ($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config->get('vms_prefix');if ($path_vol eq $vms_prefix.':'){$self->_log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix_vms($rprefix,$path_dirs)}else {$self->_log_verbose("	cannot prefixify.\n");return File::Spec->catdir($self->prefix_relpaths($self->installdirs,$type))}}$self->_log_verbose("	now $path\n");return$path}BEGIN {*_prefixify=$^O eq 'VMS' ? \&_prefixify_vms : \&_prefixify_novms}sub prefix_relative {my ($self,$installdirs,$type)=@_;my$relpath=$self->install_sets($installdirs,$type);return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type)}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,@{$relpath}): undef}if ($self->prefix){my$relpath=$self->prefix_relative($self->installdirs,$type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs,$type)}sub install_types {my$self=shift;my%types=(%{$self->{install_path}},$self->install_base ? %{$self->{install_base_relpaths}}: $self->prefix ? %{$self->{prefix_relpaths}{$self->installdirs }}: %{$self->{install_sets}{$self->installdirs }});return sort keys%types}sub install_map {my ($self,$dirs)=@_;my%localdir_for;if ($dirs && %$dirs){%localdir_for=%$dirs}else {for my$type ($self->install_types){$localdir_for{$type}=File::Spec->catdir('blib',$type)}}my (%map,@skipping);for my$type (keys%localdir_for){next if not -e $localdir_for{$type};if (my$dest=$self->install_destination($type)){$map{$localdir_for{$type}}=$dest}else {push@skipping,$type}}warn "WARNING: Can't figure out install path for types: @skipping\nFiles will not be installed.\n" if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}1;
EXTUTILS_INSTALLPATHS

$fatpacked{"ExtUtils/Installed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLED';
  package ExtUtils::Installed;use 5.00503;use strict;use Carp qw();use ExtUtils::Packlist;use ExtUtils::MakeMaker;use Config;use File::Find;use File::Basename;use File::Spec;my$Is_VMS=$^O eq 'VMS';my$DOSISH=($^O =~ /^(MSWin\d\d|os2|dos|mint)$/);require VMS::Filespec if$Is_VMS;use vars qw($VERSION);$VERSION='2.14';$VERSION=eval$VERSION;sub _is_prefix {my ($self,$path,$prefix)=@_;return unless defined$prefix && defined$path;if($Is_VMS){$prefix=VMS::Filespec::unixify($prefix);$path=VMS::Filespec::unixify($path)}$prefix=File::Spec->canonpath($prefix);return 1 if substr($path,0,length($prefix))eq $prefix;if ($DOSISH){$path =~ s|\\|/|g;$prefix =~ s|\\|/|g;return 1 if$path =~ m{^\Q$prefix\E}i}return(0)}sub _is_doc {my ($self,$path)=@_;my$man1dir=$self->{':private:'}{Config}{man1direxp};my$man3dir=$self->{':private:'}{Config}{man3direxp};return(($man1dir && $self->_is_prefix($path,$man1dir))|| ($man3dir && $self->_is_prefix($path,$man3dir))? 1 : 0)}sub _is_type {my ($self,$path,$type)=@_;return 1 if$type eq "all";return($self->_is_doc($path))if$type eq "doc";my$conf=$self->{':private:'}{Config};if ($type eq "prog"){return($self->_is_prefix($path,$conf->{prefix}|| $conf->{prefixexp})&&!($self->_is_doc($path))? 1 : 0)}return(0)}sub _is_under {my ($self,$path,@under)=@_;$under[0]="" if (!@under);for my$dir (@under){return(1)if ($self->_is_prefix($path,$dir))}return(0)}sub _fix_dirs {my ($self,@dirs)=@_;if($Is_VMS){$_=VMS::Filespec::unixify($_)for@dirs}if ($DOSISH){s|\\|/|g for@dirs}return wantarray ? @dirs : $dirs[0]}sub _make_entry {my ($self,$module,$packlist_file,$modfile)=@_;my$data={module=>$module,packlist=>scalar(ExtUtils::Packlist->new($packlist_file)),packlist_file=>$packlist_file,};if (!$modfile){$data->{version}=$self->{':private:'}{Config}{version}}else {$data->{modfile}=$modfile;$data->{version}='';for my$dir (@{$self->{':private:'}{INC}}){my$p=File::Spec->catfile($dir,$modfile);if (-r $p){$module=_module_name($p,$module)if$Is_VMS;$data->{version}=MM->parse_version($p);$data->{version_from}=$p;$data->{packlist_valid}=exists$data->{packlist}{$p};last}}}$self->{$module}=$data}our$INSTALLED;sub new {my ($class)=shift(@_);$class=ref($class)|| $class;my%args=@_;return$INSTALLED if$INSTALLED and ($args{default_get}|| $args{default});my$self=bless {},$class;$INSTALLED=$self if$args{default_set}|| $args{default};if ($args{config_override}){eval {$self->{':private:'}{Config}={%{$args{config_override}}}}or Carp::croak("The 'config_override' parameter must be a hash reference.")}else {$self->{':private:'}{Config}=\%Config}for my$tuple ([inc_override=>INC=>[@INC ]],[extra_libs=>EXTRA=>[]]){my ($arg,$key,$val)=@$tuple;if ($args{$arg}){eval {$self->{':private:'}{$key}=[@{$args{$arg}}]}or Carp::croak("The '$arg' parameter must be an array reference.")}elsif ($val){$self->{':private:'}{$key}=$val}}{my%dupe;@{$self->{':private:'}{LIBDIRS}}=grep {$_ ne '.' ||!$args{skip_cwd}}grep {-e $_ &&!$dupe{$_}++}@{$self->{':private:'}{EXTRA}},@{$self->{':private:'}{INC}}}my@dirs=$self->_fix_dirs(@{$self->{':private:'}{LIBDIRS}});my$archlib=$self->_fix_dirs($self->{':private:'}{Config}{archlibexp});$self->_make_entry("Perl",File::Spec->catfile($archlib,'.packlist'));my$root;my$sub=sub {return if $_ ne ".packlist" || $File::Find::dir eq $archlib;my$module=$File::Find::name;my$found=$module =~ s!^.*?/auto/(.*)/.packlist!$1!s or do {return};my$modfile="$module.pm";$module =~ s!/!::!g;return if$self->{$module};$self->_make_entry($module,$File::Find::name,$modfile)};while (@dirs){$root=shift@dirs;next if!-d $root;find($sub,$root)}return$self}sub _module_name {my($file,$orig_module)=@_;my$module='';if (open PACKFH,$file){while (<PACKFH>){if (/package\s+(\S+)\s*;/){my$pack=$1;if (lc($pack)eq lc($orig_module)){$module=$pack;last}}}close PACKFH}print STDERR "Couldn't figure out the package name for $file\n" unless$module;return$module}sub modules {my ($self)=@_;$self=$self->new(default=>1)if!ref$self;return wantarray ? sort grep {not /^:private:$/}keys %$self : grep {not /^:private:$/}keys %$self}sub files {my ($self,$module,$type,@under)=@_;$self=$self->new(default=>1)if!ref$self;Carp::croak("$module is not installed")if (!exists($self->{$module}));$type="all" if (!defined($type));Carp::croak('type must be "all", "prog" or "doc"')if ($type ne "all" && $type ne "prog" && $type ne "doc");my (@files);for my$file (keys(%{$self->{$module}{packlist}})){push(@files,$file)if ($self->_is_type($file,$type)&& $self->_is_under($file,@under))}return(@files)}sub directories {my ($self,$module,$type,@under)=@_;$self=$self->new(default=>1)if!ref$self;my (%dirs);for my$file ($self->files($module,$type,@under)){$dirs{dirname($file)}++}return sort keys%dirs}sub directory_tree {my ($self,$module,$type,@under)=@_;$self=$self->new(default=>1)if!ref$self;my (%dirs);for my$dir ($self->directories($module,$type,@under)){$dirs{$dir}++;my ($last)=("");while ($last ne $dir){$last=$dir;$dir=dirname($dir);last if!$self->_is_under($dir,@under);$dirs{$dir}++}}return(sort(keys(%dirs)))}sub validate {my ($self,$module,$remove)=@_;$self=$self->new(default=>1)if!ref$self;Carp::croak("$module is not installed")if (!exists($self->{$module}));return($self->{$module}{packlist}->validate($remove))}sub packlist {my ($self,$module)=@_;$self=$self->new(default=>1)if!ref$self;Carp::croak("$module is not installed")if (!exists($self->{$module}));return($self->{$module}{packlist})}sub version {my ($self,$module)=@_;$self=$self->new(default=>1)if!ref$self;Carp::croak("$module is not installed")if (!exists($self->{$module}));return($self->{$module}{version})}sub debug_dump {my ($self,$module)=@_;$self=$self->new(default=>1)if!ref$self;local$self->{":private:"}{Config};require Data::Dumper;print Data::Dumper->new([$self])->Sortkeys(1)->Indent(1)->Dump()}1;
EXTUTILS_INSTALLED

$fatpacked{"ExtUtils/Liblist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_LIBLIST';
  package ExtUtils::Liblist;use strict;our$VERSION='7.38';$VERSION =~ tr/_//d;use File::Spec;require ExtUtils::Liblist::Kid;our@ISA=qw(ExtUtils::Liblist::Kid File::Spec);sub ext {goto&ExtUtils::Liblist::Kid::ext}sub lsdir {shift;my$rex=qr/$_[1]/;opendir my$dir_fh,$_[0];my@out=grep /$rex/,readdir$dir_fh;closedir$dir_fh;return@out}
EXTUTILS_LIBLIST

$fatpacked{"ExtUtils/Liblist/Kid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_LIBLIST_KID';
  package ExtUtils::Liblist::Kid;use 5.006;use strict;use warnings;our$VERSION='7.38';$VERSION =~ tr/_//d;use ExtUtils::MakeMaker::Config;use Cwd 'cwd';use File::Basename;use File::Spec;sub ext {if ($^O eq 'VMS'){return&_vms_ext}elsif ($^O eq 'MSWin32'){return&_win32_ext}else {return&_unix_os2_ext}}sub _unix_os2_ext {my ($self,$potential_libs,$verbose,$give_libs)=@_;$verbose ||= 0;if ($^O =~ /os2|android/ and $Config{perllibs}){$potential_libs .= " " if$potential_libs;$potential_libs .= $Config{perllibs}}return ("","","","",($give_libs ? []: ()))unless$potential_libs;warn "Potential libraries are '$potential_libs':\n" if$verbose;my ($so)=$Config{so};my ($libs)=defined$Config{perllibs}? $Config{perllibs}: $Config{libs};my$Config_libext=$Config{lib_ext}|| ".a";my$Config_dlext=$Config{dlext};require Text::ParseWords;my (@searchpath);my (@libpath)=Text::ParseWords::quotewords('\s+',0,$Config{'libpth'}|| '');my (@ldloadlibs,@bsloadlibs,@extralibs,@ld_run_path,%ld_run_path_seen);my (@libs,%libs_seen);my ($fullname,@fullname);my ($pwd)=cwd();my ($found)=0;if ($^O eq 'darwin' or $^O eq 'next'){$potential_libs =~ s/(^|\s)(-(?:weak_|reexport_|lazy_)?framework)\s+(\S+)/$1-Wl,$2 -Wl,$3/g;$potential_libs =~ s/(^|\s)(-F)\s*(\S+)/$1-Wl,$2 -Wl,$3/g}for my$thislib (Text::ParseWords::quotewords('\s+',0,$potential_libs)){my ($custom_name)='';if ($thislib =~ s/^(-[LR]|-Wl,-R|-Wl,-rpath,)//){my ($ptype)=$1;unless (-d $thislib){warn "$ptype$thislib ignored, directory does not exist\n" if$verbose;next}my ($rtype)=$ptype;if (($ptype eq '-R')or ($ptype =~ m!^-Wl,-[Rr]!)){if ($Config{'lddlflags'}=~ /-Wl,-[Rr]/){$rtype='-Wl,-R'}elsif ($Config{'lddlflags'}=~ /-R/){$rtype='-R'}}unless (File::Spec->file_name_is_absolute($thislib)){warn "Warning: $ptype$thislib changed to $ptype$pwd/$thislib\n";$thislib=$self->catdir($pwd,$thislib)}push(@searchpath,$thislib);$thislib=qq{"$thislib"} if$thislib =~ / /;push(@extralibs,"$ptype$thislib");push(@ldloadlibs,"$rtype$thislib");next}if ($thislib =~ m!^-Wl,!){push(@extralibs,$thislib);push(@ldloadlibs,$thislib);next}if ($thislib =~ s/^-l(:)?//){$custom_name=$1 || ''}else {warn "Unrecognized argument in LIBS ignored: '$thislib'\n";next}my ($found_lib)=0;for my$thispth (@searchpath,@libpath){if ((@fullname=$self->lsdir($thispth,"^\Qlib$thislib.$so.\E[0-9]+"))|| (@fullname=$self->lsdir($thispth,"^\Qlib$thislib.\E[0-9]+\Q\.$so"))){$fullname="$thispth/" .(sort {my ($ma)=$a;my ($mb)=$b;$ma =~ tr/A-Za-z/0/s;$ma =~ s/\b(\d)\b/0$1/g;$mb =~ tr/A-Za-z/0/s;$mb =~ s/\b(\d)\b/0$1/g;while (length($ma)< length($mb)){$ma .= ".00"}while (length($mb)< length($ma)){$mb .= ".00"}$mb cmp $ma}@fullname)[0]}elsif (-f ($fullname="$thispth/lib$thislib.$so")&& (($Config{'dlsrc'}ne "dl_dld.xs")|| ($thislib eq "m"))){}elsif (-f ($fullname="$thispth/lib${thislib}_s$Config_libext")&& ($Config{'archname'}!~ /RM\d\d\d-svr4/)&& ($thislib .= "_s")){}elsif (-f ($fullname="$thispth/lib$thislib$Config_libext")){}elsif (defined($Config_dlext)&& -f ($fullname="$thispth/lib$thislib.$Config_dlext")){}elsif (-f ($fullname="$thispth/$thislib$Config_libext")){}elsif (-f ($fullname="$thispth/lib$thislib.dll$Config_libext")){}elsif ($^O eq 'cygwin' && -f ($fullname="$thispth/$thislib.dll")){}elsif (-f ($fullname="$thispth/Slib$thislib$Config_libext")){}elsif ($^O eq 'dgux' && -l ($fullname="$thispth/lib$thislib$Config_libext")&& readlink($fullname)=~ /^elink:/s){}elsif ($custom_name && -f ($fullname="$thispth/$thislib")){}else {warn "$thislib not found in $thispth\n" if$verbose;next}warn "'-l$thislib' found at $fullname\n" if$verbose;push@libs,$fullname unless$libs_seen{$fullname}++;$found++;$found_lib++;my$is_dyna=($fullname !~ /\Q$Config_libext\E\z/);my$in_perl=($libs =~ /\B-l:?\Q${thislib}\E\b/s);my ($fullnamedir)=dirname($fullname);push@ld_run_path,$fullnamedir if$is_dyna &&!$in_perl &&!$ld_run_path_seen{$fullnamedir}++;unless ($in_perl || ($Config{'osname'}eq 'next' && ($thislib eq 'm' || $thislib eq 'ndbm'))){push(@extralibs,"-l$custom_name$thislib")}if (($Config{'dlsrc'}=~ /dl_next/ && $Config{'osvers'}lt '4_0')|| ($Config{'dlsrc'}=~ /dl_dld/)){push(@bsloadlibs,"$fullname")}else {if ($is_dyna){push(@ldloadlibs,"-l$custom_name$thislib")unless ($in_perl and $^O eq 'sunos')}else {push(@ldloadlibs,"-l$custom_name$thislib")}}last}warn "Warning (mostly harmless): " ."No library found for -l$thislib\n" unless$found_lib > 0}unless ($found){return ('','','','',($give_libs ? \@libs : ()))}else {return ("@extralibs","@bsloadlibs","@ldloadlibs",join(":",@ld_run_path),($give_libs ? \@libs : ()))}}sub _win32_ext {require Text::ParseWords;my ($self,$potential_libs,$verbose,$give_libs)=@_;$verbose ||= 0;return ("","","","",($give_libs ? []: ()))unless$potential_libs;my%libs_seen;my@extralibs;my$cc=$Config{cc}|| '';my$VC=$cc =~ /\bcl\b/i;my$GC=$cc =~ /\bgcc\b/i;my$libext=_win32_lib_extensions();my@searchpath=('');my@libpath=_win32_default_search_paths($VC,$GC);my$pwd=cwd();my$search=1;my@lib_search_list=_win32_make_lib_search_list($potential_libs,$verbose);for (@lib_search_list){my$thislib=$_;if (/^:\w+$/){$search=0 if lc eq ':nosearch';$search=1 if lc eq ':search';_debug("Ignoring unknown flag '$thislib'\n",$verbose)if!/^:(no)?(search|default)$/i;next}unless ($search){s/^-l(.+)$/$1.lib/ unless$GC;s/^-L/-libpath:/ if$VC;push(@extralibs,$_);next}if (s/^-L// and not -d){_debug("$thislib ignored, directory does not exist\n",$verbose);next}elsif (-d){unless (File::Spec->file_name_is_absolute($_)){warn "Warning: '$thislib' changed to '-L$pwd/$_'\n";$_=$self->catdir($pwd,$_)}push(@searchpath,$_);next}my@paths=(@searchpath,@libpath);my ($fullname,$path)=_win32_search_file($thislib,$libext,\@paths,$verbose,$GC);if (!$fullname){warn "Warning (mostly harmless): No library found for $thislib\n";next}_debug("'$thislib' found as '$fullname'\n",$verbose);push(@extralibs,$fullname);$libs_seen{$fullname}=1 if$path}my@libs=sort keys%libs_seen;return ('','','','',($give_libs ? \@libs : ()))unless@extralibs;@extralibs=map {qq["$_"]}@extralibs;@libs=map {qq["$_"]}@libs;my$lib=join(' ',@extralibs);$lib =~ s,/,\\,g;_debug("Result: $lib\n",$verbose);wantarray ? ($lib,'',$lib,'',($give_libs ? \@libs : ())): $lib}sub _win32_make_lib_search_list {my ($potential_libs,$verbose)=@_;my$libs=$Config{'perllibs'};$potential_libs=join(' ',$potential_libs,$libs)if$libs and $potential_libs !~ /:nodefault/i;_debug("Potential libraries are '$potential_libs':\n",$verbose);$potential_libs =~ s,\\,/,g;my@list=Text::ParseWords::quotewords('\s+',0,$potential_libs);return@list}sub _win32_default_search_paths {my ($VC,$GC)=@_;my$libpth=$Config{'libpth'}|| '';$libpth =~ s,\\,/,g;my@libpath=Text::ParseWords::quotewords('\s+',0,$libpth);push@libpath,"$Config{installarchlib}/CORE";push@libpath,split /;/,$ENV{LIB}if$VC and $ENV{LIB};push@libpath,split /;/,$ENV{LIBRARY_PATH}if$GC and $ENV{LIBRARY_PATH};return@libpath}sub _win32_search_file {my ($thislib,$libext,$paths,$verbose,$GC)=@_;my@file_list=_win32_build_file_list($thislib,$GC,$libext);for my$lib_file (@file_list){for my$path (@{$paths}){my$fullname=$lib_file;$fullname="$path\\$fullname" if$path;return ($fullname,$path)if -f $fullname;_debug("'$thislib' not found as '$fullname'\n",$verbose)}}return}sub _win32_build_file_list {my ($lib,$GC,$extensions)=@_;my@pre_fixed=_win32_build_prefixed_list($lib,$GC);return map _win32_attach_extensions($_,$extensions),@pre_fixed}sub _win32_build_prefixed_list {my ($lib,$GC)=@_;return$lib if$lib !~ s/^-l//;return$lib if$lib =~ /^lib/ and!$GC;(my$no_prefix=$lib)=~ s/^lib//i;$lib="lib$lib" if$no_prefix eq $lib;return ($lib,$no_prefix)if$GC;return ($no_prefix,$lib)}sub _win32_attach_extensions {my ($lib,$extensions)=@_;return map _win32_try_attach_extension($lib,$_),@{$extensions}}sub _win32_try_attach_extension {my ($lib,$extension)=@_;return$lib if$lib =~ /\Q$extension\E$/i;return "$lib$extension"}sub _win32_lib_extensions {my@extensions;push@extensions,$Config{'lib_ext'}if$Config{'lib_ext'};push@extensions,'.dll.a' if grep {m!^\.a$!}@extensions;push@extensions,'.lib' unless grep {m!^\.lib$!}@extensions;return \@extensions}sub _debug {my ($message,$verbose)=@_;return if!$verbose;warn$message;return}sub _vms_ext {my ($self,$potential_libs,$verbose,$give_libs)=@_;$verbose ||= 0;my (@crtls,$crtlstr);@crtls=(($Config{'ldflags'}=~ m-/Debug-i ? $Config{'dbgprefix'}: '').'PerlShr/Share');push(@crtls,grep {not /\(/}split /\s+/,$Config{'perllibs'});push(@crtls,grep {not /\(/}split /\s+/,$Config{'libc'});if ($self->{PERL_SRC}){my ($locspec,$type);for my$lib (@crtls){if (($locspec,$type)=$lib =~ m{^([\w\$-]+)(/\w+)?} and $locspec =~ /perl/i){if (lc$type eq '/share'){$locspec .= $Config{'exe_ext'}}elsif (lc$type eq '/library'){$locspec .= $Config{'lib_ext'}}else {$locspec .= $Config{'obj_ext'}}$locspec=$self->catfile($self->{PERL_SRC},$locspec);$lib="$locspec$type" if -e $locspec}}}$crtlstr=@crtls ? join(' ',@crtls): '';unless ($potential_libs){warn "Result:\n\tEXTRALIBS: \n\tLDLOADLIBS: $crtlstr\n" if$verbose;return ('','',$crtlstr,'',($give_libs ? []: ()))}my (%found,@fndlibs,$ldlib);my$cwd=cwd();my ($so,$lib_ext,$obj_ext)=@Config{'so','lib_ext','obj_ext' };my (@flibs,%libs_seen);my%libmap=('m'=>'','f77'=>'','F77'=>'','V77'=>'','c'=>'','malloc'=>'','crypt'=>'','resolv'=>'','c_s'=>'','socket'=>'','X11'=>'DECW$XLIBSHR','Xt'=>'DECW$XTSHR','Xm'=>'DECW$XMLIBSHR','Xmu'=>'DECW$XMULIBSHR');warn "Potential libraries are '$potential_libs'\n" if$verbose;my (@dirs,@libs);for my$lib (split ' ',$potential_libs){push(@dirs,$1),next if$lib =~ /^-L(.*)/;push(@dirs,$lib),next if$lib =~ /[:>\]]$/;push(@dirs,$lib),next if -d $lib;push(@libs,$1),next if$lib =~ /^-l(.*)/;push(@libs,$lib)}push(@dirs,split(' ',$Config{'libpth'}));for my$dir (@dirs){unless (-d $dir){warn "Skipping nonexistent Directory $dir\n" if$verbose > 1;$dir='';next}warn "Resolving directory $dir\n" if$verbose;if (File::Spec->file_name_is_absolute($dir)){$dir=VMS::Filespec::vmspath($dir)}else {$dir=$self->catdir($cwd,$dir)}}@dirs=grep {length($_)}@dirs;unshift(@dirs,'');LIB: foreach my$lib (@libs){if (exists$libmap{$lib}){next unless length$libmap{$lib};$lib=$libmap{$lib}}my (@variants,$cand);my ($ctype)='';if ($lib !~ /\.[^:>\]]*$/){push(@variants,"${lib}shr","${lib}rtl","${lib}lib");push(@variants,"lib$lib")if$lib !~ /[:>\]]/}push(@variants,$lib);warn "Looking for $lib\n" if$verbose;for my$variant (@variants){my ($fullname,$name);for my$dir (@dirs){my ($type);$name="$dir$variant";warn "\tChecking $name\n" if$verbose > 2;$fullname=VMS::Filespec::rmsexpand($name);if (defined$fullname and -f $fullname){if ($fullname =~ /(?:$so|exe)$/i){$type='SHR'}elsif ($fullname =~ /(?:$lib_ext|olb)$/i){$type='OLB'}elsif ($fullname =~ /(?:$obj_ext|obj)$/i){warn "Warning (mostly harmless): " ."Plain object file $fullname found in library list\n";$type='OBJ'}else {warn "Warning (mostly harmless): " ."Unknown library type for $fullname; assuming shared\n";$type='SHR'}}elsif (-f ($fullname=VMS::Filespec::rmsexpand($name,$so))or -f ($fullname=VMS::Filespec::rmsexpand($name,'.exe'))){$type='SHR';$name=$fullname unless$fullname =~ /exe;?\d*$/i}elsif (not length($ctype)and (-f ($fullname=VMS::Filespec::rmsexpand($name,$lib_ext))or -f ($fullname=VMS::Filespec::rmsexpand($name,'.olb')))){$type='OLB';$name=$fullname unless$fullname =~ /olb;?\d*$/i}elsif (not length($ctype)and (-f ($fullname=VMS::Filespec::rmsexpand($name,$obj_ext))or -f ($fullname=VMS::Filespec::rmsexpand($name,'.obj')))){warn "Warning (mostly harmless): " ."Plain object file $fullname found in library list\n";$type='OBJ';$name=$fullname unless$fullname =~ /obj;?\d*$/i}if (defined$type){$ctype=$type;$cand=$name;last if$ctype eq 'SHR'}}if ($ctype){push @{$found{$ctype}},$cand;warn "\tFound as $cand (really $fullname), type $ctype\n" if$verbose > 1;push@flibs,$name unless$libs_seen{$fullname}++;next LIB}}warn "Warning (mostly harmless): " ."No library found for $lib\n"}push@fndlibs,@{$found{OBJ}}if exists$found{OBJ};push@fndlibs,map {"$_/Library"}@{$found{OLB}}if exists$found{OLB};push@fndlibs,map {"$_/Share"}@{$found{SHR}}if exists$found{SHR};my$lib=join(' ',@fndlibs);$ldlib=$crtlstr ? "$lib $crtlstr" : $lib;$ldlib =~ s/^\s+|\s+$//g;warn "Result:\n\tEXTRALIBS: $lib\n\tLDLOADLIBS: $ldlib\n" if$verbose;wantarray ? ($lib,'',$ldlib,'',($give_libs ? \@flibs : ())): $lib}1;
EXTUTILS_LIBLIST_KID

$fatpacked{"ExtUtils/MM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM';
  package ExtUtils::MM;use strict;use ExtUtils::MakeMaker::Config;our$VERSION='7.38';$VERSION =~ tr/_//d;require ExtUtils::Liblist;require ExtUtils::MakeMaker;our@ISA=qw(ExtUtils::Liblist ExtUtils::MakeMaker);{package MM;our@ISA=qw(ExtUtils::MM);sub DESTROY {}}sub _is_win95 {my$have_win32=eval {require Win32};return$have_win32 && defined&Win32::IsWin95 ? Win32::IsWin95():!defined$ENV{SYSTEMROOT}}my%Is=();$Is{VMS}=$^O eq 'VMS';$Is{OS2}=$^O eq 'os2';$Is{MacOS}=$^O eq 'MacOS';if($^O eq 'MSWin32'){_is_win95()? $Is{Win95}=1 : $Is{Win32}=1}$Is{UWIN}=$^O =~ /^uwin(-nt)?$/;$Is{Cygwin}=$^O eq 'cygwin';$Is{NW5}=$Config{osname}eq 'NetWare';$Is{BeOS}=($^O =~ /beos/i or $^O eq 'haiku');$Is{DOS}=$^O eq 'dos';if($Is{NW5}){$^O='NetWare';delete$Is{Win32}}$Is{VOS}=$^O eq 'vos';$Is{QNX}=$^O eq 'qnx';$Is{AIX}=$^O eq 'aix';$Is{Darwin}=$^O eq 'darwin';$Is{Unix}=!grep {$_}values%Is;map {delete$Is{$_}unless$Is{$_}}keys%Is;_assert(keys%Is==1);my($OS)=keys%Is;my$class="ExtUtils::MM_$OS";eval "require $class" unless$INC{"ExtUtils/MM_$OS.pm"};die $@ if $@;unshift@ISA,$class;sub _assert {my$sanity=shift;die sprintf "Assert failed at %s line %d\n",(caller)[1,2]unless$sanity;return}
EXTUTILS_MM

$fatpacked{"ExtUtils/MM_AIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_AIX';
  package ExtUtils::MM_AIX;use strict;our$VERSION='7.38';$VERSION =~ tr/_//d;use ExtUtils::MakeMaker::Config;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Unix);sub dlsyms {my($self,%attribs)=@_;return '' unless$self->needs_linking;join "\n",$self->xs_dlsyms_iterator(\%attribs)}sub xs_dlsyms_ext {'.exp'}sub xs_dlsyms_arg {my($self,$file)=@_;my$arg=qq{-bE:${file}};$arg='-Wl,'.$arg if$Config{lddlflags}=~ /-Wl,-bE:/;return$arg}sub init_others {my$self=shift;$self->SUPER::init_others;$self->{LDDLFLAGS}||= $Config{lddlflags};$self->{LDDLFLAGS}=~ s#(\s*)\S*\Q$(BASEEXT)\E\S*(\s*)#$1$2#;return}1;
EXTUTILS_MM_AIX

$fatpacked{"ExtUtils/MM_Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_ANY';
  package ExtUtils::MM_Any;use strict;our$VERSION='7.38';$VERSION =~ tr/_//d;use Carp;use File::Spec;use File::Basename;BEGIN {our@ISA=qw(File::Spec)}use ExtUtils::MakeMaker qw($Verbose neatvalue _sprintf562);use ExtUtils::MakeMaker::Config;my$Curdir=__PACKAGE__->curdir;my$METASPEC_URL='https://metacpan.org/pod/CPAN::Meta::Spec';my$METASPEC_V=2;sub os_flavor_is {my$self=shift;my%flavors=map {($_=>1)}$self->os_flavor;return (grep {$flavors{$_}}@_)? 1 : 0}sub can_load_xs {return defined&DynaLoader::boot_DynaLoader ? 1 : 0}sub can_run {my ($self,$command)=@_;if ($^O eq 'VMS'){require VMS::DCLsym;my$syms=VMS::DCLsym->new;return$command if scalar$syms->getsym(uc$command)}my@possibles;if(File::Spec->file_name_is_absolute($command)){return$self->maybe_command($command)}else {for my$dir (File::Spec->path,File::Spec->curdir){next if!$dir ||!-d $dir;my$abs=File::Spec->catfile($self->os_flavor_is('Win32')? Win32::GetShortPathName($dir): $dir,$command);push@possibles,$abs if$abs=$self->maybe_command($abs)}}return@possibles if wantarray;return shift@possibles}sub can_redirect_error {my$self=shift;$self->os_flavor_is('Unix')or ($self->os_flavor_is('Win32')and!$self->os_flavor_is('Win9x'))or $self->os_flavor_is('OS/2')}my%maketype2true;sub _clear_maketype_cache {%maketype2true=()}sub is_make_type {my($self,$type)=@_;return$maketype2true{$type}if defined$maketype2true{$type};(undef,undef,my$make_basename)=$self->splitpath($self->make);return$maketype2true{$type}=1 if$make_basename =~ /\b$type\b/i;return$maketype2true{$type}=0 if$make_basename =~ /\b[gdn]make\b/i;my$redirect=$self->can_redirect_error ? '2>&1' : '';my$make=$self->make || $self->{MAKE};my$minus_v=`"$make" -v $redirect`;return$maketype2true{$type}=1 if$type eq 'gmake' and $minus_v =~ /GNU make/i;return$maketype2true{$type}=1 if$type eq 'bsdmake' and $minus_v =~ /^usage: make \[-BeikNnqrstWwX\]/im;$maketype2true{$type}=0}my$cached_dep_space;sub can_dep_space {my$self=shift;return$cached_dep_space if defined$cached_dep_space;return$cached_dep_space=1 if$self->is_make_type('gmake');return$cached_dep_space=0 if$self->is_make_type('dmake');return$cached_dep_space=0 if$self->is_make_type('bsdmake');return$cached_dep_space=0}sub quote_dep {my ($self,$arg)=@_;die <<EOF if$arg =~ / / and not $self->can_dep_space;$arg =~ s/( )/\\$1/g;return$arg}sub split_command {my($self,$cmd,@args)=@_;my@cmds=();return(@cmds)unless@args;chomp$cmd;my$len_left=int($self->max_exec_len * 0.70);$len_left -= length$self->_expand_macros($cmd);do {my$arg_str='';my@next_args;while(@next_args=splice(@args,0,2)){my$next_arg_str="\t  ".join ' ',@next_args,"\n";if(!length$arg_str){$arg_str .= $next_arg_str}elsif(length($arg_str)+ length($next_arg_str)> $len_left){unshift@args,@next_args;last}else {$arg_str .= $next_arg_str}}chop$arg_str;push@cmds,$self->escape_newlines("$cmd \n$arg_str")}while@args;return@cmds}sub _expand_macros {my($self,$cmd)=@_;$cmd =~ s{\$\((\w+)\)}{
  Tried to use make dependency with space for make that can't:
    '$arg'
  EOF
          defined $self->{$1} ? $self->{$1} : "\$($1)"
      }e;return$cmd}sub make_type {return 'Unix-style'}sub stashmeta {my($self,$text,$file)=@_;$self->echo($text,$file,{allow_variables=>0,append=>0 })}sub echo {my($self,$text,$file,$opts)=@_;if(!ref$opts){my$append=$opts;$opts={append=>$append || 0 }}$opts->{allow_variables}=0 unless defined$opts->{allow_variables};my$ql_opts={allow_variables=>$opts->{allow_variables}};my@cmds=map {'$(NOECHO) $(ECHO) '.$self->quote_literal($_,$ql_opts)}split /\n/,$text;if($file){my$redirect=$opts->{append}? '>>' : '>';$cmds[0].= " $redirect $file";$_ .= " >> $file" foreach@cmds[1..$#cmds]}return@cmds}sub wraplist {my$self=shift;return join " \\\n\t",@_}sub maketext_filter {return $_[1]}sub escape_dollarsigns {my($self,$text)=@_;$text =~ s{\$ (?!\() }{\$\$}gx;return$text}sub escape_all_dollarsigns {my($self,$text)=@_;$text =~ s{\$}{\$\$}gx;return$text}sub make {my$self=shift;my$make=lc$self->{MAKE};$make =~ s/^(\w+make).*/$1/;$make =~ s/^gnu/g/;return$make}sub all_target {my$self=shift;return <<'MAKE_EXT'}sub _xs_list_basenames {my ($self)=@_;map {(my$b=$_)=~ s/\.xs$//;$b}sort keys %{$self->{XS}}}sub blibdirs_target {my$self=shift;my@dirs=map {uc "\$(INST_$_)"}qw(libdir archlib autodir archautodir bin script man1dir man3dir);if ($self->{XSMULTI}){for my$ext ($self->_xs_list_basenames){my ($v,$d,$f)=File::Spec->splitpath($ext);my@d=File::Spec->splitdir($d);shift@d if$d[0]eq 'lib';push@dirs,$self->catdir('$(INST_ARCHLIB)','auto',@d,$f)}}my@exists=map {$_.'$(DFSEP).exists'}@dirs;my$make=sprintf <<'MAKE',join(' ',@exists);$make .= $self->dir_target(@dirs);return$make}sub clean {my($self,%attribs)=@_;my@m;push(@m,'
  all :: pure_all
  	$(NOECHO) $(NOOP)
  MAKE_EXT
  blibdirs : %s
  	$(NOECHO) $(NOOP)
  
  # Backwards compat with 6.18 through 6.25
  blibdirs.ts : blibdirs
  	$(NOECHO) $(NOOP)
  
  MAKE
  # Delete temporary files but do not touch installed files. We don\'t delete
  # the Makefile here so a later make realclean still has a makefile to use.
  
  clean :: clean_subdirs
  ');my@files=sort values %{$self->{XS}};push@files,map {my$file=$_;map {$file.$_}$self->{OBJ_EXT},qw(.def _def.old .bs .bso .exp .base)}$self->_xs_list_basenames;my@dirs=qw(blib);if($attribs{FILES}){push@dirs,ref$attribs{FILES}? @{$attribs{FILES}}: split /\s+/,$attribs{FILES}}push(@files,qw[$(MAKE_APERL_FILE) MYMETA.json MYMETA.yml perlmain.c tmon.out mon.out so_locations blibdirs.ts pm_to_blib pm_to_blib.ts *$(OBJ_EXT) *$(LIB_EXT) perl.exe perl perl$(EXE_EXT) $(BOOTSTRAP) $(BASEEXT).bso $(BASEEXT).def lib$(BASEEXT).def $(BASEEXT).exp $(BASEEXT).x]);push(@files,$self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'));push(@files,$self->catfile('$(INST_ARCHAUTODIR)','extralibs.ld'));if ($^O eq 'vos'){push(@files,qw[perl*.kp])}else {push(@files,qw[core core.*perl.*.? *perl.core])}push(@files,map {"core." ."[0-9]"x$_}(1..5));push@dirs,$self->extra_clean_files;{my(%f)=map {($_=>1)}@files;@files=sort keys%f}{my(%d)=map {($_=>1)}@dirs;@dirs=sort keys%d}push@m,map "\t$_\n",$self->split_command('- $(RM_F)',@files);push@m,map "\t$_\n",$self->split_command('- $(RM_RF)',@dirs);push@m,<<'MAKE';push(@m,"\t$attribs{POSTOP}\n")if$attribs{POSTOP};join("",@m)}sub clean_subdirs_target {my($self)=shift;return <<'NOOP_FRAG' unless @{$self->{DIR}};my$clean="clean_subdirs :\n";for my$dir (@{$self->{DIR}}){my$subclean=$self->oneliner(sprintf <<'CODE',$dir);$clean .= "\t$subclean\n"}return$clean}sub dir_target {my($self,@dirs)=@_;my$make='';for my$dir (@dirs){$make .= sprintf <<'MAKE',($dir)x 4}return$make}*dist_dir=*distdir;sub distdir {my($self)=shift;my$meta_target=$self->{NO_META}? '' : 'distmeta';my$sign_target=!$self->{SIGN}? '' : 'distsignature';return sprintf <<'MAKE_FRAG',$meta_target,$sign_target}sub dist_test {my($self)=shift;my$mpl_args=join " ",map qq["$_"],@ARGV;my$test=$self->cd('$(DISTVNAME)','$(ABSPERLRUN) Makefile.PL '.$mpl_args,'$(MAKE) $(PASTHRU)','$(MAKE) test $(PASTHRU)');return sprintf <<'MAKE_FRAG',$test}sub xs_dlsyms_arg {return ''}sub xs_dlsyms_ext {die "Pure virtual method"}sub xs_dlsyms_extra {''}sub xs_dlsyms_iterator {my ($self,$attribs)=@_;if ($self->{XSMULTI}){my@m;for my$ext ($self->_xs_list_basenames){my@parts=File::Spec->splitdir($ext);shift@parts if$parts[0]eq 'lib';my$name=join '::',@parts;push@m,$self->xs_make_dlsyms($attribs,$ext .$self->xs_dlsyms_ext,"$ext.xs",$name,$parts[-1],{},[],{},[],$self->xs_dlsyms_extra .q!, 'FILE' => ! .neatvalue($ext),)}return join "\n",@m}else {return$self->xs_make_dlsyms($attribs,$self->{BASEEXT}.$self->xs_dlsyms_ext,'Makefile.PL',$self->{NAME},$self->{DLBASE},$attribs->{DL_FUNCS}|| $self->{DL_FUNCS}|| {},$attribs->{FUNCLIST}|| $self->{FUNCLIST}|| [],$attribs->{IMPORTS}|| $self->{IMPORTS}|| {},$attribs->{DL_VARS}|| $self->{DL_VARS}|| [],$self->xs_dlsyms_extra,)}}sub xs_make_dlsyms {my ($self,$attribs,$target,$dep,$name,$dlbase,$funcs,$funclist,$imports,$vars,$extra)=@_;my@m=("\n$target: $dep\n",q!	$(PERLRUN) -MExtUtils::Mksymlists \\
  	  $(NOECHO) $(RM_F) $(MAKEFILE_OLD)
  	- $(MV) $(FIRST_MAKEFILE) $(MAKEFILE_OLD) $(DEV_NULL)
  MAKE
  clean_subdirs :
  	$(NOECHO) $(NOOP)
  NOOP_FRAG
  exit 0 unless chdir '%s';  system '$(MAKE) clean' if -f '$(FIRST_MAKEFILE)';
  CODE
  %s$(DFSEP).exists :: Makefile.PL
  	$(NOECHO) $(MKPATH) %s
  	$(NOECHO) $(CHMOD) $(PERM_DIR) %s
  	$(NOECHO) $(TOUCH) %s$(DFSEP).exists
  
  MAKE
  create_distdir :
  	$(RM_RF) $(DISTVNAME)
  	$(PERLRUN) "-MExtUtils::Manifest=manicopy,maniread" \
  		-e "manicopy(maniread(),'$(DISTVNAME)', '$(DIST_CP)');"
  
  distdir : create_distdir %s %s
  	$(NOECHO) $(NOOP)
  
  MAKE_FRAG
  disttest : distdir
  	%s
  
  MAKE_FRAG
       -e "Mksymlists('NAME'=>\"!,$name,q!\", 'DLBASE' => '!,$dlbase,q!', 'DL_FUNCS' => !,neatvalue($funcs),q!, 'FUNCLIST' => !,neatvalue($funclist),q!, 'IMPORTS' => !,neatvalue($imports),q!, 'DL_VARS' => !,neatvalue($vars));push@m,$extra if defined$extra;push@m,qq!);"\n!;join '',@m}sub dynamic {my($self)=shift;'
  dynamic :: $(FIRST_MAKEFILE) config $(INST_BOOT) $(INST_DYNAMIC)
  	$(NOECHO) $(NOOP)
  '}sub makemakerdflt_target {return <<'MAKE_FRAG'}sub manifypods_target {my($self)=shift;my$man1pods='';my$man3pods='';my$dependencies='';for my$name (sort keys %{$self->{MAN1PODS}},sort keys %{$self->{MAN3PODS}}){$dependencies .= " \\\n\t$name"}my$manify=<<END;my@man_cmds;for my$num (qw(1 3)){my$pods=$self->{"MAN${num}PODS"};my$p2m=sprintf <<'CMD',"\$(MAN${num}SECTION)","$]" > 5.008 ? " -u" : "";push@man_cmds,$self->split_command($p2m,map {($_,$pods->{$_})}sort keys %$pods)}$manify .= "\t\$(NOECHO) \$(NOOP)\n" unless@man_cmds;$manify .= join '',map {"$_\n"}@man_cmds;return$manify}{my$has_cpan_meta;sub _has_cpan_meta {return$has_cpan_meta if defined$has_cpan_meta;return$has_cpan_meta=!!eval {require CPAN::Meta;CPAN::Meta->VERSION(2.112150);1}}}sub metafile_target {my$self=shift;return <<'MAKE_FRAG' if$self->{NO_META}or!_has_cpan_meta();my$metadata=$self->metafile_data($self->{META_ADD}|| {},$self->{META_MERGE}|| {},);my$meta=$self->_fix_metadata_before_conversion($metadata);my@write_metayml=$self->stashmeta($meta->as_string({version=>"1.4"}),'META_new.yml');my@write_metajson=$self->stashmeta($meta->as_string({version=>"2.0"}),'META_new.json');my$metayml=join("\n\t",@write_metayml);my$metajson=join("\n\t",@write_metajson);return sprintf <<'MAKE_FRAG',$metayml,$metajson}sub _fix_metadata_before_conversion {my ($self,$metadata)=@_;return unless _has_cpan_meta;my$bad_version=$metadata->{version}&& !CPAN::Meta::Validator->new->version('version',$metadata->{version});if($bad_version){warn "Can't parse version '$metadata->{version}'\n";$metadata->{version}=''}my$validator2=CPAN::Meta::Validator->new($metadata);my@errors;push@errors,$validator2->errors if!$validator2->is_valid;my$validator14=CPAN::Meta::Validator->new({%$metadata,'meta-spec'=>{version=>1.4 },});push@errors,$validator14->errors if!$validator14->is_valid;for my$error (@errors){my ($key)=($error =~ /Custom resource '(.*)' must be in CamelCase./);next if!$key;(my$new_key=$key)=~ s/[^_a-zA-Z]//g;$new_key=ucfirst$new_key if!$validator14->custom_1($new_key);$metadata->{resources}{$new_key}=$metadata->{resources}{$key}if$validator14->custom_1($new_key);delete$metadata->{resources}{$key}}my$meta=eval {CPAN::Meta->create($metadata,{lazy_validation=>1 })};warn $@ if $@ and $@ !~ /encountered CODE.*, but JSON can only represent references to arrays or hashes/;if(!$meta || !eval {$meta->as_string({version=>$METASPEC_V })}|| !eval {$meta->as_string}){$meta=bless$metadata,'CPAN::Meta'}my$now_license=$meta->as_struct({version=>2 })->{license};if ($self->{LICENSE}and $self->{LICENSE}ne 'unknown' and @{$now_license}==1 and $now_license->[0]eq 'unknown'){warn "Invalid LICENSE value '$self->{LICENSE}' ignored\n"}$meta}sub _sort_pairs {my$sort=shift;my$pairs=shift;return map {$_=>$pairs->{$_}}sort$sort keys %$pairs}sub _hash_merge {my ($self,$h,$k,$v)=@_;if (ref$h->{$k}eq 'ARRAY'){push @{$h->{$k}},ref$v ? @$v : $v}elsif (ref$h->{$k}eq 'HASH'){$self->_hash_merge($h->{$k},$_,$v->{$_})foreach keys %$v}else {$h->{$k}=$v}}sub metafile_data {my$self=shift;my($meta_add,$meta_merge)=@_;$meta_add ||= {};$meta_merge ||= {};my$version=_normalize_version($self->{VERSION});my$release_status=($version =~ /_/)? 'unstable' : 'stable';my%meta=(abstract=>$self->{ABSTRACT}|| 'unknown',author=>defined($self->{AUTHOR})? $self->{AUTHOR}: ['unknown'],dynamic_config=>1,generated_by=>"ExtUtils::MakeMaker version $ExtUtils::MakeMaker::VERSION",license=>[$self->{LICENSE}|| 'unknown' ],'meta-spec'=>{url=>$METASPEC_URL,version=>$METASPEC_V,},name=>$self->{DISTNAME},release_status=>$release_status,version=>$version,no_index=>{directory=>[qw(t inc)]},);$self->_add_requirements_to_meta(\%meta);if (!eval {require JSON::PP;require CPAN::Meta::Converter;CPAN::Meta::Converter->VERSION(2.141170)}){return \%meta}my$v1_add=_metaspec_version($meta_add)!~ /^2/;my ($add_v,$merge_v)=map _metaspec_version($_),$meta_add,$meta_merge;for my$frag ($meta_add,$meta_merge){my$def_v=$frag==$meta_add ? $merge_v : $add_v;$frag=CPAN::Meta::Converter->new($frag,default_version=>$def_v)->upgrade_fragment}while(my($key,$val)=each %$meta_add){if ($v1_add and $key eq 'prereqs'){$meta{$key}{$_}=$val->{$_}for keys %$val}elsif ($key ne 'meta-spec'){$meta{$key}=$val}}while(my($key,$val)=each %$meta_merge){next if$key eq 'meta-spec';$self->_hash_merge(\%meta,$key,$val)}return \%meta}sub _add_requirements_to_meta {my ($self,$meta)=@_;$meta->{prereqs}{configure}{requires}=$self->{ARGS}{CONFIGURE_REQUIRES}? $self->{CONFIGURE_REQUIRES}: {'ExtUtils::MakeMaker'=>0,};$meta->{prereqs}{build}{requires}=$self->{ARGS}{BUILD_REQUIRES}? $self->{BUILD_REQUIRES}: {'ExtUtils::MakeMaker'=>0,};$meta->{prereqs}{test}{requires}=$self->{TEST_REQUIRES}if$self->{ARGS}{TEST_REQUIRES};$meta->{prereqs}{runtime}{requires}=$self->{PREREQ_PM}if$self->{ARGS}{PREREQ_PM};$meta->{prereqs}{runtime}{requires}{perl}=_normalize_version($self->{MIN_PERL_VERSION})if$self->{MIN_PERL_VERSION}}sub _metaspec_version {my ($meta)=@_;return$meta->{'meta-spec'}->{version}if defined$meta->{'meta-spec'}and defined$meta->{'meta-spec'}->{version};return '1.4'}sub _add_requirements_to_meta_v1_4 {my ($self,$meta)=@_;if($self->{ARGS}{CONFIGURE_REQUIRES}){$meta->{configure_requires}=$self->{CONFIGURE_REQUIRES}}else {$meta->{configure_requires}={'ExtUtils::MakeMaker'=>0,}}if($self->{ARGS}{BUILD_REQUIRES}){$meta->{build_requires}=$self->{BUILD_REQUIRES}}else {$meta->{build_requires}={'ExtUtils::MakeMaker'=>0,}}if($self->{ARGS}{TEST_REQUIRES}){$meta->{build_requires}={%{$meta->{build_requires}},%{$self->{TEST_REQUIRES}},}}$meta->{requires}=$self->{PREREQ_PM}if defined$self->{PREREQ_PM};$meta->{requires}{perl}=_normalize_version($self->{MIN_PERL_VERSION})if$self->{MIN_PERL_VERSION}}sub _normalize_version {my ($version)=@_;$version=0 unless defined$version;if (ref$version eq 'version'){$version=$version->stringify}elsif ($version =~ /^[^v][^.]*\.[^.]+\./){$version="v$version"}else {}return$version}sub _dump_hash {croak "first argument should be a hash ref" unless ref $_[0]eq 'HASH';my$options=shift;my%hash=@_;my@pairs;my$k_sort =exists$options->{key_sort}? $options->{key_sort}: sub {lc$a cmp lc$b};if ($k_sort){croak "'key_sort' should be a coderef" unless ref$k_sort eq 'CODE';@pairs=_sort_pairs($k_sort,\%hash)}else {@pairs=@_}my$yaml=$options->{use_header}? "--- #YAML:1.0\n" : '';my$indent=$options->{indent}|| '';my$k_length=min(($options->{max_key_length}|| 20),max(map {length($_)+ 1}grep {!ref$hash{$_}}keys%hash));my$customs=$options->{customs}|| {};my$k_format="%-${k_length}s";while(@pairs){my($key,$val)=splice@pairs,0,2;$val='~' unless defined$val;if(ref$val eq 'HASH'){if (keys %$val){my%k_options=(delta=>$options->{delta},use_header=>0,indent=>$indent .$options->{delta},);if (exists$customs->{$key}){my%k_custom=%{$customs->{$key}};for my$k (qw(key_sort max_key_length customs)){$k_options{$k}=$k_custom{$k}if exists$k_custom{$k}}}$yaml .= $indent ."$key:\n" ._dump_hash(\%k_options,%$val)}else {$yaml .= $indent ."$key:  {}\n"}}elsif (ref$val eq 'ARRAY'){if(@$val){$yaml .= $indent ."$key:\n";for (@$val){croak "only nested arrays of non-refs are supported" if ref $_;$yaml .= $indent .$options->{delta}."- $_\n"}}else {$yaml .= $indent ."$key:  []\n"}}elsif(ref$val and!blessed($val)){croak "only nested hashes, arrays and objects are supported"}else {$yaml .= $indent .sprintf "$k_format  %s\n","$key:",$val}};return$yaml}sub blessed {return eval {$_[0]->isa("UNIVERSAL")}}sub max {return (sort {$b <=> $a}@_)[0]}sub min {return (sort {$a <=> $b}@_)[0]}sub metafile_file {my$self=shift;my%dump_options=(use_header=>1,delta=>' ' x 4,key_sort=>undef,);return _dump_hash(\%dump_options,@_)}sub distmeta_target {my$self=shift;my@add_meta=($self->oneliner(<<'CODE',['-MExtUtils::Manifest=maniadd']),$self->oneliner(<<'CODE',['-MExtUtils::Manifest=maniadd']));my@add_meta_to_distdir=map {$self->cd('$(DISTVNAME)',$_)}@add_meta;return sprintf <<'MAKE',@add_meta_to_distdir}sub mymeta {my$self=shift;my$file=shift || '';my$mymeta=$self->_mymeta_from_meta($file);my$v2=1;unless ($mymeta){$mymeta=$self->metafile_data($self->{META_ADD}|| {},$self->{META_MERGE}|| {},);$v2=0}$self->_add_requirements_to_meta($mymeta);$mymeta->{dynamic_config}=0;return$mymeta}sub _mymeta_from_meta {my$self=shift;my$metafile=shift || '';return unless _has_cpan_meta();my$meta;for my$file ($metafile,"META.json","META.yml"){next unless -e $file;eval {$meta=CPAN::Meta->load_file($file)->as_struct({version=>2 })};last if$meta}return unless$meta;if ($meta->{generated_by}&& $meta->{generated_by}=~ /ExtUtils::MakeMaker version ([\d\._]+)/){my$eummv=do {local $^W=0;$1+0};if ($eummv < 6.2501){return}}return$meta}sub write_mymeta {my$self=shift;my$mymeta=shift;return unless _has_cpan_meta();my$meta_obj=$self->_fix_metadata_before_conversion($mymeta);$meta_obj->save('MYMETA.json',{version=>"2.0" });$meta_obj->save('MYMETA.yml',{version=>"1.4" });return 1}sub realclean {my($self,%attribs)=@_;my@dirs=qw($(DISTVNAME));my@files=qw($(FIRST_MAKEFILE) $(MAKEFILE_OLD));if($self->{PERL_CORE}){push@dirs,qw($(INST_AUTODIR) $(INST_ARCHAUTODIR));push@files,values %{$self->{PM}}}if($self->has_link_code){push@files,qw($(OBJECT))}if($attribs{FILES}){if(ref$attribs{FILES}){push@dirs,@{$attribs{FILES}}}else {push@dirs,split /\s+/,$attribs{FILES}}}{my(%f)=map {($_=>1)}@files;@files=sort keys%f}{my(%d)=map {($_=>1)}@dirs;@dirs=sort keys%d}my$rm_cmd=join "\n\t",map {"$_"}$self->split_command('- $(RM_F)',@files);my$rmf_cmd=join "\n\t",map {"$_"}$self->split_command('- $(RM_RF)',@dirs);my$m=sprintf <<'MAKE',$rm_cmd,$rmf_cmd;$m .= "\t$attribs{POSTOP}\n" if$attribs{POSTOP};return$m}sub realclean_subdirs_target {my$self=shift;my@m=<<'EOF';return join '',@m,"\t\$(NOECHO) \$(NOOP)\n" unless @{$self->{DIR}};for my$dir (@{$self->{DIR}}){for my$makefile ('$(MAKEFILE_OLD)','$(FIRST_MAKEFILE)'){my$subrclean .= $self->oneliner(_sprintf562 <<'CODE',$dir,$makefile);push@m,"\t- $subrclean\n"}}return join '',@m}sub signature_target {my$self=shift;return <<'MAKE_FRAG'}sub distsignature_target {my$self=shift;my$add_sign=$self->oneliner(<<'CODE',['-MExtUtils::Manifest=maniadd']);my$sign_dist=$self->cd('$(DISTVNAME)'=>'cpansign -s');my$touch_sig=$self->cd('$(DISTVNAME)'=>'$(TOUCH) SIGNATURE');my$add_sign_to_dist=$self->cd('$(DISTVNAME)'=>$add_sign);return sprintf <<'MAKE',$add_sign_to_dist,$touch_sig,$sign_dist}sub special_targets {my$make_frag=<<'MAKE_FRAG';$make_frag .= <<'MAKE_FRAG' if$ENV{CLEARCASE_ROOT};return$make_frag}sub init_ABSTRACT {my$self=shift;if($self->{ABSTRACT_FROM}and $self->{ABSTRACT}){warn "Both ABSTRACT_FROM and ABSTRACT are set.  "."Ignoring ABSTRACT_FROM.\n";return}if ($self->{ABSTRACT_FROM}){$self->{ABSTRACT}=$self->parse_abstract($self->{ABSTRACT_FROM})or carp "WARNING: Setting ABSTRACT via file "."'$self->{ABSTRACT_FROM}' failed\n"}if ($self->{ABSTRACT}&& $self->{ABSTRACT}=~ m![[:cntrl:]]+!){warn "WARNING: ABSTRACT contains control character(s),"." they will be removed\n";$self->{ABSTRACT}=~ s![[:cntrl:]]+!!g;return}}sub init_INST {my($self)=shift;$self->{INST_ARCHLIB}||= $self->catdir($Curdir,"blib","arch");$self->{INST_BIN}||= $self->catdir($Curdir,'blib','bin');unless ($self->{INST_LIB}){if ($self->{PERL_CORE}){$self->{INST_LIB}=$self->{INST_ARCHLIB}=$self->{PERL_LIB}}else {$self->{INST_LIB}=$self->catdir($Curdir,"blib","lib")}}my@parentdir=split(/::/,$self->{PARENT_NAME});$self->{INST_LIBDIR}=$self->catdir('$(INST_LIB)',@parentdir);$self->{INST_ARCHLIBDIR}=$self->catdir('$(INST_ARCHLIB)',@parentdir);$self->{INST_AUTODIR}=$self->catdir('$(INST_LIB)','auto','$(FULLEXT)');$self->{INST_ARCHAUTODIR}=$self->catdir('$(INST_ARCHLIB)','auto','$(FULLEXT)');$self->{INST_SCRIPT}||= $self->catdir($Curdir,'blib','script');$self->{INST_MAN1DIR}||= $self->catdir($Curdir,'blib','man1');$self->{INST_MAN3DIR}||= $self->catdir($Curdir,'blib','man3');return 1}sub init_INSTALL {my($self)=shift;if($self->{ARGS}{INSTALL_BASE}and $self->{ARGS}{PREFIX}){die "Only one of PREFIX or INSTALL_BASE can be given.  Not both.\n"}if($self->{ARGS}{INSTALL_BASE}){$self->init_INSTALL_from_INSTALL_BASE}else {$self->init_INSTALL_from_PREFIX}}sub init_INSTALL_from_PREFIX {my$self=shift;$self->init_lib2arch;for my$num (1,3){my$k='installsiteman'.$num.'dir';$self->{uc$k}||= uc "\$(installman${num}dir)" unless$Config{$k}}for my$num (1,3){my$k='installvendorman'.$num.'dir';unless($Config{$k}){$self->{uc$k}||= $Config{usevendorprefix}? uc "\$(installman${num}dir)" : ''}}$self->{INSTALLSITEBIN}||= '$(INSTALLBIN)' unless$Config{installsitebin};$self->{INSTALLSITESCRIPT}||= '$(INSTALLSCRIPT)' unless$Config{installsitescript};unless($Config{installvendorbin}){$self->{INSTALLVENDORBIN}||= $Config{usevendorprefix}? $Config{installbin}: ''}unless($Config{installvendorscript}){$self->{INSTALLVENDORSCRIPT}||= $Config{usevendorprefix}? $Config{installscript}: ''}my$iprefix=$Config{installprefixexp}|| $Config{installprefix}|| $Config{prefixexp}|| $Config{prefix}|| '';my$vprefix=$Config{usevendorprefix}? $Config{vendorprefixexp}: '';my$sprefix=$Config{siteprefixexp}|| '';$sprefix=$iprefix unless$sprefix;$self->{PREFIX}||= '';if($self->{PREFIX}){@{$self}{qw(PERLPREFIX SITEPREFIX VENDORPREFIX)}=('$(PREFIX)')x 3}else {$self->{PERLPREFIX}||= $iprefix;$self->{SITEPREFIX}||= $sprefix;$self->{VENDORPREFIX}||= $vprefix;$self->{PREFIX}='$('.uc$self->{INSTALLDIRS}.'PREFIX)'}my$arch=$Config{archname};my$version=$Config{version};my$libstyle=$Config{installstyle}|| 'lib/perl5';my$manstyle='';if($self->{LIBSTYLE}){$libstyle=$self->{LIBSTYLE};$manstyle=$self->{LIBSTYLE}eq 'lib/perl5' ? 'lib/perl5' : ''}for my$num (1,3){$self->{'INSTALLMAN'.$num.'DIR'}||= 'none' unless$Config{'installman'.$num.'dir'}}my%bin_layouts=(bin=>{s=>$iprefix,t=>'perl',d=>'bin' },vendorbin=>{s=>$vprefix,t=>'vendor',d=>'bin' },sitebin=>{s=>$sprefix,t=>'site',d=>'bin' },script=>{s=>$iprefix,t=>'perl',d=>'bin' },vendorscript=>{s=>$vprefix,t=>'vendor',d=>'bin' },sitescript=>{s=>$sprefix,t=>'site',d=>'bin' },);my%man_layouts=(man1dir=>{s=>$iprefix,t=>'perl',d=>'man/man1',style=>$manstyle,},siteman1dir=>{s=>$sprefix,t=>'site',d=>'man/man1',style=>$manstyle,},vendorman1dir=>{s=>$vprefix,t=>'vendor',d=>'man/man1',style=>$manstyle,},man3dir=>{s=>$iprefix,t=>'perl',d=>'man/man3',style=>$manstyle,},siteman3dir=>{s=>$sprefix,t=>'site',d=>'man/man3',style=>$manstyle,},vendorman3dir=>{s=>$vprefix,t=>'vendor',d=>'man/man3',style=>$manstyle,},);my%lib_layouts=(privlib=>{s=>$iprefix,t=>'perl',d=>'',style=>$libstyle,},vendorlib=>{s=>$vprefix,t=>'vendor',d=>'',style=>$libstyle,},sitelib=>{s=>$sprefix,t=>'site',d=>'site_perl',style=>$libstyle,},archlib=>{s=>$iprefix,t=>'perl',d=>"$version/$arch",style=>$libstyle },vendorarch=>{s=>$vprefix,t=>'vendor',d=>"$version/$arch",style=>$libstyle },sitearch=>{s=>$sprefix,t=>'site',d=>"site_perl/$version/$arch",style=>$libstyle },);if($self->{LIB}){for my$var (keys%lib_layouts){my$Installvar=uc "install$var";if($var =~ /arch/){$self->{$Installvar}||= $self->catdir($self->{LIB},$Config{archname})}else {$self->{$Installvar}||= $self->{LIB}}}}my%type2prefix=(perl=>'PERLPREFIX',site=>'SITEPREFIX',vendor=>'VENDORPREFIX');my%layouts=(%bin_layouts,%man_layouts,%lib_layouts);while(my($var,$layout)=each(%layouts)){my($s,$t,$d,$style)=@{$layout}{qw(s t d style)};my$r='$('.$type2prefix{$t}.')';warn "Prefixing $var\n" if$Verbose >= 2;my$installvar="install$var";my$Installvar=uc$installvar;next if$self->{$Installvar};$d="$style/$d" if$style;$self->prefixify($installvar,$s,$r,$d);warn "  $Installvar == $self->{$Installvar}\n" if$Verbose >= 2}$self->{VENDORARCHEXP}||= $self->{INSTALLVENDORARCH};$self->{VENDORLIBEXP}||= $self->{INSTALLVENDORLIB};return 1}my%map=(lib=>[qw(lib perl5)],arch=>[('lib','perl5',$Config{archname})],bin=>[qw(bin)],man1dir=>[qw(man man1)],man3dir=>[qw(man man3)]);$map{script}=$map{bin};sub init_INSTALL_from_INSTALL_BASE {my$self=shift;@{$self}{qw(PREFIX VENDORPREFIX SITEPREFIX PERLPREFIX)}='$(INSTALL_BASE)';my%install;for my$thing (keys%map){for my$dir (('','SITE','VENDOR')){my$uc_thing=uc$thing;my$key="INSTALL".$dir.$uc_thing;$install{$key}||= ($thing =~ /^man.dir$/ and not $Config{lc$key})? 'none' : $self->catdir('$(INSTALL_BASE)',@{$map{$thing}})}}$install{INSTALLARCHLIB}||= delete$install{INSTALLARCH};$install{INSTALLPRIVLIB}||= delete$install{INSTALLLIB};for my$key (keys%install){$self->{$key}||= $install{$key}}return 1}sub init_VERSION {my($self)=shift;$self->{MAKEMAKER}=$ExtUtils::MakeMaker::Filename;$self->{MM_VERSION}=$ExtUtils::MakeMaker::VERSION;$self->{MM_REVISION}=$ExtUtils::MakeMaker::Revision;$self->{VERSION_FROM}||= '';if ($self->{VERSION_FROM}){$self->{VERSION}=$self->parse_version($self->{VERSION_FROM});if($self->{VERSION}eq 'undef'){carp("WARNING: Setting VERSION via file "."'$self->{VERSION_FROM}' failed\n")}}if (defined$self->{VERSION}){if ($self->{VERSION}!~ /^\s*v?[\d_\.]+\s*$/){require version;my$normal=eval {version->new($self->{VERSION})};$self->{VERSION}=$normal if defined$normal}$self->{VERSION}=~ s/^\s+//;$self->{VERSION}=~ s/\s+$//}else {$self->{VERSION}=''}$self->{VERSION_MACRO}='VERSION';($self->{VERSION_SYM}=$self->{VERSION})=~ s/\W/_/g;$self->{DEFINE_VERSION}='-D$(VERSION_MACRO)=\"$(VERSION)\"';$self->{XS_VERSION}||= $self->{VERSION};$self->{XS_VERSION_MACRO}='XS_VERSION';$self->{XS_DEFINE_VERSION}='-D$(XS_VERSION_MACRO)=\"$(XS_VERSION)\"'}sub init_tools {my$self=shift;$self->{ECHO}||= $self->oneliner('binmode STDOUT, qq{:raw}; print qq{@ARGV}',['-l']);$self->{ECHO_N}||= $self->oneliner('print qq{@ARGV}');$self->{TOUCH}||= $self->oneliner('touch',["-MExtUtils::Command"]);$self->{CHMOD}||= $self->oneliner('chmod',["-MExtUtils::Command"]);$self->{RM_F}||= $self->oneliner('rm_f',["-MExtUtils::Command"]);$self->{RM_RF}||= $self->oneliner('rm_rf',["-MExtUtils::Command"]);$self->{TEST_F}||= $self->oneliner('test_f',["-MExtUtils::Command"]);$self->{TEST_S}||= $self->oneliner('test_s',["-MExtUtils::Command::MM"]);$self->{CP_NONEMPTY}||= $self->oneliner('cp_nonempty',["-MExtUtils::Command::MM"]);$self->{FALSE}||= $self->oneliner('exit 1');$self->{TRUE}||= $self->oneliner('exit 0');$self->{MKPATH}||= $self->oneliner('mkpath',["-MExtUtils::Command"]);$self->{CP}||= $self->oneliner('cp',["-MExtUtils::Command"]);$self->{MV}||= $self->oneliner('mv',["-MExtUtils::Command"]);$self->{MOD_INSTALL}||= $self->oneliner(<<'CODE',['-MExtUtils::Install']);$self->{DOC_INSTALL}||= $self->oneliner('perllocal_install',["-MExtUtils::Command::MM"]);$self->{UNINSTALL}||= $self->oneliner('uninstall',["-MExtUtils::Command::MM"]);$self->{WARN_IF_OLD_PACKLIST}||= $self->oneliner('warn_if_old_packlist',["-MExtUtils::Command::MM"]);$self->{FIXIN}||= $self->oneliner('MY->fixin(shift)',["-MExtUtils::MY"]);$self->{EQUALIZE_TIMESTAMP}||= $self->oneliner('eqtime',["-MExtUtils::Command"]);$self->{UNINST}||= 0;$self->{VERBINST}||= 0;$self->{SHELL}||= $Config{sh};$self->{UMASK_NULL}||= "umask 0";$self->{DEV_NULL}||= "> /dev/null 2>&1";$self->{NOOP}||= '$(TRUE)';$self->{NOECHO}='@' unless defined$self->{NOECHO};$self->{FIRST_MAKEFILE}||= $self->{MAKEFILE}|| 'Makefile';$self->{MAKEFILE}||= $self->{FIRST_MAKEFILE};$self->{MAKEFILE_OLD}||= $self->{MAKEFILE}.'.old';$self->{MAKE_APERL_FILE}||= $self->{MAKEFILE}.'.aperl';$self->{USEMAKEFILE}||= '-f';$self->{MACROSTART}||= '';$self->{MACROEND}||= '';return}sub init_others {my$self=shift;$self->{LD_RUN_PATH}="";$self->{LIBS}=$self->_fix_libs($self->{LIBS});for my$libs (@{$self->{LIBS}}){$libs =~ s/^\s*(.*\S)\s*$/$1/;my(@libs)=$self->extliblist($libs);if ($libs[0]or $libs[1]or $libs[2]){($self->{EXTRALIBS},$self->{BSLOADLIBS},$self->{LDLOADLIBS},$self->{LD_RUN_PATH})=@libs;last}}if ($self->{OBJECT}){$self->{OBJECT}=join(" ",@{$self->{OBJECT}})if ref$self->{OBJECT};$self->{OBJECT}=~ s!\.o(bj)?\b!\$(OBJ_EXT)!g}elsif (($self->{MAGICXS}|| $self->{XSMULTI})&& @{$self->{O_FILES}||[]}){$self->{OBJECT}=join(" ",@{$self->{O_FILES}});$self->{OBJECT}=~ s!\.o(bj)?\b!\$(OBJ_EXT)!g}else {$self->{OBJECT}="";$self->{OBJECT}='$(BASEEXT)$(OBJ_EXT)' if @{$self->{C}||[]}}$self->{OBJECT}=~ s/\n+/ \\\n\t/g;$self->{BOOTDEP}=(-f "$self->{BASEEXT}_BS")? "$self->{BASEEXT}_BS" : "";$self->{PERLMAINCC}||= '$(CC)';$self->{LDFROM}='$(OBJECT)' unless$self->{LDFROM};if (!$self->{LINKTYPE}){$self->{LINKTYPE}=$self->{SKIPHASH}{'dynamic'}? 'static' : ($Config{usedl}? 'dynamic' : 'static')}return}sub _fix_libs {my($self,$libs)=@_;return!defined$libs ? ['']: !ref$libs ? [$libs]: !defined$libs->[0]? ['']: $libs }sub tools_other {my($self)=shift;my@m;for my$tool (qw{SHELL CHMOD CP MV NOOP NOECHO RM_F RM_RF TEST_F TOUCH UMASK_NULL DEV_NULL MKPATH EQUALIZE_TIMESTAMP FALSE TRUE ECHO ECHO_N UNINST VERBINST MOD_INSTALL DOC_INSTALL UNINSTALL WARN_IF_OLD_PACKLIST MACROSTART MACROEND USEMAKEFILE PM_FILTER FIXIN CP_NONEMPTY}){next unless defined$self->{$tool};push@m,"$tool = $self->{$tool}\n"}return join "",@m}sub init_platform {return ''}sub init_MAKE {my$self=shift;$self->{MAKE}||= $ENV{MAKE}|| $Config{make}}sub manifypods {my$self=shift;my$POD2MAN_macro=$self->POD2MAN_macro();my$manifypods_target=$self->manifypods_target();return <<END_OF_TARGET}sub POD2MAN_macro {my$self=shift;return <<'END_OF_DEF'}sub test_via_harness {my($self,$perl,$tests)=@_;return qq{\t$perl "-MExtUtils::Command::MM" "-MTest::Harness" }.qq{"-e" "undef *Test::Harness::Switches; test_harness(\$(TEST_VERBOSE), '\$(INST_LIB)', '\$(INST_ARCHLIB)')" $tests\n}}sub test_via_script {my($self,$perl,$script)=@_;return qq{\t$perl "-I\$(INST_LIB)" "-I\$(INST_ARCHLIB)" $script\n}}sub tool_autosplit {my($self,%attribs)=@_;my$maxlen=$attribs{MAXLEN}? '$$AutoSplit::Maxlen=$attribs{MAXLEN};' : '';my$asplit=$self->oneliner(sprintf <<'PERL_CODE',$maxlen);return sprintf <<'MAKE_FRAG',$asplit}sub arch_check {my$self=shift;my($pconfig,$cconfig)=@_;return 1 if$self->{PERL_SRC};my($pvol,$pthinks)=$self->splitpath($pconfig);my($cvol,$cthinks)=$self->splitpath($cconfig);$pthinks=$self->canonpath($pthinks);$cthinks=$self->canonpath($cthinks);my$ret=1;if ($pthinks ne $cthinks){print "Have $pthinks\n";print "Want $cthinks\n";$ret=0;my$arch=(grep length,$self->splitdir($pthinks))[-1];print <<END unless$self->{UNINSTALLED_PERL}}return$ret}sub catfile {my$self=shift;return$self->canonpath($self->SUPER::catfile(@_))}sub find_tests {my($self)=shift;return -d 't' ? 't/*.t' : ''}sub find_tests_recursive {my$self=shift;return$self->find_tests_recursive_in('t')}sub find_tests_recursive_in {my($self,$dir)=@_;return '' unless -d $dir;require File::Find;my$base_depth=grep {$_ ne ''}File::Spec->splitdir((File::Spec->splitpath($dir))[1]);my%depths;my$wanted=sub {return unless m!\.t$!;my ($volume,$directories,$file)=File::Spec->splitpath($File::Find::name);my$depth=grep {$_ ne ''}File::Spec->splitdir($directories);$depth -= $base_depth;$depths{$depth }=1};File::Find::find($wanted,$dir);return join ' ',map {$dir .'/*' x $_ .'.t'}sort {$a <=> $b}keys%depths}sub extra_clean_files {return}sub installvars {return qw(PRIVLIB SITELIB VENDORLIB ARCHLIB SITEARCH VENDORARCH BIN SITEBIN VENDORBIN SCRIPT SITESCRIPT VENDORSCRIPT MAN1DIR SITEMAN1DIR VENDORMAN1DIR MAN3DIR SITEMAN3DIR VENDORMAN3DIR)}sub libscan {my($self,$path)=@_;if ($path =~ m<^README\.pod$>i){warn "WARNING: Older versions of ExtUtils::MakeMaker may errantly install $path as part of this distribution. It is recommended to avoid using this path in CPAN modules.\n" unless$ENV{PERL_CORE};return ''}my($dirs,$file)=($self->splitpath($path))[1,2];return '' if grep /^(?:RCS|CVS|SCCS|\.svn|_darcs)$/,$self->splitdir($dirs),$file;return$path}sub platform_constants {return ''}sub post_constants {""}sub post_initialize {""}sub postamble {""}sub _PREREQ_PRINT {my$self=shift;require Data::Dumper;my@what=('PREREQ_PM');push@what,'MIN_PERL_VERSION' if$self->{MIN_PERL_VERSION};push@what,'BUILD_REQUIRES' if$self->{BUILD_REQUIRES};print Data::Dumper->Dump([@{$self}{@what}],\@what);exit 0}sub _PRINT_PREREQ {my$self=shift;my$prereqs=$self->{PREREQ_PM};my@prereq=map {[$_,$prereqs->{$_}]}keys %$prereqs;if ($self->{MIN_PERL_VERSION}){push@prereq,['perl'=>$self->{MIN_PERL_VERSION}]}print join(" ",map {"perl($_->[0])>=$_->[1] "}sort {$a->[0]cmp $b->[0]}@prereq),"\n";exit 0}sub _perl_header_files {my$self=shift;my$header_dir=$self->{PERL_SRC}|| $ENV{PERL_SRC}|| $self->catdir($Config{archlibexp},'CORE');opendir my$dh,$header_dir or die "Failed to opendir '$header_dir' to find header files: $!";my@perl_headers=sort grep {/\.h\z/}readdir($dh);closedir$dh;return@perl_headers}sub _perl_header_files_fragment {my ($self,$separator)=@_;$separator ||= "";return join("\\\n","PERL_HDRS = ",map {sprintf("        \$(PERL_INCDEP)%s%s            ",$separator,$_)}$self->_perl_header_files())."\n\n" ."\$(OBJECT) : \$(PERL_HDRS)\n"}1;
  makemakerdflt : all
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  manifypods : pure_all config $dependencies
  END
  	$(NOECHO) $(POD2MAN) --section=%s --perm_rw=$(PERM_RW)%s
  CMD
  metafile :
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  metafile : create_distdir
  	$(NOECHO) $(ECHO) Generating META.yml
  	%s
  	-$(NOECHO) $(MV) META_new.yml $(DISTVNAME)/META.yml
  	$(NOECHO) $(ECHO) Generating META.json
  	%s
  	-$(NOECHO) $(MV) META_new.json $(DISTVNAME)/META.json
  MAKE_FRAG
  exit unless -e q{META.yml};
  eval { maniadd({q{META.yml} => q{Module YAML meta-data (added by MakeMaker)}}) }
      or die "Could not add META.yml to MANIFEST: ${'@'}"
  CODE
  exit unless -f q{META.json};
  eval { maniadd({q{META.json} => q{Module JSON meta-data (added by MakeMaker)}}) }
      or die "Could not add META.json to MANIFEST: ${'@'}"
  CODE
  distmeta : create_distdir metafile
  	$(NOECHO) %s
  	$(NOECHO) %s
  
  MAKE
  # Delete temporary files (via clean) and also delete dist files
  realclean purge :: realclean_subdirs
  	%s
  	%s
  MAKE
  # so clean is forced to complete before realclean_subdirs runs
  realclean_subdirs : clean
  EOF
  chdir '%1$s';  system '$(MAKE) $(USEMAKEFILE) %2$s realclean' if -f '%2$s';
  CODE
  signature :
  	cpansign -s
  MAKE_FRAG
  eval { maniadd({q{SIGNATURE} => q{Public-key signature (added by MakeMaker)}}) }
      or die "Could not add SIGNATURE to MANIFEST: ${'@'}"
  CODE
  distsignature : distmeta
  	$(NOECHO) %s
  	$(NOECHO) %s
  	%s
  
  MAKE
  .SUFFIXES : .xs .c .C .cpp .i .s .cxx .cc $(OBJ_EXT)
  
  .PHONY: all config static dynamic test linkext manifest blibdirs clean realclean disttest distdir pure_all subdirs clean_subdirs makemakerdflt manifypods realclean_subdirs subdirs_dynamic subdirs_pure_nolink subdirs_static subdirs-test_dynamic subdirs-test_static test_dynamic test_static
  
  MAKE_FRAG
  .NO_CONFIG_REC: Makefile
  
  MAKE_FRAG
  install([ from_to => {@ARGV}, verbose => '$(VERBINST)', uninstall_shadows => '$(UNINST)', dir_mode => '$(PERM_DIR)' ]);
  CODE
  
  $POD2MAN_macro
  
  $manifypods_target
  
  END_OF_TARGET
  POD2MAN_EXE = $(PERLRUN) "-MExtUtils::Command::MM" -e pod2man "--"
  POD2MAN = $(POD2MAN_EXE)
  END_OF_DEF
  use AutoSplit; %s autosplit($$ARGV[0], $$ARGV[1], 0, 1, 1)
  PERL_CODE
  # Usage: $(AUTOSPLITFILE) FileToSplit AutoDirToSplitInto
  AUTOSPLITFILE = %s
  
  MAKE_FRAG
  Your perl and your Config.pm seem to have different ideas about the
  architecture they are running on.
  Perl thinks: [$arch]
  Config says: [$Config{archname}]
  This may or may not cause problems. Please check your installation of perl
  if you have problems building this extension.
  END
EXTUTILS_MM_ANY

$fatpacked{"ExtUtils/MM_BeOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_BEOS';
  package ExtUtils::MM_BeOS;use strict;use ExtUtils::MakeMaker::Config;use File::Spec;require ExtUtils::MM_Any;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Any ExtUtils::MM_Unix);our$VERSION='7.38';$VERSION =~ tr/_//d;sub os_flavor {return('BeOS')}sub init_linker {my($self)=shift;$self->{PERL_ARCHIVE}||= File::Spec->catdir('$(PERL_INC)',$Config{libperl});$self->{PERL_ARCHIVEDEP}||= '';$self->{PERL_ARCHIVE_AFTER}||= '';$self->{EXPORT_LIST}||= ''}1;
EXTUTILS_MM_BEOS

$fatpacked{"ExtUtils/MM_Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_CYGWIN';
  package ExtUtils::MM_Cygwin;use strict;use ExtUtils::MakeMaker::Config;use File::Spec;require ExtUtils::MM_Unix;require ExtUtils::MM_Win32;our@ISA=qw(ExtUtils::MM_Unix);our$VERSION='7.38';$VERSION =~ tr/_//d;sub os_flavor {return('Unix','Cygwin')}sub cflags {my($self,$libperl)=@_;return$self->{CFLAGS}if$self->{CFLAGS};return '' unless$self->needs_linking();my$base=$self->SUPER::cflags($libperl);for (split /\n/,$base){/^(\S*)\s*=\s*(\S*)$/ and $self->{$1}=$2};$self->{CCFLAGS}.= " -DUSEIMPORTLIB" if ($Config{useshrplib}eq 'true');return$self->{CFLAGS}=qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  }}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s{/+}{.}g;return$man}sub init_linker {my$self=shift;if ($Config{useshrplib}eq 'true'){my$libperl='$(PERL_INC)' .'/'."$Config{libperl}";if("$]" >= 5.006002){$libperl =~ s/(dll\.)?a$/dll.a/}$self->{PERL_ARCHIVE}=$libperl}else {$self->{PERL_ARCHIVE}='$(PERL_INC)' .'/'.("$Config{libperl}" or "libperl.a")}$self->{PERL_ARCHIVEDEP}||= '';$self->{PERL_ARCHIVE_AFTER}||= '';$self->{EXPORT_LIST}||= ''}sub maybe_command {my ($self,$file)=@_;my$cygpath=Cygwin::posix_to_win_path('/',1);my$filepath=Cygwin::posix_to_win_path($file,1);return (substr($filepath,0,length($cygpath))eq $cygpath)? $self->SUPER::maybe_command($file): ExtUtils::MM_Win32->maybe_command($file)}sub dynamic_lib {my($self,%attribs)=@_;my$s=ExtUtils::MM_Unix::dynamic_lib($self,%attribs);return '' unless$s;return$s unless %{$self->{XS}};$s .= "\t/bin/find \$\(INST_ARCHLIB\)/auto -xdev -name \\*.$self->{DLEXT} | /bin/rebase -sOT -" if (($Config{myarchname}eq 'i686-cygwin')and not (exists$ENV{CYGPORT_PACKAGE_VERSION}));$s}sub install {my($self,%attribs)=@_;my$s=ExtUtils::MM_Unix::install($self,%attribs);return '' unless$s;return$s unless %{$self->{XS}};my$INSTALLDIRS=$self->{INSTALLDIRS};my$INSTALLLIB=$self->{"INSTALL".($INSTALLDIRS eq 'perl' ? 'ARCHLIB' : uc($INSTALLDIRS)."ARCH")};my$dop="\$\(DESTDIR\)$INSTALLLIB/auto/";my$dll="$dop/$self->{FULLEXT}/$self->{BASEEXT}.$self->{DLEXT}";$s =~ s|^(pure_install :: pure_\$\(INSTALLDIRS\)_install\n\t)\$\(NOECHO\) \$\(NOOP\)\n|$1\$(CHMOD) \$(PERM_RWX) $dll\n\t/bin/find $dop -xdev -name \\*.$self->{DLEXT} \| /bin/rebase -sOT -\n|m if (($Config{myarchname}eq 'i686-cygwin')and not (exists$ENV{CYGPORT_PACKAGE_VERSION}));$s}sub all_target {ExtUtils::MM_Unix::all_target(shift)}1;
EXTUTILS_MM_CYGWIN

$fatpacked{"ExtUtils/MM_DOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_DOS';
  package ExtUtils::MM_DOS;use strict;our$VERSION='7.38';$VERSION =~ tr/_//d;require ExtUtils::MM_Any;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Any ExtUtils::MM_Unix);sub os_flavor {return('DOS')}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s,/+,__,g;return$man}sub xs_static_lib_is_xs {return 1}1;
EXTUTILS_MM_DOS

$fatpacked{"ExtUtils/MM_Darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_DARWIN';
  package ExtUtils::MM_Darwin;use strict;BEGIN {require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Unix)}our$VERSION='7.38';$VERSION =~ tr/_//d;sub init_dist {my$self=shift;$self->{TAR}||= 'COPY_EXTENDED_ATTRIBUTES_DISABLE=1 COPYFILE_DISABLE=1 tar';$self->SUPER::init_dist(@_)}1;
EXTUTILS_MM_DARWIN

$fatpacked{"ExtUtils/MM_MacOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_MACOS';
  package ExtUtils::MM_MacOS;use strict;our$VERSION='7.38';$VERSION =~ tr/_//d;sub new {die 'MacOS Classic (MacPerl) is no longer supported by MakeMaker'}1;
EXTUTILS_MM_MACOS

$fatpacked{"ExtUtils/MM_NW5.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_NW5';
  package ExtUtils::MM_NW5;use strict;use ExtUtils::MakeMaker::Config;use File::Basename;our$VERSION='7.38';$VERSION =~ tr/_//d;require ExtUtils::MM_Win32;our@ISA=qw(ExtUtils::MM_Win32);use ExtUtils::MakeMaker qw(&neatvalue &_sprintf562);$ENV{EMXSHELL}='sh';my$BORLAND=$Config{'cc'}=~ /\bbcc/i;my$GCC=$Config{'cc'}=~ /\bgcc/i;sub os_flavor {my$self=shift;return ($self->SUPER::os_flavor,'Netware')}sub init_platform {my($self)=shift;$self->SUPER::init_platform;my$libpth=$Config{'libpth'};$libpth =~ s( )(;);$self->{'LIBPTH'}=$libpth;$self->{'BASE_IMPORT'}=$Config{'base_import'};if($self->{'base_import'}){$self->{'BASE_IMPORT'}.= ', ' .$self->{'base_import'}}$self->{'NLM_VERSION'}=$Config{'nlm_version'};$self->{'MPKTOOL'}=$Config{'mpktool'};$self->{'TOOLPATH'}=$Config{'toolpath'};(my$boot=$self->{'NAME'})=~ s/:/_/g;$self->{'BOOT_SYMBOL'}=$boot;if(length($self->{'BASEEXT'})> 8){$self->{'NLM_SHORT_NAME'}=substr($self->{'BASEEXT'},0,8)}($self->{INCLUDE}=$Config{'incpath'})=~ s/([ ]*)-I/;/g;$self->{PATH}='$(PATH);$(TOOLPATH)';$self->{MM_NW5_VERSION}=$VERSION}sub platform_constants {my($self)=shift;my$make_frag='';$make_frag .= $self->SUPER::platform_constants;for my$macro (qw(LIBPTH BASE_IMPORT NLM_VERSION MPKTOOL TOOLPATH BOOT_SYMBOL NLM_SHORT_NAME INCLUDE PATH MM_NW5_VERSION)){next unless defined$self->{$macro};$make_frag .= "$macro = $self->{$macro}\n"}return$make_frag}sub static_lib_pure_cmd {my ($self,$src)=@_;$src =~ s/(\$\(\w+)(\))/$1:^"+"$2/g if$BORLAND;sprintf qq{\t\$(AR) %s\n},($BORLAND ? '$@ ' .$src : ($GCC ? '-ru $@ ' .$src : '-type library -o $@ ' .$src))}sub xs_static_lib_is_xs {return 1}sub xs_make_dynamic_lib {my ($self,$attribs,$from,$to,$todir,$ldfrom,$exportlist)=@_;my@m;if ($to =~ /^\$/){if ($self->{NLM_SHORT_NAME}){my$newto=q{$(INST_AUTODIR)\\$(NLM_SHORT_NAME).$(DLEXT)};push@m,"$to: $newto\n\n";$to=$newto}}else {my ($v,$d,$f)=File::Spec->splitpath($to);if ($f =~ /[^\.]{9}\./){$f=substr$f,0,8}my$newto=File::Spec->catpath($v,$d,$f);push@m,"$to: $newto\n\n";$to=$newto}push@m,_sprintf562 <<'MAKE_FRAG',$to,$from,$todir,$exportlist;if ($self->{CCFLAGS}=~ m/ -DMPK_ON /){(my$xdc=$exportlist)=~ s#def\z#xdc#;$xdc='$(BASEEXT).xdc';push@m,sprintf <<'MAKE_FRAG',$xdc,$exportlist}my$version=join '.',map {sprintf "%d",$_}"$]" =~ /(\d)\.(\d{3})(\d{2})/;push@m,sprintf <<'EOF',$from,$version,$to,$exportlist;join '',@m}1;
  # Create xdc data for an MT safe NLM in case of mpk build
  %1$s: %2$s $(MYEXTLIB) $(BOOTSTRAP) %3$s$(DFSEP).exists
  	$(NOECHO) $(ECHO) Export boot_$(BOOT_SYMBOL) > %4$s
  	$(NOECHO) $(ECHO) $(BASE_IMPORT) >> %4$s
  	$(NOECHO) $(ECHO) Import @$(PERL_INC)\perl.imp >> %4$s
  MAKE_FRAG
  	$(MPKTOOL) $(XDCFLAGS) %s
  	$(NOECHO) $(ECHO) xdcdata $(BASEEXT).xdc >> %s
  MAKE_FRAG
  	$(LD) $(LDFLAGS) %s -desc "Perl %s Extension ($(BASEEXT))  XS_VERSION: $(XS_VERSION)" -nlmversion $(NLM_VERSION) -o %s $(MYEXTLIB) $(PERL_INC)\Main.lib -commandfile %s
  	$(CHMOD) 755 $@
  EOF
EXTUTILS_MM_NW5

$fatpacked{"ExtUtils/MM_OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_OS2';
  package ExtUtils::MM_OS2;use strict;use ExtUtils::MakeMaker qw(neatvalue);use File::Spec;our$VERSION='7.38';$VERSION =~ tr/_//d;require ExtUtils::MM_Any;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Any ExtUtils::MM_Unix);sub init_dist {my($self)=@_;$self->{TO_UNIX}||= <<'MAKE_TEXT';$self->SUPER::init_dist}sub dlsyms {my($self,%attribs)=@_;if ($self->{IMPORTS}&& %{$self->{IMPORTS}}){-d 'tmp_imp' or mkdir 'tmp_imp',0777 or die "Can't mkdir tmp_imp";open my$imp,'>','tmpimp.imp' or die "Can't open tmpimp.imp";for my$name (sort keys %{$self->{IMPORTS}}){my$exp=$self->{IMPORTS}->{$name};my ($lib,$id)=($exp =~ /(.*)\.(.*)/)or die "Malformed IMPORT `$exp'";print$imp "$name $lib $id ?\n"}close$imp or die "Can't close tmpimp.imp";system "emximp -o tmpimp$Config::Config{lib_ext} tmpimp.imp" and die "Cannot make import library: $!, \$?=$?";eval {unlink <tmp_imp/*>;1}or system "rm tmp_imp/*";system "cd tmp_imp; $Config::Config{ar} x ../tmpimp$Config::Config{lib_ext}" and die "Cannot extract import objects: $!, \$?=$?"}return '' if$self->{SKIPHASH}{'dynamic'};$self->xs_dlsyms_iterator(\%attribs)}sub xs_dlsyms_ext {'.def'}sub xs_dlsyms_extra {join '',map {qq{, "$_" => "\$($_)"}}qw(VERSION DISTNAME INSTALLDIRS)}sub static_lib_pure_cmd {my($self)=@_;my$old=$self->SUPER::static_lib_pure_cmd;return$old unless$self->{IMPORTS}&& %{$self->{IMPORTS}};$old .<<'EOC'}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s,/+,.,g;$man}sub maybe_command {my($self,$file)=@_;$file =~ s,[/\\]+,/,g;return$file if -x $file &&!-d _;return "$file.exe" if -x "$file.exe" &&!-d _;return "$file.cmd" if -x "$file.cmd" &&!-d _;return}sub init_linker {my$self=shift;$self->{PERL_ARCHIVE}="\$(PERL_INC)/libperl\$(LIB_EXT)";$self->{PERL_ARCHIVEDEP}||= '';$self->{PERL_ARCHIVE_AFTER}=$OS2::is_aout ? '' : '$(PERL_INC)/libperl_override$(LIB_EXT)';$self->{EXPORT_LIST}='$(BASEEXT).def'}sub os_flavor {return('OS/2')}sub xs_static_lib_is_xs {return 1}1;
  $(NOECHO) $(TEST_F) tmp.zip && $(RM_F) tmp.zip; $(ZIP) -ll -mr tmp.zip $(DISTVNAME) && unzip -o tmp.zip && $(RM_F) tmp.zip
  MAKE_TEXT
  	$(AR) $(AR_STATIC_ARGS) "$@" tmp_imp/*
  	$(RANLIB) "$@"
  EOC
EXTUTILS_MM_OS2

$fatpacked{"ExtUtils/MM_QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_QNX';
  package ExtUtils::MM_QNX;use strict;our$VERSION='7.38';$VERSION =~ tr/_//d;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Unix);sub extra_clean_files {my$self=shift;my@errfiles=@{$self->{C}};for (@errfiles){s/.c$/.err/}return(@errfiles,'perlmain.err')}1;
EXTUTILS_MM_QNX

$fatpacked{"ExtUtils/MM_UWIN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_UWIN';
  package ExtUtils::MM_UWIN;use strict;our$VERSION='7.38';$VERSION =~ tr/_//d;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Unix);sub os_flavor {return('Unix','U/WIN')}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s,/+,.,g;return$man}1;
EXTUTILS_MM_UWIN

$fatpacked{"ExtUtils/MM_Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_UNIX';
  package ExtUtils::MM_Unix;require 5.006;use strict;use Carp;use ExtUtils::MakeMaker::Config;use File::Basename qw(basename dirname);our%Config_Override;use ExtUtils::MakeMaker qw($Verbose neatvalue _sprintf562);use vars qw($VERSION);$VERSION='7.38';$VERSION =~ tr/_//d;require ExtUtils::MM_Any;our@ISA=qw(ExtUtils::MM_Any);my%Is;BEGIN {$Is{OS2}=$^O eq 'os2';$Is{Win32}=$^O eq 'MSWin32' || $Config{osname}eq 'NetWare';$Is{Dos}=$^O eq 'dos';$Is{VMS}=$^O eq 'VMS';$Is{OSF}=$^O eq 'dec_osf';$Is{IRIX}=$^O eq 'irix';$Is{NetBSD}=$^O eq 'netbsd';$Is{Interix}=$^O eq 'interix';$Is{SunOS4}=$^O eq 'sunos';$Is{Solaris}=$^O eq 'solaris';$Is{SunOS}=$Is{SunOS4}|| $Is{Solaris};$Is{BSD}=($^O =~ /^(?:free|net|open)bsd$/ or grep($^O eq $_,qw(bsdos interix dragonfly)));$Is{Android}=$^O =~ /android/;if ($^O eq 'darwin' && $^X eq '/usr/bin/perl'){my@osvers=split /\./,$Config{osvers};$Is{ApplCor}=($osvers[0]>= 18)}}BEGIN {if($Is{VMS}){require VMS::Filespec;VMS::Filespec->import}}my$Curdir=__PACKAGE__->curdir;my$Updir=__PACKAGE__->updir;sub os_flavor {return('Unix')}sub c_o {my($self)=shift;return '' unless$self->needs_linking();my(@m);my$command='$(CCCMD)';my$flags='$(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE)';if ($Is{ApplCor}){$flags =~ s/"-I(\$\(PERL_INC\))"/-iwithsysroot "$1"/}if (my$cpp=$Config{cpprun}){my$cpp_cmd=$self->const_cccmd;$cpp_cmd =~ s/^CCCMD\s*=\s*\$\(CC\)/$cpp/;push@m,qq{
  .c.i:
  	$cpp_cmd $flags \$*.c > \$*.i
  }}my$m_o=$self->{XSMULTI}? $self->xs_obj_opt('$*.s'): '';push@m,sprintf <<'EOF',$command,$flags,$m_o;my@exts=qw(c cpp cxx cc);push@exts,'C' if!$Is{OS2}and!$Is{Win32}and!$Is{Dos};$m_o=$self->{XSMULTI}? $self->xs_obj_opt('$*$(OBJ_EXT)'): '';my$dbgout=$self->dbgoutflag;for my$ext (@exts){push@m,"\n.$ext\$(OBJ_EXT) :\n\t$command $flags " .($dbgout?"$dbgout ":'')."\$*.$ext" .($m_o ? " $m_o" : '')."\n"}return join "",@m}sub xs_obj_opt {my ($self,$output_file)=@_;"-o $output_file"}sub dbgoutflag {''}sub cflags {my($self,$libperl)=@_;return$self->{CFLAGS}if$self->{CFLAGS};return '' unless$self->needs_linking();my($prog,$uc,$perltype,%cflags);$libperl ||= $self->{LIBPERL_A}|| "libperl$self->{LIB_EXT}" ;$libperl =~ s/\.\$\(A\)$/$self->{LIB_EXT}/;@cflags{qw(cc ccflags optimize shellflags)}=@Config{qw(cc ccflags optimize shellflags)};my@ccextraflags=qw(ccwarnflags);if ($ENV{PERL_CORE}){for my$x (@ccextraflags){if (exists$Config{$x}){$cflags{$x}=$Config{$x}}}}my($optdebug)="";$cflags{shellflags}||= '';my(%map)=(D=>'-DDEBUGGING',E=>'-DEMBED',DE=>'-DDEBUGGING -DEMBED',M=>'-DEMBED -DMULTIPLICITY',DM=>'-DDEBUGGING -DEMBED -DMULTIPLICITY',);if ($libperl =~ /libperl(\w*)\Q$self->{LIB_EXT}/){$uc=uc($1)}else {$uc=""}$perltype=$map{$uc}? $map{$uc}: "";if ($uc =~ /^D/){$optdebug="-g"}my($name);($name=$self->{NAME}."_cflags")=~ s/:/_/g ;if ($prog=$Config{$name}){print "Processing $name hint:\n" if$Verbose;my(@o)=`cc=\"$cflags{cc}\"
  
  .c.s :
  	%s -S %s $*.c %s
  EOF
  	  ccflags=\"$cflags{ccflags}\"
  	  optimize=\"$cflags{optimize}\"
  	  perltype=\"$cflags{perltype}\"
  	  optdebug=\"$cflags{optdebug}\"
  	  eval '$prog'
  	  echo cc=\$cc
  	  echo ccflags=\$ccflags
  	  echo optimize=\$optimize
  	  echo perltype=\$perltype
  	  echo optdebug=\$optdebug
  	  `;for my$line (@o){chomp$line;if ($line =~ /(.*?)=\s*(.*)\s*$/){$cflags{$1}=$2;print "	$1 = $2\n" if$Verbose}else {print "Unrecognised result from hint: '$line'\n"}}}if ($optdebug){$cflags{optimize}=$optdebug}for (qw(ccflags optimize perltype)){$cflags{$_}||= '';$cflags{$_}=~ s/^\s+//;$cflags{$_}=~ s/\s+/ /g;$cflags{$_}=~ s/\s+$//;$self->{uc $_}||= $cflags{$_}}if ($self->{POLLUTE}){$self->{CCFLAGS}.= ' -DPERL_POLLUTE '}for my$x (@ccextraflags){next unless exists$cflags{$x};$self->{CCFLAGS}.= $cflags{$x}=~ m!^\s! ? $cflags{$x}: ' ' .$cflags{$x}}my$pollute='';if ($Config{usemymalloc}and not $Config{bincompat5005}and not $Config{ccflags}=~ /-DPERL_POLLUTE_MALLOC\b/ and $self->{PERL_MALLOC_OK}){$pollute='$(PERL_MALLOC_DEF)'}return$self->{CFLAGS}=qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  MPOLLUTE = $pollute
  }}sub const_cccmd {my($self,$libperl)=@_;return$self->{CONST_CCCMD}if$self->{CONST_CCCMD};return '' unless$self->needs_linking();return$self->{CONST_CCCMD}=q{CCCMD = $(CC) -c $(PASTHRU_INC) $(INC) \\
  	$(CCFLAGS) $(OPTIMIZE) \\
  	$(PERLTYPE) $(MPOLLUTE) $(DEFINE_VERSION) \\
  	$(XS_DEFINE_VERSION)}}sub const_config {my($self)=shift;my@m=$self->specify_shell();push@m,<<"END";my(%once_only);for my$key (@{$self->{CONFIG}}){next if$once_only{$key};push@m,uc($key),' = ',$self->{uc$key},"\n";$once_only{$key}=1}join('',@m)}sub const_loadlibs {my($self)=shift;return "" unless$self->needs_linking;my@m;push@m,qq{
  
  # These definitions are from config.sh (via $INC{'Config.pm'}).
  # They may have been overridden via Makefile.PL or on the command line.
  END
  # $self->{NAME} might depend on some other libraries:
  # See ExtUtils::Liblist for details
  #
  };for my$tmp (qw/EXTRALIBS LDLOADLIBS BSLOADLIBS/){next unless defined$self->{$tmp};push@m,"$tmp = $self->{$tmp}\n"}for my$tmp (qw/LD_RUN_PATH/){next unless$self->{$tmp};push@m,"$tmp = $self->{$tmp}\n"}return join "",@m}sub constants {my($self)=@_;my@m=();$self->{DFSEP}='$(DIRFILESEP)';for my$macro (qw(AR_STATIC_ARGS DIRFILESEP DFSEP NAME NAME_SYM VERSION VERSION_MACRO VERSION_SYM DEFINE_VERSION XS_VERSION XS_VERSION_MACRO XS_DEFINE_VERSION INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB INST_MAN1DIR INST_MAN3DIR MAN1EXT MAN3EXT MAN1SECTION MAN3SECTION INSTALLDIRS INSTALL_BASE DESTDIR PREFIX PERLPREFIX SITEPREFIX VENDORPREFIX),(map {("INSTALL".$_,"DESTINSTALL".$_)}$self->installvars),qw(PERL_LIB PERL_ARCHLIB PERL_ARCHLIBDEP LIBPERL_A MYEXTLIB FIRST_MAKEFILE MAKEFILE_OLD MAKE_APERL_FILE PERLMAINCC PERL_SRC PERL_INC PERL_INCDEP PERL FULLPERL ABSPERL PERLRUN FULLPERLRUN ABSPERLRUN PERLRUNINST FULLPERLRUNINST ABSPERLRUNINST PERL_CORE PERM_DIR PERM_RW PERM_RWX)){next unless defined$self->{$macro};$self->{$macro}=~ s/#/\\#/g;$self->{$macro}=$self->quote_dep($self->{$macro})if$ExtUtils::MakeMaker::macro_dep{$macro};push@m,"$macro = $self->{$macro}\n"}push@m,qq{
  MAKEMAKER   = $self->{MAKEMAKER}
  MM_VERSION  = $self->{MM_VERSION}
  MM_REVISION = $self->{MM_REVISION}
  };push@m,q{
  # FULLEXT = Pathname for extension directory (eg Foo/Bar/Oracle).
  # BASEEXT = Basename part of FULLEXT. May be just equal FULLEXT. (eg Oracle)
  # PARENT_NAME = NAME without BASEEXT and no trailing :: (eg Foo::Bar)
  # DLBASE  = Basename part of dynamic library. May be just equal BASEEXT.
  };for my$macro (qw/MAKE FULLEXT BASEEXT PARENT_NAME DLBASE VERSION_FROM INC DEFINE OBJECT LDFROM LINKTYPE BOOTDEP/){next unless defined$self->{$macro};push@m,"$macro = $self->{$macro}\n"}push@m,"
  # Handy lists of source code files:
  XS_FILES = ".$self->wraplist(sort keys %{$self->{XS}})."
  C_FILES  = ".$self->wraplist(sort @{$self->{C}})."
  O_FILES  = ".$self->wraplist(sort @{$self->{O_FILES}})."
  H_FILES  = ".$self->wraplist(sort @{$self->{H}})."
  MAN1PODS = ".$self->wraplist(sort keys %{$self->{MAN1PODS}})."
  MAN3PODS = ".$self->wraplist(sort keys %{$self->{MAN3PODS}})."
  ";push@m,q{
  SDKROOT := $(shell xcrun --show-sdk-path)
  PERL_SYSROOT = $(SDKROOT)
  } if$Is{ApplCor}&& $self->{'PERL_INC'}=~ m!^/System/Library/Perl/!;push@m,q{
  # Where is the Config information that we are using/depend on
  CONFIGDEP = $(PERL_ARCHLIBDEP)$(DFSEP)Config.pm $(PERL_SYSROOT)$(PERL_INCDEP)$(DFSEP)config.h
  } if$Is{ApplCor};push@m,q{
  # Where is the Config information that we are using/depend on
  CONFIGDEP = $(PERL_ARCHLIBDEP)$(DFSEP)Config.pm $(PERL_INCDEP)$(DFSEP)config.h
  } if -e $self->catfile($self->{PERL_INC},'config.h')&&!$Is{ApplCor};push@m,qq{
  # Where to build things
  INST_LIBDIR      = $self->{INST_LIBDIR}
  INST_ARCHLIBDIR  = $self->{INST_ARCHLIBDIR}
  
  INST_AUTODIR     = $self->{INST_AUTODIR}
  INST_ARCHAUTODIR = $self->{INST_ARCHAUTODIR}
  
  INST_STATIC      = $self->{INST_STATIC}
  INST_DYNAMIC     = $self->{INST_DYNAMIC}
  INST_BOOT        = $self->{INST_BOOT}
  };push@m,qq{
  # Extra linker info
  EXPORT_LIST        = $self->{EXPORT_LIST}
  PERL_ARCHIVE       = $self->{PERL_ARCHIVE}
  PERL_ARCHIVEDEP    = $self->{PERL_ARCHIVEDEP}
  PERL_ARCHIVE_AFTER = $self->{PERL_ARCHIVE_AFTER}
  };push@m,"
  
  TO_INST_PM = ".$self->wraplist(map$self->quote_dep($_),sort keys %{$self->{PM}})."\n";join('',@m)}sub depend {my($self,%attribs)=@_;my(@m,$key,$val);for my$key (sort keys%attribs){my$val=$attribs{$key};next unless defined$key and defined$val;push@m,"$key : $val\n"}join "",@m}sub init_DEST {my$self=shift;$self->{DESTDIR}||= '';for my$var ($self->installvars){my$destvar='DESTINSTALL'.$var;$self->{$destvar}||= '$(DESTDIR)$(INSTALL'.$var.')'}}sub init_dist {my$self=shift;$self->{TAR}||= 'tar';$self->{TARFLAGS}||= 'cvf';$self->{ZIP}||= 'zip';$self->{ZIPFLAGS}||= '-r';$self->{COMPRESS}||= 'gzip --best';$self->{SUFFIX}||= '.gz';$self->{SHAR}||= 'shar';$self->{PREOP}||= '$(NOECHO) $(NOOP)';$self->{POSTOP}||= '$(NOECHO) $(NOOP)';$self->{TO_UNIX}||= '$(NOECHO) $(NOOP)';$self->{CI}||= 'ci -u';$self->{RCS_LABEL}||= 'rcs -Nv$(VERSION_SYM): -q';$self->{DIST_CP}||= 'best';$self->{DIST_DEFAULT}||= 'tardist';($self->{DISTNAME}=$self->{NAME})=~ s{::}{-}g unless$self->{DISTNAME};$self->{DISTVNAME}||= $self->{DISTNAME}.'-'.$self->{VERSION}}sub dist {my($self,%attribs)=@_;my$make='';if ($attribs{SUFFIX}&& $attribs{SUFFIX}!~ m!^\.!){$attribs{SUFFIX}='.' .$attribs{SUFFIX}}for my$key (qw(TAR TARFLAGS ZIP ZIPFLAGS COMPRESS SUFFIX SHAR PREOP POSTOP TO_UNIX CI RCS_LABEL DIST_CP DIST_DEFAULT DISTNAME DISTVNAME)){my$value=$attribs{$key}|| $self->{$key};$make .= "$key = $value\n"}return$make}sub dist_basics {my($self)=shift;return <<'MAKE_FRAG'}sub dist_ci {my($self)=shift;return sprintf "ci :\n\t%s\n",$self->oneliner(<<'EOF',[qw(-MExtUtils::Manifest=maniread)])}sub dist_core {my($self)=shift;my$make_frag='';for my$target (qw(dist tardist uutardist tarfile zipdist zipfile shdist)){my$method=$target.'_target';$make_frag .= "\n";$make_frag .= $self->$method()}return$make_frag}sub dist_target {my($self)=shift;my$date_check=$self->oneliner(<<'CODE',['-l']);return sprintf <<'MAKE_FRAG',$date_check}sub tardist_target {my($self)=shift;return <<'MAKE_FRAG'}sub zipdist_target {my($self)=shift;return <<'MAKE_FRAG'}sub tarfile_target {my($self)=shift;return <<'MAKE_FRAG'}sub zipfile_target {my($self)=shift;return <<'MAKE_FRAG'}sub uutardist_target {my($self)=shift;return <<'MAKE_FRAG'}sub shdist_target {my($self)=shift;return <<'MAKE_FRAG'}sub dlsyms {return ''}sub dynamic_bs {my($self,%attribs)=@_;return "\nBOOTSTRAP =\n" unless$self->has_link_code();my@exts;if ($self->{XSMULTI}){@exts=$self->_xs_list_basenames}else {@exts='$(BASEEXT)'}return join "\n","BOOTSTRAP = @{[map { qq{$_.bs} } @exts]}\n",map {$self->_xs_make_bs($_)}@exts}sub _xs_make_bs {my ($self,$basename)=@_;my ($v,$d,$f)=File::Spec->splitpath($basename);my@d=File::Spec->splitdir($d);shift@d if$self->{XSMULTI}and $d[0]eq 'lib';my$instdir=$self->catdir('$(INST_ARCHLIB)','auto',@d,$f);$instdir='$(INST_ARCHAUTODIR)' if$basename eq '$(BASEEXT)';my$instfile=$self->catfile($instdir,"$f.bs");my$exists="$instdir\$(DFSEP).exists";return _sprintf562 <<'MAKE_FRAG',$basename,$instfile,$exists}sub dynamic_lib {my($self,%attribs)=@_;return '' unless$self->needs_linking();return '' unless$self->has_link_code;my@m=$self->xs_dynamic_lib_macros(\%attribs);my@libs;my$dlsyms_ext=eval {$self->xs_dlsyms_ext};if ($self->{XSMULTI}){my@exts=$self->_xs_list_basenames;for my$ext (@exts){my ($v,$d,$f)=File::Spec->splitpath($ext);my@d=File::Spec->splitdir($d);shift@d if$d[0]eq 'lib';pop@d if$d[$#d]eq '';my$instdir=$self->catdir('$(INST_ARCHLIB)','auto',@d,$f);eval {require DynaLoader};if (defined&DynaLoader::mod2fname){$f=&DynaLoader::mod2fname([@d,$f])}my$instfile=$self->catfile($instdir,"$f.\$(DLEXT)");my$objfile=$self->_xsbuild_value('xs',$ext,'OBJECT');$objfile="$ext\$(OBJ_EXT)" unless defined$objfile;my$ldfrom=$self->_xsbuild_value('xs',$ext,'LDFROM');$ldfrom=$objfile unless defined$ldfrom;my$exportlist="$ext.def";my@libchunk=($objfile,$instfile,$instdir,$ldfrom,$exportlist);push@libchunk,$dlsyms_ext ? $ext.$dlsyms_ext : undef;push@libs,\@libchunk}}else {my@libchunk=qw($(OBJECT) $(INST_DYNAMIC) $(INST_ARCHAUTODIR) $(LDFROM) $(EXPORT_LIST));push@libchunk,$dlsyms_ext ? '$(BASEEXT)'.$dlsyms_ext : undef;@libs=(\@libchunk)}push@m,map {$self->xs_make_dynamic_lib(\%attribs,@$_)}@libs;return join("\n",@m)}sub xs_dynamic_lib_macros {my ($self,$attribs)=@_;my$otherldflags=$attribs->{OTHERLDFLAGS}|| "";my$inst_dynamic_dep=$attribs->{INST_DYNAMIC_DEP}|| "";my$armaybe=$self->_xs_armaybe($attribs);my$ld_opt=$Is{OS2}? '$(OPTIMIZE) ' : '';my$ld_fix=$Is{OS2}? '|| ( $(RM_F) $@ && sh -c false )' : '';sprintf <<'EOF',$armaybe,$ld_opt.$otherldflags,$inst_dynamic_dep,$ld_fix}sub _xs_armaybe {my ($self,$attribs)=@_;my$armaybe=$attribs->{ARMAYBE}|| $self->{ARMAYBE}|| ":";$armaybe='ar' if ($Is{OSF}and $armaybe eq ':');$armaybe}sub xs_make_dynamic_lib {my ($self,$attribs,$object,$to,$todir,$ldfrom,$exportlist,$dlsyms)=@_;$exportlist='' if$exportlist ne '$(EXPORT_LIST)';my$armaybe=$self->_xs_armaybe($attribs);my@m=sprintf '%s : %s $(MYEXTLIB) %s$(DFSEP).exists %s $(PERL_ARCHIVEDEP) $(PERL_ARCHIVE_AFTER) $(INST_DYNAMIC_DEP) %s'."\n",$to,$object,$todir,$exportlist,($dlsyms || '');my$dlsyms_arg=$self->xs_dlsyms_arg($dlsyms);if ($armaybe ne ':'){$ldfrom='tmp$(LIB_EXT)';push(@m,"	\$(ARMAYBE) cr $ldfrom $object\n");push(@m,"	\$(RANLIB) $ldfrom\n")}$ldfrom="-all $ldfrom -none" if$Is{OSF};my$ldrun=$Is{IRIX}&& $self->{LD_RUN_PATH}? qq{-rpath "$self->{LD_RUN_PATH}"} : '';push(@m,"	\$(RM_F) \$\@\n");my$libs='$(LDLOADLIBS)';if (($Is{NetBSD}|| $Is{Interix}|| $Is{Android})&& $Config{'useshrplib'}eq 'true'){if ($Config{'lddlflags'}=~ /-Wl,-R/){$libs .= ' "-L$(PERL_INC)" "-Wl,-R$(INSTALLARCHLIB)/CORE" "-Wl,-R$(PERL_ARCHLIB)/CORE" -lperl'}elsif ($Config{'lddlflags'}=~ /-R/){$libs .= ' "-L$(PERL_INC)" "-R$(INSTALLARCHLIB)/CORE" "-R$(PERL_ARCHLIB)/CORE" -lperl'}elsif ($Is{Android}){$libs .= ' "-L$(PERL_INC)" -lperl'}}my$ld_run_path_shell="";if ($self->{LD_RUN_PATH}ne ""){$ld_run_path_shell='LD_RUN_PATH="$(LD_RUN_PATH)" '}push@m,sprintf <<'MAKE',$ld_run_path_shell,$ldrun,$dlsyms_arg,$ldfrom,$self->xs_obj_opt('$@'),$libs,$exportlist;join '',@m}sub exescan {my($self,$path)=@_;$path}sub extliblist {my($self,$libs)=@_;require ExtUtils::Liblist;$self->ext($libs,$Verbose)}sub find_perl {my($self,$ver,$names,$dirs,$trace)=@_;if ($trace >= 2){print "Looking for perl $ver by these names:
  distclean :: realclean distcheck
  	$(NOECHO) $(NOOP)
  
  distcheck :
  	$(PERLRUN) "-MExtUtils::Manifest=fullcheck" -e fullcheck
  
  skipcheck :
  	$(PERLRUN) "-MExtUtils::Manifest=skipcheck" -e skipcheck
  
  manifest :
  	$(PERLRUN) "-MExtUtils::Manifest=mkmanifest" -e mkmanifest
  
  veryclean : realclean
  	$(RM_F) *~ */*~ *.orig */*.orig *.bak */*.bak *.old */*.old
  
  MAKE_FRAG
  @all = sort keys %{ maniread() };
  print(qq{Executing $(CI) @all\n});
  system(qq{$(CI) @all}) == 0 or die $!;
  print(qq{Executing $(RCS_LABEL) ...\n});
  system(qq{$(RCS_LABEL) @all}) == 0 or die $!;
  EOF
  print 'Warning: Makefile possibly out of date with $(VERSION_FROM)'
      if -e '$(VERSION_FROM)' and -M '$(VERSION_FROM)' < -M '$(FIRST_MAKEFILE)';
  CODE
  dist : $(DIST_DEFAULT) $(FIRST_MAKEFILE)
  	$(NOECHO) %s
  MAKE_FRAG
  tardist : $(DISTVNAME).tar$(SUFFIX)
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  zipdist : $(DISTVNAME).zip
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  $(DISTVNAME).tar$(SUFFIX) : distdir
  	$(PREOP)
  	$(TO_UNIX)
  	$(TAR) $(TARFLAGS) $(DISTVNAME).tar $(DISTVNAME)
  	$(RM_RF) $(DISTVNAME)
  	$(COMPRESS) $(DISTVNAME).tar
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).tar$(SUFFIX)'
  	$(POSTOP)
  MAKE_FRAG
  $(DISTVNAME).zip : distdir
  	$(PREOP)
  	$(ZIP) $(ZIPFLAGS) $(DISTVNAME).zip $(DISTVNAME)
  	$(RM_RF) $(DISTVNAME)
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).zip'
  	$(POSTOP)
  MAKE_FRAG
  uutardist : $(DISTVNAME).tar$(SUFFIX)
  	uuencode $(DISTVNAME).tar$(SUFFIX) $(DISTVNAME).tar$(SUFFIX) > $(DISTVNAME).tar$(SUFFIX)_uu
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).tar$(SUFFIX)_uu'
  MAKE_FRAG
  shdist : distdir
  	$(PREOP)
  	$(SHAR) $(DISTVNAME) > $(DISTVNAME).shar
  	$(RM_RF) $(DISTVNAME)
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).shar'
  	$(POSTOP)
  MAKE_FRAG
  # As Mkbootstrap might not write a file (if none is required)
  # we use touch to prevent make continually trying to remake it.
  # The DynaLoader only reads a non-empty file.
  %1$s.bs : $(FIRST_MAKEFILE) $(BOOTDEP)
  	$(NOECHO) $(ECHO) "Running Mkbootstrap for %1$s ($(BSLOADLIBS))"
  	$(NOECHO) $(PERLRUN) \
  		"-MExtUtils::Mkbootstrap" \
  		-e "Mkbootstrap('%1$s','$(BSLOADLIBS)');"
  	$(NOECHO) $(TOUCH) "%1$s.bs"
  	$(CHMOD) $(PERM_RW) "%1$s.bs"
  
  %2$s : %1$s.bs %3$s
  	$(NOECHO) $(RM_RF) %2$s
  	- $(CP_NONEMPTY) %1$s.bs %2$s $(PERM_RW)
  MAKE_FRAG
  # This section creates the dynamically loadable objects from relevant
  # objects and possibly $(MYEXTLIB).
  ARMAYBE = %s
  OTHERLDFLAGS = %s
  INST_DYNAMIC_DEP = %s
  INST_DYNAMIC_FIX = %s
  EOF
  	%s$(LD) %s $(LDDLFLAGS) %s %s $(OTHERLDFLAGS) %s $(MYEXTLIB) \
  	  $(PERL_ARCHIVE) %s $(PERL_ARCHIVE_AFTER) %s \
  	  $(INST_DYNAMIC_FIX)
  	$(CHMOD) $(PERM_RWX) $@
  MAKE
  @$names
  in these dirs:
  @$dirs
  "}my$stderr_duped=0;local*STDERR_COPY;unless ($Is{BSD}){if(open(STDERR_COPY,'>&STDERR')){$stderr_duped=1}else {warn <<WARNING}}for my$name (@$names){my ($abs,$use_dir);if ($self->file_name_is_absolute($name)){$abs=$name}elsif ($self->canonpath($name)eq $self->canonpath(basename($name))){$use_dir=1}else {$abs=$self->catfile($Curdir,$name)}for my$dir ($use_dir ? @$dirs : 1){next unless defined$dir;$abs=$self->catfile($dir,$name)if$use_dir;print "Checking $abs\n" if ($trace >= 2);next unless$self->maybe_command($abs);print "Executing $abs\n" if ($trace >= 2);my$val;my$version_check=qq{"$abs" -le "require $ver; print qq{VER_OK}"};if ($Is{BSD}){$val=`$version_check 2>&1`}else {close STDERR if$stderr_duped;$val=`$version_check`;open STDERR,">&STDERR_COPY" if$stderr_duped}if ($val =~ /^VER_OK/m){print "Using PERL=$abs\n" if$trace;return$abs}elsif ($trace >= 2){print "Result: '$val' ".($? >> 8)."\n"}}}print "Unable to find a perl $ver (by these names: @$names, in these dirs: @$dirs)\n";0}sub fixin {my ($self,@files)=@_;for my$file (@files){my$file_new="$file.new";my$file_bak="$file.bak";open(my$fixin,'<',$file)or croak "Can't process '$file': $!";local $/="\n";chomp(my$line=<$fixin>);next unless$line =~ s/^\s*\#!\s*//;my$shb=$self->_fixin_replace_shebang($file,$line);next unless defined$shb;open(my$fixout,">","$file_new")or do {warn "Can't create new $file: $!\n";next};local $\;local $/;print$fixout $shb,<$fixin>;close$fixin;close$fixout;chmod 0666,$file_bak;unlink$file_bak;unless (_rename($file,$file_bak)){warn "Can't rename $file to $file_bak: $!";next}unless (_rename($file_new,$file)){warn "Can't rename $file_new to $file: $!";unless (_rename($file_bak,$file)){warn "Can't rename $file_bak back to $file either: $!";warn "Leaving $file renamed as $file_bak\n"}next}unlink$file_bak}continue {system("$Config{'eunicefix'} $file")if$Config{'eunicefix'}ne ':'}}sub _rename {my($old,$new)=@_;for my$file ($old,$new){if($Is{VMS}and basename($file)!~ /\./){$file="$file."}}return rename($old,$new)}sub _fixin_replace_shebang {my ($self,$file,$line)=@_;my ($origcmd,$arg)=split ' ',$line,2;(my$cmd=$origcmd)=~ s!^.*/!!;my$interpreter;if (defined$ENV{PERL_MM_SHEBANG}&& $ENV{PERL_MM_SHEBANG}eq "relocatable"){$interpreter="/usr/bin/env perl"}elsif ($cmd =~ m{^perl(?:\z|[^a-z])}){if ($Config{startperl}=~ m,^\#!.*/perl,){$interpreter=$Config{startperl};$interpreter =~ s,^\#!,,}else {$interpreter=$Config{perlpath}}}else {my (@absdirs)=reverse grep {$self->file_name_is_absolute($_)}$self->path;$interpreter='';for my$dir (@absdirs){my$maybefile=$self->catfile($dir,$cmd);if ($self->maybe_command($maybefile)){warn "Ignoring $interpreter in $file\n" if$Verbose && $interpreter;$interpreter=$maybefile}}if ($origcmd ne $interpreter and $self->file_name_is_absolute($origcmd)){my$origdir=dirname($origcmd);if ($self->maybe_command($origcmd)&& grep {$_ eq $origdir}@absdirs){my ($odev,$oino)=stat$origcmd;my ($idev,$iino)=stat$interpreter;if ($odev==$idev && $oino==$iino){warn "$origcmd is the same as $interpreter, leaving alone" if$Verbose;$interpreter=$origcmd}}}}my ($does_shbang)=$Config{'sharpbang'}=~ /^\s*\#\!/;my ($shb)="";if ($interpreter){print "Changing sharpbang in $file to $interpreter" if$Verbose;if ($does_shbang){$shb .= "$Config{'sharpbang'}$interpreter";$shb .= ' ' .$arg if defined$arg;$shb .= "\n"}}else {warn "Can't find $cmd in PATH, $file unchanged" if$Verbose;return}return$shb}sub force {my($self)=shift;'# Phony target to force checking subdirectories.
  find_perl() can't dup STDERR: $!
  You might see some garbage while we search for Perl
  WARNING
  FORCE :
  	$(NOECHO) $(NOOP)
  '}sub guess_name {my($self)=@_;use Cwd 'cwd';my$name=basename(cwd());$name =~ s|[\-_][\d\.\-]+\z||;print "Warning: Guessing NAME [$name] from current directory name.\n";$name}sub has_link_code {my($self)=shift;return$self->{HAS_LINK_CODE}if defined$self->{HAS_LINK_CODE};if ($self->{OBJECT}or @{$self->{C}|| []}or $self->{MYEXTLIB}){$self->{HAS_LINK_CODE}=1;return 1}return$self->{HAS_LINK_CODE}=0}sub init_dirscan {my($self)=@_;my(%dir,%xs,%c,%o,%h,%pl_files,%pm);my%ignore=map {($_=>1)}qw(Makefile.PL Build.PL test.pl t);$Is{VMS}? $ignore{"$self->{DISTVNAME}.dir"}=1 : $ignore{$self->{DISTVNAME}}=1;my$distprefix=$Is{VMS}? qr/^\Q$self->{DISTNAME}\E-v?[\d\.]+\.dir$/i : qr/^\Q$self->{DISTNAME}\E-v?[\d\.]+$/;@ignore{map lc,keys%ignore}=values%ignore if$Is{VMS};if (defined$self->{XS}and!defined$self->{C}){my@c_files=grep {m/\.c(pp|xx)?\z/i}values %{$self->{XS}};my@o_files=grep {m/(?:.(?:o(?:bj)?)|\$\(OBJ_EXT\))\z/i}values %{$self->{XS}};%c=map {$_=>1}@c_files;%o=map {$_=>1}@o_files}for my$name ($self->lsdir($Curdir)){next if$name =~ /\#/;next if$name =~ $distprefix && -d $name;$name=lc($name)if$Is{VMS};next if$name eq $Curdir or $name eq $Updir or $ignore{$name};next unless$self->libscan($name);if (-d $name){next if -l $name;next if$self->{NORECURS};$dir{$name}=$name if (-f $self->catfile($name,"Makefile.PL"))}elsif ($name =~ /\.xs\z/){my($c);($c=$name)=~ s/\.xs\z/.c/;$xs{$name}=$c;$c{$c}=1}elsif ($name =~ /\.c(pp|xx|c)?\z/i){$c{$name}=1 unless$name =~ m/perlmain\.c/}elsif ($name =~ /\.h\z/i){$h{$name}=1}elsif ($name =~ /\.PL\z/){($pl_files{$name}=$name)=~ s/\.PL\z// }elsif (($Is{VMS}|| $Is{Dos})&& $name =~ /[._]pl$/i){local($/);open(my$pl,'<',$name);my$txt=<$pl>;close$pl;if ($txt =~ /Extracting \S+ \(with variable substitutions/){($pl_files{$name}=$name)=~ s/[._]pl\z//i }else {$pm{$name}=$self->catfile($self->{INST_LIBDIR},$name)}}elsif ($name =~ /\.(p[ml]|pod)\z/){$pm{$name}=$self->catfile($self->{INST_LIBDIR},$name)}}$self->{PL_FILES}||= \%pl_files;$self->{DIR}||= [sort keys%dir];$self->{XS}||= \%xs;$self->{C}||= [sort keys%c];$self->{H}||= [sort keys%h];$self->{PM}||= \%pm;my@o_files=@{$self->{C}};%o=(%o,map {$_=>1}grep s/\.c(pp|xx|c)?\z/$self->{OBJ_EXT}/i,@o_files);$self->{O_FILES}=[sort keys%o]}sub init_MANPODS {my$self=shift;for my$man (qw(MAN1 MAN3)){if ($self->{"${man}PODS"}or $self->{"INSTALL${man}DIR"}=~ /^(none|\s*)$/){$self->{"${man}PODS"}||= {}}else {my$init_method="init_${man}PODS";$self->$init_method()}}for my$num (1,3){my$installdirs=uc$self->{INSTALLDIRS};$installdirs='' if$installdirs eq 'PERL';my$mandir=$self->_expand_macros($self->{"INSTALL${installdirs}MAN${num}DIR" });my$section=$num;for ($num,"${num}p","${num}pm",qw<l n o C L>,"L$num"){if ($mandir =~ /\b(?:man|cat)$_$/){$section=$_;last}}$self->{"MAN${num}SECTION"}=$section}}sub _has_pod {my($self,$file)=@_;my($ispod)=0;if (open(my$fh,'<',$file)){while (<$fh>){if (/^=(?:head\d+|item|pod)\b/){$ispod=1;last}}close$fh}else {$ispod=1}return$ispod}sub init_MAN1PODS {my($self)=@_;if (exists$self->{EXE_FILES}){for my$name (@{$self->{EXE_FILES}}){next unless$self->_has_pod($name);$self->{MAN1PODS}->{$name}=$self->catfile("\$(INST_MAN1DIR)",basename($name).".\$(MAN1EXT)")}}}sub init_MAN3PODS {my$self=shift;my%manifypods=();for my$name (keys %{$self->{PM}}){if ($name =~ /\.pod\z/){$manifypods{$name}=$self->{PM}{$name}}elsif ($name =~ /\.p[ml]\z/){if($self->_has_pod($name)){$manifypods{$name}=$self->{PM}{$name}}}}my$parentlibs_re=join '|',@{$self->{PMLIBPARENTDIRS}};for my$name (keys%manifypods){if (($self->{PERL_CORE}and $name =~ /(config|setup).*\.pm/is)or ($name =~ m/^README\.pod$/i)){delete$manifypods{$name};next}my($manpagename)=$name;$manpagename =~ s/\.p(od|m|l)\z//;unless($manpagename =~ s!^\W*($parentlibs_re)\W+!!s){$manpagename=$self->catfile(split(/::/,$self->{PARENT_NAME}),$manpagename)}$manpagename=$self->replace_manpage_separator($manpagename);$self->{MAN3PODS}->{$name}=$self->catfile("\$(INST_MAN3DIR)","$manpagename.\$(MAN3EXT)")}}sub init_PM {my$self=shift;unless($self->{PMLIBDIRS}){if($Is{VMS}){$self->{PMLIBDIRS}=['./lib',"./$self->{BASEEXT}"]}else {$self->{PMLIBDIRS}=['lib',$self->{BASEEXT}]}}my (@pmlibdirs)=@{$self->{PMLIBDIRS}};@{$self->{PMLIBDIRS}}=();my%dir=map {($_=>$_)}@{$self->{DIR}};for my$pmlibdir (@pmlibdirs){-d $pmlibdir &&!$dir{$pmlibdir}&& push @{$self->{PMLIBDIRS}},$pmlibdir}unless($self->{PMLIBPARENTDIRS}){@{$self->{PMLIBPARENTDIRS}}=('lib')}return if$self->{PM}and $self->{ARGS}{PM};if (@{$self->{PMLIBDIRS}}){print "Searching PMLIBDIRS: @{$self->{PMLIBDIRS}}\n" if ($Verbose >= 2);require File::Find;File::Find::find(sub {if (-d $_){unless ($self->libscan($_)){$File::Find::prune=1}return}return if /\#/;return if /~$/;return if /,v$/;return if m{\.swp$};my$path=$File::Find::name;my$prefix=$self->{INST_LIBDIR};my$striplibpath;my$parentlibs_re=join '|',@{$self->{PMLIBPARENTDIRS}};$prefix=$self->{INST_LIB}if ($striplibpath=$path)=~ s{^(\W*)($parentlibs_re)\W}
  	                                       {$1}i;my($inst)=$self->catfile($prefix,$striplibpath);local($_)=$inst;$inst=$self->libscan($inst);print "libscan($path) => '$inst'\n" if ($Verbose >= 2);return unless$inst;if ($self->{XSMULTI}and $inst =~ /\.xs\z/){my($base);($base=$path)=~ s/\.xs\z//;$self->{XS}{$path}="$base.c";push @{$self->{C}},"$base.c";push @{$self->{O_FILES}},"$base$self->{OBJ_EXT}"}else {$self->{PM}{$path}=$inst}},@{$self->{PMLIBDIRS}})}}sub init_DIRFILESEP {my($self)=shift;$self->{DIRFILESEP}='/'}sub init_main {my($self)=@_;$self->{FULLEXT}=$self->catdir(split /::/,$self->{NAME});my(@modparts)=split(/::/,$self->{NAME});my($modfname)=$modparts[-1];eval {require DynaLoader};if (defined&DynaLoader::mod2fname){$modfname=&DynaLoader::mod2fname(\@modparts)}($self->{PARENT_NAME},$self->{BASEEXT})=$self->{NAME}=~ m!(?:([\w:]+)::)?(\w+)\z! ;$self->{PARENT_NAME}||= '';if (defined&DynaLoader::mod2fname){$self->{DLBASE}=$modfname}else {$self->{DLBASE}='$(BASEEXT)'}my$inc_config_dir=dirname($INC{'Config.pm'});my$inc_carp_dir=dirname($INC{'Carp.pm'});unless ($self->{PERL_SRC}){for my$dir_count (1..8){my$dir=$self->catdir(($Updir)x $dir_count);if (-f $self->catfile($dir,"config_h.SH")&& -f $self->catfile($dir,"perl.h")&& -f $self->catfile($dir,"lib","strict.pm")){$self->{PERL_SRC}=$dir ;last}}}warn "PERL_CORE is set but I can't find your PERL_SRC!\n" if $self->{PERL_CORE}and!$self->{PERL_SRC};if ($self->{PERL_SRC}){$self->{PERL_LIB}||= $self->catdir("$self->{PERL_SRC}","lib");$self->{PERL_ARCHLIB}=$self->{PERL_LIB};$self->{PERL_INC}=($Is{Win32})? $self->catdir($self->{PERL_LIB},"CORE"): $self->{PERL_SRC};unless (-s $self->catfile($self->{PERL_SRC},'cflags')or $Is{VMS}&& -s $self->catfile($self->{PERL_SRC},'vmsish.h')or $Is{Win32}){warn qq{
  You cannot build extensions below the perl source tree after executing
  a 'make clean' in the perl source tree.
  
  To rebuild extensions distributed with the perl source you should
  simply Configure (to include those extensions) and then build perl as
  normal. After installing perl the source tree can be deleted. It is
  not needed for building extensions by running 'perl Makefile.PL'
  usually without extra arguments.
  
  It is recommended that you unpack and build additional extensions away
  from the perl source tree.
  }}}else {my$old=$self->{PERL_LIB}|| $self->{PERL_ARCHLIB}|| $self->{PERL_INC};$self->{PERL_LIB}||= $Config{privlibexp};$self->{PERL_ARCHLIB}||= $Config{archlibexp};$self->{PERL_INC}=$self->catdir("$self->{PERL_ARCHLIB}","CORE");my$perl_h;if (not -f ($perl_h=$self->catfile($self->{PERL_INC},"perl.h"))and not $old){my$lib;for my$dir (@INC){$lib=$dir,last if -e $self->catfile($dir,"Config.pm")}if ($lib){my$inc=$Is{Win32}? $self->catdir($lib,"CORE"): dirname$lib;if (-e $self->catfile($inc,"perl.h")){$self->{PERL_LIB}=$lib;$self->{PERL_ARCHLIB}=$lib;$self->{PERL_INC}=$inc;$self->{UNINSTALLED_PERL}=1;print <<EOP}}}}if ($Is{Android}){$self->{PERL_LIB}=File::Spec->rel2abs($self->{PERL_LIB});$self->{PERL_ARCHLIB}=File::Spec->rel2abs($self->{PERL_ARCHLIB})}$self->{PERL_INCDEP}=$self->{PERL_INC};$self->{PERL_ARCHLIBDEP}=$self->{PERL_ARCHLIB};$self->{INSTALLDIRS}||= "site";$self->{MAN1EXT}||= $Config{man1ext};$self->{MAN3EXT}||= $Config{man3ext};print "CONFIG must be an array ref\n" if ($self->{CONFIG}and ref$self->{CONFIG}ne 'ARRAY');$self->{CONFIG}=[]unless (ref$self->{CONFIG});push(@{$self->{CONFIG}},@ExtUtils::MakeMaker::Get_from_Config);push(@{$self->{CONFIG}},'shellflags')if$Config{shellflags};my(%once_only);for my$m (@{$self->{CONFIG}}){next if$once_only{$m};print "CONFIG key '$m' does not exist in Config.pm\n" unless exists$Config{$m};$self->{uc$m}||= $Config{$m};$once_only{$m}=1}$self->{AR_STATIC_ARGS}||= "cr";$self->{OBJ_EXT}||= '.o';$self->{LIB_EXT}||= '.a';$self->{MAP_TARGET}||= "perl";$self->{LIBPERL_A}||= "libperl$self->{LIB_EXT}";warn "Warning: PERL_LIB ($self->{PERL_LIB}) seems not to be a perl library directory
  ... Detected uninstalled Perl.  Trying to continue.
  EOP
          (strict.pm not found)" unless -f $self->catfile("$self->{PERL_LIB}","strict.pm")|| $self->{NAME}eq "ExtUtils::MakeMaker"}sub init_tools {my$self=shift;$self->{ECHO}||= 'echo';$self->{ECHO_N}||= 'echo -n';$self->{RM_F}||= "rm -f";$self->{RM_RF}||= "rm -rf";$self->{TOUCH}||= "touch";$self->{TEST_F}||= "test -f";$self->{TEST_S}||= "test -s";$self->{CP}||= "cp";$self->{MV}||= "mv";$self->{CHMOD}||= "chmod";$self->{FALSE}||= 'false';$self->{TRUE}||= 'true';$self->{LD}||= 'ld';return$self->SUPER::init_tools(@_);$self->{SHELL}||= '/bin/sh';return}sub init_linker {my($self)=shift;$self->{PERL_ARCHIVE}||= '';$self->{PERL_ARCHIVEDEP}||= '';$self->{PERL_ARCHIVE_AFTER}||= '';$self->{EXPORT_LIST}||= ''}sub init_lib2arch {my($self)=shift;for my$libpair ({l=>"privlib",a=>"archlib"},{l=>"sitelib",a=>"sitearch"},{l=>"vendorlib",a=>"vendorarch"},){my$lib="install$libpair->{l}";my$Lib=uc$lib;my$Arch=uc "install$libpair->{a}";if($self->{$Lib}&&!$self->{$Arch}){my($ilib)=$Config{$lib};$self->prefixify($Arch,$ilib,$self->{$Lib});unless (-d $self->{$Arch}){print "Directory $self->{$Arch} not found\n" if$Verbose;$self->{$Arch}=$self->{$Lib}}print "Defaulting $Arch to $self->{$Arch}\n" if$Verbose}}}sub init_PERL {my($self)=shift;my@defpath=();for my$component ($self->{PERL_SRC},$self->path(),$Config{binexp}){push@defpath,$component if defined$component}my$thisperl=$self->canonpath($^X);$thisperl .= $Config{exe_ext}unless $Is{VMS}? $thisperl =~ m/$Config{exe_ext}(;\d+)?$/i : $thisperl =~ m/$Config{exe_ext}$/i;$thisperl=$self->abs2rel($thisperl)if$self->{PERL_CORE};my@perls=($thisperl);push@perls,map {"$_$Config{exe_ext}"}("perl$Config{version}",'perl5','perl');my$miniperl="miniperl$Config{exe_ext}";if($self->{PERL_CORE}){splice@perls,1,0,$miniperl}else {push@perls,$miniperl}$self->{PERL}||= $self->find_perl(5.0,\@perls,\@defpath,$Verbose);my$perl=$self->{PERL};$perl =~ s/^"//;my$has_mcr=$perl =~ s/^MCR\s*//;my$perlflags='';my$stripped_perl;while ($perl){($stripped_perl=$perl)=~ s/"$//;last if -x $stripped_perl;last unless$perl =~ s/(\s+\S+)$//;$perlflags=$1.$perlflags}$self->{PERL}=$stripped_perl;$self->{PERL}='MCR '.$self->{PERL}if$has_mcr || $Is{VMS};my$perl_name='perl';$perl_name='ndbgperl' if$Is{VMS}&& defined$Config{usevmsdebug}&& $Config{usevmsdebug}eq 'define';unless ($self->{FULLPERL}){($self->{FULLPERL}=$self->{PERL})=~ s/\Q$miniperl\E$/$perl_name$Config{exe_ext}/i;$self->{FULLPERL}=qq{"$self->{FULLPERL}"}.$perlflags}$self->{FULLPERL}=~ tr/"//d if$Is{VMS};$self->{FULLPERL}=~ s/^"(\S(:\\|:)?)/$1"/ if$self->is_make_type('dmake');$self->{ABSPERL}=$self->{PERL};$has_mcr=$self->{ABSPERL}=~ s/^MCR\s*//;if($self->file_name_is_absolute($self->{ABSPERL})){$self->{ABSPERL}='$(PERL)'}else {$self->{ABSPERL}=$self->rel2abs($self->{ABSPERL});$self->{ABSPERL}=$self->quote_literal($self->{ABSPERL})if$self->{ABSPERL}=~ /\s/;$self->{ABSPERL}='MCR '.$self->{ABSPERL}if$has_mcr}$self->{PERL}=qq{"$self->{PERL}"}.$perlflags;$self->{PERL}=~ tr/"//d if$Is{VMS};$self->{PERL}=~ s/^"(\S(:\\|:)?)/$1"/ if$self->is_make_type('dmake');$self->{PERL_CORE}=$ENV{PERL_CORE}unless exists$self->{PERL_CORE};$self->{PERL_CORE}=0 unless defined$self->{PERL_CORE};my$lib_paths=$self->{UNINSTALLED_PERL}|| $self->{PERL_CORE}? ($self->{PERL_ARCHLIB}&& $self->{PERL_LIB}&& $self->{PERL_ARCHLIB}ne $self->{PERL_LIB})? q{ "-I$(PERL_LIB)" "-I$(PERL_ARCHLIB)"} : q{ "-I$(PERL_LIB)"} : undef;my$inst_lib_paths=$self->{INST_ARCHLIB}ne $self->{INST_LIB}? 'RUN)'.$perlflags.' "-I$(INST_ARCHLIB)" "-I$(INST_LIB)"' : 'RUN)'.$perlflags.' "-I$(INST_LIB)"';for my$perl (qw(PERL FULLPERL ABSPERL)){my$run=$perl.'RUN';$self->{$run}=qq{\$($perl)};$self->{$run}.= $lib_paths if$lib_paths;$self->{$perl.'RUNINST'}='$('.$perl.$inst_lib_paths}return 1}sub init_platform {my($self)=shift;$self->{MM_Unix_VERSION}=$VERSION;$self->{PERL_MALLOC_DEF}='-DPERL_EXTMALLOC_DEF -Dmalloc=Perl_malloc '.'-Dfree=Perl_mfree -Drealloc=Perl_realloc '.'-Dcalloc=Perl_calloc'}sub platform_constants {my($self)=shift;my$make_frag='';for my$macro (qw(MM_Unix_VERSION PERL_MALLOC_DEF)){next unless defined$self->{$macro};$make_frag .= "$macro = $self->{$macro}\n"}return$make_frag}sub init_PERM {my($self)=shift;$self->{PERM_DIR}=755 unless defined$self->{PERM_DIR};$self->{PERM_RW}=644 unless defined$self->{PERM_RW};$self->{PERM_RWX}=755 unless defined$self->{PERM_RWX};return 1}sub init_xs {my$self=shift;if ($self->has_link_code()){$self->{INST_STATIC}=$self->catfile('$(INST_ARCHAUTODIR)','$(BASEEXT)$(LIB_EXT)');$self->{INST_DYNAMIC}=$self->catfile('$(INST_ARCHAUTODIR)','$(DLBASE).$(DLEXT)');$self->{INST_BOOT}=$self->catfile('$(INST_ARCHAUTODIR)','$(BASEEXT).bs');if ($self->{XSMULTI}){my@exts=$self->_xs_list_basenames;my (@statics,@dynamics,@boots);for my$ext (@exts){my ($v,$d,$f)=File::Spec->splitpath($ext);my@d=File::Spec->splitdir($d);shift@d if defined$d[0]and $d[0]eq 'lib';pop@d if$d[$#d]eq '';my$instdir=$self->catdir('$(INST_ARCHLIB)','auto',@d,$f);my$instfile=$self->catfile($instdir,$f);push@statics,"$instfile\$(LIB_EXT)";my$dynfile=$instfile;eval {require DynaLoader};if (defined&DynaLoader::mod2fname){$dynfile=$self->catfile($instdir,&DynaLoader::mod2fname([@d,$f]))}push@dynamics,"$dynfile.\$(DLEXT)";push@boots,"$instfile.bs"}$self->{INST_STATIC}=join ' ',@statics;$self->{INST_DYNAMIC}=join ' ',@dynamics;$self->{INST_BOOT}=join ' ',@boots}}else {$self->{INST_STATIC}='';$self->{INST_DYNAMIC}='';$self->{INST_BOOT}=''}}sub install {my($self,%attribs)=@_;my(@m);push@m,q{
  install :: pure_install doc_install
  	$(NOECHO) $(NOOP)
  
  install_perl :: pure_perl_install doc_perl_install
  	$(NOECHO) $(NOOP)
  
  install_site :: pure_site_install doc_site_install
  	$(NOECHO) $(NOOP)
  
  install_vendor :: pure_vendor_install doc_vendor_install
  	$(NOECHO) $(NOOP)
  
  pure_install :: pure_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  doc_install :: doc_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  pure__install : pure_site_install
  	$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
  
  doc__install : doc_site_install
  	$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
  
  pure_perl_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  };push@m,q{		read "}.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{" \
  		write "}.$self->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').q{" \
  } unless$self->{NO_PACKLIST};push@m,q{		"$(INST_LIB)" "$(DESTINSTALLPRIVLIB)" \
  		"$(INST_ARCHLIB)" "$(DESTINSTALLARCHLIB)" \
  		"$(INST_BIN)" "$(DESTINSTALLBIN)" \
  		"$(INST_SCRIPT)" "$(DESTINSTALLSCRIPT)" \
  		"$(INST_MAN1DIR)" "$(DESTINSTALLMAN1DIR)" \
  		"$(INST_MAN3DIR)" "$(DESTINSTALLMAN3DIR)"
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) \
  		"}.$self->catdir('$(SITEARCHEXP)','auto','$(FULLEXT)').q{"
  
  
  pure_site_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  };push@m,q{		read "}.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{" \
  		write "}.$self->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').q{" \
  } unless$self->{NO_PACKLIST};push@m,q{		"$(INST_LIB)" "$(DESTINSTALLSITELIB)" \
  		"$(INST_ARCHLIB)" "$(DESTINSTALLSITEARCH)" \
  		"$(INST_BIN)" "$(DESTINSTALLSITEBIN)" \
  		"$(INST_SCRIPT)" "$(DESTINSTALLSITESCRIPT)" \
  		"$(INST_MAN1DIR)" "$(DESTINSTALLSITEMAN1DIR)" \
  		"$(INST_MAN3DIR)" "$(DESTINSTALLSITEMAN3DIR)"
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) \
  		"}.$self->catdir('$(PERL_ARCHLIB)','auto','$(FULLEXT)').q{"
  
  pure_vendor_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  };push@m,q{		read "}.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{" \
  		write "}.$self->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').q{" \
  } unless$self->{NO_PACKLIST};push@m,q{		"$(INST_LIB)" "$(DESTINSTALLVENDORLIB)" \
  		"$(INST_ARCHLIB)" "$(DESTINSTALLVENDORARCH)" \
  		"$(INST_BIN)" "$(DESTINSTALLVENDORBIN)" \
  		"$(INST_SCRIPT)" "$(DESTINSTALLVENDORSCRIPT)" \
  		"$(INST_MAN1DIR)" "$(DESTINSTALLVENDORMAN1DIR)" \
  		"$(INST_MAN3DIR)" "$(DESTINSTALLVENDORMAN3DIR)"
  
  };push@m,q{
  doc_perl_install :: all
  	$(NOECHO) $(NOOP)
  
  doc_site_install :: all
  	$(NOECHO) $(NOOP)
  
  doc_vendor_install :: all
  	$(NOECHO) $(NOOP)
  
  } if$self->{NO_PERLLOCAL};push@m,q{
  doc_perl_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to "$(DESTINSTALLARCHLIB)/perllocal.pod"
  	-$(NOECHO) $(MKPATH) "$(DESTINSTALLARCHLIB)"
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" "$(INSTALLPRIVLIB)" \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> "}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{"
  
  doc_site_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to "$(DESTINSTALLARCHLIB)/perllocal.pod"
  	-$(NOECHO) $(MKPATH) "$(DESTINSTALLARCHLIB)"
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" "$(INSTALLSITELIB)" \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> "}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{"
  
  doc_vendor_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to "$(DESTINSTALLARCHLIB)/perllocal.pod"
  	-$(NOECHO) $(MKPATH) "$(DESTINSTALLARCHLIB)"
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" "$(INSTALLVENDORLIB)" \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> "}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{"
  
  } unless$self->{NO_PERLLOCAL};push@m,q{
  uninstall :: uninstall_from_$(INSTALLDIRS)dirs
  	$(NOECHO) $(NOOP)
  
  uninstall_from_perldirs ::
  	$(NOECHO) $(UNINSTALL) "}.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{"
  
  uninstall_from_sitedirs ::
  	$(NOECHO) $(UNINSTALL) "}.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{"
  
  uninstall_from_vendordirs ::
  	$(NOECHO) $(UNINSTALL) "}.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{"
  };join("",@m)}sub installbin {my($self)=shift;return "" unless$self->{EXE_FILES}&& ref$self->{EXE_FILES}eq "ARRAY";my@exefiles=sort @{$self->{EXE_FILES}};return "" unless@exefiles;@exefiles=map vmsify($_),@exefiles if$Is{VMS};my%fromto;for my$from (@exefiles){my($path)=$self->catfile('$(INST_SCRIPT)',basename($from));local($_)=$path;my$to=$self->libscan($path);print "libscan($from) => '$to'\n" if ($Verbose >=2);$to=vmsify($to)if$Is{VMS};$fromto{$from}=$to}my@to=sort values%fromto;my@m;push(@m,qq{
  EXE_FILES = @exefiles
  
  pure_all :: @to
  	\$(NOECHO) \$(NOOP)
  
  realclean ::
  });push@m,map "\t$_\n",$self->split_command('$(RM_F)',@to);push@m,"\n";my@froms=sort keys%fromto;for my$from (@froms){push@m,_sprintf562 <<'MAKE',$from,$fromto{$from}}join "",@m}sub linkext {my($self,%attribs)=@_;my$linktype=$attribs{LINKTYPE};$linktype=$self->{LINKTYPE}unless defined$linktype;if (defined$linktype and $linktype eq ''){warn "Warning: LINKTYPE set to '', no longer necessary\n"}$linktype='$(LINKTYPE)' unless defined$linktype;"
  %2$s : %1$s $(FIRST_MAKEFILE) $(INST_SCRIPT)$(DFSEP).exists $(INST_BIN)$(DFSEP).exists
  	$(NOECHO) $(RM_F) %2$s
  	$(CP) %1$s %2$s
  	$(FIXIN) %2$s
  	-$(NOECHO) $(CHMOD) $(PERM_RWX) %2$s
  
  MAKE
  linkext :: $linktype
  	\$(NOECHO) \$(NOOP)
  "}sub lsdir {my(undef,$dir,$regex)=@_;opendir(my$dh,defined($dir)? $dir : ".")or return;my@ls=readdir$dh;closedir$dh;@ls=grep(/$regex/,@ls)if defined$regex;@ls}sub macro {my($self,%attribs)=@_;my@m;for my$key (sort keys%attribs){my$val=$attribs{$key};push@m,"$key = $val\n"}join "",@m}sub makeaperl {my($self,%attribs)=@_;my($makefilename,$searchdirs,$static,$extra,$perlinc,$target,$tmp,$libperl)=@attribs{qw(MAKE DIRS STAT EXTRA INCL TARGET TMP LIBPERL)};s/^(.*)/"-I$1"/ for @{$perlinc || []};my(@m);push@m,"
  # --- MakeMaker makeaperl section ---
  MAP_TARGET    = $target
  FULLPERL      = $self->{FULLPERL}
  MAP_PERLINC   = @{$perlinc || []}
  ";return join '',@m if$self->{PARENT};my($dir)=join ":",@{$self->{DIR}};unless ($self->{MAKEAPERL}){push@m,q{
  $(MAP_TARGET) :: $(MAKE_APERL_FILE)
  	$(MAKE) $(USEMAKEFILE) $(MAKE_APERL_FILE) $@
  
  $(MAKE_APERL_FILE) : static $(FIRST_MAKEFILE) pm_to_blib
  	$(NOECHO) $(ECHO) Writing \"$(MAKE_APERL_FILE)\" for this $(MAP_TARGET)
  	$(NOECHO) $(PERLRUNINST) \
  		Makefile.PL DIR="},$dir,q{" \
  		MAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \
  		MAKEAPERL=1 NORECURS=1 CCCDLFLAGS=};for (@ARGV){my$arg=$_;if ($arg =~ /(^.*?=)(.*['\s].*)/){$arg=$1 .$self->quote_literal($2)}push@m," \\\n\t\t$arg"}push@m,"\n";return join '',@m}my$cccmd=$self->const_cccmd($libperl);$cccmd =~ s/^CCCMD\s*=\s*//;$cccmd =~ s/\$\(INC\)/ "-I$self->{PERL_INC}" /;$cccmd .= " $Config{cccdlflags}" if ($Config{useshrplib}eq 'true');$cccmd =~ s/\(CC\)/\(PERLMAINCC\)/;my$linkcmd=join ' ',"\$(CC)",grep($_,@Config{qw(ldflags ccdlflags)});$linkcmd =~ s/\s+/ /g;$linkcmd =~ s,(perl\.exp),\$(PERL_INC)/$1,;my$staticlib21=$self->_find_static_libs($searchdirs);$static=[]unless$static;@$staticlib21{@{$static}}=(1)x @{$static};$extra=[]unless$extra && ref$extra eq 'ARRAY';for (sort keys %$staticlib21){next unless /\Q$self->{LIB_EXT}\E\z/;$_=dirname($_)."/extralibs.ld";push @$extra,$_}s/^(.*)/"-I$1"/ for @{$perlinc || []};$target ||= "perl";$tmp ||= ".";my@map_static=reverse sort keys %$staticlib21;push@m,"
  MAP_LINKCMD   = $linkcmd
  MAP_STATIC    = ",join(" \\\n\t",map {qq{"$_"}}@map_static),"
  MAP_STATICDEP = ",join(' ',map {$self->quote_dep($_)}@map_static),"
  
  MAP_PRELIBS   = $Config{perllibs} $Config{cryptlib}
  ";my$lperl;if (defined$libperl){($lperl=$libperl)=~ s/\$\(A\)/$self->{LIB_EXT}/}unless ($libperl && -f $lperl){my$dir=$self->{PERL_SRC}|| "$self->{PERL_ARCHLIB}/CORE";$dir="$self->{PERL_ARCHLIB}/.." if$self->{UNINSTALLED_PERL};$libperl ||= "libperl$self->{LIB_EXT}";$libperl="$dir/$libperl";$lperl ||= "libperl$self->{LIB_EXT}";$lperl="$dir/$lperl";if (!-f $libperl and!-f $lperl){if ($Is{SunOS}){$lperl=$libperl="$dir/$Config{libperl}";$libperl='' if$Is{SunOS4}}}print <<EOF unless -f $lperl || defined($self->{PERL_SRC})}my$llibperl=$libperl ? '$(MAP_LIBPERL)' : '-lperl';my$libperl_dep=$self->quote_dep($libperl);push@m,"
  Warning: $libperl not found
  If you're going to build a static perl binary, make sure perl is installed
  otherwise ignore this warning
  EOF
  MAP_LIBPERL = $libperl
  MAP_LIBPERLDEP = $libperl_dep
  LLIBPERL    = $llibperl
  ";push@m,'
  $(INST_ARCHAUTODIR)/extralibs.all : $(INST_ARCHAUTODIR)$(DFSEP).exists '.join(" \\\n\t",@$extra).'
  	$(NOECHO) $(RM_F)  $@
  	$(NOECHO) $(TOUCH) $@
  ';for my$catfile (@$extra){push@m,"\tcat $catfile >> \$\@\n"}my$ldfrom=$self->{XSMULTI}? '' : '$(LDFROM)';push@m,_sprintf562 <<'EOF',$tmp,$ldfrom,$self->xs_obj_opt('$@'),$makefilename;push@m,"\t".$self->cd($tmp,qq[$cccmd "-I\$(PERL_INC)" perlmain.c])."\n";my$maybe_DynaLoader=$Config{usedl}? 'q(DynaLoader)' : '';push@m,_sprintf562 <<'EOF',$tmp,$makefilename,$maybe_DynaLoader;push@m,"\t",q{$(NOECHO) $(PERL) "$(INSTALLSCRIPT)/fixpmain"
  $(MAP_TARGET) :: %1$s/perlmain$(OBJ_EXT) $(MAP_LIBPERLDEP) $(MAP_STATICDEP) $(INST_ARCHAUTODIR)/extralibs.all
  	$(MAP_LINKCMD) %2$s $(OPTIMIZE) %1$s/perlmain$(OBJ_EXT) %3$s $(MAP_STATIC) "$(LLIBPERL)" `cat $(INST_ARCHAUTODIR)/extralibs.all` $(MAP_PRELIBS)
  	$(NOECHO) $(ECHO) "To install the new '$(MAP_TARGET)' binary, call"
  	$(NOECHO) $(ECHO) "    $(MAKE) $(USEMAKEFILE) %4$s inst_perl MAP_TARGET=$(MAP_TARGET)"
  	$(NOECHO) $(ECHO) "    $(MAKE) $(USEMAKEFILE) %4$s map_clean"
  
  %1$s/perlmain\$(OBJ_EXT): %1$s/perlmain.c
  EOF
  
  %1$s/perlmain.c: %2$s
  	$(NOECHO) $(ECHO) Writing $@
  	$(NOECHO) $(PERL) $(MAP_PERLINC) "-MExtUtils::Miniperl" \
  		-e "writemain(grep(s#.*/auto/##s, @ARGV), %3$s)" $(MAP_STATIC) > $@t
  	$(MV) $@t $@
  
  EOF
  } if (defined (&Dos::UseLFN)&& Dos::UseLFN()==0);push@m,q{
  doc_inst_perl :
  	$(NOECHO) $(ECHO) Appending installation info to "$(DESTINSTALLARCHLIB)/perllocal.pod"
  	-$(NOECHO) $(MKPATH) "$(DESTINSTALLARCHLIB)"
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Perl binary" "$(MAP_TARGET)" \
  		MAP_STATIC "$(MAP_STATIC)" \
  		MAP_EXTRA "`cat $(INST_ARCHAUTODIR)/extralibs.all`" \
  		MAP_LIBPERL "$(MAP_LIBPERL)" \
  		>> "}.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{"
  
  };push@m,q{
  inst_perl : pure_inst_perl doc_inst_perl
  
  pure_inst_perl : $(MAP_TARGET)
  	}.$self->{CP}.q{ $(MAP_TARGET) "}.$self->catfile('$(DESTINSTALLBIN)','$(MAP_TARGET)').q{"
  
  clean :: map_clean
  
  map_clean :
  	}.$self->{RM_F}.qq{ $tmp/perlmain\$(OBJ_EXT) $tmp/perlmain.c \$(MAP_TARGET) $makefilename \$(INST_ARCHAUTODIR)/extralibs.all
  };join '',@m}sub _find_static_libs {my ($self,$searchdirs)=@_;my$installed_version=join('/','auto',$self->{FULLEXT},"$self->{BASEEXT}$self->{LIB_EXT}");my%staticlib21;require File::Find;File::Find::find(sub {if ($File::Find::name =~ m{/auto/share\z}){$File::Find::prune=1;return}return unless m/\Q$self->{LIB_EXT}\E$/;return unless -f 'extralibs.ld';return if m/^libperl/ or m/^perl\Q$self->{LIB_EXT}\E$/;return if m/_pure_\w+_\w+_\w+\.\w+$/ and -f "$File::Find::dir/.pure";if(exists$self->{INCLUDE_EXT}){my$found=0;(my$xx=$File::Find::name)=~ s,.*?/auto/,,s;$xx =~ s,/?$_,,;$xx =~ s,/,::,g;for my$incl ((@{$self->{INCLUDE_EXT}},'DynaLoader')){if($xx eq $incl){$found++;last}}return unless$found}elsif(exists$self->{EXCLUDE_EXT}){(my$xx=$File::Find::name)=~ s,.*?/auto/,,s;$xx =~ s,/?$_,,;$xx =~ s,/,::,g;for my$excl (@{$self->{EXCLUDE_EXT}}){return if($xx eq $excl)}}return if$File::Find::name =~ m:\Q$installed_version\E\z:;return if!$self->xs_static_lib_is_xs($_);use Cwd 'cwd';$staticlib21{cwd()."/" .$_}++},grep(-d $_,map {$self->catdir($_,'auto')}@{$searchdirs || []}));return \%staticlib21}sub xs_static_lib_is_xs {my ($self,$libfile)=@_;my$devnull=File::Spec->devnull;return `nm $libfile 2>$devnull` =~ /\b_?boot_/}sub makefile {my($self)=shift;my$m;$m='
  $(OBJECT) : $(FIRST_MAKEFILE)
  
  ' if$self->{OBJECT};my$newer_than_target=$Is{VMS}? '$(MMS$SOURCE_LIST)' : '$?';my$mpl_args=join " ",map qq["$_"],@ARGV;my$cross='';if (defined$::Cross::platform){$cross="-MCross=$::Cross::platform "}$m .= sprintf <<'MAKE_FRAG',$newer_than_target,$cross,$mpl_args;return$m}sub maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d $file;return}sub needs_linking {my($self)=shift;my$caller=(caller(0))[3];confess("needs_linking called too early")if $caller =~ /^ExtUtils::MakeMaker::/;return$self->{NEEDS_LINKING}if defined$self->{NEEDS_LINKING};if ($self->has_link_code or $self->{MAKEAPERL}){$self->{NEEDS_LINKING}=1;return 1}for my$child (keys %{$self->{CHILDREN}}){if ($self->{CHILDREN}->{$child}->needs_linking){$self->{NEEDS_LINKING}=1;return 1}}return$self->{NEEDS_LINKING}=0}sub parse_abstract {my($self,$parsefile)=@_;my$result;local $/="\n";open(my$fh,'<',$parsefile)or die "Could not open '$parsefile': $!";binmode$fh;my$inpod=0;my$pod_encoding;my$package=$self->{DISTNAME};$package =~ s/-/::/g;while (<$fh>){$inpod=/^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;next if!$inpod;s#\r*\n\z##;if (/^=encoding\s*(.*)$/i){$pod_encoding=$1}if (/^($package(?:\.pm)? \s+ -+ \s+)(.*)/x){$result=$2;next}next unless$result;if ($result && (/^\s*$/ || /^\=/)){last}$result=join ' ',$result,$_}close$fh;if ($pod_encoding and!("$]" < 5.008 or!$Config{useperlio})){eval {require Encode;$result=Encode::decode($pod_encoding,$result)}}return$result}sub parse_version {my($self,$parsefile)=@_;my$result;local $/="\n";local $_;open(my$fh,'<',$parsefile)or die "Could not open '$parsefile': $!";my$inpod=0;while (<$fh>){$inpod=/^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;next if$inpod || /^\s*#/;chop;next if /^\s*(if|unless|elsif)/;if (m{^ \s* package \s+ \w[\w\:\']* \s+ (v?[0-9._]+) \s* (;|\{)  }x){local $^W=0;$result=$1}elsif (m{(?<!\\) ([\$*]) (([\w\:\']*) \bVERSION)\b .* (?<![<>=!])\=[^=]}x){$result=$self->get_version($parsefile,$1,$2)}else {next}last if defined$result}close$fh;if (defined$result && $result !~ /^v?[\d_\.]+$/){require version;my$normal=eval {version->new($result)};$result=$normal if defined$normal}$result="undef" unless defined$result;return$result}sub get_version {my ($self,$parsefile,$sigil,$name)=@_;my$line=$_;{package ExtUtils::MakeMaker::_version;undef*version;eval {require version;version::->import};no strict;local *{$name};local $^W=0;$line=$1 if$line =~ m{^(.+)}s;eval($line);return ${$name}}}sub pasthru {my($self)=shift;my(@m);my(@pasthru);my($sep)=$Is{VMS}? ',' : '';$sep .= "\\\n\t";for my$key (qw(LIB LIBPERL_A LINKTYPE OPTIMIZE PREFIX INSTALL_BASE)){next unless defined$self->{$key};push@pasthru,"$key=\"\$($key)\""}for my$key (qw(DEFINE INC)){my$val=qq{\$($key)};chomp($val=$self->{$key})if defined$self->{$key};$val .= " \$(PASTHRU_$key)";my$quoted=$self->quote_literal($val);push@pasthru,qq{PASTHRU_$key=$quoted}}push@m,"\nPASTHRU = ",join ($sep,@pasthru),"\n";join "",@m}sub perl_script {my($self,$file)=@_;return$file if -r $file && -f _;return}sub perldepend {my($self)=shift;my(@m);my$make_config=$self->cd('$(PERL_SRC)','$(MAKE) lib/Config.pm');push@m,sprintf <<'MAKE_FRAG',$make_config if$self->{PERL_SRC};return join "",@m unless$self->needs_linking;if ($self->{OBJECT}){push@m,$self->_perl_header_files_fragment("/")}push@m,join(" ",sort values %{$self->{XS}})." : \$(XSUBPPDEPS)\n" if %{$self->{XS}};return join "\n",@m}sub pm_to_blib {my$self=shift;my($autodir)=$self->catdir('$(INST_LIB)','auto');my$r=q{
  # We take a very conservative approach here, but it's worth it.
  # We move Makefile to Makefile.old here to avoid gnu make looping.
  $(FIRST_MAKEFILE) : Makefile.PL $(CONFIGDEP)
  	$(NOECHO) $(ECHO) "Makefile out-of-date with respect to %s"
  	$(NOECHO) $(ECHO) "Cleaning current config before rebuilding Makefile..."
  	-$(NOECHO) $(RM_F) $(MAKEFILE_OLD)
  	-$(NOECHO) $(MV)   $(FIRST_MAKEFILE) $(MAKEFILE_OLD)
  	- $(MAKE) $(USEMAKEFILE) $(MAKEFILE_OLD) clean $(DEV_NULL)
  	$(PERLRUN) %sMakefile.PL %s
  	$(NOECHO) $(ECHO) "==> Your Makefile has been rebuilt. <=="
  	$(NOECHO) $(ECHO) "==> Please rerun the $(MAKE) command.  <=="
  	$(FALSE)
  
  MAKE_FRAG
  # Check for unpropogated config.sh changes. Should never happen.
  # We do NOT just update config.h because that is not sufficient.
  # An out of date config.h is not fatal but complains loudly!
  $(PERL_INCDEP)/config.h: $(PERL_SRC)/config.sh
  	-$(NOECHO) $(ECHO) "Warning: $(PERL_INC)/config.h out of date with $(PERL_SRC)/config.sh"; $(FALSE)
  
  $(PERL_ARCHLIB)/Config.pm: $(PERL_SRC)/config.sh
  	$(NOECHO) $(ECHO) "Warning: $(PERL_ARCHLIB)/Config.pm may be out of date with $(PERL_SRC)/config.sh"
  	%s
  MAKE_FRAG
  pm_to_blib : $(FIRST_MAKEFILE) $(TO_INST_PM)
  };my$pm_to_blib=$self->oneliner(<<CODE,['-MExtUtils::Install']);my@cmds=$self->split_command($pm_to_blib,map {($self->quote_literal($_)=>$self->quote_literal($self->{PM}->{$_}))}sort keys %{$self->{PM}});$r .= join '',map {"\t\$(NOECHO) $_\n"}@cmds;$r .= qq{\t\$(NOECHO) \$(TOUCH) pm_to_blib\n};return$r}sub _ppd_version {my ($self,$string)=@_;return join ',',((split /\./,$string),(0)x 4)[0..3]}sub ppd {my($self)=@_;my$abstract=$self->{ABSTRACT}|| '';$abstract =~ s/\n/\\n/sg;$abstract =~ s/</&lt;/g;$abstract =~ s/>/&gt;/g;my$author=join(', ',@{ref$self->{AUTHOR}eq 'ARRAY' ? $self->{AUTHOR}: [$self->{AUTHOR}|| '']});$author =~ s/</&lt;/g;$author =~ s/>/&gt;/g;my$ppd_file="$self->{DISTNAME}.ppd";my@ppd_chunks=qq(<SOFTPKG NAME="$self->{DISTNAME}" VERSION="$self->{VERSION}">\n);push@ppd_chunks,sprintf <<'PPD_HTML',$abstract,$author;push@ppd_chunks,"    <IMPLEMENTATION>\n";if ($self->{MIN_PERL_VERSION}){my$min_perl_version=$self->_ppd_version($self->{MIN_PERL_VERSION});push@ppd_chunks,sprintf <<'PPD_PERLVERS',$min_perl_version}my%prereqs=%{$self->{PREREQ_PM}};delete$prereqs{perl};for my$prereq (sort keys%prereqs){my$name=$prereq;$name .= '::' unless$name =~ /::/;my$version=$prereqs{$prereq};my%attrs=(NAME=>$name);$attrs{VERSION}=$version if$version;my$attrs=join " ",map {qq[$_="$attrs{$_}"]}sort keys%attrs;push@ppd_chunks,qq(        <REQUIRE $attrs />\n)}my$archname=$Config{archname};if ("$]" >= 5.008){$archname .= "-$Config{PERL_REVISION}.$Config{PERL_VERSION}"}push@ppd_chunks,sprintf <<'PPD_OUT',$archname;if ($self->{PPM_INSTALL_SCRIPT}){if ($self->{PPM_INSTALL_EXEC}){push@ppd_chunks,sprintf qq{        <INSTALL EXEC="%s">%s</INSTALL>\n},$self->{PPM_INSTALL_EXEC},$self->{PPM_INSTALL_SCRIPT}}else {push@ppd_chunks,sprintf qq{        <INSTALL>%s</INSTALL>\n},$self->{PPM_INSTALL_SCRIPT}}}if ($self->{PPM_UNINSTALL_SCRIPT}){if ($self->{PPM_UNINSTALL_EXEC}){push@ppd_chunks,sprintf qq{        <UNINSTALL EXEC="%s">%s</UNINSTALL>\n},$self->{PPM_UNINSTALL_EXEC},$self->{PPM_UNINSTALL_SCRIPT}}else {push@ppd_chunks,sprintf qq{        <UNINSTALL>%s</UNINSTALL>\n},$self->{PPM_UNINSTALL_SCRIPT}}}my ($bin_location)=$self->{BINARY_LOCATION}|| '';$bin_location =~ s/\\/\\\\/g;push@ppd_chunks,sprintf <<'PPD_XML',$bin_location;my@ppd_cmds=$self->stashmeta(join('',@ppd_chunks),$ppd_file);return sprintf <<'PPD_OUT',join "\n\t",@ppd_cmds}sub prefixify {my($self,$var,$sprefix,$rprefix,$default)=@_;my$path=$self->{uc$var}|| $Config_Override{lc$var}|| $Config{lc$var}|| '';$rprefix .= '/' if$sprefix =~ m|/$|;warn "  prefixify $var => $path\n" if$Verbose >= 2;warn "    from $sprefix to $rprefix\n" if$Verbose >= 2;if($self->{ARGS}{PREFIX}&& $path !~ s{^\Q$sprefix\E\b}{$rprefix}s){warn "    cannot prefix, using default.\n" if$Verbose >= 2;warn "    no default!\n" if!$default && $Verbose >= 2;$path=$self->catdir($rprefix,$default)if$default}print "    now $path\n" if$Verbose >= 2;return$self->{uc$var}=$path}sub processPL {my$self=shift;my$pl_files=$self->{PL_FILES};return "" unless$pl_files;my$m='';for my$plfile (sort keys %$pl_files){my$targets=$pl_files->{$plfile};my$list=ref($targets)eq 'HASH' ? [sort keys %$targets ]: ref($targets)eq 'ARRAY' ? $pl_files->{$plfile}: [$pl_files->{$plfile}];for my$target (@$list){if($Is{VMS}){$plfile=vmsify($self->eliminate_macros($plfile));$target=vmsify($self->eliminate_macros($target))}my$pm_dep;my$perlrun;if(defined$self->{PM}{$target}){$pm_dep='';$perlrun='PERLRUN'}else {$pm_dep='pm_to_blib';$perlrun='PERLRUNINST'}my$extra_inputs='';if(ref($targets)eq 'HASH'){my$inputs=ref($targets->{$target})? $targets->{$target}: [$targets->{$target}];for my$input (@$inputs){if($Is{VMS}){$input=vmsify($self->eliminate_macros($input))}$extra_inputs .= ' '.$input}}$m .= <<MAKE_FRAG}}return$m}sub specify_shell {return ''}sub quote_paren {my$arg=shift;$arg =~ s{\$\((.+?)\)}{\$\\\\($1\\\\)}g;$arg =~ s{(?<!\\)([()])}{\\$1}g;$arg =~ s{\$\\\\\((.+?)\\\\\)}{\$($1)}g;return$arg}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s,/+,::,g;return$man}sub cd {my($self,$dir,@cmds)=@_;my$make_frag=join "\n\t",map {"cd $dir && $_"}@cmds;return$make_frag}sub oneliner {my($self,$cmd,$switches)=@_;$switches=[]unless defined$switches;$cmd =~ s{^\n+}{};$cmd =~ s{\n+$}{};my@cmds=split /\n/,$cmd;$cmd=join " \n\t  -e ",map$self->quote_literal($_),@cmds;$cmd=$self->escape_newlines($cmd);$switches=join ' ',@$switches;return qq{\$(ABSPERLRUN) $switches -e $cmd --}}sub quote_literal {my($self,$text,$opts)=@_;$opts->{allow_variables}=1 unless defined$opts->{allow_variables};$text =~ s{'}{'\\''}g;$text=$opts->{allow_variables}? $self->escape_dollarsigns($text): $self->escape_all_dollarsigns($text);return "'$text'"}sub escape_newlines {my($self,$text)=@_;$text =~ s{\n}{\\\n}g;return$text}sub max_exec_len {my$self=shift;if (!defined$self->{_MAX_EXEC_LEN}){if (my$arg_max=eval {require POSIX;&POSIX::ARG_MAX}){$self->{_MAX_EXEC_LEN}=$arg_max}else {$self->{_MAX_EXEC_LEN}=4096}}return$self->{_MAX_EXEC_LEN}}sub static {my($self)=shift;'
  pm_to_blib({\@ARGV}, '$autodir', q[\$(PM_FILTER)], '\$(PERM_DIR)')
  CODE
      <ABSTRACT>%s</ABSTRACT>
      <AUTHOR>%s</AUTHOR>
  PPD_HTML
          <PERLCORE VERSION="%s" />
  PPD_PERLVERS
          <ARCHITECTURE NAME="%s" />
  PPD_OUT
          <CODEBASE HREF="%s" />
      </IMPLEMENTATION>
  </SOFTPKG>
  PPD_XML
  # Creates a PPD (Perl Package Description) for a binary distribution.
  ppd :
  	%s
  PPD_OUT
  
  pure_all :: $target
  	\$(NOECHO) \$(NOOP)
  
  $target :: $plfile $pm_dep $extra_inputs
  	\$($perlrun) $plfile $target $extra_inputs
  MAKE_FRAG
  ## $(INST_PM) has been moved to the all: target.
  ## It remains here for awhile to allow for old usage: "make static"
  static :: $(FIRST_MAKEFILE) $(INST_STATIC)
  	$(NOECHO) $(NOOP)
  '}sub static_lib {my($self)=@_;return '' unless$self->has_link_code;my(@m);my@libs;if ($self->{XSMULTI}){for my$ext ($self->_xs_list_basenames){my ($v,$d,$f)=File::Spec->splitpath($ext);my@d=File::Spec->splitdir($d);shift@d if$d[0]eq 'lib';my$instdir=$self->catdir('$(INST_ARCHLIB)','auto',@d,$f);my$instfile=$self->catfile($instdir,"$f\$(LIB_EXT)");my$objfile="$ext\$(OBJ_EXT)";push@libs,[$objfile,$instfile,$instdir ]}}else {@libs=([qw($(OBJECT) $(INST_STATIC) $(INST_ARCHAUTODIR)) ])}push@m,map {$self->xs_make_static_lib(@$_)}@libs;join "\n",@m}sub xs_make_static_lib {my ($self,$from,$to,$todir)=@_;my@m=sprintf '%s: %s $(MYEXTLIB) %s$(DFSEP).exists'."\n",$to,$from,$todir;push@m,"\t\$(RM_F) \"\$\@\"\n";push@m,$self->static_lib_fixtures;push@m,$self->static_lib_pure_cmd($from);push@m,"\t\$(CHMOD) \$(PERM_RWX) \$\@\n";push@m,$self->static_lib_closures($todir);join '',@m}sub static_lib_closures {my ($self,$todir)=@_;my@m=sprintf <<'MAKE_FRAG',$todir;push@m,<<'MAKE_FRAG' if$self->{PERL_SRC}&& $self->{EXTRALIBS};@m}sub static_lib_fixtures {my ($self)=@_;return unless$self->{MYEXTLIB};"\t\$(CP) \$(MYEXTLIB) \"\$\@\"\n"}sub static_lib_pure_cmd {my ($self,$from)=@_;my$ar;if (exists$self->{FULL_AR}&& -x $self->{FULL_AR}){$ar='FULL_AR'}else {$ar='AR'}sprintf <<'MAKE_FRAG',$ar,$from}sub staticmake {my($self,%attribs)=@_;my(@static);my(@searchdirs)=($self->{PERL_ARCHLIB},$self->{SITEARCHEXP},$self->{INST_ARCHLIB});if (@{$self->{C}}){@static=$self->catfile($self->{INST_ARCHLIB},"auto",$self->{FULLEXT},"$self->{BASEEXT}$self->{LIB_EXT}")}my(@perlinc)=($self->{INST_ARCHLIB},$self->{INST_LIB},$self->{PERL_ARCHLIB},$self->{PERL_LIB});$self->makeaperl(MAKE=>$self->{MAKEFILE},DIRS=>\@searchdirs,STAT=>\@static,INCL=>\@perlinc,TARGET=>$self->{MAP_TARGET},TMP=>"",LIBPERL=>$self->{LIBPERL_A})}sub subdir_x {my($self,$subdir)=@_;my$subdir_cmd=$self->cd($subdir,'$(MAKE) $(USEMAKEFILE) $(FIRST_MAKEFILE) all $(PASTHRU)');return sprintf <<'EOT',$subdir_cmd}sub subdirs {my($self)=shift;my(@m);for my$dir (@{$self->{DIR}}){push@m,$self->subdir_x($dir)}if (@m){unshift@m,<<'EOF'}else {push(@m,"\n# none")}join('',@m)}sub test {my($self,%attribs)=@_;my$tests=$attribs{TESTS}|| '';if (!$tests && -d 't' && defined$attribs{RECURSIVE_TEST_FILES}){$tests=$self->find_tests_recursive}elsif (!$tests && -d 't'){$tests=$self->find_tests}$tests =~ s!/!\\!g if$self->is_make_type('nmake');my@m;my$default_testtype=$Config{usedl}? 'dynamic' : 'static';push@m,<<EOF;for my$linktype (qw(dynamic static)){my$directdeps=join ' ',grep!$self->{SKIPHASH}{$_},$linktype,"pure_all";push@m,"subdirs-test_$linktype :: $directdeps\n";for my$dir (@{$self->{DIR}}){my$test=$self->cd($dir,"\$(MAKE) test_$linktype \$(PASTHRU)");push@m,"\t\$(NOECHO) $test\n"}push@m,"\n";if ($tests or -f "test.pl"){for my$testspec (['','' ],['db',' $(TESTDB_SW)' ]){my ($db,$switch)=@$testspec;my ($command,$deps);$deps=$db eq 'db' ? $directdeps : "subdirs-test_$linktype";if ($linktype eq 'static' and $self->needs_linking){my$target=File::Spec->rel2abs('$(MAP_TARGET)');$command=qq{"$target" \$(MAP_PERLINC)};$deps .= ' $(MAP_TARGET)'}else {$command='$(FULLPERLRUN)' .$switch}push@m,"test${db}_$linktype :: $deps\n";if ($db eq 'db'){push@m,$self->test_via_script($command,'$(TEST_FILE)')}else {push@m,$self->test_via_script($command,'$(TEST_FILE)')if -f "test.pl";push@m,$self->test_via_harness($command,'$(TEST_FILES)')if$tests}push@m,"\n"}}else {push@m,_sprintf562 <<'EOF',$linktype}}join "",@m}sub test_via_harness {my($self,$perl,$tests)=@_;return$self->SUPER::test_via_harness("PERL_DL_NONLAZY=1 $perl",$tests)}sub test_via_script {my($self,$perl,$script)=@_;return$self->SUPER::test_via_script("PERL_DL_NONLAZY=1 $perl",$script)}sub tool_xsubpp {my($self)=shift;return "" unless$self->needs_linking;my$xsdir;my@xsubpp_dirs=@INC;unshift@xsubpp_dirs,$self->{PERL_LIB}if$self->{PERL_CORE};my$foundxsubpp=0;for my$dir (@xsubpp_dirs){$xsdir=$self->catdir($dir,'ExtUtils');if(-r $self->catfile($xsdir,"xsubpp")){$foundxsubpp=1;last}}die "ExtUtils::MM_Unix::tool_xsubpp : Can't find xsubpp" if!$foundxsubpp;my$tmdir=$self->catdir($self->{PERL_LIB},"ExtUtils");my(@tmdeps)=$self->catfile($tmdir,'typemap');if($self->{TYPEMAPS}){for my$typemap (@{$self->{TYPEMAPS}}){if(!-f $typemap){warn "Typemap $typemap not found.\n"}else {$typemap=vmsify($typemap)if$Is{VMS};push(@tmdeps,$typemap)}}}push(@tmdeps,"typemap")if -f "typemap";my@tmargs=map {'-typemap '.$self->quote_literal(File::Spec->rel2abs($_))}@tmdeps;$_=$self->quote_dep($_)for@tmdeps;if(exists$self->{XSOPT}){unshift(@tmargs,$self->{XSOPT})}if ($Is{VMS}&& $Config{'ldflags'}&& $Config{'ldflags'}=~ m!/Debug!i && (!exists($self->{XSOPT})|| $self->{XSOPT}!~ /linenumbers/)){unshift(@tmargs,'-nolinenumbers')}$self->{XSPROTOARG}="" unless defined$self->{XSPROTOARG};my$xsdirdep=$self->quote_dep($xsdir);return qq{
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" > %s$(DFSEP)extralibs.ld
  MAKE_FRAG
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" >> $(PERL_SRC)$(DFSEP)ext.libs
  MAKE_FRAG
  	$(%s) $(AR_STATIC_ARGS) "$@" %s
  	$(RANLIB) "$@"
  MAKE_FRAG
  
  subdirs ::
  	$(NOECHO) %s
  EOT
  
  # The default clean, realclean and test targets in this Makefile
  # have automatically been given entries for each subdir.
  
  EOF
  TEST_VERBOSE=0
  TEST_TYPE=test_\$(LINKTYPE)
  TEST_FILE = test.pl
  TEST_FILES = $tests
  TESTDB_SW = -d
  
  testdb :: testdb_\$(LINKTYPE)
  	\$(NOECHO) \$(NOOP)
  
  test :: \$(TEST_TYPE)
  	\$(NOECHO) \$(NOOP)
  
  # Occasionally we may face this degenerate target:
  test_ : test_$default_testtype
  	\$(NOECHO) \$(NOOP)
  
  EOF
  testdb_%1$s test_%1$s :: subdirs-test_%1$s
  	$(NOECHO) $(ECHO) 'No tests defined for $(NAME) extension.'
  
  EOF
  XSUBPPDIR = $xsdir
  XSUBPP = "\$(XSUBPPDIR)\$(DFSEP)xsubpp"
  XSUBPPRUN = \$(PERLRUN) \$(XSUBPP)
  XSPROTOARG = $self->{XSPROTOARG}
  XSUBPPDEPS = @tmdeps $xsdirdep\$(DFSEP)xsubpp
  XSUBPPARGS = @tmargs
  XSUBPP_EXTRA_ARGS =
  }}sub all_target {my$self=shift;return <<'MAKE_EXT'}sub top_targets {my($self)=shift;my(@m);push@m,$self->all_target,"\n" unless$self->{SKIPHASH}{'all'};push@m,sprintf <<'EOF';push@m,'
  all :: pure_all manifypods
  	$(NOECHO) $(NOOP)
  MAKE_EXT
  pure_all :: config pm_to_blib subdirs linkext
  	$(NOECHO) $(NOOP)
  
  	$(NOECHO) $(NOOP)
  
  subdirs :: $(MYEXTLIB)
  	$(NOECHO) $(NOOP)
  
  config :: $(FIRST_MAKEFILE) blibdirs
  	$(NOECHO) $(NOOP)
  EOF
  $(O_FILES) : $(H_FILES)
  ' if @{$self->{O_FILES}|| []}&& @{$self->{H}|| []};push@m,q{
  help :
  	perldoc ExtUtils::MakeMaker
  };join('',@m)}sub writedoc {my($self,$what,$name,@attribs)=@_;my$time=gmtime($ENV{SOURCE_DATE_EPOCH}|| time);print "=head2 $time: $what C<$name>\n\n=over 4\n\n=item *\n\n";print join "\n\n=item *\n\n",map("C<$_>",@attribs);print "\n\n=back\n\n"}sub xs_c {my($self)=shift;return '' unless$self->needs_linking();'
  .xs.c:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(XSUBPP_EXTRA_ARGS) $*.xs > $*.xsc
  	$(MV) $*.xsc $*.c
  '}sub xs_cpp {my($self)=shift;return '' unless$self->needs_linking();'
  .xs.cpp:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc
  	$(MV) $*.xsc $*.cpp
  '}sub xs_o {my ($self)=@_;return '' unless$self->needs_linking();my$m_o=$self->{XSMULTI}? $self->xs_obj_opt('$*$(OBJ_EXT)'): '';my$dbgout=$self->dbgoutflag;$dbgout=$dbgout ? "$dbgout " : '';my$frag='';$frag .= sprintf <<'EOF',$dbgout,$m_o unless$self->is_make_type('dmake');if ($self->{XSMULTI}){for my$ext ($self->_xs_list_basenames){my$pmfile="$ext.pm";croak "$ext.xs has no matching $pmfile: $!" unless -f $pmfile;my$version=$self->parse_version($pmfile);my$cccmd=$self->{CONST_CCCMD};$cccmd =~ s/^\s*CCCMD\s*=\s*//;$cccmd =~ s/\$\(DEFINE_VERSION\)/-DVERSION=\\"$version\\"/;$cccmd =~ s/\$\(XS_DEFINE_VERSION\)/-DXS_VERSION=\\"$version\\"/;$self->_xsbuild_replace_macro($cccmd,'xs',$ext,'INC');my$define='$(DEFINE)';$self->_xsbuild_replace_macro($define,'xs',$ext,'DEFINE');$frag .= _sprintf562 <<'EOF',$ext,$cccmd,$m_o,$define,$dbgout}}$frag =~ s/"-I(\$\(PERL_INC\))"/-iwithsysroot "$1"/sg if$Is{ApplCor};$frag}sub _xsbuild_replace_macro {my ($self,undef,$xstype,$ext,$varname)=@_;my$value=$self->_xsbuild_value($xstype,$ext,$varname);return unless defined$value;$_[1]=~ s/\$\($varname\)/$value/}sub _xsbuild_value {my ($self,$xstype,$ext,$varname)=@_;return$self->{XSBUILD}{$xstype}{$ext}{$varname}if$self->{XSBUILD}{$xstype}{$ext}{$varname};return$self->{XSBUILD}{$xstype}{all}{$varname}if$self->{XSBUILD}{$xstype}{all}{$varname};()}1;
  .xs$(OBJ_EXT) :
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc
  	$(MV) $*.xsc $*.c
  	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) %s$*.c %s
  EOF
  
  %1$s$(OBJ_EXT): %1$s.xs
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc
  	$(MV) $*.xsc $*.c
  	%2$s $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) %4$s %5$s$*.c %3$s
  EOF
EXTUTILS_MM_UNIX

$fatpacked{"ExtUtils/MM_VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_VMS';
  package ExtUtils::MM_VMS;use strict;use ExtUtils::MakeMaker::Config;require Exporter;BEGIN {if($^O eq 'VMS'){require VMS::Filespec;VMS::Filespec->import}}use File::Basename;our$VERSION='7.38';$VERSION =~ tr/_//d;require ExtUtils::MM_Any;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Any ExtUtils::MM_Unix);use ExtUtils::MakeMaker qw($Verbose neatvalue _sprintf562);our$Revision=$ExtUtils::MakeMaker::Revision;sub wraplist {my($self)=shift;my($line,$hlen)=('',0);for my$word (@_){next unless$word =~ /\w/;$line .= ' ' if length($line);if ($hlen > 80){$line .= "\\\n\t";$hlen=0}$line .= $word;$hlen += length($word)+ 2}$line}sub ext {require ExtUtils::Liblist::Kid;goto&ExtUtils::Liblist::Kid::ext}sub guess_name {my($self)=@_;my($defname,$defpm,@pm,%xs);local*PM;$defname=basename(fileify($ENV{'DEFAULT'}));$defname =~ s![\d\-_]*\.dir.*$!!;$defpm=$defname;if (not -e "${defpm}.pm"){@pm=glob('*.pm');s/.pm$// for@pm;if (@pm==1){($defpm=$pm[0])=~ s/.pm$//}elsif (@pm){%xs=map {s/.xs$//;($_,1)}glob('*.xs');if (keys%xs){for my$pm (@pm){$defpm=$pm,last if exists$xs{$pm}}}}}if (open(my$pm,'<',"${defpm}.pm")){while (<$pm>){if (/^\s*package\s+([^;]+)/i){$defname=$1;last}}print "Warning (non-fatal): Couldn't find package name in ${defpm}.pm;\n\t","defaulting package name to $defname\n" if eof($pm);close$pm}else {print "Warning (non-fatal): Couldn't find ${defpm}.pm;\n\t","defaulting package name to $defname\n"}$defname =~ s#[\d.\-_]+$##;$defname}sub find_perl {my($self,$ver,$names,$dirs,$trace)=@_;my($vmsfile,@sdirs,@snames,@cand);my($rslt);my($inabs)=0;local*TCF;if($self->{PERL_CORE}){@sdirs=sort {my($absa)=$self->file_name_is_absolute($a);my($absb)=$self->file_name_is_absolute($b);if ($absa && $absb){return$a cmp $b}else {return$absa ? 1 : ($absb ? -1 : ($a cmp $b))}}@$dirs;@snames=sort {my($ba)=$a =~ m!([^:>\]/]+)$!;my($bb)=$b =~ m!([^:>\]/]+)$!;my($ahasdir)=(length($a)- length($ba)> 0);my($bhasdir)=(length($b)- length($bb)> 0);if ($ahasdir and not $bhasdir){return 1}elsif ($bhasdir and not $ahasdir){return -1}else {$bb =~ /\d/ <=> $ba =~ /\d/ or substr($ba,0,1)cmp substr($bb,0,1)or length($bb)<=> length($ba)}}@$names}else {@sdirs=@$dirs;@snames=@$names}s/\.(\d+)$/_$1/ for@snames;if ($trace >= 2){print "Looking for perl $ver by these names:\n";print "\t@snames,\n";print "in these dirs:\n";print "\t@sdirs\n"}for my$dir (@sdirs){next unless defined$dir;$inabs++ if$self->file_name_is_absolute($dir);if ($inabs==1){for my$name (@snames){push(@cand,$name)if$name =~ /^[\w\-\$]+$/}$inabs++}for my$name (@snames){push@cand,($name !~ m![/:>\]]!)? $self->catfile($dir,$name): $self->fixpath($name,0)}}for my$name (@cand){print "Checking $name\n" if$trace >= 2;if ($name =~ /^[\w\-\$]+$/){open(my$tcf,">","temp_mmvms.com")or die('unable to open temp file');print$tcf "\$ set message/nofacil/nosever/noident/notext\n";print$tcf "\$ $name -e \"require $ver; print \"\"VER_OK\\n\"\"\"\n";close$tcf;$rslt=`\@temp_mmvms.com` ;unlink('temp_mmvms.com');if ($rslt =~ /VER_OK/){print "Using PERL=$name\n" if$trace;return$name}}next unless$vmsfile=$self->maybe_command($name);$vmsfile =~ s/;[\d\-]*$//;print "Executing $vmsfile\n" if ($trace >= 2);open(my$tcf,'>',"temp_mmvms.com")or die('unable to open temp file');print$tcf "\$ set message/nofacil/nosever/noident/notext\n";print$tcf "\$ mcr $vmsfile -e \"require $ver; print \"\"VER_OK\\n\"\"\" \n";close$tcf;$rslt=`\@temp_mmvms.com`;unlink('temp_mmvms.com');if ($rslt =~ /VER_OK/){print "Using PERL=MCR $vmsfile\n" if$trace;return "MCR $vmsfile"}}print "Unable to find a perl $ver (by these names: @$names, in these dirs: @$dirs)\n";0}sub _fixin_replace_shebang {my ($self,$file,$line)=@_;my (undef,$arg)=split ' ',$line,2;return$Config{startperl}."\n" .$Config{sharpbang}."perl $arg\n"}sub maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d _;my(@dirs)=('');my(@exts)=('',$Config{'exe_ext'},'.exe','.com');if ($file !~ m![/:>\]]!){for (my$i=0;defined$ENV{"DCL\$PATH;$i"};$i++){my$dir=$ENV{"DCL\$PATH;$i"};$dir .= ':' unless$dir =~ m%[\]:]$%;push(@dirs,$dir)}push(@dirs,'Sys$System:');for my$dir (@dirs){my$sysfile="$dir$file";for my$ext (@exts){return$file if -x "$sysfile$ext" &&!-d _}}}return 0}sub pasthru {my($self)=shift;my$pasthru=$self->SUPER::pasthru;$pasthru =~ s|(PASTHRU\s*=\s*)|$1/MACRO=(|;$pasthru =~ s|\n\z|)\n|m;$pasthru =~ s|/defi?n?e?=\(?([^\),]+)\)?|,$1|ig;return$pasthru}sub pm_to_blib {my$self=shift;my$make=$self->SUPER::pm_to_blib;$make =~ s{^pm_to_blib :}{pm_to_blib.ts :}m;$make =~ s{\$\(TOUCH\) pm_to_blib}{\$(TOUCH) pm_to_blib.ts};$make=<<'MAKE' .$make;return$make}sub perl_script {my($self,$file)=@_;return$file if -r $file &&!-d _;return "$file.com" if -r "$file.com";return "$file.pl" if -r "$file.pl";return ''}sub replace_manpage_separator {my($self,$man)=@_;$man=unixify($man);$man =~ s#/+#__#g;$man}sub init_DEST {my$self=shift;$self->SUPER::init_DEST;for my$var ($self->installvars){my$destvar='DESTINSTALL'.$var;$self->{$destvar}=$self->eliminate_macros($self->{$destvar})}}sub init_DIRFILESEP {my($self)=shift;$self->{DIRFILESEP}='';return 1}sub init_main {my($self)=shift;$self->SUPER::init_main;$self->{DEFINE}||= '';if ($self->{DEFINE}ne ''){my(@terms)=split(/\s+/,$self->{DEFINE});my(@defs,@udefs);for my$def (@terms){next unless$def;my$targ=\@defs;if ($def =~ s/^-([DU])//){$targ=\@udefs if $1 eq 'U';$def =~ s/='(.*)'$/=$1/;$def =~ s/^'(.*)'$/$1/}if ($def =~ /=/){$def =~ s/"/""/g;$def=qq["$def"]}push @$targ,$def}$self->{DEFINE}='';if (@defs){$self->{DEFINE}='/Define=(' .join(',',@defs).')'}if (@udefs){$self->{DEFINE}.= '/Undef=(' .join(',',@udefs).')'}}}sub init_tools {my($self)=@_;$self->{NOOP}='Continue';$self->{NOECHO}||= '@ ';$self->{MAKEFILE}||= $self->{FIRST_MAKEFILE}|| 'Descrip.MMS';$self->{FIRST_MAKEFILE}||= $self->{MAKEFILE};$self->{MAKE_APERL_FILE}||= 'Makeaperl.MMS';$self->{MAKEFILE_OLD}||= $self->eliminate_macros('$(FIRST_MAKEFILE)_old');$self->{MAKEFILE}.= '.' unless$self->{MAKEFILE}=~ m/\./;$self->{FIRST_MAKEFILE}.= '.' unless$self->{FIRST_MAKEFILE}=~ m/\./;$self->{MAKE_APERL_FILE}.= '.' unless$self->{MAKE_APERL_FILE}=~ m/\./;$self->{MAKEFILE_OLD}.= '.' unless$self->{MAKEFILE_OLD}=~ m/\./;$self->{MACROSTART}||= '/Macro=(';$self->{MACROEND}||= ')';$self->{USEMAKEFILE}||= '/Descrip=';$self->{EQUALIZE_TIMESTAMP}||= '$(ABSPERLRUN) -we "open F,qq{>>$ARGV[1]};close F;utime(0,(stat($ARGV[0]))[9]+1,$ARGV[1])"';$self->{MOD_INSTALL}||= $self->oneliner(<<'CODE',['-MExtUtils::Install']);$self->{UMASK_NULL}='! ';$self->SUPER::init_tools;$self->{SHELL}||= 'Posix';$self->{DEV_NULL}='';return}sub init_platform {my($self)=shift;$self->{MM_VMS_REVISION}=$Revision;$self->{MM_VMS_VERSION}=$VERSION;$self->{PERL_VMS}=$self->catdir($self->{PERL_SRC},'VMS')if$self->{PERL_SRC}}sub platform_constants {my($self)=shift;my$make_frag='';for my$macro (qw(PERL_VMS MM_VMS_REVISION MM_VMS_VERSION)){next unless defined$self->{$macro};$make_frag .= "$macro = $self->{$macro}\n"}return$make_frag}sub init_VERSION {my$self=shift;$self->SUPER::init_VERSION;$self->{DEFINE_VERSION}='"$(VERSION_MACRO)=""$(VERSION)"""';$self->{XS_DEFINE_VERSION}='"$(XS_VERSION_MACRO)=""$(XS_VERSION)"""';$self->{MAKEMAKER}=vmsify($INC{'ExtUtils/MakeMaker.pm'})}sub constants {my($self)=@_;for (@ARGV){$_=uc($_)if /POLLUTE/i}for my$macro (qw [ INST_BIN INST_SCRIPT INST_LIB INST_ARCHLIB PERL_LIB PERL_ARCHLIB PERL_ARCHLIBDEP PERL_INC PERL_SRC],(map {'INSTALL'.$_}$self->installvars),(map {'DESTINSTALL'.$_}$self->installvars)){next unless defined$self->{$macro};next if$macro =~ /MAN/ && $self->{$macro}eq 'none';$self->{$macro}=$self->fixpath($self->{$macro},1)}for my$macro (qw[LIBPERL_A FIRST_MAKEFILE MAKEFILE_OLD MAKE_APERL_FILE MYEXTLIB]){next unless defined$self->{$macro};$self->{$macro}=$self->fixpath($self->{$macro},0)}for my$macro (qw/FULLEXT VERSION_FROM/){next unless defined$self->{$macro};$self->{$macro}=$self->fixpath($self->{$macro},0)}for my$macro (qw/OBJECT LDFROM/){next unless defined$self->{$macro};$self->{$macro}=$self->eliminate_macros($self->{$macro});if ($self->{$macro}=~ /(?<!\^)\s/){$self->{$macro}=~ s/(\\)?\n+\s+/ /g;$self->{$macro}=$self->wraplist(map$self->fixpath($_,0),split /,?(?<!\^)\s+/,$self->{$macro})}else {$self->{$macro}=$self->fixpath($self->{$macro},0)}}for my$macro (qw/XS MAN1PODS MAN3PODS PM/){next unless$self ne " " && defined$self->{$macro};my%tmp=();for my$key (keys %{$self->{$macro}}){$tmp{$self->fixpath($key,0)}=$self->fixpath($self->{$macro}{$key},0)}$self->{$macro}=\%tmp}for my$macro (qw/C O_FILES H/){next unless defined$self->{$macro};my@tmp=();for my$val (@{$self->{$macro}}){push(@tmp,$self->fixpath($val,0))}$self->{$macro}=\@tmp}$self->{MAKE}='$(MMS)$(MMSQUALIFIERS)';return$self->SUPER::constants}sub special_targets {my$self=shift;my$make_frag .= <<'MAKE_FRAG';return$make_frag}sub cflags {my($self,$libperl)=@_;my($quals)=$self->{CCFLAGS}|| $Config{'ccflags'};my($definestr,$undefstr,$flagoptstr)=('','','');my($incstr)='/Include=($(PERL_INC)';my($name,$sys,@m);($name=$self->{NAME}."_cflags")=~ s/:/_/g ;print "Unix shell script ".$Config{"$self->{'BASEEXT'}_cflags"}." required to modify CC command for $self->{'BASEEXT'}\n" if ($Config{$name});if ($quals =~ / -[DIUOg]/){while ($quals =~ / -([Og])(\d*)\b/){my($type,$lvl)=($1,$2);$quals =~ s/ -$type$lvl\b\s*//;if ($type eq 'g'){$flagoptstr='/NoOptimize'}else {$flagoptstr='/Optimize' .(defined($lvl)? "=$lvl" : '')}}while ($quals =~ / -([DIU])(\S+)/){my($type,$def)=($1,$2);$quals =~ s/ -$type$def\s*//;$def =~ s/"/""/g;if ($type eq 'D'){$definestr .= qq["$def",]}elsif ($type eq 'I'){$incstr .= ',' .$self->fixpath($def,1)}else {$undefstr .= qq["$def",]}}}if (length$quals and $quals !~ m!/!){warn "MM_VMS: Ignoring unrecognized CCFLAGS elements \"$quals\"\n";$quals=''}$definestr .= q["PERL_POLLUTE",] if$self->{POLLUTE};if (length$definestr){chop($definestr);$quals .= "/Define=($definestr)"}if (length$undefstr){chop($undefstr);$quals .= "/Undef=($undefstr)"}if ($self->{DEFINE}){$quals .= $self->{DEFINE}}for my$type (qw(Def Undef)){my(@terms);while ($quals =~ m:/${type}i?n?e?=([^/]+):ig){my$term=$1;$term =~ s:^\((.+)\)$:$1:;push@terms,$term}if ($type eq 'Def'){push@terms,qw[$(DEFINE_VERSION) $(XS_DEFINE_VERSION)]}if (@terms){$quals =~ s:/${type}i?n?e?=[^/]+::ig;$quals .= "/${type}ine=(" .join(',',@terms).($type eq 'Def' ? '$(PASTHRU_DEFINE)' : '').')'}}$libperl or $libperl=$self->{LIBPERL_A}|| "libperl.olb";if ($self->{'INC'}){my(@includes)=split(/\s+/,$self->{INC});for (@includes){s/^-I//;$incstr .= ','.$self->fixpath($_,1)}}$quals .= "$incstr)";$self->{CCFLAGS}=$quals;$self->{PERLTYPE}||= '';$self->{OPTIMIZE}||= $flagoptstr || $Config{'optimize'};if ($self->{OPTIMIZE}!~ m!/!){if ($self->{OPTIMIZE}=~ m!-g!){$self->{OPTIMIZE}='/Debug/NoOptimize'}elsif ($self->{OPTIMIZE}=~ /-O(\d*)/){$self->{OPTIMIZE}='/Optimize' .(defined($1)? "=$1" : '')}else {warn "MM_VMS: Can't parse OPTIMIZE \"$self->{OPTIMIZE}\"; using default\n" if length$self->{OPTIMIZE};$self->{OPTIMIZE}='/Optimize'}}return$self->{CFLAGS}=qq{
  # Dummy target to match Unix target name; we use pm_to_blib.ts as
  # timestamp file to avoid repeated invocations under VMS
  pm_to_blib : pm_to_blib.ts
  	$(NOECHO) $(NOOP)
  
  MAKE
  install([ from_to => {split('\|', <STDIN>)}, verbose => '$(VERBINST)', uninstall_shadows => '$(UNINST)', dir_mode => '$(PERM_DIR)' ]);
  CODE
  .SUFFIXES :
  .SUFFIXES : $(OBJ_EXT) .c .cpp .cxx .xs
  
  MAKE_FRAG
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  }}sub const_cccmd {my($self,$libperl)=@_;my(@m);return$self->{CONST_CCCMD}if$self->{CONST_CCCMD};return '' unless$self->needs_linking();if ($Config{'vms_cc_type'}eq 'gcc'){push@m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" Then Define/NoLog SYS GNU_CC_Include:[VMS]'}elsif ($Config{'vms_cc_type'}eq 'vaxc'){push@m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("VAXC$Include").eqs."" Then Define/NoLog SYS Sys$Library
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("VAXC$Include").nes."" Then Define/NoLog SYS VAXC$Include'}else {push@m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("DECC$System_Include").eqs."" Then Define/NoLog SYS ',($Config{'archname'}eq 'VMS_AXP' ? 'Sys$Library' : 'DECC$Library_Include'),'
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("DECC$System_Include").nes."" Then Define/NoLog SYS DECC$System_Include'}push(@m,"\n\nCCCMD = $Config{'cc'} \$(CCFLAGS)\$(OPTIMIZE)\n");$self->{CONST_CCCMD}=join('',@m)}sub tools_other {my($self)=@_;my$extra_tools=<<'EXTRA_TOOLS';return$self->SUPER::tools_other .$extra_tools}sub init_dist {my($self)=@_;$self->{ZIPFLAGS}||= '-Vu';$self->{COMPRESS}||= 'gzip';$self->{SUFFIX}||= '-gz';$self->{SHAR}||= 'vms_share';$self->{DIST_DEFAULT}||= 'zipdist';$self->SUPER::init_dist;$self->{DISTVNAME}="$self->{DISTNAME}-$self->{VERSION_SYM}" unless$self->{ARGS}{DISTVNAME};return}sub c_o {my($self)=@_;return '' unless$self->needs_linking();'
  
  # Just in case anyone is using the old macro.
  USEMACROS = $(MACROSTART)
  SAY = $(ECHO)
  
  EXTRA_TOOLS
  .c$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)
  
  .cpp$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).cpp /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)
  
  .cxx$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).cxx /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)
  
  '}sub xs_c {my($self)=@_;return '' unless$self->needs_linking();'
  .xs.c :
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET_NAME).xsc
  	$(MV) $(MMS$TARGET_NAME).xsc $(MMS$TARGET_NAME).c
  '}sub xs_o {my ($self)=@_;return '' unless$self->needs_linking();my$frag='
  .xs$(OBJ_EXT) :
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET_NAME).xsc
  	$(MV) $(MMS$TARGET_NAME).xsc $(MMS$TARGET_NAME).c
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)
  ';if ($self->{XSMULTI}){for my$ext ($self->_xs_list_basenames){my$version=$self->parse_version("$ext.pm");my$ccflags=$self->{CCFLAGS};$ccflags =~ s/\$\(DEFINE_VERSION\)/\"VERSION_MACRO=\\"\"$version\\"\"/;$ccflags =~ s/\$\(XS_DEFINE_VERSION\)/\"XS_VERSION_MACRO=\\"\"$version\\"\"/;$self->_xsbuild_replace_macro($ccflags,'xs',$ext,'INC');$self->_xsbuild_replace_macro($ccflags,'xs',$ext,'DEFINE');$frag .= _sprintf562 <<'EOF',$ext,$ccflags}}$frag}sub _xsbuild_replace_macro {my ($self,undef,$xstype,$ext,$varname)=@_;my$value=$self->_xsbuild_value($xstype,$ext,$varname);return unless defined$value;$_[1]=_vms_replace_qualifier($self,$_[1],$value,$varname)}sub _xsbuild_value {my ($self,$xstype,$ext,$varname)=@_;$ext=unixify($ext);return$self->SUPER::_xsbuild_value($xstype,$ext,$varname)}sub _vms_replace_qualifier {my ($self,$flags,$newflag,$macro)=@_;my$qual_type;my$type_suffix;my$quote_subquals=0;my@subquals_new=split /\s+/,$newflag;if ($macro eq 'DEFINE'){$qual_type='Def';$type_suffix='ine';map {$_ =~ s/^-D//}@subquals_new;$quote_subquals=1}elsif ($macro eq 'INC'){$qual_type='Inc';$type_suffix='lude';map {$_ =~ s/^-I//;$_=$self->fixpath($_)}@subquals_new}my@subquals=();while ($flags =~ m:/${qual_type}\S{0,4}=([^/]+):ig){my$term=$1;$term =~ s/\"//g;$term =~ s:^\((.+)\)$:$1:;push@subquals,split /,/,$term}for my$new (@subquals_new){my ($sq_new,$sqval_new)=split /=/,$new;my$replaced_old=0;for my$old (@subquals){my ($sq,$sqval)=split /=/,$old;if ($sq_new eq $sq){$old=$sq_new;$old .= '=' .$sqval_new if defined($sqval_new)and length($sqval_new);$replaced_old=1;last}}push@subquals,$new unless$replaced_old}if (@subquals){$flags =~ s:/${qual_type}\S{0,4}=[^/]+::ig;map {$_=qq/"$_"/ if $_ !~ m/^\$\(/}@subquals if$quote_subquals;$flags .= "/${qual_type}$type_suffix=(" .join(',',@subquals).')'}return$flags}sub xs_dlsyms_ext {'.opt'}sub dlsyms {my ($self,%attribs)=@_;return '' unless$self->needs_linking;$self->xs_dlsyms_iterator}sub xs_make_dlsyms {my ($self,$attribs,$target,$dep,$name,$dlbase,$funcs,$funclist,$imports,$vars,$extra)=@_;my@m;my$instloc;if ($self->{XSMULTI}){my ($v,$d,$f)=File::Spec->splitpath($target);my@d=File::Spec->splitdir($d);shift@d if$d[0]eq 'lib';$instloc=$self->catfile('$(INST_ARCHLIB)','auto',@d,$f);push@m,"\ndynamic :: $instloc\n\t\$(NOECHO) \$(NOOP)\n" unless$self->{SKIPHASH}{'dynamic'};push@m,"\nstatic :: $instloc\n\t\$(NOECHO) \$(NOOP)\n" unless$self->{SKIPHASH}{'static'};push@m,"\n",sprintf <<'EOF',$instloc,$target}else {push@m,"\ndynamic :: \$(INST_ARCHAUTODIR)$self->{BASEEXT}.opt\n\t\$(NOECHO) \$(NOOP)\n" unless$self->{SKIPHASH}{'dynamic'};push@m,"\nstatic :: \$(INST_ARCHAUTODIR)$self->{BASEEXT}.opt\n\t\$(NOECHO) \$(NOOP)\n" unless$self->{SKIPHASH}{'static'};push@m,"\n",sprintf <<'EOF',$target}push@m,"\n$target : $dep\n\t",q!$(PERLRUN) -MExtUtils::Mksymlists -e "Mksymlists('NAME'=>'!,$name,q!', 'DLBASE' => '!,$dlbase,q!', 'DL_FUNCS' => !,neatvalue($funcs),q!, 'FUNCLIST' => !,neatvalue($funclist),q!, 'IMPORTS' => !,neatvalue($imports),q!, 'DL_VARS' => !,neatvalue($vars);push@m,$extra if defined$extra;push@m,qq!);"\n\t!;my$olb_base=basename($target,'.opt');if ($self->{XSMULTI}){my$olb_dir=$self->catdir(dirname($instloc),$olb_base);push@m,qq!\$(PERL) -e "print ""${olb_dir}${olb_base}\$(LIB_EXT)/Include=!;push@m,($Config{d_vms_case_sensitive_symbols}? uc($olb_base): $olb_base);push@m,'\n' .$olb_dir .$olb_base .'$(LIB_EXT)/Library\n"";" >>$(MMS$TARGET)',"\n"}else {push@m,qq!\$(PERL) -e "print ""\$(INST_ARCHAUTODIR)${olb_base}\$(LIB_EXT)/Include=!;if ($self->{OBJECT}=~ /\bBASEEXT\b/ or $self->{OBJECT}=~ /\b$self->{BASEEXT}\b/i){push@m,($Config{d_vms_case_sensitive_symbols}? uc($self->{BASEEXT}):'$(BASEEXT)')}else {my($upcase)=$Config{d_vms_case_sensitive_symbols};my(@omods)=split ' ',$self->eliminate_macros($self->{OBJECT});for (@omods){s/\.[^.]*$//;s[\$\(\w+_EXT\)][];s/.*[:>\/\]]//;$_=uc if$upcase};my(@lines);my$tmp=shift@omods;for my$elt (@omods){$tmp .= ",$elt";if (length($tmp)> 80){push@lines,$tmp;$tmp=''}}push@lines,$tmp;push@m,'(',join(qq[, -\\n\\t"";" >>\$(MMS\$TARGET)\n\t\$(PERL) -e "print ""],@lines),')'}push@m,'\n$(INST_ARCHAUTODIR)' .$olb_base .'$(LIB_EXT)/Library\n"";" >>$(MMS$TARGET)',"\n"}if (length$self->{LDLOADLIBS}){my($line)='';for my$lib (split ' ',$self->{LDLOADLIBS}){$lib =~ s%\$%\\\$%g;if (length($line)+ length($lib)> 160){push@m,"\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n";$line=$lib .'\n'}else {$line .= $lib .'\n'}}push@m,"\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n" if$line}join '',@m}sub xs_obj_opt {my ($self,$output_file)=@_;"/OBJECT=$output_file"}sub xs_dynamic_lib_macros {my ($self,$attribs)=@_;my$otherldflags=$attribs->{OTHERLDFLAGS}|| "";my$inst_dynamic_dep=$attribs->{INST_DYNAMIC_DEP}|| "";sprintf <<'EOF',$otherldflags,$inst_dynamic_dep}sub xs_make_dynamic_lib {my ($self,$attribs,$from,$to,$todir,$ldfrom,$exportlist)=@_;my$shr=$Config{'dbgprefix'}.'PerlShr';$exportlist =~ s/.def$/.opt/;_sprintf562 <<'EOF',$to,$todir,$exportlist,$shr,"$shr Sys\$Share:$shr.$Config{'dlext'}"}sub xs_make_static_lib {my ($self,$object,$to,$todir)=@_;my@objects;if ($self->{XSMULTI}){my$lib=$object;$lib =~ s/\$\(OBJ_EXT\)\z//;my$override=$self->_xsbuild_value('xs',$lib,'OBJECT');$object=$override if defined$override;@objects=map {$self->fixpath($_,0)}split /(?<!\^)\s+/,$object}else {push@objects,$object}my@m;for my$obj (@objects){push(@m,sprintf "\n%s : %s\$(DFSEP).exists",$obj,$todir)}push(@m,sprintf "\n\n%s : %s \$(MYEXTLIB)\n",$to,(join ' ',@objects));push(@m,"\t",'$(CP) $(MYEXTLIB) $(MMS$TARGET)',"\n")if$self->{MYEXTLIB};push(@m,"\t",'If F$Search("$(MMS$TARGET)").eqs."" Then Library/Object/Create $(MMS$TARGET)',"\n");if ($self->{MYEXTLIB}){for my$obj (@objects){push(@m,"\t",'Library/Object/Replace $(MMS$TARGET) ' .$obj,"\n")}}else {push(@m,"\t",'Library/Object/Replace $(MMS$TARGET) $(MMS$SOURCE_LIST)',"\n")}push@m,"\t\$(NOECHO) \$(PERL) -e 1 >\$(INST_ARCHAUTODIR)extralibs.ld\n";for my$lib (split ' ',$self->{EXTRALIBS}){push(@m,"\t",'$(NOECHO) $(PERL) -e "print qq{',$lib,'\n}" >>$(INST_ARCHAUTODIR)extralibs.ld',"\n")}join('',@m)}sub static_lib_pure_cmd {my ($self,$from)=@_;sprintf <<'MAKE_FRAG',$from}sub xs_static_lib_is_xs {return 1}sub extra_clean_files {return qw(*.Map *.Dmp *.Lis *.cpp *.$(DLEXT) *.Opt $(BASEEXT).bso .MM_Tmp cxx_repository)}sub zipfile_target {my($self)=shift;return <<'MAKE_FRAG'}sub tarfile_target {my($self)=shift;return <<'MAKE_FRAG'}sub shdist_target {my($self)=shift;return <<'MAKE_FRAG'}sub install {my($self,%attribs)=@_;my(@m);push@m,q[
  
  %1$s$(OBJ_EXT) : %1$s.xs
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs > $(MMS$TARGET_NAME).xsc
  	$(MV) $(MMS$TARGET_NAME).xsc $(MMS$TARGET_NAME).c
  	$(CC)%2$s$(OPTIMIZE) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c /OBJECT=$(MMS$TARGET_NAME)$(OBJ_EXT)
  EOF
  %s : %s
  	$(CP) $(MMS$SOURCE) $(MMS$TARGET)
  EOF
  $(INST_ARCHAUTODIR)$(BASEEXT).opt : %s
  	$(CP) $(MMS$SOURCE) $(MMS$TARGET)
  EOF
  # This section creates the dynamically loadable objects from relevant
  # objects and possibly $(MYEXTLIB).
  OTHERLDFLAGS = %s
  INST_DYNAMIC_DEP = %s
  EOF
  %1$s : $(INST_STATIC) $(PERL_INC)perlshr_attr.opt %2$s$(DFSEP).exists %3$s $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
  	If F$TrnLNm("%4$s").eqs."" Then Define/NoLog/User %5$s
  	Link $(LDFLAGS) /Shareable=$(MMS$TARGET)$(OTHERLDFLAGS) %3$s/Option,$(PERL_INC)perlshr_attr.opt/Option
  EOF
  	If F$Search("$(MMS$TARGET)").eqs."" Then Library/Object/Create $(MMS$TARGET)
  	Library/Object/Replace $(MMS$TARGET) %s
  MAKE_FRAG
  $(DISTVNAME).zip : distdir
  	$(PREOP)
  	$(ZIP) "$(ZIPFLAGS)" $(MMS$TARGET) [.$(DISTVNAME)...]*.*;
  	$(RM_RF) $(DISTVNAME)
  	$(POSTOP)
  MAKE_FRAG
  $(DISTVNAME).tar$(SUFFIX) : distdir
  	$(PREOP)
  	$(TO_UNIX)
  	$(TAR) "$(TARFLAGS)" $(DISTVNAME).tar [.$(DISTVNAME)...]
  	$(RM_RF) $(DISTVNAME)
  	$(COMPRESS) $(DISTVNAME).tar
  	$(POSTOP)
  MAKE_FRAG
  shdist : distdir
  	$(PREOP)
  	$(SHAR) [.$(DISTVNAME)...]*.*; $(DISTVNAME).share
  	$(RM_RF) $(DISTVNAME)
  	$(POSTOP)
  MAKE_FRAG
  install :: all pure_install doc_install
  	$(NOECHO) $(NOOP)
  
  install_perl :: all pure_perl_install doc_perl_install
  	$(NOECHO) $(NOOP)
  
  install_site :: all pure_site_install doc_site_install
  	$(NOECHO) $(NOOP)
  
  install_vendor :: all pure_vendor_install doc_vendor_install
  	$(NOECHO) $(NOOP)
  
  pure_install :: pure_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  doc_install :: doc_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  pure__install : pure_site_install
  	$(NOECHO) $(ECHO) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
  
  doc__install : doc_site_install
  	$(NOECHO) $(ECHO) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
  
  # This hack brought to you by DCL's 255-character command line limit
  pure_perl_install ::
  ];push@m,q[	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read|'.File::Spec->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').'|'" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write|'.File::Spec->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').'|'" >>.MM_tmp
  ] unless$self->{NO_PACKLIST};push@m,q[	$(NOECHO) $(ECHO_N) "$(INST_LIB)|$(DESTINSTALLPRIVLIB)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB)|$(DESTINSTALLARCHLIB)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN)|$(DESTINSTALLBIN)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT)|$(DESTINSTALLSCRIPT)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR) $(DESTINSTALLMAN1DIR) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR)|$(DESTINSTALLMAN3DIR)" >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) "].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q["
  
  # Likewise
  pure_site_install ::
  ];push@m,q[	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read|'.File::Spec->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').'|'" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write|'.File::Spec->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').'|'" >>.MM_tmp
  ] unless$self->{NO_PACKLIST};push@m,q[	$(NOECHO) $(ECHO_N) "$(INST_LIB)|$(DESTINSTALLSITELIB)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB)|$(DESTINSTALLSITEARCH)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN)|$(DESTINSTALLSITEBIN)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT)|$(DESTINSTALLSCRIPT)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR)|$(DESTINSTALLSITEMAN1DIR)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR)|$(DESTINSTALLSITEMAN3DIR)" >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) "].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q["
  
  pure_vendor_install ::
  ];push@m,q[	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read|'.File::Spec->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').'|'" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write|'.File::Spec->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').'|'" >>.MM_tmp
  ] unless$self->{NO_PACKLIST};push@m,q[	$(NOECHO) $(ECHO_N) "$(INST_LIB)|$(DESTINSTALLVENDORLIB)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB)|$(DESTINSTALLVENDORARCH)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN)|$(DESTINSTALLVENDORBIN)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT)|$(DESTINSTALLSCRIPT)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR)|$(DESTINSTALLVENDORMAN1DIR)|" >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR)|$(DESTINSTALLVENDORMAN3DIR)" >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  
  ];push@m,q[
  # Ditto
  doc_perl_install ::
  	$(NOECHO) $(NOOP)
  
  # And again
  doc_site_install ::
  	$(NOECHO) $(NOOP)
  
  doc_vendor_install ::
  	$(NOECHO) $(NOOP)
  
  ] if$self->{NO_PERLLOCAL};push@m,q[
  # Ditto
  doc_perl_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLPRIVLIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  # And again
  doc_site_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLSITELIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  doc_vendor_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLVENDORLIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  ] unless$self->{NO_PERLLOCAL};push@m,q[
  uninstall :: uninstall_from_$(INSTALLDIRS)dirs
  	$(NOECHO) $(NOOP)
  
  uninstall_from_perldirs ::
  	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[
  
  uninstall_from_sitedirs ::
  	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[
  
  uninstall_from_vendordirs ::
  	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{VENDORARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[
  ];join('',@m)}sub perldepend {my($self)=@_;my(@m);if ($self->{OBJECT}){push@m,$self->_perl_header_files_fragment("")}if ($self->{PERL_SRC}){my(@macros);my($mmsquals)='$(USEMAKEFILE)[.vms]$(FIRST_MAKEFILE)';push(@macros,'__AXP__=1')if$Config{'archname'}eq 'VMS_AXP';push(@macros,'DECC=1')if$Config{'vms_cc_type'}eq 'decc';push(@macros,'GNUC=1')if$Config{'vms_cc_type'}eq 'gcc';push(@macros,'SOCKET=1')if$Config{'d_has_sockets'};push(@macros,qq["CC=$Config{'cc'}"])if$Config{'cc'}=~ m!/!;$mmsquals .= '$(USEMACROS)' .join(',',@macros).'$(MACROEND)' if@macros;push(@m,q[
  # Check for unpropagated config.sh changes. Should never happen.
  # We do NOT just update config.h because that is not sufficient.
  # An out of date config.h is not fatal but complains loudly!
  $(PERL_INC)config.h : $(PERL_SRC)config.sh
  	$(NOOP)
  
  $(PERL_ARCHLIB)Config.pm : $(PERL_SRC)config.sh
  	$(NOECHO) Write Sys$Error "$(PERL_ARCHLIB)Config.pm may be out of date with config.h or genconfig.pl"
  	olddef = F$Environment("Default")
  	Set Default $(PERL_SRC)
  	$(MMS)],$mmsquals,);if ($self->{PERL_ARCHLIB}=~ m|\[-| && $self->{PERL_SRC}=~ m|(\[-+)|){my($prefix,$target)=($1,$self->fixpath('$(PERL_ARCHLIB)Config.pm',0));$target =~ s/\Q$prefix/[/;push(@m," $target")}else {push(@m,' $(MMS$TARGET)')}push(@m,q[
  	Set Default 'olddef'
  ])}push(@m,join(" ",map($self->fixpath($_,0),sort values %{$self->{XS}}))." : \$(XSUBPPDEPS)\n")if %{$self->{XS}};join('',@m)}our%olbs;sub makeaperl {my($self,%attribs)=@_;my($makefilename,$searchdirs,$static,$extra,$perlinc,$target,$tmpdir,$libperl)=@attribs{qw(MAKE DIRS STAT EXTRA INCL TARGET TMP LIBPERL)};my(@m);push@m,"
  # --- MakeMaker makeaperl section ---
  MAP_TARGET    = $target
  ";return join '',@m if$self->{PARENT};my($dir)=join ":",@{$self->{DIR}};unless ($self->{MAKEAPERL}){push@m,q{
  $(MAKE_APERL_FILE) : $(FIRST_MAKEFILE)
  	$(NOECHO) $(ECHO) "Writing ""$(MMS$TARGET)"" for this $(MAP_TARGET)"
  	$(NOECHO) $(PERLRUNINST) \
  		Makefile.PL DIR=},$dir,q{ \
  		FIRST_MAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \
  		MAKEAPERL=1 NORECURS=1 };push@m,map(q[ \\\n\t\t"$_"],@ARGV),q{
  
  $(MAP_TARGET) :: $(MAKE_APERL_FILE)
  	$(MAKE)$(USEMAKEFILE)$(MAKE_APERL_FILE) static $(MMS$TARGET)
  };push@m,"\n";return join '',@m}my($linkcmd,@optlibs,@staticpkgs,$extralist,$targdir,$libperldir,%libseen);local($_);$linkcmd=join ' ',$Config{'ld'},grep($_,@Config{qw(large split ldflags ccdlflags)});$linkcmd =~ s/\s+/ /g;local(%olbs);$olbs{$self->{INST_ARCHAUTODIR}}="$self->{BASEEXT}\$(LIB_EXT)";require File::Find;File::Find::find(sub {return unless m/\Q$self->{LIB_EXT}\E$/;return if m/^libperl/;if(exists$self->{INCLUDE_EXT}){my$found=0;(my$xx=$File::Find::name)=~ s,.*?/auto/,,;$xx =~ s,/?$_,,;$xx =~ s,/,::,g;for my$incl ((@{$self->{INCLUDE_EXT}},'DynaLoader')){if($xx eq $incl){$found++;last}}return unless$found}elsif(exists$self->{EXCLUDE_EXT}){(my$xx=$File::Find::name)=~ s,.*?/auto/,,;$xx =~ s,/?$_,,;$xx =~ s,/,::,g;for my$excl (@{$self->{EXCLUDE_EXT}}){return if($xx eq $excl)}}$olbs{$ENV{DEFAULT}}=$_},grep(-d $_,@{$searchdirs || []}));$static=[]unless$static;@olbs{@{$static}}=(1)x @{$static};$extra=[]unless$extra && ref$extra eq 'ARRAY';for (sort {length($a)<=> length($b)|| $a cmp $b}keys%olbs){next unless$olbs{$_}=~ /\Q$self->{LIB_EXT}\E$/;my($dir)=$self->fixpath($_,1);my($extralibs)=$dir ."extralibs.ld";my($extopt)=$dir .$olbs{$_};$extopt =~ s/$self->{LIB_EXT}$/.opt/;push@optlibs,"$dir$olbs{$_}";if (-f $extralibs){my%seenthis;open my$list,"<",$extralibs or warn $!,next;while (<$list>){chomp;my$skip=exists($libseen{$_})&&!exists($seenthis{$_});$libseen{$_}++;$seenthis{$_}++;next if$skip;push @$extra,$_}}if (-f $extopt){open my$opt,'<',$extopt or die $!;while (<$opt>){next unless /(?:UNIVERSAL|VECTOR)=boot_([\w_]+)/;my$pkg=$1;$pkg =~ s#__*#::#g;push@staticpkgs,$pkg}}}push@optlibs,@$extra;$target="Perl$Config{'exe_ext'}" unless$target;my$shrtarget;($shrtarget,$targdir)=fileparse($target);$shrtarget =~ s/^([^.]*)/$1Shr/;$shrtarget=$targdir .$shrtarget;$target="Perlshr.$Config{'dlext'}" unless$target;$tmpdir="[]" unless$tmpdir;$tmpdir=$self->fixpath($tmpdir,1);if (@optlibs){$extralist=join(' ',@optlibs)}else {$extralist=''}push@optlibs,grep {!/PerlShr/i}split ' ',+($self->ext())[2];if ($libperl){unless (-f $libperl || -f ($libperl=$self->catfile($Config{'installarchlib'},'CORE',$libperl))){print "Warning: $libperl not found\n";undef$libperl}}unless ($libperl){if (defined$self->{PERL_SRC}){$libperl=$self->catfile($self->{PERL_SRC},"libperl$self->{LIB_EXT}")}elsif (-f ($libperl=$self->catfile($Config{'installarchlib'},'CORE',"libperl$self->{LIB_EXT}"))){}else {print "Warning: $libperl not found
      If you're going to build a static perl binary, make sure perl is installed
      otherwise ignore this warning\n"}}$libperldir=$self->fixpath((fileparse($libperl))[1],1);push@m,'
  # Fill in the target you want to produce if it\'s not perl
  MAP_TARGET    = ',$self->fixpath($target,0),'
  MAP_SHRTARGET = ',$self->fixpath($shrtarget,0),"
  MAP_LINKCMD   = $linkcmd
  MAP_PERLINC   = ",$perlinc ? map('"$_" ',@{$perlinc}): '',"
  MAP_EXTRA     = $extralist
  MAP_LIBPERL = ",$self->fixpath($libperl,0),'
  ';push@m,"\n${tmpdir}Makeaperl.Opt : \$(MAP_EXTRA)\n";for (@optlibs){push@m,'	$(NOECHO) $(PERL) -e "print q{',$_,'}" >>$(MMS$TARGET)',"\n"}push@m,"\n${tmpdir}PerlShr.Opt :\n\t";push@m,'$(NOECHO) $(PERL) -e "print q{$(MAP_SHRTARGET)}" >$(MMS$TARGET)',"\n";push@m,'
  $(MAP_SHRTARGET) : $(MAP_LIBPERL) Makeaperl.Opt ',"${libperldir}Perlshr_Attr.Opt",'
  	$(MAP_LINKCMD)/Shareable=$(MMS$TARGET) $(MAP_LIBPERL), Makeaperl.Opt/Option ',"${libperldir}Perlshr_Attr.Opt/Option",'
  $(MAP_TARGET) : $(MAP_SHRTARGET) ',"${tmpdir}perlmain\$(OBJ_EXT) ${tmpdir}PerlShr.Opt",'
  	$(MAP_LINKCMD) ',"${tmpdir}perlmain\$(OBJ_EXT)",', PerlShr.Opt/Option
  	$(NOECHO) $(ECHO) "To install the new ""$(MAP_TARGET)"" binary, say"
  	$(NOECHO) $(ECHO) "    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) inst_perl $(USEMACROS)MAP_TARGET=$(MAP_TARGET)$(ENDMACRO)"
  	$(NOECHO) $(ECHO) "To remove the intermediate files, say
  	$(NOECHO) $(ECHO) "    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) map_clean"
  ';push@m,"\n${tmpdir}perlmain.c : \$(FIRST_MAKEFILE)\n\t\$(NOECHO) \$(PERL) -e 1 >${tmpdir}Writemain.tmp\n";push@m,"# More from the 255-char line length limit\n";for (@staticpkgs){push@m,'	$(NOECHO) $(PERL) -e "print q{',$_,qq[}" >>${tmpdir}Writemain.tmp\n]}push@m,sprintf <<'MAKE_FRAG',$tmpdir,$tmpdir;push@m,q[
  	$(NOECHO) $(PERL) $(MAP_PERLINC) -ane "use ExtUtils::Miniperl; writemain(@F)" %sWritemain.tmp >$(MMS$TARGET)
  	$(NOECHO) $(RM_F) %sWritemain.tmp
  MAKE_FRAG
  # Still more from the 255-char line length limit
  doc_inst_perl :
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO) "Perl binary $(MAP_TARGET)|" >.MM_tmp
  	$(NOECHO) $(ECHO) "MAP_STATIC|$(MAP_STATIC)|" >>.MM_tmp
  	$(NOECHO) $(PERL) -pl040 -e " " ].$self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'),q[ >>.MM_tmp
  	$(NOECHO) $(ECHO) -e "MAP_LIBPERL|$(MAP_LIBPERL)|" >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) <.MM_tmp >>].$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  ];push@m,"
  inst_perl : pure_inst_perl doc_inst_perl
  	\$(NOECHO) \$(NOOP)
  
  pure_inst_perl : \$(MAP_TARGET)
  	$self->{CP} \$(MAP_SHRTARGET) ",$self->fixpath($Config{'installbin'},1),"
  	$self->{CP} \$(MAP_TARGET) ",$self->fixpath($Config{'installbin'},1),"
  
  clean :: map_clean
  	\$(NOECHO) \$(NOOP)
  
  map_clean :
  	\$(RM_F) ${tmpdir}perlmain\$(OBJ_EXT) ${tmpdir}perlmain.c \$(FIRST_MAKEFILE)
  	\$(RM_F) ${tmpdir}Makeaperl.Opt ${tmpdir}PerlShr.Opt \$(MAP_TARGET)
  ";join '',@m}sub maketext_filter {my($self,$text)=@_;$text =~ s/^([^\s:=]+)(:+\s)/$1 $2/mg;return$text}sub prefixify {my($self,$var,$sprefix,$rprefix,$default)=@_;$rprefix=$self->eliminate_macros($rprefix);$rprefix=vmspath($rprefix)if$rprefix;$sprefix=vmspath($sprefix)if$sprefix;$default=vmsify($default)unless$default =~ /\[.*\]/;(my$var_no_install=$var)=~ s/^install//;my$path=$self->{uc$var}|| $ExtUtils::MM_Unix::Config_Override{lc$var}|| $Config{lc$var}|| $Config{lc$var_no_install};if(!$path){warn "  no Config found for $var.\n" if$Verbose >= 2;$path=$self->_prefixify_default($rprefix,$default)}elsif(!$self->{ARGS}{PREFIX}||!$self->file_name_is_absolute($path)){}elsif($sprefix eq $rprefix){warn "  no new prefix.\n" if$Verbose >= 2}else {warn "  prefixify $var => $path\n" if$Verbose >= 2;warn "    from $sprefix to $rprefix\n" if$Verbose >= 2;my($path_vol,$path_dirs)=$self->splitpath($path);if($path_vol eq $Config{vms_prefix}.':'){warn "  $Config{vms_prefix}: seen\n" if$Verbose >= 2;$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix($rprefix,$path_dirs)}else {$path=$self->_prefixify_default($rprefix,$default)}}print "    now $path\n" if$Verbose >= 2;return$self->{uc$var}=$path}sub _prefixify_default {my($self,$rprefix,$default)=@_;warn "  cannot prefix, using default.\n" if$Verbose >= 2;if(!$default){warn "No default!\n" if$Verbose >= 1;return}if(!$rprefix){warn "No replacement prefix!\n" if$Verbose >= 1;return ''}return$self->_catprefix($rprefix,$default)}sub _catprefix {my($self,$rprefix,$default)=@_;my($rvol,$rdirs)=$self->splitpath($rprefix);if($rvol){return$self->catpath($rvol,$self->catdir($rdirs,$default),'')}else {return$self->catdir($rdirs,$default)}}sub cd {my($self,$dir,@cmds)=@_;$dir=vmspath($dir);my$cmd=join "\n\t",map "$_",@cmds;my$make_frag=sprintf <<'MAKE_FRAG',$dir,$cmd;chomp$make_frag;return$make_frag}sub oneliner {my($self,$cmd,$switches)=@_;$switches=[]unless defined$switches;$cmd =~ s{^\n+}{};$cmd =~ s{\n+$}{};my@cmds=split /\n/,$cmd;$cmd=join " \n\t  -e ",map$self->quote_literal($_),@cmds;$cmd=$self->escape_newlines($cmd);$switches=join ' ',map {qq{"$_"}}@$switches;return qq{\$(ABSPERLRUN) $switches -e $cmd "--"}}sub echo {my($self,$text,$file,$opts)=@_;if(!ref$opts){my$append=$opts;$opts={append=>$append || 0 }}my$opencmd=$opts->{append}? 'Open/Append' : 'Open/Write';$opts->{allow_variables}=0 unless defined$opts->{allow_variables};my$ql_opts={allow_variables=>$opts->{allow_variables}};my@cmds=("\$(NOECHO) $opencmd MMECHOFILE $file ");push@cmds,map {'$(NOECHO) Write MMECHOFILE '.$self->quote_literal($_,$ql_opts)}split /\n/,$text;push@cmds,'$(NOECHO) Close MMECHOFILE';return@cmds}sub quote_literal {my($self,$text,$opts)=@_;$opts->{allow_variables}=1 unless defined$opts->{allow_variables};$text =~ s{"}{""}g;$text=$opts->{allow_variables}? $self->escape_dollarsigns($text): $self->escape_all_dollarsigns($text);return qq{"$text"}}sub escape_dollarsigns {my($self,$text)=@_;$text =~ s{\$ (?!\() }{"\$"}gx;return$text}sub escape_all_dollarsigns {my($self,$text)=@_;$text =~ s{\$}{"\$\"}gx;return$text}sub escape_newlines {my($self,$text)=@_;$text =~ s{\n}{-\n}g;return$text}sub max_exec_len {my$self=shift;return$self->{_MAX_EXEC_LEN}||= 256}sub init_linker {my$self=shift;$self->{EXPORT_LIST}||= '$(BASEEXT).opt';my$shr=$Config{dbgprefix}.'PERLSHR';if ($self->{PERL_SRC}){$self->{PERL_ARCHIVE}||= $self->catfile($self->{PERL_SRC},"$shr.$Config{'dlext'}")}else {$self->{PERL_ARCHIVE}||= $ENV{$shr}? $ENV{$shr}: "Sys\$Share:$shr.$Config{'dlext'}"}$self->{PERL_ARCHIVEDEP}||= '';$self->{PERL_ARCHIVE_AFTER}||= ''}sub catdir {my$self=shift;my@args=map {m{\$\(} ? $self->eliminate_macros($_): $_}@_;my$dir=$self->SUPER::catdir(@args);$dir=$self->fixpath($dir,1);return$dir}sub catfile {my$self=shift;my@args=map {m{\$\(} ? $self->eliminate_macros($_): $_}@_;my$file=$self->SUPER::catfile(@args);$file=vmsify($file);return$file}sub eliminate_macros {my($self,$path)=@_;return '' unless$path;$self={}unless ref$self;my($npath)=unixify($path);$npath =~ s{\0$}{};my($complex)=0;my($head,$macro,$tail);while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs){if (defined$self->{$2}){($head,$macro,$tail)=($1,$2,$3);if (ref$self->{$macro}){if (ref$self->{$macro}eq 'ARRAY'){$macro=join ' ',@{$self->{$macro}}}else {print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),"\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";$macro="\cB$macro\cB";$complex=1}}else {$macro=$self->{$macro};$macro=unixify($macro)unless ($macro =~ /(?<!\^)\s/);$macro =~ s#/\Z(?!\n)##}$npath="$head$macro$tail"}}if ($complex){$npath =~ s#\cB(.*?)\cB#\${$1}#gs}$npath}sub fixpath {my($self,$path,$force_path)=@_;return '' unless$path;$self=bless {},$self unless ref$self;my($fixedpath,$prefix,$name);if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#){if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/){$fixedpath=vmspath($self->eliminate_macros($path))}else {$fixedpath=vmsify($self->eliminate_macros($path))}}elsif ((($prefix,$name)=($path =~ m#^\$\(([^\)]+)\)(.+)#s))&& $self->{$prefix}){my($vmspre)=$self->eliminate_macros("\$($prefix)");$vmspre=($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/)? vmspath($vmspre): '';$fixedpath=($vmspre ? $vmspre : $self->{$prefix}).$name;$fixedpath=vmspath($fixedpath)if$force_path}else {$fixedpath=$path;$fixedpath=vmspath($fixedpath)if$force_path}if (!defined($force_path)and $fixedpath !~ /[:>(.\]]/){$fixedpath=vmspath($fixedpath)if -d $fixedpath}$fixedpath =~ s/\.000000([\]>])/$1/;if ($path =~ /^[\[>][^.\-]/){$fixedpath =~ s/^[^\[<]+//}return$fixedpath}sub os_flavor {return('VMS')}sub is_make_type {my($self,$type)=@_;return 0}sub make_type {"$Config{make}-style"}1;
  startdir = F$Environment("Default")
  	Set Default %s
  	%s
  	Set Default 'startdir'
  MAKE_FRAG
EXTUTILS_MM_VMS

$fatpacked{"ExtUtils/MM_VOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_VOS';
  package ExtUtils::MM_VOS;use strict;our$VERSION='7.38';$VERSION =~ tr/_//d;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Unix);sub extra_clean_files {return qw(*.kp)}1;
EXTUTILS_MM_VOS

$fatpacked{"ExtUtils/MM_Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_WIN32';
  package ExtUtils::MM_Win32;use strict;use ExtUtils::MakeMaker::Config;use File::Basename;use File::Spec;use ExtUtils::MakeMaker qw(neatvalue _sprintf562);require ExtUtils::MM_Any;require ExtUtils::MM_Unix;our@ISA=qw(ExtUtils::MM_Any ExtUtils::MM_Unix);our$VERSION='7.38';$VERSION =~ tr/_//d;$ENV{EMXSHELL}='sh';my ($BORLAND,$GCC,$MSVC)=_identify_compiler_environment(\%Config);sub _identify_compiler_environment {my ($config)=@_;my$BORLAND=$config->{cc}=~ /\bbcc/i ? 1 : 0;my$GCC=$config->{cc}=~ /\bgcc\b/i ? 1 : 0;my$MSVC=$config->{cc}=~ /\b(?:cl|icl)/i ? 1 : 0;return ($BORLAND,$GCC,$MSVC)}sub dlsyms {my($self,%attribs)=@_;return '' if$self->{SKIPHASH}{'dynamic'};$self->xs_dlsyms_iterator(\%attribs)}sub xs_dlsyms_ext {'.def'}sub replace_manpage_separator {my($self,$man)=@_;$man =~ s,[/\\]+,.,g;$man}sub maybe_command {my($self,$file)=@_;my@e=exists($ENV{'PATHEXT'})? split(/;/,$ENV{PATHEXT}): qw(.com .exe .bat .cmd);my$e='';for (@e){$e .= "\Q$_\E|"}chop$e;if ($file =~ /($e)$/i){return$file if -e $file}else {for (@e){return "$file$_" if -e "$file$_"}}return}sub init_DIRFILESEP {my($self)=shift;$self->{DIRFILESEP}=$self->is_make_type('nmake')? '^\\' : $self->is_make_type('dmake')? '\\\\' : $self->is_make_type('gmake')? '/' : '\\'}sub init_tools {my ($self)=@_;$self->{NOOP}||= 'rem';$self->{DEV_NULL}||= '> NUL';$self->{FIXIN}||= $self->{PERL_CORE}? "\$(PERLRUN) -I$self->{PERL_SRC}\\cpan\\ExtUtils-PL2Bat\\lib $self->{PERL_SRC}\\win32\\bin\\pl2bat.pl" : 'pl2bat.bat';$self->SUPER::init_tools;delete$self->{SHELL};return}sub init_others {my$self=shift;$self->{LD}||= 'link';$self->{AR}||= 'lib';$self->SUPER::init_others;$self->{LDLOADLIBS}||= $Config{libs};if ($BORLAND){my$libs=$self->{LDLOADLIBS};my$libpath='';while ($libs =~ s/(?:^|\s)(("?)-L.+?\2)(?:\s|$)/ /){$libpath .= ' ' if length$libpath;$libpath .= $1}$self->{LDLOADLIBS}=$libs;$self->{LDDLFLAGS}||= $Config{lddlflags};$self->{LDDLFLAGS}.= " $libpath"}return}sub init_platform {my($self)=shift;$self->{MM_Win32_VERSION}=$VERSION;return}sub platform_constants {my($self)=shift;my$make_frag='';for my$macro (qw(MM_Win32_VERSION)){next unless defined$self->{$macro};$make_frag .= "$macro = $self->{$macro}\n"}return$make_frag}sub specify_shell {my$self=shift;return '' unless$self->is_make_type('gmake');"\nSHELL = $ENV{COMSPEC}\n"}sub constants {my$self=shift;my$make_text=$self->SUPER::constants;return$make_text unless$self->is_make_type('dmake');my$size=$self->{MAXLINELENGTH}|| 800000;my$prefix=qq{
  # Get dmake to read long commands like PM_TO_BLIB
  MAXLINELENGTH = $size
  
  };return$prefix .$make_text}sub special_targets {my($self)=@_;my$make_frag=$self->SUPER::special_targets;$make_frag .= <<'MAKE_FRAG' if$self->is_make_type('dmake');return$make_frag}sub static_lib_pure_cmd {my ($self,$from)=@_;$from =~ s/(\$\(\w+)(\))/$1:^"+"$2/g if$BORLAND;sprintf qq{\t\$(AR) %s\n},($BORLAND ? '$@ ' .$from : ($GCC ? '-ru $@ ' .$from : '-out:$@ ' .$from))}sub xs_make_dynamic_lib {my ($self,$attribs,$from,$to,$todir,$ldfrom,$exportlist)=@_;my@m=sprintf '%s : %s $(MYEXTLIB) %s$(DFSEP).exists %s $(PERL_ARCHIVEDEP) $(INST_DYNAMIC_DEP)'."\n",$to,$from,$todir,$exportlist;if ($GCC){push@m,_sprintf562 <<'EOF',$exportlist,$ldfrom}elsif ($BORLAND){my$ldargs=$self->is_make_type('dmake')? q{"$(PERL_ARCHIVE:s,/,\,)" $(LDLOADLIBS:s,/,\,) $(MYEXTLIB:s,/,\,),} : q{"$(subst /,\,$(PERL_ARCHIVE))" $(subst /,\,$(LDLOADLIBS)) $(subst /,\,$(MYEXTLIB)),};my$subbed;if ($exportlist eq '$(EXPORT_LIST)'){$subbed=$self->is_make_type('dmake')? q{$(EXPORT_LIST:s,/,\,)} : q{$(subst /,\,$(EXPORT_LIST))}}else {($subbed=$exportlist)=~ s#/#\\#g}push@m,sprintf <<'EOF',$ldfrom,$ldargs .$subbed}else {push@m,sprintf <<'EOF',$ldfrom,$exportlist;push(@m,q{	if exist $@.manifest mt -nologo -manifest $@.manifest -outputresource:$@;2
  .USESHELL :
  MAKE_FRAG
  	$(LD) %1$s -o $@ $(LDDLFLAGS) %2$s $(OTHERLDFLAGS) $(MYEXTLIB) "$(PERL_ARCHIVE)" $(LDLOADLIBS) -Wl,--enable-auto-image-base
  EOF
          $(LD) $(LDDLFLAGS) $(OTHERLDFLAGS) %s,$@,,%s,$(RESFILES)
  EOF
  	$(LD) -out:$@ $(LDDLFLAGS) %s $(OTHERLDFLAGS) $(MYEXTLIB) "$(PERL_ARCHIVE)" $(LDLOADLIBS) -def:%s
  EOF
  	if exist $@.manifest del $@.manifest})}push@m,"\n\t\$(CHMOD) \$(PERM_RWX) \$\@\n";join '',@m}sub xs_dynamic_lib_macros {my ($self,$attribs)=@_;my$otherldflags=$attribs->{OTHERLDFLAGS}|| ($BORLAND ? 'c0d32.obj': '');my$inst_dynamic_dep=$attribs->{INST_DYNAMIC_DEP}|| "";sprintf <<'EOF',$otherldflags,$inst_dynamic_dep}sub extra_clean_files {my$self=shift;return$GCC ? (qw(dll.base dll.exp)): ('*.pdb')}sub init_linker {my$self=shift;$self->{PERL_ARCHIVE}="\$(PERL_INC)\\$Config{libperl}";$self->{PERL_ARCHIVEDEP}="\$(PERL_INCDEP)\\$Config{libperl}";$self->{PERL_ARCHIVE_AFTER}='';$self->{EXPORT_LIST}='$(BASEEXT).def'}sub perl_script {my($self,$file)=@_;return$file if -r $file && -f _;return "$file.pl" if -r "$file.pl" && -f _;return "$file.plx" if -r "$file.plx" && -f _;return "$file.bat" if -r "$file.bat" && -f _;return}sub can_dep_space {my$self=shift;1}sub quote_dep {my ($self,$arg)=@_;if ($arg =~ / / and not $self->is_make_type('gmake')){require Win32;$arg=Win32::GetShortPathName($arg);die <<EOF if not defined$arg or $arg =~ / /;return$arg}return$self->SUPER::quote_dep($arg)}sub xs_obj_opt {my ($self,$output_file)=@_;($MSVC ? "/Fo" : "-o ").$output_file}sub pasthru {my($self)=shift;my$old=$self->SUPER::pasthru;return$old unless$self->is_make_type('nmake');$old =~ s/(PASTHRU\s*=\s*)/$1 -nologo /;$old}sub arch_check {my$self=shift;return 1 unless$self->can_load_xs;return$self->SUPER::arch_check(map {$self->_normalize_path_name($_)}@_)}sub _normalize_path_name {my$self=shift;my$file=shift;require Win32;my$short=Win32::GetShortPathName($file);return defined$short ? lc$short : lc$file}sub oneliner {my($self,$cmd,$switches)=@_;$switches=[]unless defined$switches;$cmd =~ s{^\n+}{};$cmd =~ s{\n+$}{};$cmd=$self->quote_literal($cmd);$cmd=$self->escape_newlines($cmd);$switches=join ' ',@$switches;return qq{\$(ABSPERLRUN) $switches -e $cmd --}}sub quote_literal {my($self,$text,$opts)=@_;$opts->{allow_variables}=1 unless defined$opts->{allow_variables};$text =~ s{\\\\"}{\\\\\\\\\\"}g;$text =~ s{(?<!\\)\\"}{\\\\\\"}g;$text =~ s{(?<!\\)"}{\\"}g;$text=qq{"$text"} if$text =~ /[ \t#]/;my@text=split /("[^"]*")/,$text;s{([<>|&^@!])}{^$1}g foreach grep {!/^"[^"]*"$/}@text;$text=join('',@text);if($self->is_make_type('dmake')){$text =~ s/{/{{/g;$text =~ s/}/}}/g}$text=$opts->{allow_variables}? $self->escape_dollarsigns($text): $self->escape_all_dollarsigns($text);return$text}sub escape_newlines {my($self,$text)=@_;$text =~ s{\n}{\\\n}g;return$text}sub cd {my($self,$dir,@cmds)=@_;return$self->SUPER::cd($dir,@cmds)unless$self->is_make_type('nmake');my$cmd=join "\n\t",map "$_",@cmds;my$updirs=$self->catdir(map {$self->updir}$self->splitdir($dir));my$make_frag=sprintf <<'MAKE_FRAG',$dir,$cmd,$updirs;chomp$make_frag;return$make_frag}sub max_exec_len {my$self=shift;return$self->{_MAX_EXEC_LEN}||= 2 * 1024}sub os_flavor {return('Win32')}sub dbgoutflag {$MSVC ? '-Fd$(*).pdb' : ''}sub cflags {my($self,$libperl)=@_;return$self->{CFLAGS}if$self->{CFLAGS};return '' unless$self->needs_linking();my$base=$self->SUPER::cflags($libperl);for (split /\n/,$base){/^(\S*)\s*=\s*(\S*)$/ and $self->{$1}=$2};$self->{CCFLAGS}.= " -DPERLDLL" if ($self->{LINKTYPE}eq 'static');return$self->{CFLAGS}=qq{
  # This section creates the dynamically loadable objects from relevant
  # objects and possibly $(MYEXTLIB).
  OTHERLDFLAGS = %s
  INST_DYNAMIC_DEP = %s
  EOF
  Tried to use make dependency with space for non-GNU make:
    '$arg'
  Fallback to short pathname failed.
  EOF
  cd %s
  	%s
  	cd %s
  MAKE_FRAG
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  }}sub make_type {my ($self)=@_;my$make=$self->make;$make=+(File::Spec->splitpath($make))[-1];$make =~ s!\.exe$!!i;if ($make =~ m![^A-Z0-9]!i){($make)=grep {m!make!i}split m![^A-Z0-9]!i,$make}return "$make-style"}1;
EXTUTILS_MM_WIN32

$fatpacked{"ExtUtils/MM_Win95.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_WIN95';
  package ExtUtils::MM_Win95;use strict;our$VERSION='7.38';$VERSION =~ tr/_//d;require ExtUtils::MM_Win32;our@ISA=qw(ExtUtils::MM_Win32);use ExtUtils::MakeMaker::Config;sub max_exec_len {my$self=shift;return$self->{_MAX_EXEC_LEN}||= 1024}sub os_flavor {my$self=shift;return ($self->SUPER::os_flavor,'Win9x')}1;
EXTUTILS_MM_WIN95

$fatpacked{"ExtUtils/MY.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MY';
  package ExtUtils::MY;use strict;require ExtUtils::MM;our$VERSION='7.38';$VERSION =~ tr/_//d;our@ISA=qw(ExtUtils::MM);{package MY;our@ISA=qw(ExtUtils::MY)}sub DESTROY {}
EXTUTILS_MY

$fatpacked{"ExtUtils/MakeMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER';
  package ExtUtils::MakeMaker;use strict;BEGIN {require 5.006}require Exporter;use ExtUtils::MakeMaker::Config;use ExtUtils::MakeMaker::version;use Carp;use File::Path;my$CAN_DECODE=eval {require ExtUtils::MakeMaker::Locale};eval {ExtUtils::MakeMaker::Locale::reinit('UTF-8')}if$CAN_DECODE and Encode::find_encoding('locale')->name eq 'ascii';our$Verbose=0;our@Parent;our@Get_from_Config;our@MM_Sections;our@Overridable;my@Prepend_parent;my%Recognized_Att_Keys;our%macro_fsentity;our%macro_dep;our$VERSION='7.38';$VERSION =~ tr/_//d;(our$Revision=$VERSION)=~ s{_}{};$Revision=int$Revision * 10000;our$Filename=__FILE__;our@ISA=qw(Exporter);our@EXPORT=qw(&WriteMakefile $Verbose &prompt &os_unsupported);our@EXPORT_OK=qw($VERSION &neatvalue &mkbootstrap &mksymlists &WriteEmptyMakefile &open_for_writing &write_file_via_tmp &_sprintf562);my$Is_VMS=$^O eq 'VMS';my$Is_Win32=$^O eq 'MSWin32';our$UNDER_CORE=$ENV{PERL_CORE};full_setup();require ExtUtils::MM;require ExtUtils::MY;sub _sprintf562 {my ($format,@args)=@_;for (my$i=1;$i <= @args;$i++){$format =~ s#%$i\$s#$args[$i-1]#g}$format}sub WriteMakefile {croak "WriteMakefile: Need even number of args" if @_ % 2;require ExtUtils::MY;my%att=@_;_convert_compat_attrs(\%att);_verify_att(\%att);my$mm=MM->new(\%att);$mm->flush;return$mm}my%Att_Sigs;my%Special_Sigs=(AUTHOR=>'ARRAY',C=>'ARRAY',CONFIG=>'ARRAY',CONFIGURE=>'CODE',DIR=>'ARRAY',DL_FUNCS=>'HASH',DL_VARS=>'ARRAY',EXCLUDE_EXT=>'ARRAY',EXE_FILES=>'ARRAY',FUNCLIST=>'ARRAY',H=>'ARRAY',IMPORTS=>'HASH',INCLUDE_EXT=>'ARRAY',LIBS=>['ARRAY',''],MAN1PODS=>'HASH',MAN3PODS=>'HASH',META_ADD=>'HASH',META_MERGE=>'HASH',OBJECT=>['ARRAY',''],PL_FILES=>'HASH',PM=>'HASH',PMLIBDIRS=>'ARRAY',PMLIBPARENTDIRS=>'ARRAY',PREREQ_PM=>'HASH',BUILD_REQUIRES=>'HASH',CONFIGURE_REQUIRES=>'HASH',TEST_REQUIRES=>'HASH',SKIP=>'ARRAY',TYPEMAPS=>'ARRAY',XS=>'HASH',XSBUILD=>'HASH',VERSION=>['version',''],_KEEP_AFTER_FLUSH=>'',clean=>'HASH',depend=>'HASH',dist=>'HASH',dynamic_lib=>'HASH',linkext=>'HASH',macro=>'HASH',postamble=>'HASH',realclean=>'HASH',test=>'HASH',tool_autosplit=>'HASH',);@Att_Sigs{keys%Recognized_Att_Keys}=('')x keys%Recognized_Att_Keys;@Att_Sigs{keys%Special_Sigs}=values%Special_Sigs;sub _convert_compat_attrs {my($att)=@_;if (exists$att->{AUTHOR}){if ($att->{AUTHOR}){if (!ref($att->{AUTHOR})){my$t=$att->{AUTHOR};$att->{AUTHOR}=[$t]}}else {$att->{AUTHOR}=[]}}}sub _verify_att {my($att)=@_;for my$key (sort keys %$att){my$val=$att->{$key};my$sig=$Att_Sigs{$key};unless(defined$sig){warn "WARNING: $key is not a known parameter.\n";next}my@sigs=ref$sig ? @$sig : $sig;my$given=ref$val;unless(grep {_is_of_type($val,$_)}@sigs){my$takes=join " or ",map {_format_att($_)}@sigs;my$has=_format_att($given);warn "WARNING: $key takes a $takes not a $has.\n"."         Please inform the author.\n"}}}sub _is_of_type {my($thing,$type)=@_;return 1 if ref$thing eq $type;local$SIG{__DIE__};return 1 if eval{$thing->isa($type)};return 0}sub _format_att {my$given=shift;return$given eq '' ? "string/number" : uc$given eq $given ? "$given reference" : "$given object" }sub prompt ($;$) {my($mess,$def)=@_;confess("prompt function called without an argument")unless defined$mess;my$isa_tty=-t STDIN && (-t STDOUT ||!(-f STDOUT || -c STDOUT));my$dispdef=defined$def ? "[$def] " : " ";$def=defined$def ? $def : "";local $|=1;local $\;print "$mess $dispdef";my$ans;if ($ENV{PERL_MM_USE_DEFAULT}|| (!$isa_tty && eof STDIN)){print "$def\n"}else {$ans=<STDIN>;if(defined$ans){$ans =~ s{\015?\012$}{}}else {print "\n"}}return (!defined$ans || $ans eq '')? $def : $ans}sub os_unsupported {die "OS unsupported\n"}sub eval_in_subdirs {my($self)=@_;use Cwd qw(cwd abs_path);my$pwd=cwd()|| die "Can't figure out your cwd!";local@INC=map eval {abs_path($_)if -e}|| $_,@INC;push@INC,'.';for my$dir (@{$self->{DIR}}){my($abs)=$self->catdir($pwd,$dir);eval {$self->eval_in_x($abs)};last if $@}chdir$pwd;die $@ if $@}sub eval_in_x {my($self,$dir)=@_;chdir$dir or carp("Couldn't change to directory $dir: $!");{package main;do './Makefile.PL'};if ($@){die "ERROR from evaluation of $dir/Makefile.PL: $@"}}my$PACKNAME='PACK000';sub full_setup {$Verbose ||= 0;my@dep_macros=qw/PERL_INCDEP PERL_ARCHLIBDEP PERL_ARCHIVEDEP/;my@fs_macros=qw/FULLPERL XSUBPPDIR INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB INST_MAN1DIR INST_MAN3DIR INSTALLDIRS DESTDIR PREFIX INSTALL_BASE PERLPREFIX SITEPREFIX VENDORPREFIX INSTALLPRIVLIB INSTALLSITELIB INSTALLVENDORLIB INSTALLARCHLIB INSTALLSITEARCH INSTALLVENDORARCH INSTALLBIN INSTALLSITEBIN INSTALLVENDORBIN INSTALLMAN1DIR INSTALLMAN3DIR INSTALLSITEMAN1DIR INSTALLSITEMAN3DIR INSTALLVENDORMAN1DIR INSTALLVENDORMAN3DIR INSTALLSCRIPT INSTALLSITESCRIPT INSTALLVENDORSCRIPT PERL_LIB PERL_ARCHLIB SITELIBEXP SITEARCHEXP MAKE LIBPERL_A LIB PERL_SRC PERL_INC PPM_INSTALL_EXEC PPM_UNINSTALL_EXEC PPM_INSTALL_SCRIPT PPM_UNINSTALL_SCRIPT/;my@attrib_help=qw/AUTHOR ABSTRACT ABSTRACT_FROM BINARY_LOCATION C CAPI CCFLAGS CONFIG CONFIGURE DEFINE DIR DISTNAME DISTVNAME DL_FUNCS DL_VARS EXCLUDE_EXT EXE_FILES FIRST_MAKEFILE FULLPERLRUN FULLPERLRUNINST FUNCLIST H IMPORTS INC INCLUDE_EXT LDFROM LIBS LICENSE LINKTYPE MAKEAPERL MAKEFILE MAKEFILE_OLD MAN1PODS MAN3PODS MAP_TARGET META_ADD META_MERGE MIN_PERL_VERSION BUILD_REQUIRES CONFIGURE_REQUIRES MYEXTLIB NAME NEEDS_LINKING NOECHO NO_META NO_MYMETA NO_PACKLIST NO_PERLLOCAL NORECURS NO_VC OBJECT OPTIMIZE PERL_MALLOC_OK PERL PERLMAINCC PERLRUN PERLRUNINST PERL_CORE PERM_DIR PERM_RW PERM_RWX MAGICXS PL_FILES PM PM_FILTER PMLIBDIRS PMLIBPARENTDIRS POLLUTE PREREQ_FATAL PREREQ_PM PREREQ_PRINT PRINT_PREREQ PUREPERL_ONLY SIGN SKIP TEST_REQUIRES TYPEMAPS UNINST VERSION VERSION_FROM XS XSBUILD XSMULTI XSOPT XSPROTOARG XS_VERSION clean depend dist dynamic_lib linkext macro realclean tool_autosplit MAN1EXT MAN3EXT MACPERL_SRC MACPERL_LIB MACLIBS_68K MACLIBS_PPC MACLIBS_SC MACLIBS_MRC MACLIBS_ALL_68K MACLIBS_ALL_PPC MACLIBS_SHARED/;push@attrib_help,@fs_macros;@macro_fsentity{@fs_macros,@dep_macros}=(1)x (@fs_macros+@dep_macros);@macro_dep{@dep_macros}=(1)x @dep_macros;@MM_Sections=qw(post_initialize const_config constants platform_constants tool_autosplit tool_xsubpp tools_other makemakerdflt dist macro depend cflags const_loadlibs const_cccmd post_constants pasthru special_targets c_o xs_c xs_o top_targets blibdirs linkext dlsyms dynamic_bs dynamic dynamic_lib static static_lib manifypods processPL installbin subdirs clean_subdirs clean realclean_subdirs realclean metafile signature dist_basics dist_core distdir dist_test dist_ci distmeta distsignature install force perldepend makefile staticmake test ppd);@Overridable=@MM_Sections;push@Overridable,qw[libscan makeaperl needs_linking subdir_x test_via_harness test_via_script init_VERSION init_dist init_INST init_INSTALL init_DEST init_dirscan init_PM init_MANPODS init_xs init_PERL init_DIRFILESEP init_linker];push@MM_Sections,qw[pm_to_blib selfdocument];push@MM_Sections,"postamble";push@Overridable,"postamble";@Recognized_Att_Keys{@MM_Sections}=(1)x @MM_Sections;@Get_from_Config=qw(ar cc cccdlflags ccdlflags dlext dlsrc exe_ext full_ar ld lddlflags ldflags libc lib_ext obj_ext osname osvers ranlib sitelibexp sitearchexp so);push@Get_from_Config,qw(vendorarchexp vendorlibexp) if "$]" >= 5.006;for my$item (@attrib_help){$Recognized_Att_Keys{$item}=1}for my$item (@Get_from_Config){$Recognized_Att_Keys{uc$item}=$Config{$item};print "Attribute '\U$item\E' => '$Config{$item}'\n" if ($Verbose >= 2)}@Prepend_parent=qw(INST_BIN INST_LIB INST_ARCHLIB INST_SCRIPT MAP_TARGET INST_MAN1DIR INST_MAN3DIR PERL_SRC PERL FULLPERL)}sub _has_cpan_meta_requirements {return eval {require CPAN::Meta::Requirements;CPAN::Meta::Requirements->VERSION(2.130);require B}}sub new {my($class,$self)=@_;my($key);_convert_compat_attrs($self)if defined$self && $self;for my$k (keys %$self){$self->{ARGS}{$k}=$self->{$k}}$self={}unless defined$self;bless$self,"MM";my%key2cmr;for my$key (qw(PREREQ_PM BUILD_REQUIRES CONFIGURE_REQUIRES TEST_REQUIRES)){$self->{$key}||= {};if (_has_cpan_meta_requirements){my$cmr=CPAN::Meta::Requirements->from_string_hash($self->{$key},{bad_version_hook=>sub {my$fallback;if ($_[0]=~ m!^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$!){$fallback=sprintf "%f",$_[0]}else {($fallback)=$_[0]? ($_[0]=~ /^([0-9.]+)/): 0;$fallback += 0;carp "Unparsable version '$_[0]' for prerequisite $_[1] treated as $fallback"}version->new($fallback)},},);$self->{$key}=$cmr->as_string_hash;$key2cmr{$key}=$cmr}else {for my$module (sort keys %{$self->{$key}}){my$version=$self->{$key}->{$module};my$fallback=0;if (!defined($version)or!length($version)){carp "Undefined requirement for $module treated as '0' (CPAN::Meta::Requirements not available)"}elsif ($version =~ /^\d+(?:\.\d+(?:_\d+)*)?$/){next}else {if ($version =~ m!^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$!){$fallback=sprintf "%f",$version}else {($fallback)=$version ? ($version =~ /^([0-9.]+)/): 0;$fallback += 0;carp "Unparsable version '$version' for prerequisite $module treated as $fallback (CPAN::Meta::Requirements not available)"}}$self->{$key}->{$module}=$fallback}}}if ("@ARGV" =~ /\bPREREQ_PRINT\b/){$self->_PREREQ_PRINT}if ("@ARGV" =~ /\bPRINT_PREREQ\b/){$self->_PRINT_PREREQ}print "MakeMaker (v$VERSION)\n" if$Verbose;if (-f "MANIFEST" &&!-f "Makefile" &&!$UNDER_CORE){check_manifest()}check_hints($self);if (defined$self->{MIN_PERL_VERSION}&& $self->{MIN_PERL_VERSION}!~ /^v?[\d_\.]+$/){require version;my$normal=eval {local$SIG{__WARN__}=sub {die @_};version->new($self->{MIN_PERL_VERSION})};$self->{MIN_PERL_VERSION}=$normal if defined$normal &&!$@}if(defined$self->{MIN_PERL_VERSION}){$self->{MIN_PERL_VERSION}=~ s{ ^v? (\d+) \. (\d+) \. (\d+) $ }
                                        {sprintf "%d.%03d%03d", $1, $2, $3}ex}my$perl_version_ok=eval {local$SIG{__WARN__}=sub {die @_};!$self->{MIN_PERL_VERSION}or $self->{MIN_PERL_VERSION}<= "$]"};if (!$perl_version_ok){if (!defined$perl_version_ok){die <<'END'}elsif ($self->{PREREQ_FATAL}){die sprintf <<"END",$self->{MIN_PERL_VERSION},$]}else {warn sprintf "Warning: Perl version %s or higher required. We run %s.\n",$self->{MIN_PERL_VERSION},$]}}my%configure_att;my(%initial_att)=%$self;my(%unsatisfied)=();my%prereq2version;my$cmr;if (_has_cpan_meta_requirements){$cmr=CPAN::Meta::Requirements->new;for my$key (qw(PREREQ_PM BUILD_REQUIRES CONFIGURE_REQUIRES TEST_REQUIRES)){$cmr->add_requirements($key2cmr{$key})if$key2cmr{$key}}for my$prereq ($cmr->required_modules){$prereq2version{$prereq}=$cmr->requirements_for_module($prereq)}}else {for my$key (qw(PREREQ_PM BUILD_REQUIRES CONFIGURE_REQUIRES TEST_REQUIRES)){next unless my$module2version=$self->{$key};$prereq2version{$_}=$module2version->{$_}for keys %$module2version}}for my$prereq (sort keys%prereq2version){my$required_version=$prereq2version{$prereq};my$pr_version=0;my$installed_file;if ($prereq eq 'perl'){if (defined$required_version && $required_version =~ /^v?[\d_\.]+$/ || $required_version !~ /^v?[\d_\.]+$/){require version;my$normal=eval {version->new($required_version)};$required_version=$normal if defined$normal}$installed_file=$prereq;$pr_version=$]}else {$installed_file=MM->_installed_file_for_module($prereq);$pr_version=MM->parse_version($installed_file)if$installed_file;$pr_version=0 if$pr_version eq 'undef';if (!eval {version->new($pr_version);1}){my$fallback;if ($pr_version =~ m!^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$!){$fallback=sprintf '%f',$pr_version}else {($fallback)=$pr_version ? ($pr_version =~ /^([0-9.]+)/): 0;$fallback += 0;carp "Unparsable version '$pr_version' for installed prerequisite $prereq treated as $fallback"}$pr_version=$fallback}}$pr_version =~ s/(\d+)\.(\d+)_(\d+)/$1.$2$3/;if (!$installed_file){warn sprintf "Warning: prerequisite %s %s not found.\n",$prereq,$required_version unless$self->{PREREQ_FATAL}or $UNDER_CORE;$unsatisfied{$prereq}='not installed'}elsif ($cmr ?!$cmr->accepts_module($prereq,$pr_version): $required_version > $pr_version){warn sprintf "Warning: prerequisite %s %s not found. We have %s.\n",$prereq,$required_version,($pr_version || 'unknown version')unless$self->{PREREQ_FATAL}or $UNDER_CORE;$unsatisfied{$prereq}=$required_version || 'unknown version' }}if (%unsatisfied && $self->{PREREQ_FATAL}){my$failedprereqs=join "\n",map {"    $_ $unsatisfied{$_}"}sort {$a cmp $b}keys%unsatisfied;die <<"END"}if (defined$self->{CONFIGURE}){if (ref$self->{CONFIGURE}eq 'CODE'){%configure_att=%{&{$self->{CONFIGURE}}};_convert_compat_attrs(\%configure_att);$self={%$self,%configure_att }}else {croak "Attribute 'CONFIGURE' to WriteMakefile() not a code reference\n"}}my$newclass=++$PACKNAME;local@Parent=@Parent;{print "Blessing Object into class [$newclass]\n" if$Verbose>=2;mv_all_methods("MY",$newclass);bless$self,$newclass;push@Parent,$self;require ExtUtils::MY;no strict 'refs';@{"$newclass\:\:ISA"}='MM'}if (defined$Parent[-2]){$self->{PARENT}=$Parent[-2];for my$key (@Prepend_parent){next unless defined$self->{PARENT}{$key};next if defined$self->{ARGS}{$key}and $self->{ARGS}{$key}eq $self->{$key};$self->{$key}=$self->{PARENT}{$key};if ($Is_VMS && $key =~ /PERL$/){my@cmd=split /\s+/,$self->{$key};$cmd[1]=$self->catfile('[-]',$cmd[1])unless (@cmd < 2)|| $self->file_name_is_absolute($cmd[1]);$self->{$key}=join(' ',@cmd)}else {my$value=$self->{$key};$value =~ s/"// if$key =~ /PERL$/ and $self->is_make_type('dmake');$value =~ s/^"// if$key =~ /PERL$/;$value=$self->catdir("..",$value)unless$self->file_name_is_absolute($value);$value=qq{"$value} if$key =~ /PERL$/;$self->{$key}=$value}}if ($self->{PARENT}){$self->{PARENT}->{CHILDREN}->{$newclass}=$self;for my$opt (qw(POLLUTE PERL_CORE LINKTYPE AR FULL_AR CC CCFLAGS OPTIMIZE LD LDDLFLAGS LDFLAGS PERL_ARCHLIB DESTDIR)){if (exists$self->{PARENT}->{$opt}and not exists$self->{$opt}){$self->{$opt}=$self->{PARENT}->{$opt}}}}my@fm=grep /^FIRST_MAKEFILE=/,@ARGV;parse_args($self,@fm)if@fm}else {parse_args($self,_shellwords($ENV{PERL_MM_OPT}|| ''),@ARGV)}if (%unsatisfied && $self->{PREREQ_FATAL}){my$failedprereqs=join "\n",map {"    $_ $unsatisfied{$_}"}sort {$a cmp $b}keys%unsatisfied;die <<"END"}$self->{NAME}||= $self->guess_name;warn "Warning: NAME must be a package name\n" unless$self->{NAME}=~ m!^[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*$!;($self->{NAME_SYM}=$self->{NAME})=~ s/\W+/_/g;$self->init_MAKE;$self->init_main;$self->init_VERSION;$self->init_dist;$self->init_INST;$self->init_INSTALL;$self->init_DEST;$self->init_dirscan;$self->init_PM;$self->init_MANPODS;$self->init_xs;$self->init_PERL;$self->init_DIRFILESEP;$self->init_linker;$self->init_ABSTRACT;$self->arch_check($INC{'Config.pm'},$self->catfile($Config{'archlibexp'},"Config.pm"));$self->init_tools();$self->init_others();$self->init_platform();$self->init_PERM();my@args=@ARGV;@args=map {Encode::decode(locale=>$_)}@args if$CAN_DECODE;my($argv)=neatvalue(\@args);$argv =~ s/^\[/(/;$argv =~ s/\]$/)/;push @{$self->{RESULT}},<<END;push @{$self->{RESULT}},$self->_MakeMaker_Parameters_section(\%initial_att);if (defined$self->{CONFIGURE}){push @{$self->{RESULT}},<<END;if (scalar(keys%configure_att)> 0){for my$key (sort keys%configure_att){next if$key eq 'ARGS';my($v)=neatvalue($configure_att{$key});$v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;$v =~ tr/\n/ /s;push @{$self->{RESULT}},"#     $key => $v"}}else {push @{$self->{RESULT}},"# no values returned"}undef%configure_att}for my$skip (@{$self->{SKIP}|| []}){$self->{SKIPHASH}{$skip}=1}delete$self->{SKIP};if ($self->{PARENT}){for (qw/install dist dist_basics dist_core distdir dist_test dist_ci/){$self->{SKIPHASH}{$_}=1}}unless ($self->{NORECURS}){$self->eval_in_subdirs if @{$self->{DIR}}}for my$section (@MM_Sections){my$method=$section;$method .= '_target' unless$self->can($method);print "Processing Makefile '$section' section\n" if ($Verbose >= 2);my($skipit)=$self->skipcheck($section);if ($skipit){push @{$self->{RESULT}},"\n# --- MakeMaker $section section $skipit."}else {my(%a)=%{$self->{$section}|| {}};push @{$self->{RESULT}},"\n# --- MakeMaker $section section:";push @{$self->{RESULT}},"# " .join ", ",%a if$Verbose && %a;push @{$self->{RESULT}},$self->maketext_filter($self->$method(%a))}}push @{$self->{RESULT}},"\n# End.";$self}sub WriteEmptyMakefile {croak "WriteEmptyMakefile: Need an even number of args" if @_ % 2;my%att=@_;$att{DIR}=[]unless$att{DIR};my$self=MM->new(\%att);my$new=$self->{MAKEFILE};my$old=$self->{MAKEFILE_OLD};if (-f $old){_unlink($old)or warn "unlink $old: $!"}if (-f $new){_rename($new,$old)or warn "rename $new => $old: $!"}open my$mfh,'>',$new or die "open $new for write: $!";print$mfh <<'EOP';close$mfh or die "close $new for write: $!"}sub _installed_file_for_module {my$class=shift;my$prereq=shift;my$file="$prereq.pm";$file =~ s{::}{/}g;my$path;for my$dir (@INC){my$tmp=File::Spec->catfile($dir,$file);if (-r $tmp){$path=$tmp;last}}return$path}sub _MakeMaker_Parameters_section {my$self=shift;my$att=shift;my@result=<<'END';for my$key (sort keys %$att){next if$key eq 'ARGS';my$v;if ($key eq 'PREREQ_PM'){$v=neatvalue({%{$att->{PREREQ_PM}|| {}},%{$att->{BUILD_REQUIRES}|| {}},%{$att->{TEST_REQUIRES}|| {}},})}else {$v=neatvalue($att->{$key})}$v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;$v =~ tr/\n/ /s;push@result,"#     $key => $v"}return@result}sub _shellwords {my (@lines)=@_;my@allwords;for my$line (@lines){$line =~ s/^\s+//;my@words=_parse_line('\s+',0,$line);pop@words if (@words and!defined$words[-1]);return()unless (@words ||!length($line));push(@allwords,@words)}return(@allwords)}sub _parse_line {my($delimiter,$keep,$line)=@_;my($word,@pieces);no warnings 'uninitialized';while (length($line)){$line =~ s/^
  Warning: MIN_PERL_VERSION is not in a recognized format.
  Recommended is a quoted numerical value like '5.005' or '5.008001'.
  END
  MakeMaker FATAL: perl version too low for this distribution.
  Required is %s. We run %s.
  END
  MakeMaker FATAL: prerequisites not found.
  $failedprereqs
  
  Please install these modules first and rerun 'perl Makefile.PL'.
  END
  MakeMaker FATAL: prerequisites not found.
  $failedprereqs
  
  Please install these modules first and rerun 'perl Makefile.PL'.
  END
  # This Makefile is for the $self->{NAME} extension to perl.
  #
  # It was generated automatically by MakeMaker version
  # $VERSION (Revision: $Revision) from the contents of
  # Makefile.PL. Don't edit this file, edit Makefile.PL instead.
  #
  #       ANY CHANGES MADE HERE WILL BE LOST!
  #
  #   MakeMaker ARGV: $argv
  #
  END
  
  #   MakeMaker 'CONFIGURE' Parameters:
  END
  all :
  
  manifypods :
  
  subdirs :
  
  dynamic :
  
  static :
  
  clean :
  
  install :
  
  makemakerdflt :
  
  test :
  
  test_dynamic :
  
  test_static :
  
  EOP
  #   MakeMaker Parameters:
  END
                      (?:
                          # double quoted string
                          (")                             # $quote
                          ((?>[^\\"]*(?:\\.[^\\"]*)*))"   # $quoted
          | # --OR--
                          # singe quoted string
                          (')                             # $quote
                          ((?>[^\\']*(?:\\.[^\\']*)*))'   # $quoted
                      |   # --OR--
                          # unquoted string
              (                               # $unquoted
                              (?:\\.|[^\\"'])*?
                          )
                          # followed by
              (                               # $delim
                              \Z(?!\n)                    # EOL
                          |   # --OR--
                              (?-x:$delimiter)            # delimiter
                          |   # --OR--
                              (?!^)(?=["'])               # a quote
                          )
          )//xs or return;my ($quote,$quoted,$unquoted,$delim)=(($1 ? ($1,$2): ($3,$4)),$5,$6);return()unless(defined($quote)|| length($unquoted)|| length($delim));if ($keep){$quoted="$quote$quoted$quote"}else {$unquoted =~ s/\\(.)/$1/sg;if (defined$quote){$quoted =~ s/\\(.)/$1/sg if ($quote eq '"')}}$word .= substr($line,0,0);$word .= defined$quote ? $quoted : $unquoted;if (length($delim)){push(@pieces,$word);push(@pieces,$delim)if ($keep eq 'delimiters');undef$word}if (!length($line)){push(@pieces,$word)}}return(@pieces)}sub check_manifest {print "Checking if your kit is complete...\n";require ExtUtils::Manifest;$ExtUtils::Manifest::Quiet=$ExtUtils::Manifest::Quiet=1;my(@missed)=ExtUtils::Manifest::manicheck();if (@missed){print "Warning: the following files are missing in your kit:\n";print "\t",join "\n\t",@missed;print "\n";print "Please inform the author.\n"}else {print "Looks good\n"}}sub parse_args{my($self,@args)=@_;@args=map {Encode::decode(locale=>$_)}@args if$CAN_DECODE;for (@args){unless (m/(.*?)=(.*)/){++$Verbose if m/^verb/;next}my($name,$value)=($1,$2);if ($value =~ m/^~(\w+)?/){$value =~ s [^~(\w*)]
                  [$1 ?
                   ((getpwnam($1))[7] || "~$1") :
                   (getpwuid($>))[7]
                   ]ex}$self->{ARGS}{uc$name}=$self->{uc$name}=$value}if (defined$self->{potential_libs}){my($msg)="'potential_libs' => '$self->{potential_libs}' should be";if ($self->{potential_libs}){print "$msg changed to:\n\t'LIBS' => ['$self->{potential_libs}']\n"}else {print "$msg deleted.\n"}$self->{LIBS}=[$self->{potential_libs}];delete$self->{potential_libs}}if (defined$self->{ARMAYBE}){my($armaybe)=$self->{ARMAYBE};print "ARMAYBE => '$armaybe' should be changed to:\n","\t'dynamic_lib' => {ARMAYBE => '$armaybe'}\n";my(%dl)=%{$self->{dynamic_lib}|| {}};$self->{dynamic_lib}={%dl,ARMAYBE=>$armaybe};delete$self->{ARMAYBE}}if (defined$self->{LDTARGET}){print "LDTARGET should be changed to LDFROM\n";$self->{LDFROM}=$self->{LDTARGET};delete$self->{LDTARGET}}if (defined$self->{DIR}&& ref \$self->{DIR}eq 'SCALAR'){$self->{DIR}=[grep $_,split ":",$self->{DIR}]}if (defined$self->{INCLUDE_EXT}&& ref \$self->{INCLUDE_EXT}eq 'SCALAR'){$self->{INCLUDE_EXT}=[grep $_,split '\s+',$self->{INCLUDE_EXT}]}if (defined$self->{EXCLUDE_EXT}&& ref \$self->{EXCLUDE_EXT}eq 'SCALAR'){$self->{EXCLUDE_EXT}=[grep $_,split '\s+',$self->{EXCLUDE_EXT}]}for my$mmkey (sort keys %$self){next if$mmkey eq 'ARGS';print "  $mmkey => ",neatvalue($self->{$mmkey}),"\n" if$Verbose;print "'$mmkey' is not a known MakeMaker parameter name.\n" unless exists$Recognized_Att_Keys{$mmkey}}$|=1 if$Verbose}sub check_hints {my($self)=@_;require File::Spec;my$curdir=File::Spec->curdir;my$hint_dir=File::Spec->catdir($curdir,"hints");return unless -d $hint_dir;my($hint)="${^O}_$Config{osvers}";$hint =~ s/\./_/g;$hint =~ s/_$//;return unless$hint;while (1){last if -f File::Spec->catfile($hint_dir,"$hint.pl")}continue {last unless$hint =~ s/_[^_]*$//}my$hint_file=File::Spec->catfile($hint_dir,"$hint.pl");return unless -f $hint_file;_run_hintfile($self,$hint_file)}sub _run_hintfile {our$self;local($self)=shift;my($hint_file)=shift;local($@,$!);print "Processing hints file $hint_file\n" if$Verbose;local@INC=(File::Spec->curdir,@INC);my$ret=do$hint_file;if(!defined$ret){my$error=$@ || $!;warn$error}}sub mv_all_methods {my($from,$to)=@_;local$SIG{__WARN__}=sub {warn @_ unless $_[0]=~ /^Subroutine .* redefined/};for my$method (@Overridable){next unless defined &{"${from}::$method"};no strict 'refs';*{"${to}::$method"}=\&{"${from}::$method"};{package MY;my$super="SUPER::".$method;*{$method}=sub {shift->$super(@_)}}}}sub skipcheck {my($self)=shift;my($section)=@_;return 'skipped' if$section eq 'metafile' && $UNDER_CORE;if ($section eq 'dynamic'){print "Warning (non-fatal): Target 'dynamic' depends on targets ","in skipped section 'dynamic_bs'\n" if$self->{SKIPHASH}{dynamic_bs}&& $Verbose;print "Warning (non-fatal): Target 'dynamic' depends on targets ","in skipped section 'dynamic_lib'\n" if$self->{SKIPHASH}{dynamic_lib}&& $Verbose}if ($section eq 'dynamic_lib'){print "Warning (non-fatal): Target '\$(INST_DYNAMIC)' depends on ","targets in skipped section 'dynamic_bs'\n" if$self->{SKIPHASH}{dynamic_bs}&& $Verbose}if ($section eq 'static'){print "Warning (non-fatal): Target 'static' depends on targets ","in skipped section 'static_lib'\n" if$self->{SKIPHASH}{static_lib}&& $Verbose}return 'skipped' if$self->{SKIPHASH}{$section};return ''}sub open_for_writing {my ($file)=@_;open my$fh,">",$file or die "Unable to open $file: $!";my@layers=':raw';push@layers,join ' ',':encoding(locale)' if$CAN_DECODE;binmode$fh,join ' ',@layers;$fh}sub flush {my$self=shift;my$finalname=$self->{MAKEFILE};printf "Generating a %s %s\n",$self->make_type,$finalname if$Verbose ||!$self->{PARENT};print "Writing $finalname for $self->{NAME}\n" if$Verbose ||!$self->{PARENT};unlink($finalname,"MakeMaker.tmp",$Is_VMS ? 'Descrip.MMS' : ());write_file_via_tmp($finalname,$self->{RESULT});print "Writing MYMETA.yml and MYMETA.json\n" if!$self->{NO_MYMETA}and $self->write_mymeta($self->mymeta);if ($self->{PARENT}&&!$self->{_KEEP_AFTER_FLUSH}){my%keep=map {($_=>1)}qw(NEEDS_LINKING HAS_LINK_CODE);delete$self->{$_}for grep!$keep{$_},keys %$self}system("$Config::Config{eunicefix} $finalname")if$Config::Config{eunicefix}ne ":";return}sub write_file_via_tmp {my ($finalname,$contents)=@_;my$fh=open_for_writing("MakeMaker.tmp");die "write_file_via_tmp: 2nd arg must be ref" unless ref$contents;for my$chunk (@$contents){my$to_write=$chunk;utf8::encode$to_write if!$CAN_DECODE && "$]" > 5.008;print$fh "$to_write\n" or die "Can't write to MakeMaker.tmp: $!"}close$fh or die "Can't write to MakeMaker.tmp: $!";_rename("MakeMaker.tmp",$finalname)or warn "rename MakeMaker.tmp => $finalname: $!";chmod 0644,$finalname if!$Is_VMS;return}sub _rename {my($src,$dest)=@_;_unlink($dest);return rename$src,$dest}sub _unlink {my@files=@_;chmod 0666,@files;return unlink@files}sub mkbootstrap {die <<END}sub mksymlists {die <<END}sub neatvalue {my($v)=@_;return "undef" unless defined$v;my($t)=ref$v;return "q[$v]" unless$t;if ($t eq 'ARRAY'){my(@m,@neat);push@m,"[";for my$elem (@$v){push@neat,"q[$elem]"}push@m,join ", ",@neat;push@m,"]";return join "",@m}return$v unless$t eq 'HASH';my(@m,$key,$val);for my$key (sort keys %$v){last unless defined$key;push@m,"$key=>".neatvalue($v->{$key})}return "{ ".join(', ',@m)." }"}sub _find_magic_vstring {my$value=shift;return$value if$UNDER_CORE;my$tvalue='';require B;my$sv=B::svref_2object(\$value);my$magic=ref($sv)eq 'B::PVMG' ? $sv->MAGIC : undef;while ($magic){if ($magic->TYPE eq 'V'){$tvalue=$magic->PTR;$tvalue =~ s/^v?(.+)$/v$1/;last}else {$magic=$magic->MOREMAGIC}}return$tvalue}sub selfdocument {my($self)=@_;my(@m);if ($Verbose){push@m,"\n# Full list of MakeMaker attribute values:";for my$key (sort keys %$self){next if$key eq 'RESULT' || $key =~ /^[A-Z][a-z]/;my($v)=neatvalue($self->{$key});$v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;$v =~ tr/\n/ /s;push@m,"# $key => $v"}}push@m,<<'EOF';push@m,join "\n",map "$_ ::\n\t\$(NOECHO) \$(NOOP)\n",grep!$self->{SKIPHASH}{$_},qw(static dynamic config);join "\n",@m}1;
  !!! Your Makefile has been built such a long time ago, !!!
  !!! that is unlikely to work with current MakeMaker.   !!!
  !!! Please rebuild your Makefile                       !!!
  END
  !!! Your Makefile has been built such a long time ago, !!!
  !!! that is unlikely to work with current MakeMaker.   !!!
  !!! Please rebuild your Makefile                       !!!
  END
  
  # here so even if top_targets is overridden, these will still be defined
  # gmake will silently still work if any are .PHONY-ed but nmake won't
  EOF
EXTUTILS_MAKEMAKER

$fatpacked{"ExtUtils/MakeMaker/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_CPANFILE';
  package ExtUtils::MakeMaker::CPANfile;use strict;use warnings;use ExtUtils::MakeMaker ();use File::Spec::Functions qw/catfile rel2abs/;use Module::CPANfile;use version;our$VERSION="0.09";sub import {my$class=shift;my$orig=\&ExtUtils::MakeMaker::WriteMakefile;my$writer=sub {my%params=@_;my ($caller,$file,$line)=caller;(my$root=rel2abs($file))=~ s/Makefile\.PL$//i or return;if (my$file=eval {Module::CPANfile->load(catfile($root,"cpanfile"))}){my$prereqs=$file->prereqs;_merge(\%params,_get($prereqs,'runtime','requires'),'PREREQ_PM',);_merge(\%params,_get($prereqs,'build','requires'),_eumm('6.56')? 'BUILD_REQUIRES' : 'PREREQ_PM',);_merge(\%params,_get($prereqs,'test','requires'),_eumm('6.63_03')? 'TEST_REQUIRES' : _eumm('6.56')? 'BUILD_REQUIRES' : 'PREREQ_PM',);_merge(\%params,_get($prereqs,'configure','requires'),_eumm('6.52')? 'CONFIGURE_REQUIRES' : undef,);_merge(\%params,{'ExtUtils::MakeMaker::CPANfile'=>$VERSION},_eumm('6.52')? 'CONFIGURE_REQUIRES' : undef,);if (!exists$params{META_ADD}{dynamic_config}&& !exists$params{META_MERGE}{dynamic_config}){$params{META_MERGE}{dynamic_config}=0}my$requires_2_0;for my$type (qw/recommends suggests conflicts/){for my$phase (qw/configure build test runtime develop/){my%tmp=%{$params{META_MERGE}{prereqs}{$phase}|| {}};_merge(\%tmp,_get($prereqs,$phase,$type),$type,);if ($tmp{$type}){$params{META_MERGE}{prereqs}{$phase}=\%tmp;$requires_2_0=1}}}if ($requires_2_0){my$tmp_prereqs=delete$params{META_MERGE}{prereqs};require CPAN::Meta::Converter;for my$key (qw/META_ADD META_MERGE/){next unless %{$params{$key}|| {}};my$converter=CPAN::Meta::Converter->new($params{$key},default_version=>1.4);$params{$key}=$converter->upgrade_fragment}if ($params{META_MERGE}{prereqs}){require CPAN::Meta::Requirements;for my$phase (keys %{$tmp_prereqs || {}}){for my$rel (keys %{$tmp_prereqs->{$phase}|| {}}){my$req1=CPAN::Meta::Requirements->from_string_hash($tmp_prereqs->{$phase}{$rel});my$req2=CPAN::Meta::Requirements->from_string_hash($params{META_MERGE}{prereqs}{$phase}{$rel});$req1->add_requirements($req2);$params{META_MERGE}{prereqs}{$phase}=$req1->as_string_hash}}}else {$params{META_MERGE}{prereqs}=$tmp_prereqs}}{last if _eumm('6.66_03');if (my$r=delete$params{TEST_REQUIRES}){_merge(\%params,$r,'BUILD_REQUIRES')}last if _eumm('6.56');if (my$r=delete$params{BUILD_REQUIRES}){_merge(\%params,$r,'PREREQ_PM')}last if _eumm('6.52');delete$params{CONFIGURE_REQUIRES};last if _eumm('6.47_01');delete$params{MIN_PERL_VERSION};last if _eumm('6.45_01');delete$params{META_ADD};delete$params{META_MERGE};last if _eumm('6.30_01');delete$params{LICENSE}}}else {print "cpanfile is not available: $@\n";exit 0}$orig->(%params)};{no warnings 'redefine';*main::WriteMakefile=*ExtUtils::MakeMaker::WriteMakefile=$writer}}sub _eumm {my$version=shift;eval {ExtUtils::MakeMaker->VERSION($version)}? 1 : 0}sub _get {my$prereqs=shift;eval {$prereqs->requirements_for(@_)->as_string_hash}}sub _merge {my ($params,$requires,$key)=@_;return unless$key;for (keys %{$requires || {}}){my$version=_normalize_version($requires->{$_});next unless defined$version;if (not exists$params->{$key}{$_}){$params->{$key}{$_}=$version}else {my$prev=$params->{$key}{$_};if (version->parse($prev)< version->parse($version)){$params->{$key}{$_}=$version}}}}sub _normalize_version {my$version=shift;return unless defined$version;return$version unless$version =~ /\s/;$version =~ s/(?:>=|==)\s*//;$version =~ s/,.+$//;return$version unless$version =~ /\s/;return}1;
EXTUTILS_MAKEMAKER_CPANFILE

$fatpacked{"ExtUtils/MakeMaker/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_CONFIG';
  package ExtUtils::MakeMaker::Config;use strict;our$VERSION='7.38';$VERSION =~ tr/_//d;use Config ();our%Config=%Config::Config;sub import {my$caller=caller;no strict 'refs';*{$caller.'::Config'}=\%Config}1;
EXTUTILS_MAKEMAKER_CONFIG

$fatpacked{"ExtUtils/MakeMaker/Locale.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_LOCALE';
  package ExtUtils::MakeMaker::Locale;use strict;our$VERSION="7.38";$VERSION =~ tr/_//d;use base 'Exporter';our@EXPORT_OK=qw(decode_argv env $ENCODING_LOCALE $ENCODING_LOCALE_FS $ENCODING_CONSOLE_IN $ENCODING_CONSOLE_OUT);use Encode ();use Encode::Alias ();our$ENCODING_LOCALE;our$ENCODING_LOCALE_FS;our$ENCODING_CONSOLE_IN;our$ENCODING_CONSOLE_OUT;sub DEBUG () {0}sub _init {if ($^O eq "MSWin32"){unless ($ENCODING_LOCALE){eval {unless (defined&GetConsoleCP){require Win32;*GetConsoleCP=sub {&Win32::GetConsoleCP}if defined&Win32::GetConsoleCP}unless (defined&GetConsoleCP){require Win32::API;Win32::API->Import('kernel32','int GetConsoleCP()')}if (defined&GetConsoleCP){my$cp=GetConsoleCP();$ENCODING_LOCALE="cp$cp" if$cp}}}unless ($ENCODING_CONSOLE_IN){unless (defined&GetInputCP){eval {require Win32;eval {local$SIG{__WARN__}=sub {}if ("$]" < 5.014);Win32::GetConsoleCP()};*GetInputCP=sub {&Win32::GetConsoleCP}if defined&Win32::GetConsoleCP;*GetOutputCP=sub {&Win32::GetConsoleOutputCP}if defined&Win32::GetConsoleOutputCP};unless (defined&GetInputCP){eval {require Win32::Console;*GetInputCP=sub {&Win32::Console::InputCP}if defined&Win32::Console::InputCP;*GetOutputCP=sub {&Win32::Console::OutputCP}if defined&Win32::Console::OutputCP}}unless (defined&GetInputCP){*GetInputCP=*GetOutputCP=sub {((qx(chcp) || '')=~ /^Active code page: (\d+)/)? $1 : ()}}}my$cp=GetInputCP();$ENCODING_CONSOLE_IN="cp$cp" if$cp;$cp=GetOutputCP();$ENCODING_CONSOLE_OUT="cp$cp" if$cp}}unless ($ENCODING_LOCALE){eval {require I18N::Langinfo;$ENCODING_LOCALE=I18N::Langinfo::langinfo(I18N::Langinfo::CODESET());$ENCODING_LOCALE="ascii" if$ENCODING_LOCALE eq "646";$ENCODING_LOCALE="hp-roman8" if $^O eq "hpux" && $ENCODING_LOCALE eq "roman8"};$ENCODING_LOCALE ||= $ENCODING_CONSOLE_IN}$ENCODING_LOCALE='UTF-7' if$ENCODING_LOCALE && lc($ENCODING_LOCALE)eq "cp65000";$ENCODING_LOCALE='utf-8-strict' if$ENCODING_LOCALE && lc($ENCODING_LOCALE)eq "cp65001";if ($^O eq "darwin"){$ENCODING_LOCALE_FS ||= "UTF-8"}$ENCODING_LOCALE ||= $^O eq "MSWin32" ? "cp1252" : "UTF-8";$ENCODING_LOCALE_FS ||= $ENCODING_LOCALE;$ENCODING_CONSOLE_IN ||= $ENCODING_LOCALE;$ENCODING_CONSOLE_OUT ||= $ENCODING_CONSOLE_IN;unless (Encode::find_encoding($ENCODING_LOCALE)){my$foundit;if (lc($ENCODING_LOCALE)eq "gb18030"){eval {require Encode::HanExtra};if ($@){die "Need Encode::HanExtra to be installed to support locale codeset ($ENCODING_LOCALE), stopped"}$foundit++ if Encode::find_encoding($ENCODING_LOCALE)}die "The locale codeset ($ENCODING_LOCALE) isn't one that perl can decode, stopped" unless$foundit}}_init();Encode::Alias::define_alias(sub {no strict 'refs';no warnings 'once';return ${"ENCODING_" .uc(shift)}},"locale");sub _flush_aliases {no strict 'refs';for my$a (sort keys%Encode::Alias::Alias){if (defined ${"ENCODING_" .uc($a)}){delete$Encode::Alias::Alias{$a};warn "Flushed alias cache for $a" if DEBUG}}}sub reinit {$ENCODING_LOCALE=shift;$ENCODING_LOCALE_FS=shift;$ENCODING_CONSOLE_IN=$ENCODING_LOCALE;$ENCODING_CONSOLE_OUT=$ENCODING_LOCALE;_init();_flush_aliases()}sub decode_argv {die if defined wantarray;for (@ARGV){$_=Encode::decode(locale=>$_,@_)}}sub env {my$k=Encode::encode(locale=>shift);my$old=$ENV{$k};if (@_){my$v=shift;if (defined$v){$ENV{$k}=Encode::encode(locale=>$v)}else {delete$ENV{$k}}}return Encode::decode(locale=>$old)if defined wantarray}1;
EXTUTILS_MAKEMAKER_LOCALE

$fatpacked{"ExtUtils/MakeMaker/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_VERSION';
  package ExtUtils::MakeMaker::version;use 5.006001;use strict;use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);$VERSION='7.38';$VERSION =~ tr/_//d;$CLASS='version';{local$SIG{'__DIE__'};eval "use version";if ($@){eval "use ExtUtils::MakeMaker::version::vpp";die "$@" if ($@);local $^W;delete$INC{'version.pm'};$INC{'version.pm'}=$INC{'ExtUtils/MakeMaker/version.pm'};push@version::ISA,"ExtUtils::MakeMaker::version::vpp";$version::VERSION=$VERSION;*version::qv=\&ExtUtils::MakeMaker::version::vpp::qv;*version::declare=\&ExtUtils::MakeMaker::version::vpp::declare;*version::_VERSION=\&ExtUtils::MakeMaker::version::vpp::_VERSION;*version::vcmp=\&ExtUtils::MakeMaker::version::vpp::vcmp;*version::new=\&ExtUtils::MakeMaker::version::vpp::new;if ("$]" >= 5.009000){no strict 'refs';*version::stringify=\&ExtUtils::MakeMaker::version::vpp::stringify;*{'version::(""'}=\&ExtUtils::MakeMaker::version::vpp::stringify;*{'version::(<=>'}=\&ExtUtils::MakeMaker::version::vpp::vcmp;*version::parse=\&ExtUtils::MakeMaker::version::vpp::parse}require ExtUtils::MakeMaker::version::regex;*version::is_lax=\&ExtUtils::MakeMaker::version::regex::is_lax;*version::is_strict=\&ExtUtils::MakeMaker::version::regex::is_strict;*LAX=\$ExtUtils::MakeMaker::version::regex::LAX;*STRICT=\$ExtUtils::MakeMaker::version::regex::STRICT}elsif (!version->can('is_qv')){*version::is_qv=sub {exists $_[0]->{qv}}}}1;
EXTUTILS_MAKEMAKER_VERSION

$fatpacked{"ExtUtils/MakeMaker/version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_VERSION_REGEX';
  package ExtUtils::MakeMaker::version::regex;use strict;use vars qw($VERSION $CLASS $STRICT $LAX);$VERSION='7.38';$VERSION =~ tr/_//d;my$FRACTION_PART=qr/\.[0-9]+/;my$STRICT_INTEGER_PART=qr/0|[1-9][0-9]*/;my$LAX_INTEGER_PART=qr/[0-9]+/;my$STRICT_DOTTED_DECIMAL_PART=qr/\.[0-9]{1,3}/;my$LAX_DOTTED_DECIMAL_PART=qr/\.[0-9]+/;my$LAX_ALPHA_PART=qr/_[0-9]+/;my$STRICT_DECIMAL_VERSION=qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;my$STRICT_DOTTED_DECIMAL_VERSION=qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;$STRICT=qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;my$LAX_DECIMAL_VERSION=qr/ $LAX_INTEGER_PART (?: \. | $FRACTION_PART $LAX_ALPHA_PART? )?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;my$LAX_DOTTED_DECIMAL_VERSION=qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;$LAX=qr/ undef | $LAX_DECIMAL_VERSION | $LAX_DOTTED_DECIMAL_VERSION /x;sub is_strict {defined $_[0]&& $_[0]=~ qr/ \A $STRICT \z /x}sub is_lax {defined $_[0]&& $_[0]=~ qr/ \A $LAX \z /x}1;
EXTUTILS_MAKEMAKER_VERSION_REGEX

$fatpacked{"ExtUtils/MakeMaker/version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_VERSION_VPP';
  package ExtUtils::MakeMaker::charstar;use overload ('""'=>\&thischar,'0+'=>\&thischar,'++'=>\&increment,'--'=>\&decrement,'+'=>\&plus,'-'=>\&minus,'*'=>\&multiply,'cmp'=>\&cmp,'<=>'=>\&spaceship,'bool'=>\&thischar,'='=>\&clone,);sub new {my ($self,$string)=@_;my$class=ref($self)|| $self;my$obj={string=>[split(//,$string)],current=>0,};return bless$obj,$class}sub thischar {my ($self)=@_;my$last=$#{$self->{string}};my$curr=$self->{current};if ($curr >= 0 && $curr <= $last){return$self->{string}->[$curr]}else {return ''}}sub increment {my ($self)=@_;$self->{current}++}sub decrement {my ($self)=@_;$self->{current}--}sub plus {my ($self,$offset)=@_;my$rself=$self->clone;$rself->{current}+= $offset;return$rself}sub minus {my ($self,$offset)=@_;my$rself=$self->clone;$rself->{current}-= $offset;return$rself}sub multiply {my ($left,$right,$swapped)=@_;my$char=$left->thischar();return$char * $right}sub spaceship {my ($left,$right,$swapped)=@_;unless (ref($right)){$right=$left->new($right)}return$left->{current}<=> $right->{current}}sub cmp {my ($left,$right,$swapped)=@_;unless (ref($right)){if (length($right)==1){return$left->thischar cmp $right}$right=$left->new($right)}return$left->currstr cmp $right->currstr}sub bool {my ($self)=@_;my$char=$self->thischar;return ($char ne '')}sub clone {my ($left,$right,$swapped)=@_;$right={string=>[@{$left->{string}}],current=>$left->{current},};return bless$right,ref($left)}sub currstr {my ($self,$s)=@_;my$curr=$self->{current};my$last=$#{$self->{string}};if (defined($s)&& $s->{current}< $last){$last=$s->{current}}my$string=join('',@{$self->{string}}[$curr..$last]);return$string}package ExtUtils::MakeMaker::version::vpp;use 5.006001;use strict;use Config;use vars qw($VERSION $CLASS @ISA $LAX $STRICT);$VERSION='7.38';$VERSION =~ tr/_//d;$CLASS='ExtUtils::MakeMaker::version::vpp';require ExtUtils::MakeMaker::version::regex;*ExtUtils::MakeMaker::version::vpp::is_strict=\&ExtUtils::MakeMaker::version::regex::is_strict;*ExtUtils::MakeMaker::version::vpp::is_lax=\&ExtUtils::MakeMaker::version::regex::is_lax;*LAX=\$ExtUtils::MakeMaker::version::regex::LAX;*STRICT=\$ExtUtils::MakeMaker::version::regex::STRICT;use overload ('""'=>\&stringify,'0+'=>\&numify,'cmp'=>\&vcmp,'<=>'=>\&vcmp,'bool'=>\&vbool,'+'=>\&vnoop,'-'=>\&vnoop,'*'=>\&vnoop,'/'=>\&vnoop,'+='=>\&vnoop,'-='=>\&vnoop,'*='=>\&vnoop,'/='=>\&vnoop,'abs'=>\&vnoop,);eval "use warnings";if ($@){eval '
  	package
  	warnings;
  	sub enabled {return $^W;}
  	1;
      '}sub import {no strict 'refs';my ($class)=shift;unless ($class eq $CLASS){local $^W;*{$class.'::declare'}=\&{$CLASS.'::declare'};*{$class.'::qv'}=\&{$CLASS.'::qv'}}my%args;if (@_){map {$args{$_}=1}@_}else {%args=(qv=>1,'UNIVERSAL::VERSION'=>1,)}my$callpkg=caller();if (exists($args{declare})){*{$callpkg.'::declare'}=sub {return$class->declare(shift)}unless defined(&{$callpkg.'::declare'})}if (exists($args{qv})){*{$callpkg.'::qv'}=sub {return$class->qv(shift)}unless defined(&{$callpkg.'::qv'})}if (exists($args{'UNIVERSAL::VERSION'})){local $^W;*UNIVERSAL::VERSION =\&{$CLASS.'::_VERSION'}}if (exists($args{'VERSION'})){*{$callpkg.'::VERSION'}=\&{$CLASS.'::_VERSION'}}if (exists($args{'is_strict'})){*{$callpkg.'::is_strict'}=\&{$CLASS.'::is_strict'}unless defined(&{$callpkg.'::is_strict'})}if (exists($args{'is_lax'})){*{$callpkg.'::is_lax'}=\&{$CLASS.'::is_lax'}unless defined(&{$callpkg.'::is_lax'})}}my$VERSION_MAX=0x7FFFFFFF;use constant TRUE=>1;use constant FALSE=>0;sub isDIGIT {my ($char)=shift->thischar();return ($char =~ /\d/)}sub isALPHA {my ($char)=shift->thischar();return ($char =~ /[a-zA-Z]/)}sub isSPACE {my ($char)=shift->thischar();return ($char =~ /\s/)}sub BADVERSION {my ($s,$errstr,$error)=@_;if ($errstr){$$errstr=$error}return$s}sub prescan_version {my ($s,$strict,$errstr,$sqv,$ssaw_decimal,$swidth,$salpha)=@_;my$qv=defined$sqv ? $$sqv : FALSE;my$saw_decimal=defined$ssaw_decimal ? $$ssaw_decimal : 0;my$width=defined$swidth ? $$swidth : 3;my$alpha=defined$salpha ? $$salpha : FALSE;my$d=$s;if ($qv && isDIGIT($d)){goto dotted_decimal_version}if ($d eq 'v'){$d++;if (isDIGIT($d)){$qv=TRUE}else {return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}dotted_decimal_version: if ($strict && $d eq '0' && isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)")}while (isDIGIT($d)){$d++}if ($d eq '.'){$saw_decimal++;$d++}else {if ($strict){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}else {goto version_prescan_finish}}{my$i=0;my$j=0;while (isDIGIT($d)){$i++;while (isDIGIT($d)){$d++;$j++;if ($strict && $j > 3){return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)")}}if ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)")}$d++;$alpha=TRUE}elsif ($d eq '.'){if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)")}$saw_decimal++;$d++}elsif (!isDIGIT($d)){last}$j=0}if ($strict && $i < 2){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}}}else {my$j=0;if ($strict){if ($d eq '.'){return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)")}if ($d eq '0' && isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)")}}if ($d eq '-'){return BADVERSION($s,$errstr,"Invalid version format (negative version number)")}while (isDIGIT($d)){$d++}if ($d eq '.'){$saw_decimal++;$d++}elsif (!$d || $d eq ';' || isSPACE($d)|| $d eq '}'){if ($d==$s){return BADVERSION($s,$errstr,"Invalid version format (version required)")}goto version_prescan_finish}elsif ($d==$s){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}elsif ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}elsif (isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)")}else {return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)")}}elsif ($d){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}if ($d &&!isDIGIT($d)&& ($strict ||!($d eq ';' || isSPACE($d)|| $d eq '}'))){return BADVERSION($s,$errstr,"Invalid version format (fractional part required)")}while (isDIGIT($d)){$d++;$j++;if ($d eq '.' && isDIGIT($d-1)){if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)")}if ($strict){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')")}$d=$s;$qv=TRUE;goto dotted_decimal_version}if ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)")}if (!isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)")}$width=$j;$d++;$alpha=TRUE}}}version_prescan_finish: while (isSPACE($d)){$d++}if ($d &&!isDIGIT($d)&& (!($d eq ';' || $d eq '}'))){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}if (defined$sqv){$$sqv=$qv}if (defined$swidth){$$swidth=$width}if (defined$ssaw_decimal){$$ssaw_decimal=$saw_decimal}if (defined$salpha){$$salpha=$alpha}return$d}sub scan_version {my ($s,$rv,$qv)=@_;my$start;my$pos;my$last;my$errstr;my$saw_decimal=0;my$width=3;my$alpha=FALSE;my$vinf=FALSE;my@av;$s=new ExtUtils::MakeMaker::charstar$s;while (isSPACE($s)){$s++}$last=prescan_version($s,FALSE,\$errstr,\$qv,\$saw_decimal,\$width,\$alpha);if ($errstr){if ($s ne 'undef'){require Carp;Carp::croak($errstr)}}$start=$s;if ($s eq 'v'){$s++}$pos=$s;if ($qv){$$rv->{qv}=$qv}if ($alpha){$$rv->{alpha}=$alpha}if (!$qv && $width < 3){$$rv->{width}=$width}while (isDIGIT($pos)){$pos++}if (!isALPHA($pos)){my$rev;for (;;){$rev=0;{my$end=$pos;my$mult=1;my$orev;if (!$qv && $s > $start && $saw_decimal==1){$mult *= 100;while ($s < $end){$orev=$rev;$rev += $s * $mult;$mult /= 10;if ((abs($orev)> abs($rev))|| (abs($rev)> $VERSION_MAX)){warn("Integer overflow in version %d",$VERSION_MAX);$s=$end - 1;$rev=$VERSION_MAX;$vinf=1}$s++;if ($s eq '_'){$s++}}}else {while (--$end >= $s){$orev=$rev;$rev += $end * $mult;$mult *= 10;if ((abs($orev)> abs($rev))|| (abs($rev)> $VERSION_MAX)){warn("Integer overflow in version");$end=$s - 1;$rev=$VERSION_MAX;$vinf=1}}}}push@av,$rev;if ($vinf){$s=$last;last}elsif ($pos eq '.'){$s=++$pos}elsif ($pos eq '_' && isDIGIT($pos+1)){$s=++$pos}elsif ($pos eq ',' && isDIGIT($pos+1)){$s=++$pos}elsif (isDIGIT($pos)){$s=$pos}else {$s=$pos;last}if ($qv){while (isDIGIT($pos)){$pos++}}else {my$digits=0;while ((isDIGIT($pos)|| $pos eq '_')&& $digits < 3){if ($pos ne '_'){$digits++}$pos++}}}}if ($qv){my$len=$#av;$len=2 - $len;while ($len-- > 0){push@av,0}}if ($vinf){$$rv->{original}="v.Inf";$$rv->{vinf}=1}elsif ($s > $start){$$rv->{original}=$start->currstr($s);if ($qv && $saw_decimal==1 && $start ne 'v'){$$rv->{original}='v' .$$rv->{original}}}else {$$rv->{original}='0';push(@av,0)}$$rv->{version}=\@av;if ($s eq 'undef'){$s += 5}return$s}sub new {my$class=shift;unless (defined$class or $#_ > 1){require Carp;Carp::croak('Usage: version::new(class, version)')}my$self=bless ({},ref ($class)|| $class);my$qv=FALSE;if ($#_==1){$qv=TRUE}my$value=pop;if (ref($value)&& eval('$value->isa("version")')){$self->{version}=[@{$value->{version}}];$self->{qv}=1 if$value->{qv};$self->{alpha}=1 if$value->{alpha};$self->{original}=''.$value->{original};return$self}if (not defined$value or $value =~ /^undef$/){push @{$self->{version}},0;$self->{original}="0";return ($self)}if (ref($value)=~ m/ARRAY|HASH/){require Carp;Carp::croak("Invalid version format (non-numeric data)")}$value=_un_vstring($value);if ($Config{d_setlocale}&& eval {require POSIX}){require locale;my$currlocale=POSIX::setlocale(&POSIX::LC_ALL);if (POSIX::localeconv()->{decimal_point}eq ','){$value =~ tr/,/./}}if ($value =~ /\d+.?\d*e[-+]?\d+/){$value=sprintf("%.9f",$value);$value =~ s/(0+)$//}my$s=scan_version($value,\$self,$qv);if ($s){warn("Version string '%s' contains invalid data; " ."ignoring: '%s'",$value,$s)}return ($self)}*parse=\&new;sub numify {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}my$width=$self->{width}|| 3;my$alpha=$self->{alpha}|| "";my$len=$#{$self->{version}};my$digit=$self->{version}[0];my$string=sprintf("%d.",$digit);for (my$i=1 ;$i < $len ;$i++ ){$digit=$self->{version}[$i];if ($width < 3){my$denom=10**(3-$width);my$quot=int($digit/$denom);my$rem=$digit - ($quot * $denom);$string .= sprintf("%0".$width."d_%d",$quot,$rem)}else {$string .= sprintf("%03d",$digit)}}if ($len > 0){$digit=$self->{version}[$len];if ($alpha && $width==3){$string .= "_"}$string .= sprintf("%0".$width."d",$digit)}else {$string .= sprintf("000")}return$string}sub normal {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}my$alpha=$self->{alpha}|| "";my$len=$#{$self->{version}};my$digit=$self->{version}[0];my$string=sprintf("v%d",$digit);for (my$i=1 ;$i < $len ;$i++ ){$digit=$self->{version}[$i];$string .= sprintf(".%d",$digit)}if ($len > 0){$digit=$self->{version}[$len];if ($alpha){$string .= sprintf("_%0d",$digit)}else {$string .= sprintf(".%0d",$digit)}}if ($len <= 2){for ($len=2 - $len;$len!=0;$len-- ){$string .= sprintf(".%0d",0)}}return$string}sub stringify {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}return exists$self->{original}? $self->{original}: exists$self->{qv}? $self->normal : $self->numify}sub vcmp {require UNIVERSAL;my ($left,$right,$swap)=@_;my$class=ref($left);unless (UNIVERSAL::isa($right,$class)){$right=$class->new($right)}if ($swap){($left,$right)=($right,$left)}unless (_verify($left)){require Carp;Carp::croak("Invalid version object")}unless (_verify($right)){require Carp;Carp::croak("Invalid version format")}my$l=$#{$left->{version}};my$r=$#{$right->{version}};my$m=$l < $r ? $l : $r;my$lalpha=$left->is_alpha;my$ralpha=$right->is_alpha;my$retval=0;my$i=0;while ($i <= $m && $retval==0){$retval=$left->{version}[$i]<=> $right->{version}[$i];$i++}if ($retval==0 && $l==$r && $left->{version}[$m]==$right->{version}[$m]&& ($lalpha || $ralpha)){if ($lalpha &&!$ralpha){$retval=-1}elsif ($ralpha &&!$lalpha){$retval=+1}}if ($retval==0 && $l!=$r){if ($l < $r){while ($i <= $r && $retval==0){if ($right->{version}[$i]!=0){$retval=-1}$i++}}else {while ($i <= $l && $retval==0){if ($left->{version}[$i]!=0){$retval=+1}$i++}}}return$retval}sub vbool {my ($self)=@_;return vcmp($self,$self->new("0"),1)}sub vnoop {require Carp;Carp::croak("operation not supported with version object")}sub is_alpha {my ($self)=@_;return (exists$self->{alpha})}sub qv {my$value=shift;my$class=$CLASS;if (@_){$class=ref($value)|| $value;$value=shift}$value=_un_vstring($value);$value='v'.$value unless$value =~ /(^v|\d+\.\d+\.\d)/;my$obj=$CLASS->new($value);return bless$obj,$class}*declare=\&qv;sub is_qv {my ($self)=@_;return (exists$self->{qv})}sub _verify {my ($self)=@_;if (ref($self)&& eval {exists$self->{version}}&& ref($self->{version})eq 'ARRAY'){return 1}else {return 0}}sub _is_non_alphanumeric {my$s=shift;$s=new ExtUtils::MakeMaker::charstar$s;while ($s){return 0 if isSPACE($s);return 1 unless (isALPHA($s)|| isDIGIT($s)|| $s =~ /[.-]/);$s++}return 0}sub _un_vstring {my$value=shift;if (length($value)>= 3 && $value !~ /[._]/ && _is_non_alphanumeric($value)){my$tvalue;if ("$]" >= 5.008_001){$tvalue=_find_magic_vstring($value);$value=$tvalue if length$tvalue}elsif ("$]" >= 5.006_000){$tvalue=sprintf("v%vd",$value);if ($tvalue =~ /^v\d+(\.\d+){2,}$/){$value=$tvalue}}}return$value}sub _find_magic_vstring {my$value=shift;my$tvalue='';require B;my$sv=B::svref_2object(\$value);my$magic=ref($sv)eq 'B::PVMG' ? $sv->MAGIC : undef;while ($magic){if ($magic->TYPE eq 'V'){$tvalue=$magic->PTR;$tvalue =~ s/^v?(.+)$/v$1/;last}else {$magic=$magic->MOREMAGIC}}return$tvalue}sub _VERSION {my ($obj,$req)=@_;my$class=ref($obj)|| $obj;no strict 'refs';if (exists$INC{"$class.pm"}and not %{"$class\::"}and "$]" >= 5.008){require Carp;Carp::croak("$class defines neither package nor VERSION" ."--version check failed")}my$version=eval "\$$class\::VERSION";if (defined$version){local $^W if "$]" <= 5.008;$version=ExtUtils::MakeMaker::version::vpp->new($version)}if (defined$req){unless (defined$version){require Carp;my$msg="$]" < 5.006 ? "$class version $req required--this is only version " : "$class does not define \$$class\::VERSION" ."--version check failed";if ($ENV{VERSION_DEBUG}){Carp::confess($msg)}else {Carp::croak($msg)}}$req=ExtUtils::MakeMaker::version::vpp->new($req);if ($req > $version){require Carp;if ($req->is_qv){Carp::croak(sprintf ("%s version %s required--"."this is only version %s",$class,$req->normal,$version->normal))}else {Carp::croak(sprintf ("%s version %s required--"."this is only version %s",$class,$req->stringify,$version->stringify))}}}return defined$version ? $version->stringify : undef}1;
EXTUTILS_MAKEMAKER_VERSION_VPP

$fatpacked{"ExtUtils/Mkbootstrap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MKBOOTSTRAP';
  package ExtUtils::Mkbootstrap;use strict 'refs';our$VERSION='7.38';$VERSION =~ tr/_//d;require Exporter;our@ISA=('Exporter');our@EXPORT=('&Mkbootstrap');use Config;our$Verbose=0;sub Mkbootstrap {my($baseext,@bsloadlibs)=@_;@bsloadlibs=grep($_,@bsloadlibs);print "	bsloadlibs=@bsloadlibs\n" if$Verbose;require DynaLoader;rename "$baseext.bs","$baseext.bso" if -s "$baseext.bs";if (-f "${baseext}_BS"){$_="${baseext}_BS";package DynaLoader;local($osname,$dlsrc)=();($osname,$dlsrc)=@Config::Config{qw(osname dlsrc)};$bscode="";unshift@INC,".";require $_;shift@INC}if ($Config{'dlsrc'}=~ /^dl_dld/){package DynaLoader;push(@dl_resolve_using,dl_findfile('-lc'))}my(@all)=(@bsloadlibs,@DynaLoader::dl_resolve_using);my($method)='';if (@all || (defined$DynaLoader::bscode && length$DynaLoader::bscode)){open my$bs,">","$baseext.bs" or die "Unable to open $baseext.bs: $!";print "Writing $baseext.bs\n";print "	containing: @all" if$Verbose;print$bs "# $baseext DynaLoader bootstrap file for $^O architecture.\n";print$bs "# Do not edit this file, changes will be lost.\n";print$bs "# This file was automatically generated by the\n";print$bs "# Mkbootstrap routine in ExtUtils::Mkbootstrap (v$VERSION).\n";if (@all){print$bs "\@DynaLoader::dl_resolve_using = ";if (" @all" =~ m/ -[lLR]/){print$bs "  dl_findfile(qw(\n  @all\n  ));\n"}else {print$bs "  qw(@all);\n"}}print$bs $DynaLoader::bscode if$DynaLoader::bscode;print$bs "\n1;\n";close$bs}}1;
EXTUTILS_MKBOOTSTRAP

$fatpacked{"ExtUtils/Mksymlists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MKSYMLISTS';
  package ExtUtils::Mksymlists;use 5.006;use strict qw[subs refs];use Carp;use Exporter;use Config;our@ISA=qw(Exporter);our@EXPORT=qw(&Mksymlists);our$VERSION='7.38';$VERSION =~ tr/_//d;sub Mksymlists {my(%spec)=@_;my($osname)=$^O;croak("Insufficient information specified to Mksymlists")unless ($spec{NAME}or ($spec{FILE}and ($spec{DL_FUNCS}or $spec{FUNCLIST})));$spec{DL_VARS}=[]unless$spec{DL_VARS};($spec{FILE}=$spec{NAME})=~ s/.*::// unless$spec{FILE};$spec{FUNCLIST}=[]unless$spec{FUNCLIST};$spec{DL_FUNCS}={$spec{NAME}=>[]}unless (($spec{DL_FUNCS}and keys %{$spec{DL_FUNCS}})or @{$spec{FUNCLIST}});if (defined$spec{DL_FUNCS}){for my$package (sort keys %{$spec{DL_FUNCS}}){my($packprefix,$bootseen);($packprefix=$package)=~ s/\W/_/g;for my$sym (@{$spec{DL_FUNCS}->{$package}}){if ($sym =~ /^boot_/){push(@{$spec{FUNCLIST}},$sym);$bootseen++}else {push(@{$spec{FUNCLIST}},"XS_${packprefix}_$sym")}}push(@{$spec{FUNCLIST}},"boot_$packprefix")unless$bootseen}}if (defined&DynaLoader::mod2fname and not $spec{DLBASE}){$spec{DLBASE}=DynaLoader::mod2fname([split(/::/,$spec{NAME})])}if ($osname eq 'aix'){_write_aix(\%spec)}elsif ($osname eq 'MacOS'){_write_aix(\%spec)}elsif ($osname eq 'VMS'){_write_vms(\%spec)}elsif ($osname eq 'os2'){_write_os2(\%spec)}elsif ($osname eq 'MSWin32'){_write_win32(\%spec)}else {croak("Don't know how to create linker option file for $osname\n")}}sub _write_aix {my($data)=@_;rename "$data->{FILE}.exp","$data->{FILE}.exp_old";open(my$exp,">","$data->{FILE}.exp")or croak("Can't create $data->{FILE}.exp: $!\n");print$exp join("\n",@{$data->{DL_VARS}},"\n")if @{$data->{DL_VARS}};print$exp join("\n",@{$data->{FUNCLIST}},"\n")if @{$data->{FUNCLIST}};close$exp}sub _write_os2 {my($data)=@_;require Config;my$threaded=($Config::Config{archname}=~ /-thread/ ? " threaded" : "");if (not $data->{DLBASE}){($data->{DLBASE}=$data->{NAME})=~ s/.*:://;$data->{DLBASE}=substr($data->{DLBASE},0,7).'_'}my$distname=$data->{DISTNAME}|| $data->{NAME};$distname="Distribution $distname";my$patchlevel=" pl$Config{perl_patchlevel}" || '';my$comment=sprintf "Perl (v%s%s%s) module %s",$Config::Config{version},$threaded,$patchlevel,$data->{NAME};chomp$comment;if ($data->{INSTALLDIRS}and $data->{INSTALLDIRS}eq 'perl'){$distname='perl5-porters@perl.org';$comment="Core $comment"}$comment="$comment (Perl-config: $Config{config_args})";$comment=substr($comment,0,200)."...)" if length$comment > 203;rename "$data->{FILE}.def","$data->{FILE}_def.old";open(my$def,">","$data->{FILE}.def")or croak("Can't create $data->{FILE}.def: $!\n");print$def "LIBRARY '$data->{DLBASE}' INITINSTANCE TERMINSTANCE\n";print$def "DESCRIPTION '\@#$distname:$data->{VERSION}#\@ $comment'\n";print$def "CODE LOADONCALL\n";print$def "DATA LOADONCALL NONSHARED MULTIPLE\n";print$def "EXPORTS\n  ";print$def join("\n  ",@{$data->{DL_VARS}},"\n")if @{$data->{DL_VARS}};print$def join("\n  ",@{$data->{FUNCLIST}},"\n")if @{$data->{FUNCLIST}};_print_imports($def,$data);close$def}sub _print_imports {my ($def,$data)=@_;my$imports=$data->{IMPORTS}or return;if (keys %$imports){print$def "IMPORTS\n";for my$name (sort keys %$imports){print$def "  $name=$imports->{$name}\n"}}}sub _write_win32 {my($data)=@_;require Config;if (not $data->{DLBASE}){($data->{DLBASE}=$data->{NAME})=~ s/.*:://;$data->{DLBASE}=substr($data->{DLBASE},0,7).'_'}rename "$data->{FILE}.def","$data->{FILE}_def.old";open(my$def,">","$data->{FILE}.def")or croak("Can't create $data->{FILE}.def: $!\n");if ($Config::Config{'cc'}!~ /\bgcc/i){print$def "LIBRARY \"$data->{DLBASE}\"\n"}print$def "EXPORTS\n  ";my@syms;unless("$]" >= 5.016){if ($Config::Config{'cc'}=~ /^bcc/i){push@syms,"_$_","$_ = _$_" for (@{$data->{DL_VARS}},@{$data->{FUNCLIST}})}else {push@syms,"$_","_$_ = $_" for (@{$data->{DL_VARS}},@{$data->{FUNCLIST}})}}else {push@syms,"$_" for (@{$data->{DL_VARS}},@{$data->{FUNCLIST}})}print$def join("\n  ",@syms,"\n")if@syms;_print_imports($def,$data);close$def}sub _write_vms {my($data)=@_;require Config;require ExtUtils::XSSymSet;my($isvax)=$Config::Config{'archname'}=~ /VAX/i;my($set)=new ExtUtils::XSSymSet;rename "$data->{FILE}.opt","$data->{FILE}.opt_old";open(my$opt,">","$data->{FILE}.opt")or croak("Can't create $data->{FILE}.opt: $!\n");print$opt "case_sensitive=yes\n" if$Config::Config{d_vms_case_sensitive_symbols};for my$sym (@{$data->{FUNCLIST}}){my$safe=$set->addsym($sym);if ($isvax){print$opt "UNIVERSAL=$safe\n"}else {print$opt "SYMBOL_VECTOR=($safe=PROCEDURE)\n"}}for my$sym (@{$data->{DL_VARS}}){my$safe=$set->addsym($sym);print$opt "PSECT_ATTR=${sym},PIC,OVR,RD,NOEXE,WRT,NOSHR\n";if ($isvax){print$opt "UNIVERSAL=$safe\n"}else {print$opt "SYMBOL_VECTOR=($safe=DATA)\n"}}close$opt}1;
EXTUTILS_MKSYMLISTS

$fatpacked{"ExtUtils/Packlist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_PACKLIST';
  package ExtUtils::Packlist;use 5.00503;use strict;use Carp qw();use Config;use vars qw($VERSION $Relocations);$VERSION='2.14';$VERSION=eval$VERSION;my$fhname="FH1";sub mkfh() {no strict;local $^W;my$fh=\*{$fhname++};use strict;return($fh)}sub __find_relocations {my%paths;while (my ($raw_key,$raw_val)=each%Config){my$exp_key=$raw_key ."exp";next unless exists$Config{$exp_key};next unless$raw_val =~ m!\.\.\./!;$paths{$Config{$exp_key}}++}my$alternations=join "|",map {quotemeta $_}sort {length$b <=> length$a}keys%paths;qr/^($alternations)/o}sub new($$) {my ($class,$packfile)=@_;$class=ref($class)|| $class;my%self;tie(%self,$class,$packfile);return(bless(\%self,$class))}sub TIEHASH {my ($class,$packfile)=@_;my$self={packfile=>$packfile };bless($self,$class);$self->read($packfile)if (defined($packfile)&& -f $packfile);return($self)}sub STORE {$_[0]->{data}->{$_[1]}=$_[2]}sub FETCH {return($_[0]->{data}->{$_[1]})}sub FIRSTKEY {my$reset=scalar(keys(%{$_[0]->{data}}));return(each(%{$_[0]->{data}}))}sub NEXTKEY {return(each(%{$_[0]->{data}}))}sub EXISTS {return(exists($_[0]->{data}->{$_[1]}))}sub DELETE {return(delete($_[0]->{data}->{$_[1]}))}sub CLEAR {%{$_[0]->{data}}=()}sub DESTROY {}sub read($;$) {my ($self,$packfile)=@_;$self=tied(%$self)|| $self;if (defined($packfile)){$self->{packfile}=$packfile}else {$packfile=$self->{packfile}}Carp::croak("No packlist filename specified")if (!defined($packfile));my$fh=mkfh();open($fh,"<$packfile")|| Carp::croak("Can't open file $packfile: $!");$self->{data}={};my ($line);while (defined($line=<$fh>)){chomp$line;my ($key,$data)=$line;if ($key =~ /^(.*?)( \w+=.*)$/){$key=$1;$data={map {split('=',$_)}split(' ',$2)};if ($Config{userelocatableinc}&& $data->{relocate_as}){require File::Spec;require Cwd;my ($vol,$dir)=File::Spec->splitpath($packfile);my$newpath=File::Spec->catpath($vol,$dir,$data->{relocate_as});$key=Cwd::realpath($newpath)}}$key =~ s!/\./!/!g;$self->{data}->{$key}=$data}close($fh)}sub write($;$) {my ($self,$packfile)=@_;$self=tied(%$self)|| $self;if (defined($packfile)){$self->{packfile}=$packfile}else {$packfile=$self->{packfile}}Carp::croak("No packlist filename specified")if (!defined($packfile));my$fh=mkfh();open($fh,">$packfile")|| Carp::croak("Can't open file $packfile: $!");for my$key (sort(keys(%{$self->{data}}))){my$data=$self->{data}->{$key};if ($Config{userelocatableinc}){$Relocations ||= __find_relocations();if ($packfile =~ $Relocations){my$prefix=$1;if (File::Spec->no_upwards(File::Spec->abs2rel($key,$prefix))){my$packfile_prefix;(undef,$packfile_prefix)=File::Spec->splitpath($packfile);my$relocate_as =File::Spec->abs2rel($key,$packfile_prefix);if (!ref$data){$data={}}$data->{relocate_as}=$relocate_as}}}print$fh ("$key");if (ref($data)){for my$k (sort(keys(%$data))){print$fh (" $k=$data->{$k}")}}print$fh ("\n")}close($fh)}sub validate($;$) {my ($self,$remove)=@_;$self=tied(%$self)|| $self;my@missing;for my$key (sort(keys(%{$self->{data}}))){if (!-e $key){push(@missing,$key);delete($self->{data}{$key})if ($remove)}}return(@missing)}sub packlist_file($) {my ($self)=@_;$self=tied(%$self)|| $self;return($self->{packfile})}1;
EXTUTILS_PACKLIST

$fatpacked{"ExtUtils/ParseXS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_PARSEXS';
  package ExtUtils::ParseXS;use strict;use 5.006001;use Cwd;use Config;use Exporter 'import';use File::Basename;use File::Spec;use Symbol;our$VERSION;BEGIN {$VERSION='3.35'}use ExtUtils::ParseXS::Constants$VERSION;use ExtUtils::ParseXS::CountLines$VERSION;use ExtUtils::ParseXS::Utilities$VERSION;use ExtUtils::ParseXS::Eval$VERSION;$VERSION=eval$VERSION if$VERSION =~ /_/;use ExtUtils::ParseXS::Utilities qw(standard_typemap_locations trim_whitespace C_string valid_proto_string process_typemaps map_type standard_XS_defs assign_func_args analyze_preprocessor_statements set_cond Warn current_line_number blurt death check_conditional_preprocessor_statements escape_file_for_line_directive report_typemap_failure);our@EXPORT_OK=qw(process_file report_error_count);our ($C_group_rex,$C_arg);$C_group_rex=qr/ [({\[]
               (?: (?> [^()\[\]{}]+ ) | (??{ $C_group_rex }) )*
               [)}\]] /x;$C_arg=qr/ (?: (?> [^()\[\]{},"']+ )
         |   (??{ $C_group_rex })
         |   " (?: (?> [^\\"]+ )
           |   \\.
           )* "        # String literal
                |   ' (?: (?> [^\\']+ ) | \\. )* ' # Char literal
         )* /xs;my$END="!End!\n\n";my$BLOCK_regexp='\s*(' .$ExtUtils::ParseXS::Constants::XSKeywordsAlternation ."|$END)\\s*:";sub new {return bless {}=>shift}our$Singleton=__PACKAGE__->new;sub process_file {my$self;if (@_ % 2){my$invocant=shift;$self=ref($invocant)? $invocant : $invocant->new}else {$self=$Singleton}my%options=@_;$self->{ProtoUsed}=exists$options{prototypes};my%args=(argtypes=>1,csuffix=>'.c',except=>0,hiertype=>0,inout=>1,linenumbers=>1,optimize=>1,output=>\*STDOUT,prototypes=>0,typemap=>[],versioncheck=>1,FH=>Symbol::gensym(),%options,);$args{except}=$args{except}? ' TRY' : '';my ($Is_VMS,$SymSet);if ($^O eq 'VMS'){$Is_VMS=1;require ExtUtils::XSSymSet;$SymSet=ExtUtils::XSSymSet->new(28)}@{$self->{XSStack}}=({type=>'none'});$self->{InitFileCode}=[@ExtUtils::ParseXS::Constants::InitFileCode ];$self->{Overload}=0;$self->{errors}=0;$self->{Fallback}='&PL_sv_undef';$self->{RetainCplusplusHierarchicalTypes}=$args{hiertype};$self->{WantPrototypes}=$args{prototypes};$self->{WantVersionChk}=$args{versioncheck};$self->{WantLineNumbers}=$args{linenumbers};$self->{IncludedFiles}={};die "Missing required parameter 'filename'" unless$args{filename};$self->{filepathname}=$args{filename};($self->{dir},$self->{filename})=(dirname($args{filename}),basename($args{filename}));$self->{filepathname}=~ s/\\/\\\\/g;$self->{IncludedFiles}->{$args{filename}}++;if (not ref$args{output}){open my($fh),"> $args{output}" or die "Can't create $args{output}: $!";$args{outfile}=$args{output};$args{output}=$fh}my$orig_cwd=cwd();my$orig_fh=select();chdir($self->{dir});my$pwd=cwd();my$csuffix=$args{csuffix};if ($self->{WantLineNumbers}){my$cfile;if ($args{outfile}){$cfile=$args{outfile}}else {$cfile=$args{filename};$cfile =~ s/\.xs$/$csuffix/i or $cfile .= $csuffix}tie(*PSEUDO_STDOUT,'ExtUtils::ParseXS::CountLines',$cfile,$args{output});select PSEUDO_STDOUT}else {select$args{output}}$self->{typemap}=process_typemaps($args{typemap},$pwd);for my$datum (qw|argtypes except inout optimize|){$self->{$datum}=$args{$datum}}$self->{strip_c_func_prefix}=$args{s};print <<EOM;print("#line 1 \"" .escape_file_for_line_directive($self->{filepathname})."\"\n")if$self->{WantLineNumbers};open($self->{FH},'<',$self->{filename})or die "cannot open $self->{filename}: $!\n";FIRSTMODULE: while (readline($self->{FH})){if (/^=/){my$podstartline=$.;do {if (/^=cut\s*$/){print("#if 0\n  \"Skipped embedded POD.\"\n#endif\n");printf("#line %d \"%s\"\n",$. + 1,escape_file_for_line_directive($self->{filepathname}))if$self->{WantLineNumbers};next FIRSTMODULE}}while (readline($self->{FH}));die ("Error: Unterminated pod in $self->{filename}, line $podstartline\n")unless$self->{lastline}}last if ($self->{Package},$self->{Prefix})=/^MODULE\s*=\s*[\w:]+(?:\s+PACKAGE\s*=\s*([\w:]+))?(?:\s+PREFIX\s*=\s*(\S+))?\s*$/;print $_}unless (defined $_){warn "Didn't find a 'MODULE ... PACKAGE ... PREFIX' line\n";exit 0}print 'ExtUtils::ParseXS::CountLines'->end_marker,"\n" if$self->{WantLineNumbers};standard_XS_defs();print 'ExtUtils::ParseXS::CountLines'->end_marker,"\n" if$self->{WantLineNumbers};$self->{lastline}=$_;$self->{lastline_no}=$.;my$BootCode_ref=[];my$XSS_work_idx=0;my$cpp_next_tmp='XSubPPtmpAAAA';PARAGRAPH: while ($self->fetch_para()){my$outlist_ref=[];while (@{$self->{line}}&& $self->{line}->[0]!~ /^[^\#]/){my$ln=shift(@{$self->{line}});print$ln,"\n";next unless$ln =~ /^\#\s*((if)(?:n?def)?|elsif|else|endif)\b/;my$statement=$+;($self,$XSS_work_idx,$BootCode_ref)=analyze_preprocessor_statements($self,$statement,$XSS_work_idx,$BootCode_ref)}next PARAGRAPH unless @{$self->{line}};if ($XSS_work_idx &&!$self->{XSStack}->[$XSS_work_idx]{varname}){print "#define $cpp_next_tmp 1\n\n";push(@{$self->{InitFileCode}},"#if $cpp_next_tmp\n");push(@{$BootCode_ref},"#if $cpp_next_tmp");$self->{XSStack}->[$XSS_work_idx]{varname}=$cpp_next_tmp++}$self->death("Code is not inside a function" ." (maybe last function was ended by a blank line " ." followed by a statement on column one?)")if$self->{line}->[0]=~ /^\s/;for my$member (qw(args_match var_types defaults arg_list argtype_seen in_out lengthof)){$self->{$member}={}}$self->{proto_arg}=[];$self->{processing_arg_with_types}=0;$self->{proto_in_this_xsub}=0;$self->{scope_in_this_xsub}=0;$self->{interface}=0;$self->{interface_macro}='XSINTERFACE_FUNC';$self->{interface_macro_set}='XSINTERFACE_FUNC_SET';$self->{ProtoThisXSUB}=$self->{WantPrototypes};$self->{ScopeThisXSUB}=0;my$xsreturn=0;$_=shift(@{$self->{line}});while (my$kwd=$self->check_keyword("REQUIRE|PROTOTYPES|EXPORT_XSUB_SYMBOLS|FALLBACK|VERSIONCHECK|INCLUDE(?:_COMMAND)?|SCOPE")){my$method=$kwd ."_handler";$self->$method($_);next PARAGRAPH unless @{$self->{line}};$_=shift(@{$self->{line}})}if ($self->check_keyword("BOOT")){check_conditional_preprocessor_statements($self);push (@{$BootCode_ref},"#line $self->{line_no}->[@{ $self->{line_no} } - @{ $self->{line} }] \"" .escape_file_for_line_directive($self->{filepathname})."\"")if$self->{WantLineNumbers}&& $self->{line}->[0]!~ /^\s*#\s*line\b/;push (@{$BootCode_ref},@{$self->{line}},"");next PARAGRAPH}($self->{ret_type})=ExtUtils::Typemaps::tidy_type($_);my$RETVAL_no_return=1 if$self->{ret_type}=~ s/^NO_OUTPUT\s+//;unshift @{$self->{line}},$2 if$self->{argtypes}and $self->{ret_type}=~ s/^(.*?\w.*?)\s*\b(\w+\s*\(.*)/$1/s;$self->blurt("Error: Function definition too short '$self->{ret_type}'"),next PARAGRAPH unless @{$self->{line}};my$externC=1 if$self->{ret_type}=~ s/^extern "C"\s+//;my$static=1 if$self->{ret_type}=~ s/^static\s+//;my$func_header=shift(@{$self->{line}});$self->blurt("Error: Cannot parse function definition from '$func_header'"),next PARAGRAPH unless$func_header =~ /^(?:([\w:]*)::)?(\w+)\s*\(\s*(.*?)\s*\)\s*(const)?\s*(;\s*)?$/s;my ($class,$orig_args);($class,$self->{func_name},$orig_args)=($1,$2,$3);$class="$4 $class" if $4;($self->{pname}=$self->{func_name})=~ s/^($self->{Prefix})?/$self->{Packprefix}/;my$clean_func_name;($clean_func_name=$self->{func_name})=~ s/^$self->{Prefix}//;$self->{Full_func_name}="$self->{Packid}_$clean_func_name";if ($Is_VMS){$self->{Full_func_name}=$SymSet->addsym($self->{Full_func_name})}for my$tmp (@{$self->{XSStack}}){next unless defined$tmp->{functions}{$self->{Full_func_name}};Warn($self,"Warning: duplicate function definition '$clean_func_name' detected");last}$self->{XSStack}->[$XSS_work_idx]{functions}{$self->{Full_func_name}}++;delete$self->{XsubAliases};delete$self->{XsubAliasValues};%{$self->{Interfaces}}=();@{$self->{Attributes}}=();$self->{DoSetMagic}=1;$orig_args =~ s/\\\s*/ /g;my@args;my (@fake_INPUT_pre);my (@fake_INPUT);my$only_C_inlist_ref={};if ($self->{argtypes}and $orig_args =~ /\S/){my$args="$orig_args ,";use re 'eval';if ($args =~ /^( (??{ $C_arg }) , )* $ /x){@args=($args =~ /\G ( (??{ $C_arg }) ) , /xg);no re 'eval';for (@args){s/^\s+//;s/\s+$//;my ($arg,$default)=($_ =~ m/ ( [^=]* ) ( (?: = .* )? ) /x);my ($pre,$len_name)=($arg =~ /(.*?) \s*
  /*
   * This file was generated automatically by ExtUtils::ParseXS version $VERSION from the
   * contents of $self->{filename}. Do not edit this file, edit $self->{filename} instead.
   *
   *    ANY CHANGES MADE HERE WILL BE LOST!
   *
   */
  
  EOM
                               \b ( \w+ | length\( \s*\w+\s* \) )
                               \s* $ /x);next unless defined($pre)&& length($pre);my$out_type='';my$inout_var;if ($self->{inout}and s/^(IN|IN_OUTLIST|OUTLIST|OUT|IN_OUT)\b\s*//){my$type=$1;$out_type=$type if$type ne 'IN';$arg =~ s/^(IN|IN_OUTLIST|OUTLIST|OUT|IN_OUT)\b\s*//;$pre =~ s/^(IN|IN_OUTLIST|OUTLIST|OUT|IN_OUT)\b\s*//}my$islength;if ($len_name =~ /^length\( \s* (\w+) \s* \)\z/x){$len_name="XSauto_length_of_$1";$islength=1;die "Default value on length() argument: '$_'" if length$default}if (length$pre or $islength){if ($islength){push@fake_INPUT_pre,$arg}else {push@fake_INPUT,$arg}$self->{argtype_seen}->{$len_name}++;$_="$len_name$default"}$only_C_inlist_ref->{$_}=1 if$out_type eq "OUTLIST" or $islength;push @{$outlist_ref},$len_name if$out_type =~ /OUTLIST$/;$self->{in_out}->{$len_name}=$out_type if$out_type}}else {no re 'eval';@args=split(/\s*,\s*/,$orig_args);Warn($self,"Warning: cannot parse argument list '$orig_args', fallback to split")}}else {@args=split(/\s*,\s*/,$orig_args);for (@args){if ($self->{inout}and s/^(IN|IN_OUTLIST|OUTLIST|IN_OUT|OUT)\b\s*//){my$out_type=$1;next if$out_type eq 'IN';$only_C_inlist_ref->{$_}=1 if$out_type eq "OUTLIST";if ($out_type =~ /OUTLIST$/){push @{$outlist_ref},undef}$self->{in_out}->{$_}=$out_type}}}if (defined($class)){my$arg0=((defined($static)or $self->{func_name}eq 'new')? "CLASS" : "THIS");unshift(@args,$arg0)}my$extra_args=0;my@args_num=();my$num_args=0;my$report_args='';my$ellipsis;for my$i (0 .. $#args){if ($args[$i]=~ s/\.\.\.//){$ellipsis=1;if ($args[$i]eq '' && $i==$#args){$report_args .= ", ...";pop(@args);last}}if ($only_C_inlist_ref->{$args[$i]}){push@args_num,undef}else {push@args_num,++$num_args;$report_args .= ", $args[$i]"}if ($args[$i]=~ /^([^=]*[^\s=])\s*=\s*(.*)/s){$extra_args++;$args[$i]=$1;$self->{defaults}->{$args[$i]}=$2;$self->{defaults}->{$args[$i]}=~ s/"/\\"/g}$self->{proto_arg}->[$i+1]='$'}my$min_args=$num_args - $extra_args;$report_args =~ s/"/\\"/g;$report_args =~ s/^,\s+//;$self->{func_args}=assign_func_args($self,\@args,$class);@{$self->{args_match}}{@args}=@args_num;my$PPCODE=grep(/^\s*PPCODE\s*:/,@{$self->{line}});my$CODE=grep(/^\s*CODE\s*:/,@{$self->{line}});my$EXPLICIT_RETURN=($CODE && ("@{ $self->{line} }" =~ /(\bST\s*\([^;]*=) | (\bXST_m\w+\s*\()/x));$self->{ALIAS}=grep(/^\s*ALIAS\s*:/,@{$self->{line}});my$INTERFACE=grep(/^\s*INTERFACE\s*:/,@{$self->{line}});$xsreturn=1 if$EXPLICIT_RETURN;$externC=$externC ? qq[extern "C"] : "";print Q(<<"EOF");print Q(<<"EOF")if$self->{ALIAS};print Q(<<"EOF")if$INTERFACE;$self->{cond}=set_cond($ellipsis,$min_args,$num_args);print Q(<<"EOF")if$self->{except};if($self->{cond}){print Q(<<"EOF")}else {print Q(<<"EOF")}print Q(<<"EOF")if$PPCODE;print Q(<<"EOF")if$PPCODE;$self->{condnum}=0;$self->{cond}='';push(@{$self->{line}},"$END:");push(@{$self->{line_no}},$self->{line_no}->[-1]);$_='';check_conditional_preprocessor_statements();while (@{$self->{line}}){$self->CASE_handler($_)if$self->check_keyword("CASE");print Q(<<"EOF");$self->{thisdone}=0;$self->{retvaldone}=0;$self->{deferred}="";%{$self->{arg_list}}=();$self->{gotRETVAL}=0;$self->INPUT_handler($_);$self->process_keyword("INPUT|PREINIT|INTERFACE_MACRO|C_ARGS|ALIAS|ATTRS|PROTOTYPE|SCOPE|OVERLOAD");print Q(<<"EOF")if$self->{ScopeThisXSUB};if (!$self->{thisdone}&& defined($class)){if (defined($static)or $self->{func_name}eq 'new'){print "\tchar *";$self->{var_types}->{"CLASS"}="char *";$self->generate_init({type=>"char *",num=>1,var=>"CLASS",printed_name=>undef,})}else {print "\t" .map_type($self,"$class *");$self->{var_types}->{"THIS"}="$class *";$self->generate_init({type=>"$class *",num=>1,var=>"THIS",printed_name=>undef,})}}$self->{have_OUTPUT}=$self->{have_CODE_with_RETVAL}=0;my ($wantRETVAL);if (/^\s*NOT_IMPLEMENTED_YET/){print "\n\tPerl_croak(aTHX_ \"$self->{pname}: not implemented yet\");\n";$_=''}else {if ($self->{ret_type}ne "void"){print "\t" .map_type($self,$self->{ret_type},'RETVAL').";\n" if!$self->{retvaldone};$self->{args_match}->{"RETVAL"}=0;$self->{var_types}->{"RETVAL"}=$self->{ret_type};my$outputmap=$self->{typemap}->get_outputmap(ctype=>$self->{ret_type});print "\tdXSTARG;\n" if$self->{optimize}and $outputmap and $outputmap->targetable}if (@fake_INPUT or @fake_INPUT_pre){unshift @{$self->{line}},@fake_INPUT_pre,@fake_INPUT,$_;$_="";$self->{processing_arg_with_types}=1;$self->INPUT_handler($_)}print$self->{deferred};$self->process_keyword("INIT|ALIAS|ATTRS|PROTOTYPE|INTERFACE_MACRO|INTERFACE|C_ARGS|OVERLOAD");if ($self->check_keyword("PPCODE")){$self->print_section();$self->death("PPCODE must be last thing")if @{$self->{line}};print "\tLEAVE;\n" if$self->{ScopeThisXSUB};print "\tPUTBACK;\n\treturn;\n"}elsif ($self->check_keyword("CODE")){my$consumed_code=$self->print_section();if ($consumed_code =~ /\bRETVAL\b/){$self->{have_CODE_with_RETVAL}=1}}elsif (defined($class)and $self->{func_name}eq "DESTROY"){print "\n\t";print "delete THIS;\n"}else {print "\n\t";if ($self->{ret_type}ne "void"){print "RETVAL = ";$wantRETVAL=1}if (defined($static)){if ($self->{func_name}eq 'new'){$self->{func_name}="$class"}else {print "${class}::"}}elsif (defined($class)){if ($self->{func_name}eq 'new'){$self->{func_name}.= " $class"}else {print "THIS->"}}my$strip=$self->{strip_c_func_prefix};$self->{func_name}=~ s/^\Q$strip// if defined$strip;$self->{func_name}='XSFUNCTION' if$self->{interface};print "$self->{func_name}($self->{func_args});\n"}}$self->{gotRETVAL}=0;undef$self->{RETVAL_code};($wantRETVAL,$self->{ret_type})=(0,'void')if$RETVAL_no_return;undef %{$self->{outargs}};$self->process_keyword("POSTCALL|OUTPUT|ALIAS|ATTRS|PROTOTYPE|OVERLOAD");if ($self->{have_CODE_with_RETVAL}and not $self->{have_OUTPUT}and $self->{ret_type}ne 'void'){$self->Warn("Warning: Found a 'CODE' section which seems to be using 'RETVAL' but no 'OUTPUT' section.")}$self->generate_output({type=>$self->{var_types}->{$_},num=>$self->{args_match}->{$_},var=>$_,do_setmagic=>$self->{DoSetMagic},do_push=>undef,})for grep$self->{in_out}->{$_}=~ /OUT$/,sort keys %{$self->{in_out}};my$prepush_done;if ($self->{gotRETVAL}&& $self->{RETVAL_code}){print "\t$self->{RETVAL_code}\n"}elsif ($self->{gotRETVAL}|| $wantRETVAL){my$outputmap=$self->{typemap}->get_outputmap(ctype=>$self->{ret_type});my$trgt=$self->{optimize}&& $outputmap && $outputmap->targetable;my$var='RETVAL';my$type=$self->{ret_type};if ($trgt){my$what=$self->eval_output_typemap_code(qq("$trgt->{what}"),{var=>$var,type=>$self->{ret_type}});if (not $trgt->{with_size}and $trgt->{type}eq 'p'){print "\tsv_setpv(TARG, $what); XSprePUSH; PUSHTARG;\n";$prepush_done=1}else {my$tsize=$trgt->{what_size};$tsize='' unless defined$tsize;$tsize=$self->eval_output_typemap_code(qq("$tsize"),{var=>$var,type=>$self->{ret_type}});print "\tXSprePUSH; PUSH$trgt->{type}($what$tsize);\n";$prepush_done=1}}else {$self->generate_output({type=>$self->{ret_type},num=>0,var=>'RETVAL',do_setmagic=>0,do_push=>undef,})}}$xsreturn=1 if$self->{ret_type}ne "void";my$num=$xsreturn;my$c=@{$outlist_ref};print "\tXSprePUSH;" if$c and not $prepush_done;print "\tEXTEND(SP,$c);\n" if$c;$xsreturn += $c;$self->generate_output({type=>$self->{var_types}->{$_},num=>$num++,var=>$_,do_setmagic=>0,do_push=>1,})for @{$outlist_ref};$self->process_keyword("CLEANUP|ALIAS|ATTRS|PROTOTYPE|OVERLOAD");print Q(<<"EOF")if$self->{ScopeThisXSUB};print Q(<<"EOF")if$self->{ScopeThisXSUB}and not $PPCODE;print Q(<<"EOF");print Q(<<"EOF")if$self->{except};if ($self->check_keyword("CASE")){$self->blurt("Error: No 'CASE:' at top of function")unless$self->{condnum};$_="CASE: $_";next}last if $_ eq "$END:";$self->death(/^$BLOCK_regexp/o ? "Misplaced '$1:'" : "Junk at end of function ($_)")}print Q(<<"EOF")if$self->{except};if ($xsreturn){print Q(<<"EOF")unless$PPCODE}else {print Q(<<"EOF")unless$PPCODE}print Q(<<"EOF");$self->{proto}="";unless($self->{ProtoThisXSUB}){$self->{newXS}="newXS_deffile";$self->{file}=""}else {$self->{newXS}="newXSproto_portable";$self->{file}=", file";if ($self->{ProtoThisXSUB}eq 2){}elsif ($self->{ProtoThisXSUB}eq 1){my$s=';';if ($min_args < $num_args){$s='';$self->{proto_arg}->[$min_args].= ";"}push @{$self->{proto_arg}},"$s\@" if$ellipsis;$self->{proto}=join ("",grep defined,@{$self->{proto_arg}})}else {$self->{proto}=$self->{ProtoThisXSUB}}$self->{proto}=qq{, "$self->{proto}"}}if ($self->{XsubAliases}and keys %{$self->{XsubAliases}}){$self->{XsubAliases}->{$self->{pname}}=0 unless defined$self->{XsubAliases}->{$self->{pname}};for my$xname (sort keys %{$self->{XsubAliases}}){my$value=$self->{XsubAliases}{$xname};push(@{$self->{InitFileCode}},Q(<<"EOF"))}}elsif (@{$self->{Attributes}}){push(@{$self->{InitFileCode}},Q(<<"EOF"))}elsif ($self->{interface}){for my$yname (sort keys %{$self->{Interfaces}}){my$value=$self->{Interfaces}{$yname};$yname="$self->{Package}\::$yname" unless$yname =~ /::/;push(@{$self->{InitFileCode}},Q(<<"EOF"))}}elsif($self->{newXS}eq 'newXS_deffile'){push(@{$self->{InitFileCode}},"        $self->{newXS}(\"$self->{pname}\", XS_$self->{Full_func_name}$self->{file}$self->{proto});\n")}else {push(@{$self->{InitFileCode}},"        (void)$self->{newXS}(\"$self->{pname}\", XS_$self->{Full_func_name}$self->{file}$self->{proto});\n")}}if ($self->{Overload}){print Q(<<"EOF");unshift(@{$self->{InitFileCode}},<<"MAKE_FETCHMETHOD_WORK")}print Q(<<"EOF");print Q(<<"EOF");print Q(<<"EOF")if$self->{Full_func_name};print Q("#\n");print Q(<<"EOF");if($self->{WantVersionChk}){print Q(<<"EOF")}else {print Q(<<"EOF")}print Q(<<"EOF")if defined$self->{XsubAliases}or defined$self->{interfaces};print Q(<<"EOF")if ($self->{Overload});print @{$self->{InitFileCode}};print Q(<<"EOF")if defined$self->{XsubAliases}or defined$self->{interfaces};if (@{$BootCode_ref}){print "\n    /* Initialisation Section */\n\n";@{$self->{line}}=@{$BootCode_ref};$self->print_section();print "\n    /* End of Initialisation Section */\n\n"}print Q(<<'EOF');warn("Please specify prototyping behavior for $self->{filename} (see perlxs manual)\n")unless$self->{ProtoUsed};chdir($orig_cwd);select($orig_fh);untie*PSEUDO_STDOUT if tied*PSEUDO_STDOUT;close$self->{FH};return 1}sub report_error_count {if (@_){return $_[0]->{errors}||0}else {return$Singleton->{errors}||0}}sub check_keyword {my$self=shift;$_=shift(@{$self->{line}})while!/\S/ && @{$self->{line}};s/^(\s*)($_[0])\s*:\s*(?:#.*)?/$1/s && $2}sub print_section {my$self=shift;do {$_=shift(@{$self->{line}})}while!/\S/ && @{$self->{line}};my$consumed_code='';print("#line ",$self->{line_no}->[@{$self->{line_no}}- @{$self->{line}}-1]," \"",escape_file_for_line_directive($self->{filepathname}),"\"\n")if$self->{WantLineNumbers}&&!/^\s*#\s*line\b/ &&!/^#if XSubPPtmp/;for (;defined($_)&&!/^$BLOCK_regexp/o;$_=shift(@{$self->{line}})){print "$_\n";$consumed_code .= "$_\n"}print 'ExtUtils::ParseXS::CountLines'->end_marker,"\n" if$self->{WantLineNumbers};return$consumed_code}sub merge_section {my$self=shift;my$in='';while (!/\S/ && @{$self->{line}}){$_=shift(@{$self->{line}})}for (;defined($_)&&!/^$BLOCK_regexp/o;$_=shift(@{$self->{line}})){$in .= "$_\n"}chomp$in;return$in}sub process_keyword {my($self,$pattern)=@_;while (my$kwd=$self->check_keyword($pattern)){my$method=$kwd ."_handler";$self->$method($_)}}sub CASE_handler {my$self=shift;$_=shift;$self->blurt("Error: 'CASE:' after unconditional 'CASE:'")if$self->{condnum}&& $self->{cond}eq '';$self->{cond}=$_;trim_whitespace($self->{cond});print "   ",($self->{condnum}++ ? " else" : ""),($self->{cond}? " if ($self->{cond})\n" : "\n");$_=''}sub INPUT_handler {my$self=shift;$_=shift;for (;!/^$BLOCK_regexp/o;$_=shift(@{$self->{line}})){last if /^\s*NOT_IMPLEMENTED_YET/;next unless /\S/;trim_whitespace($_);my$ln=$_;s/\s*;$//g unless /[=;+].*\S/;if (s/^([^=]*)\blength\(\s*(\w+)\s*\)\s*$/$1 XSauto_length_of_$2=NO_INIT/x){print "\tSTRLEN\tSTRLEN_length_of_$2;\n";$self->{lengthof}->{$2}=undef;$self->{deferred}.= "\n\tXSauto_length_of_$2 = STRLEN_length_of_$2;\n"}my$var_init='';$var_init=$1 if s/\s*([=;+].*)$//s;$var_init =~ s/"/\\"/g;my$is_overridden_typemap=$var_init =~ /ST\s*\(|\$arg\b/;s/\s+/ /g;my ($var_type,$var_addr,$var_name)=/^(.*?[^&\s])\s*(\&?)\s*\b(\w+)$/s or $self->blurt("Error: invalid argument declaration '$ln'"),next;$self->blurt("Error: duplicate definition of argument '$var_name' ignored"),next if$self->{arg_list}->{$var_name}++ or defined$self->{argtype_seen}->{$var_name}and not $self->{processing_arg_with_types};$self->{thisdone}|= $var_name eq "THIS";$self->{retvaldone}|= $var_name eq "RETVAL";$self->{var_types}->{$var_name}=$var_type;my$printed_name;if ($var_type =~ / \( \s* \* \s* \) /x){print "\t" .map_type($self,$var_type,$var_name);$printed_name=1}else {print "\t" .map_type($self,$var_type,undef);$printed_name=0}$self->{var_num}=$self->{args_match}->{$var_name};if ($self->{var_num}){my$typemap=$self->{typemap}->get_typemap(ctype=>$var_type);$self->report_typemap_failure($self->{typemap},$var_type,"death")if not $typemap and not $is_overridden_typemap;$self->{proto_arg}->[$self->{var_num}]=($typemap && $typemap->proto)|| "\$"}$self->{func_args}=~ s/\b($var_name)\b/&$1/ if$var_addr;if ($var_init =~ /^[=;]\s*NO_INIT\s*;?\s*$/ or $self->{in_out}->{$var_name}and $self->{in_out}->{$var_name}=~ /^OUT/ and $var_init !~ /\S/){if ($printed_name){print ";\n"}else {print "\t$var_name;\n"}}elsif ($var_init =~ /\S/){$self->output_init({type=>$var_type,num=>$self->{var_num},var=>$var_name,init=>$var_init,printed_name=>$printed_name,})}elsif ($self->{var_num}){$self->generate_init({type=>$var_type,num=>$self->{var_num},var=>$var_name,printed_name=>$printed_name,})}else {print ";\n"}}}sub OUTPUT_handler {my$self=shift;$self->{have_OUTPUT}=1;$_=shift;for (;!/^$BLOCK_regexp/o;$_=shift(@{$self->{line}})){next unless /\S/;if (/^\s*SETMAGIC\s*:\s*(ENABLE|DISABLE)\s*/){$self->{DoSetMagic}=($1 eq "ENABLE" ? 1 : 0);next}my ($outarg,$outcode)=/^\s*(\S+)\s*(.*?)\s*$/s;$self->blurt("Error: duplicate OUTPUT argument '$outarg' ignored"),next if$self->{outargs}->{$outarg}++;if (!$self->{gotRETVAL}and $outarg eq 'RETVAL'){$self->{RETVAL_code}=$outcode;$self->{gotRETVAL}=1;next}$self->blurt("Error: OUTPUT $outarg not an argument"),next unless defined($self->{args_match}->{$outarg});$self->blurt("Error: No input definition for OUTPUT argument '$outarg' - ignored"),next unless defined$self->{var_types}->{$outarg};$self->{var_num}=$self->{args_match}->{$outarg};if ($outcode){print "\t$outcode\n";print "\tSvSETMAGIC(ST(",$self->{var_num}- 1,"));\n" if$self->{DoSetMagic}}else {$self->generate_output({type=>$self->{var_types}->{$outarg},num=>$self->{var_num},var=>$outarg,do_setmagic=>$self->{DoSetMagic},do_push=>undef,})}delete$self->{in_out}->{$outarg}if exists$self->{in_out}->{$outarg}and $self->{in_out}->{$outarg}=~ /OUT$/}}sub C_ARGS_handler {my$self=shift;$_=shift;my$in=$self->merge_section();trim_whitespace($in);$self->{func_args}=$in}sub INTERFACE_MACRO_handler {my$self=shift;$_=shift;my$in=$self->merge_section();trim_whitespace($in);if ($in =~ /\s/){($self->{interface_macro},$self->{interface_macro_set})=split ' ',$in}else {$self->{interface_macro}=$in;$self->{interface_macro_set}='UNKNOWN_CVT'}$self->{interface}=1;$self->{interfaces}=1}sub INTERFACE_handler {my$self=shift;$_=shift;my$in=$self->merge_section();trim_whitespace($in);for (split /[\s,]+/,$in){my$iface_name=$_;$iface_name =~ s/^$self->{Prefix}//;$self->{Interfaces}->{$iface_name}=$_}print Q(<<"EOF");$self->{interface}=1;$self->{interfaces}=1}sub CLEANUP_handler {my$self=shift;$self->print_section()}sub PREINIT_handler {my$self=shift;$self->print_section()}sub POSTCALL_handler {my$self=shift;$self->print_section()}sub INIT_handler {my$self=shift;$self->print_section()}sub get_aliases {my$self=shift;my ($line)=@_;my ($orig)=$line;while ($line =~ s/^\s*([\w:]+)\s*=\s*(\w+)\s*//){my ($alias,$value)=($1,$2);my$orig_alias=$alias;$alias=$self->{Packprefix}.$alias if$alias !~ /::/;Warn($self,"Warning: Ignoring duplicate alias '$orig_alias'")if defined$self->{XsubAliases}->{$alias};Warn($self,"Warning: Aliases '$orig_alias' and '$self->{XsubAliasValues}->{$value}' have identical values")if$self->{XsubAliasValues}->{$value};$self->{XsubAliases}->{$alias}=$value;$self->{XsubAliasValues}->{$value}=$orig_alias}blurt($self,"Error: Cannot parse ALIAS definitions from '$orig'")if$line}sub ATTRS_handler {my$self=shift;$_=shift;for (;!/^$BLOCK_regexp/o;$_=shift(@{$self->{line}})){next unless /\S/;trim_whitespace($_);push @{$self->{Attributes}},$_}}sub ALIAS_handler {my$self=shift;$_=shift;for (;!/^$BLOCK_regexp/o;$_=shift(@{$self->{line}})){next unless /\S/;trim_whitespace($_);$self->get_aliases($_)if $_}}sub OVERLOAD_handler {my$self=shift;$_=shift;for (;!/^$BLOCK_regexp/o;$_=shift(@{$self->{line}})){next unless /\S/;trim_whitespace($_);while (s/^\s*([\w:"\\)\+\-\*\/\%\<\>\.\&\|\^\!\~\{\}\=]+)\s*//){$self->{Overload}=1 unless$self->{Overload};my$overload="$self->{Package}\::(".$1;push(@{$self->{InitFileCode}},"        (void)$self->{newXS}(\"$overload\", XS_$self->{Full_func_name}$self->{file}$self->{proto});\n")}}}sub FALLBACK_handler {my ($self,$setting)=@_;trim_whitespace($setting);$setting=uc($setting);my%map=(TRUE=>"&PL_sv_yes",1=>"&PL_sv_yes",FALSE=>"&PL_sv_no",0=>"&PL_sv_no",UNDEF=>"&PL_sv_undef",);$self->death("Error: FALLBACK: TRUE/FALSE/UNDEF")unless exists$map{$setting};$self->{Fallback}=$map{$setting}}sub REQUIRE_handler {my ($self,$ver)=@_;trim_whitespace($ver);$self->death("Error: REQUIRE expects a version number")unless$ver;$self->death("Error: REQUIRE: expected a number, got '$ver'")unless$ver =~ /^\d+(\.\d*)?/;$self->death("Error: xsubpp $ver (or better) required--this is only $VERSION.")unless$VERSION >= $ver}sub VERSIONCHECK_handler {my ($self,$setting)=@_;trim_whitespace($setting);$self->death("Error: VERSIONCHECK: ENABLE/DISABLE")unless$setting =~ /^(ENABLE|DISABLE)/i;$self->{WantVersionChk}=1 if $1 eq 'ENABLE';$self->{WantVersionChk}=0 if $1 eq 'DISABLE'}sub PROTOTYPE_handler {my$self=shift;$_=shift;my$specified;$self->death("Error: Only 1 PROTOTYPE definition allowed per xsub")if$self->{proto_in_this_xsub}++;for (;!/^$BLOCK_regexp/o;$_=shift(@{$self->{line}})){next unless /\S/;$specified=1;trim_whitespace($_);if ($_ eq 'DISABLE'){$self->{ProtoThisXSUB}=0}elsif ($_ eq 'ENABLE'){$self->{ProtoThisXSUB}=1}else {s/\s+//g;$self->death("Error: Invalid prototype '$_'")unless valid_proto_string($_);$self->{ProtoThisXSUB}=C_string($_)}}$self->{ProtoThisXSUB}=2 unless$specified;$self->{ProtoUsed}=1}sub SCOPE_handler {my ($self,$setting)=@_;$self->death("Error: Only 1 SCOPE declaration allowed per xsub")if$self->{scope_in_this_xsub}++;trim_whitespace($setting);$self->death("Error: SCOPE: ENABLE/DISABLE")unless$setting =~ /^(ENABLE|DISABLE)\b/i;$self->{ScopeThisXSUB}=(uc($1)eq 'ENABLE')}sub PROTOTYPES_handler {my ($self,$setting)=@_;trim_whitespace($setting);$self->death("Error: PROTOTYPES: ENABLE/DISABLE")unless$setting =~ /^(ENABLE|DISABLE)/i;$self->{WantPrototypes}=1 if $1 eq 'ENABLE';$self->{WantPrototypes}=0 if $1 eq 'DISABLE';$self->{ProtoUsed}=1}sub EXPORT_XSUB_SYMBOLS_handler {my ($self,$setting)=@_;trim_whitespace($setting);$self->death("Error: EXPORT_XSUB_SYMBOLS: ENABLE/DISABLE")unless$setting =~ /^(ENABLE|DISABLE)/i;my$xs_impl=$1 eq 'ENABLE' ? 'XS_EXTERNAL' : 'XS_INTERNAL';print Q(<<"EOF")}sub PushXSStack {my$self=shift;my%args=@_;push(@{$self->{XSStack}},{type=>'file',LastLine=>$self->{lastline},LastLineNo=>$self->{lastline_no},Line=>$self->{line},LineNo=>$self->{line_no},Filename=>$self->{filename},Filepathname=>$self->{filepathname},Handle=>$self->{FH},IsPipe=>scalar($self->{filename}=~ /\|\s*$/),%args,})}sub INCLUDE_handler {my$self=shift;$_=shift;trim_whitespace($_);$self->death("INCLUDE: filename missing")unless $_;$self->death("INCLUDE: output pipe is illegal")if /^\s*\|/;$self->death("INCLUDE loop detected")if$self->{IncludedFiles}->{$_};++$self->{IncludedFiles}->{$_}unless /\|\s*$/;if (/\|\s*$/ && /^\s*perl\s/){Warn($self,"The INCLUDE directive with a command is discouraged." ." Use INCLUDE_COMMAND instead! In particular using 'perl'" ." in an 'INCLUDE: ... |' directive is not guaranteed to pick" ." up the correct perl. The INCLUDE_COMMAND directive allows" ." the use of \$^X as the currently running perl, see" ." 'perldoc perlxs' for details.")}$self->PushXSStack();$self->{FH}=Symbol::gensym();open($self->{FH},$_)or $self->death("Cannot open '$_': $!");print Q(<<"EOF");$self->{filename}=$_;$self->{filepathname}=($^O =~ /^mswin/i)? qq($self->{dir}/$self->{filename}) : File::Spec->catfile($self->{dir},$self->{filename});while (readline($self->{FH})){last unless /^\s*$/}$self->{lastline}=$_;$self->{lastline_no}=$.}sub QuoteArgs {my$cmd=shift;my@args=split /\s+/,$cmd;$cmd=shift@args;for (@args){$_=q(").$_.q(") if!/^\"/ && length($_)> 0}return join (' ',($cmd,@args))}{my ($quote,$use_quote)=$^O eq 'MSWin32' ? (q{"},q{"}): (q{"'},q{'});sub _safe_quote {my ($self,$command)=@_;if (defined($command)and $command =~ /\s/ and $command !~ /[$quote]/){return qq{$use_quote$command$use_quote}}return$command}}sub INCLUDE_COMMAND_handler {my$self=shift;$_=shift;trim_whitespace($_);$_=QuoteArgs($_)if $^O eq 'VMS';$self->death("INCLUDE_COMMAND: command missing")unless $_;$self->death("INCLUDE_COMMAND: pipes are illegal")if /^\s*\|/ or /\|\s*$/;$self->PushXSStack(IsPipe=>1);$self->{FH}=Symbol::gensym();my$X=$self->_safe_quote($^X);s/^\s*\$\^X/$X/;open ($self->{FH},"-|",$_)or $self->death($self,"Cannot run command '$_' to include its output: $!");print Q(<<"EOF");$self->{filename}=$_;$self->{filepathname}=$self->{filename};$self->{filepathname}=~ s/\\/\\\\/g;while (readline($self->{FH})){last unless /^\s*$/}$self->{lastline}=$_;$self->{lastline_no}=$.}sub PopFile {my$self=shift;return 0 unless$self->{XSStack}->[-1]{type}eq 'file';my$data=pop @{$self->{XSStack}};my$ThisFile=$self->{filename};my$isPipe=$data->{IsPipe};--$self->{IncludedFiles}->{$self->{filename}}unless$isPipe;close$self->{FH};$self->{FH}=$data->{Handle};$self->{filename}=$data->{Filename};$self->{filepathname}=$data->{Filepathname};$self->{lastline}=$data->{LastLine};$self->{lastline_no}=$data->{LastLineNo};@{$self->{line}}=@{$data->{Line}};@{$self->{line_no}}=@{$data->{LineNo}};if ($isPipe and $?){--$self->{lastline_no};print STDERR "Error reading from pipe '$ThisFile': $! in $self->{filename}, line $self->{lastline_no}\n" ;exit 1}print Q(<<"EOF");return 1}sub Q {my($text)=@_;$text =~ s/^#//gm;$text =~ s/\[\[/{/g;$text =~ s/\]\]/}/g;$text}sub _process_module_xs_line {my ($self,$module,$pkg,$prefix)=@_;($self->{Module_cname}=$module)=~ s/\W/_/g;$self->{Package}=defined($pkg)? $pkg : '';$self->{Prefix}=quotemeta(defined($prefix)? $prefix : '');($self->{Packid}=$self->{Package})=~ tr/:/_/;$self->{Packprefix}=$self->{Package};$self->{Packprefix}.= "::" if$self->{Packprefix}ne "";$self->{lastline}=""}sub _maybe_skip_pod {my ($self)=@_;while ($self->{lastline}=~ /^=/){while ($self->{lastline}=readline($self->{FH})){last if ($self->{lastline}=~ /^=cut\s*$/)}$self->death("Error: Unterminated pod")unless defined$self->{lastline};$self->{lastline}=readline($self->{FH});chomp$self->{lastline};$self->{lastline}=~ s/^\s+$//}}sub _maybe_parse_typemap_block {my ($self)=@_;if ($self->{lastline}=~ /^TYPEMAP\s*:\s*<<\s*(?:(["'])(.+?)\1|([^\s'"]+?))\s*;?\s*$/){my$end_marker=quotemeta(defined($1)? $2 : $3);my@tmaplines;while (1){$self->{lastline}=readline($self->{FH});$self->death("Error: Unterminated TYPEMAP section")if not defined$self->{lastline};last if$self->{lastline}=~ /^$end_marker\s*$/;push@tmaplines,$self->{lastline}}my$tmap=ExtUtils::Typemaps->new(string=>join("",@tmaplines),lineno_offset=>1 + ($self->current_line_number()|| 0),fake_filename=>$self->{filename},);$self->{typemap}->merge(typemap=>$tmap,replace=>1);$self->{lastline}=""}}sub fetch_para {my$self=shift;$self->death("Error: Unterminated '#if/#ifdef/#ifndef'")if!defined$self->{lastline}&& $self->{XSStack}->[-1]{type}eq 'if';@{$self->{line}}=();@{$self->{line_no}}=();return$self->PopFile()if not defined$self->{lastline};if ($self->{lastline}=~ /^MODULE\s*=\s*([\w:]+)(?:\s+PACKAGE\s*=\s*([\w:]+))?(?:\s+PREFIX\s*=\s*(\S+))?\s*$/){$self->_process_module_xs_line($1,$2,$3)}for (;;){$self->_maybe_skip_pod;$self->_maybe_parse_typemap_block;if ($self->{lastline}!~ /^\s*#/ || $self->{lastline}=~ /^\#[ \t]*
  #$externC
  #XS_EUPXS(XS_$self->{Full_func_name}); /* prototype to pass -Wmissing-prototypes */
  #XS_EUPXS(XS_$self->{Full_func_name})
  #[[
  #    dVAR; dXSARGS;
  EOF
  #    dXSI32;
  EOF
  #    dXSFUNCTION($self->{ret_type});
  EOF
  #    char errbuf[1024];
  #    *errbuf = '\\0';
  EOF
  #    if ($self->{cond})
  #       croak_xs_usage(cv,  "$report_args");
  EOF
  #    PERL_UNUSED_VAR(cv); /* -W */
  EOF
  #    PERL_UNUSED_VAR(ax); /* -Wall */
  EOF
  #    SP -= items;
  EOF
  #   $self->{except} [[
  EOF
  #   ENTER;
  #   [[
  EOF
  #   ]]
  EOF
  #   LEAVE;
  EOF
  #    ]]
  EOF
  #    BEGHANDLERS
  #    CATCHALL
  #    sprintf(errbuf, "%s: %s\\tpropagated", Xname, Xreason);
  #    ENDHANDLERS
  EOF
  #    if (errbuf[0])
  #    Perl_croak(aTHX_ errbuf);
  EOF
  #    XSRETURN($xsreturn);
  EOF
  #    XSRETURN_EMPTY;
  EOF
  #]]
  #
  EOF
  #        cv = $self->{newXS}(\"$xname\", XS_$self->{Full_func_name}$self->{file}$self->{proto});
  #        XSANY.any_i32 = $value;
  EOF
  #        cv = $self->{newXS}(\"$self->{pname}\", XS_$self->{Full_func_name}$self->{file}$self->{proto});
  #        apply_attrs_string("$self->{Package}", cv, "@{ $self->{Attributes} }", 0);
  EOF
  #        cv = $self->{newXS}(\"$yname\", XS_$self->{Full_func_name}$self->{file}$self->{proto});
  #        $self->{interface_macro_set}(cv,$value);
  EOF
  #XS_EUPXS(XS_$self->{Packid}_nil); /* prototype to pass -Wmissing-prototypes */
  #XS_EUPXS(XS_$self->{Packid}_nil)
  #{
  #   dXSARGS;
  #   XSRETURN_EMPTY;
  #}
  #
  EOF
      /* Making a sub named "$self->{Package}::()" allows the package */
      /* to be findable via fetchmethod(), and causes */
      /* overload::Overloaded("$self->{Package}") to return true. */
      (void)$self->{newXS}("$self->{Package}::()", XS_$self->{Packid}_nil$self->{file}$self->{proto});
  MAKE_FETCHMETHOD_WORK
  ##ifdef __cplusplus
  #extern "C"
  ##endif
  EOF
  #XS_EXTERNAL(boot_$self->{Module_cname}); /* prototype to pass -Wmissing-prototypes */
  #XS_EXTERNAL(boot_$self->{Module_cname})
  #[[
  ##if PERL_VERSION_LE(5, 21, 5)
  #    dVAR; dXSARGS;
  ##else
  #    dVAR; ${\($self->{WantVersionChk} ?
       'dXSBOOTARGSXSAPIVERCHK;' : 'dXSBOOTARGSAPIVERCHK;')}
  ##endif
  EOF
  ##if (PERL_REVISION == 5 && PERL_VERSION < 9)
  #    char* file = __FILE__;
  ##else
  #    const char* file = __FILE__;
  ##endif
  #
  #    PERL_UNUSED_VAR(file);
  EOF
  #    PERL_UNUSED_VAR(cv); /* -W */
  #    PERL_UNUSED_VAR(items); /* -W */
  EOF
  ##if PERL_VERSION_LE(5, 21, 5)
  #    XS_VERSION_BOOTCHECK;
  ##  ifdef XS_APIVERSION_BOOTCHECK
  #    XS_APIVERSION_BOOTCHECK;
  ##  endif
  ##endif
  
  EOF
  ##if PERL_VERSION_LE(5, 21, 5) && defined(XS_APIVERSION_BOOTCHECK)
  #  XS_APIVERSION_BOOTCHECK;
  ##endif
  
  EOF
  #    {
  #        CV * cv;
  #
  EOF
  #    /* register the overloading (type 'A') magic */
  ##if (PERL_REVISION == 5 && PERL_VERSION < 9)
  #    PL_amagic_generation++;
  ##endif
  #    /* The magic for overload gets a GV* via gv_fetchmeth as */
  #    /* mentioned above, and looks in the SV* slot of it for */
  #    /* the "fallback" status. */
  #    sv_setsv(
  #        get_sv( "$self->{Package}::()", TRUE ),
  #        $self->{Fallback}
  #    );
  EOF
  #    }
  EOF
  ##if PERL_VERSION_LE(5, 21, 5)
  ##  if PERL_VERSION_GE(5, 9, 0)
  #    if (PL_unitcheckav)
  #        call_list(PL_scopestack_ix, PL_unitcheckav);
  ##  endif
  #    XSRETURN_YES;
  ##else
  #    Perl_xs_boot_epilog(aTHX_ ax);
  ##endif
  #]]
  #
  EOF
  #    XSFUNCTION = $self->{interface_macro}($self->{ret_type},cv,XSANY.any_dptr);
  EOF
  ##undef XS_EUPXS
  ##if defined(PERL_EUPXS_ALWAYS_EXPORT)
  ##  define XS_EUPXS(name) XS_EXTERNAL(name)
  ##elif defined(PERL_EUPXS_NEVER_EXPORT)
  ##  define XS_EUPXS(name) XS_INTERNAL(name)
  ##else
  ##  define XS_EUPXS(name) $xs_impl(name)
  ##endif
  EOF
  #
  #/* INCLUDE:  Including '$_' from '$self->{filename}' */
  #
  EOF
  #
  #/* INCLUDE_COMMAND:  Including output of '$_' from '$self->{filename}' */
  #
  EOF
  #
  #/* INCLUDE: Returning to '$self->{filename}' from '$ThisFile' */
  #
  EOF
                                    (?:
                                          (?:if|ifn?def|elif|else|endif|
                                             define|undef|pragma|error|
                                             warning|line\s+\d+|ident)
                                          \b
                                        | (?:include(?:_next)?|import)
                                          \s* ["<] .* [>"]
                                   )
                                  /x){last if$self->{lastline}=~ /^\S/ && @{$self->{line}}&& $self->{line}->[-1]eq "";push(@{$self->{line}},$self->{lastline});push(@{$self->{line_no}},$self->{lastline_no})}last unless defined($self->{lastline}=readline($self->{FH}));$self->{lastline_no}=$.;my$tmp_line;$self->{lastline}.= $tmp_line while ($self->{lastline}=~ /\\$/ && defined($tmp_line=readline($self->{FH})));chomp$self->{lastline};$self->{lastline}=~ s/^\s+$//}pop(@{$self->{line}}),pop(@{$self->{line_no}})while @{$self->{line}}&& $self->{line}->[-1]eq "";return 1}sub output_init {my$self=shift;my$argsref=shift;my ($type,$num,$var,$init,$printed_name)=@{$argsref}{qw(type num var init printed_name)};local$argsref->{arg}=$num ? "ST(" .($num-1).")" : "/* not a parameter */";if ($init =~ /^=/){if ($printed_name){$self->eval_input_typemap_code(qq/print " $init\\n"/,$argsref)}else {$self->eval_input_typemap_code(qq/print "\\t$var $init\\n"/,$argsref)}}else {if ($init =~ s/^\+// && $num){$self->generate_init({type=>$type,num=>$num,var=>$var,printed_name=>$printed_name,})}elsif ($printed_name){print ";\n";$init =~ s/^;//}else {$self->eval_input_typemap_code(qq/print "\\t$var;\\n"/,$argsref);$init =~ s/^;//}$self->{deferred}.= $self->eval_input_typemap_code(qq/"\\n\\t$init\\n"/,$argsref)}}sub generate_init {my$self=shift;my$argsref=shift;my ($type,$num,$var,$printed_name)=@{$argsref}{qw(type num var printed_name)};my$argoff=$num - 1;my$arg="ST($argoff)";my$typemaps=$self->{typemap};$type=ExtUtils::Typemaps::tidy_type($type);if (not $typemaps->get_typemap(ctype=>$type)){$self->report_typemap_failure($typemaps,$type);return}(my$ntype=$type)=~ s/\s*\*/Ptr/g;(my$subtype=$ntype)=~ s/(?:Array)?(?:Ptr)?$//;my$typem=$typemaps->get_typemap(ctype=>$type);my$xstype=$typem->xstype;$xstype =~ s/OBJ$/REF/ || $xstype =~ s/^T_REF_IV_PTR$/T_PTRREF/ if$self->{func_name}=~ /DESTROY$/;if ($xstype eq 'T_PV' and exists$self->{lengthof}->{$var}){print "\t$var" unless$printed_name;print " = ($type)SvPV($arg, STRLEN_length_of_$var);\n";die "default value not supported with length(NAME) supplied" if defined$self->{defaults}->{$var};return}$type =~ tr/:/_/ unless$self->{RetainCplusplusHierarchicalTypes};my$inputmap=$typemaps->get_inputmap(xstype=>$xstype);if (not defined$inputmap){$self->blurt("Error: No INPUT definition for type '$type', typekind '" .$type->xstype ."' found");return}my$expr=$inputmap->cleaned_code;if ($expr =~ /DO_ARRAY_ELEM/){my$subtypemap=$typemaps->get_typemap(ctype=>$subtype);if (not $subtypemap){$self->report_typemap_failure($typemaps,$subtype);return}my$subinputmap=$typemaps->get_inputmap(xstype=>$subtypemap->xstype);if (not $subinputmap){$self->blurt("Error: No INPUT definition for type '$subtype', typekind '" .$subtypemap->xstype ."' found");return}my$subexpr=$subinputmap->cleaned_code;$subexpr =~ s/\$type/\$subtype/g;$subexpr =~ s/ntype/subtype/g;$subexpr =~ s/\$arg/ST(ix_$var)/g;$subexpr =~ s/\n\t/\n\t\t/g;$subexpr =~ s/is not of (.*\")/[arg %d] is not of $1, ix_$var + 1/g;$subexpr =~ s/\$var/${var}\[ix_$var - $argoff]/;$expr =~ s/DO_ARRAY_ELEM/$subexpr/}if ($expr =~ m#/\*.*scope.*\*/#i){$self->{ScopeThisXSUB}=1}my$eval_vars={var=>$var,printed_name=>$printed_name,type=>$type,ntype=>$ntype,subtype=>$subtype,num=>$num,arg=>$arg,argoff=>$argoff,};if (defined($self->{defaults}->{$var})){$expr =~ s/(\t+)/$1    /g;$expr =~ s/        /\t/g;if ($printed_name){print ";\n"}else {$self->eval_input_typemap_code(qq/print "\\t$var;\\n"/,$eval_vars)}if ($self->{defaults}->{$var}eq 'NO_INIT'){$self->{deferred}.= $self->eval_input_typemap_code(qq/"\\n\\tif (items >= $num) {\\n$expr;\\n\\t}\\n"/,$eval_vars)}else {$self->{deferred}.= $self->eval_input_typemap_code(qq/"\\n\\tif (items < $num)\\n\\t    $var = $self->{defaults}->{$var};\\n\\telse {\\n$expr;\\n\\t}\\n"/,$eval_vars)}}elsif ($self->{ScopeThisXSUB}or $expr !~ /^\s*\$var =/){if ($printed_name){print ";\n"}else {$self->eval_input_typemap_code(qq/print "\\t$var;\\n"/,$eval_vars)}$self->{deferred}.= $self->eval_input_typemap_code(qq/"\\n$expr;\\n"/,$eval_vars)}else {die "panic: do not know how to handle this branch for function pointers" if$printed_name;$self->eval_input_typemap_code(qq/print "$expr;\\n"/,$eval_vars)}}sub generate_output {my$self=shift;my$argsref=shift;my ($type,$num,$var,$do_setmagic,$do_push)=@{$argsref}{qw(type num var do_setmagic do_push)};my$arg="ST(" .($num - ($num!=0)).")";my$typemaps=$self->{typemap};$type=ExtUtils::Typemaps::tidy_type($type);local$argsref->{type}=$type;if ($type =~ /^array\(([^,]*),(.*)\)/){print "\t$arg = sv_newmortal();\n";print "\tsv_setpvn($arg, (char *)$var, $2 * sizeof($1));\n";print "\tSvSETMAGIC($arg);\n" if$do_setmagic}else {my$typemap=$typemaps->get_typemap(ctype=>$type);if (not $typemap){$self->report_typemap_failure($typemaps,$type);return}my$outputmap=$typemaps->get_outputmap(xstype=>$typemap->xstype);if (not $outputmap){$self->blurt("Error: No OUTPUT definition for type '$type', typekind '" .$typemap->xstype ."' found");return}(my$ntype=$type)=~ s/\s*\*/Ptr/g;$ntype =~ s/\(\)//g;(my$subtype=$ntype)=~ s/(?:Array)?(?:Ptr)?$//;my$eval_vars={%$argsref,subtype=>$subtype,ntype=>$ntype,arg=>$arg};my$expr=$outputmap->cleaned_code;if ($expr =~ /DO_ARRAY_ELEM/){my$subtypemap=$typemaps->get_typemap(ctype=>$subtype);if (not $subtypemap){$self->report_typemap_failure($typemaps,$subtype);return}my$suboutputmap=$typemaps->get_outputmap(xstype=>$subtypemap->xstype);if (not $suboutputmap){$self->blurt("Error: No OUTPUT definition for type '$subtype', typekind '" .$subtypemap->xstype ."' found");return}my$subexpr=$suboutputmap->cleaned_code;$subexpr =~ s/ntype/subtype/g;$subexpr =~ s/\$arg/ST(ix_$var)/g;$subexpr =~ s/\$var/${var}\[ix_$var]/g;$subexpr =~ s/\n\t/\n\t\t/g;$expr =~ s/DO_ARRAY_ELEM\n/$subexpr/;$self->eval_output_typemap_code("print qq\a$expr\a",$eval_vars);print "\t\tSvSETMAGIC(ST(ix_$var));\n" if$do_setmagic}elsif ($var eq 'RETVAL'){my$orig_arg=$arg;my$indent;my$use_RETVALSV=1;my$do_mortal=0;my$do_copy_tmp=1;my$pre_expr;local$eval_vars->{arg}=$arg='RETVALSV';my$evalexpr=$self->eval_output_typemap_code("qq\a$expr\a",$eval_vars);if ($expr =~ /^\t\Q$arg\E = new/){$do_mortal=1}elsif ($evalexpr =~ /^\t\Q$arg\E\s*=\s*(boolSV\(|(&PL_sv_yes|&PL_sv_no|&PL_sv_undef)\s*;)/){$do_copy_tmp=0;$use_RETVALSV=0}elsif ($evalexpr =~ /^\s*\Q$arg\E\s*=/){$use_RETVALSV=0 if$ntype eq "SVPtr";$do_mortal=1}else {$pre_expr="RETVALSV = sv_newmortal();\n";$do_setmagic=0}if($use_RETVALSV){print "\t{\n\t    SV * RETVALSV;\n";$indent="\t    "}else {$indent="\t"}print$indent.$pre_expr if$pre_expr;if($use_RETVALSV){$evalexpr =~ s/^(\t|        )/$indent/gm;$evalexpr =~ s/\t/        /g;$evalexpr =~ s/        /\t/g}else {if($do_mortal || $do_setmagic){$evalexpr =~ s/RETVALSV/RETVAL/g}else {$evalexpr =~ s/RETVALSV/$orig_arg/g}}print$evalexpr if$evalexpr !~ /^\s*RETVAL = RETVAL;$/;print$indent.'RETVAL'.($use_RETVALSV ? 'SV':'').' = sv_2mortal(RETVAL'.($use_RETVALSV ? 'SV':'').");\n" if$do_mortal;print$indent.'SvSETMAGIC(RETVAL'.($use_RETVALSV ? 'SV':'').");\n" if$do_setmagic;print$indent."$orig_arg = RETVAL".($use_RETVALSV ? 'SV':'').";\n" if$do_mortal || $do_setmagic || $do_copy_tmp;print "\t}\n" if$use_RETVALSV}elsif ($do_push){print "\tPUSHs(sv_newmortal());\n";local$eval_vars->{arg}="ST($num)";$self->eval_output_typemap_code("print qq\a$expr\a",$eval_vars);print "\tSvSETMAGIC($arg);\n" if$do_setmagic}elsif ($arg =~ /^ST\(\d+\)$/){$self->eval_output_typemap_code("print qq\a$expr\a",$eval_vars);print "\tSvSETMAGIC($arg);\n" if$do_setmagic}}}sub eval_output_typemap_code {my ($self,$code,$other)=@_;return ExtUtils::ParseXS::Eval::eval_output_typemap_code($self,$code,$other)}sub eval_input_typemap_code {my ($self,$code,$other)=@_;return ExtUtils::ParseXS::Eval::eval_input_typemap_code($self,$code,$other)}1;
EXTUTILS_PARSEXS

$fatpacked{"ExtUtils/ParseXS/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_PARSEXS_CONSTANTS';
  package ExtUtils::ParseXS::Constants;use strict;use warnings;use Symbol;our$VERSION='3.35';our@InitFileCode;our$PrototypeRegexp="[" .quotemeta('\$%&*@;[]_')."]";our@XSKeywords=qw(REQUIRE BOOT CASE PREINIT INPUT INIT CODE PPCODE OUTPUT CLEANUP ALIAS ATTRS PROTOTYPES PROTOTYPE VERSIONCHECK INCLUDE INCLUDE_COMMAND SCOPE INTERFACE INTERFACE_MACRO C_ARGS POSTCALL OVERLOAD FALLBACK EXPORT_XSUB_SYMBOLS);our$XSKeywordsAlternation=join('|',@XSKeywords);1;
EXTUTILS_PARSEXS_CONSTANTS

$fatpacked{"ExtUtils/ParseXS/CountLines.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_PARSEXS_COUNTLINES';
  package ExtUtils::ParseXS::CountLines;use strict;our$VERSION='3.35';our$SECTION_END_MARKER;sub TIEHANDLE {my ($class,$cfile,$fh)=@_;$cfile =~ s/\\/\\\\/g;$cfile =~ s/"/\\"/g;$SECTION_END_MARKER=qq{#line --- "$cfile"};return bless {buffer=>'',fh=>$fh,line_no=>1,},$class}sub PRINT {my$self=shift;for (@_){$self->{buffer}.= $_;while ($self->{buffer}=~ s/^([^\n]*\n)//){my$line=$1;++$self->{line_no};$line =~ s|^\#line\s+---(?=\s)|#line $self->{line_no}|;print {$self->{fh}}$line}}}sub PRINTF {my$self=shift;my$fmt=shift;$self->PRINT(sprintf($fmt,@_))}sub DESTROY {my$self=shift;print {$self->{fh}}$self->{buffer}}sub UNTIE {}sub end_marker {return$SECTION_END_MARKER}1;
EXTUTILS_PARSEXS_COUNTLINES

$fatpacked{"ExtUtils/ParseXS/Eval.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_PARSEXS_EVAL';
  package ExtUtils::ParseXS::Eval;use strict;use warnings;our$VERSION='3.35';sub eval_output_typemap_code {my ($_pxs,$_code,$_other)=@_;my ($Package,$ALIAS,$func_name,$Full_func_name,$pname)=@{$_pxs}{qw(Package ALIAS func_name Full_func_name pname)};my ($var,$type,$ntype,$subtype,$arg)=@{$_other}{qw(var type ntype subtype arg)};my$rv=eval$_code;warn $@ if $@;return$rv}sub eval_input_typemap_code {my ($_pxs,$_code,$_other)=@_;my ($Package,$ALIAS,$func_name,$Full_func_name,$pname)=@{$_pxs}{qw(Package ALIAS func_name Full_func_name pname)};my ($var,$type,$num,$init,$printed_name,$arg,$ntype,$argoff,$subtype)=@{$_other}{qw(var type num init printed_name arg ntype argoff subtype)};my$rv=eval$_code;warn $@ if $@;return$rv}1;
EXTUTILS_PARSEXS_EVAL

$fatpacked{"ExtUtils/ParseXS/Utilities.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_PARSEXS_UTILITIES';
  package ExtUtils::ParseXS::Utilities;use strict;use warnings;use Exporter;use File::Spec;use ExtUtils::ParseXS::Constants ();our$VERSION='3.35';our (@ISA,@EXPORT_OK);@ISA=qw(Exporter);@EXPORT_OK=qw(standard_typemap_locations trim_whitespace C_string valid_proto_string process_typemaps map_type standard_XS_defs assign_func_args analyze_preprocessor_statements set_cond Warn current_line_number blurt death check_conditional_preprocessor_statements escape_file_for_line_directive report_typemap_failure);SCOPE: {my@tm_template;sub standard_typemap_locations {my$include_ref=shift;if (not @tm_template){@tm_template=qw(typemap);my$updir=File::Spec->updir();for my$dir (File::Spec->catdir(($updir)x 1),File::Spec->catdir(($updir)x 2),File::Spec->catdir(($updir)x 3),File::Spec->catdir(($updir)x 4),){unshift@tm_template,File::Spec->catfile($dir,'typemap');unshift@tm_template,File::Spec->catfile($dir,lib=>ExtUtils=>'typemap')}}my@tm=@tm_template;for my$dir (@{$include_ref}){my$file=File::Spec->catfile($dir,ExtUtils=>'typemap');unshift@tm,$file if -e $file}return@tm}}sub trim_whitespace {$_[0]=~ s/^\s+|\s+$//go}sub C_string {my($string)=@_;$string =~ s[\\][\\\\]g;$string}sub valid_proto_string {my ($string)=@_;if ($string =~ /^$ExtUtils::ParseXS::Constants::PrototypeRegexp+$/){return$string}return 0}sub process_typemaps {my ($tmap,$pwd)=@_;my@tm=ref$tmap ? @{$tmap}: ($tmap);for my$typemap (@tm){die "Can't find $typemap in $pwd\n" unless -r $typemap}push@tm,standard_typemap_locations(\@INC);require ExtUtils::Typemaps;my$typemap=ExtUtils::Typemaps->new;for my$typemap_loc (@tm){next unless -f $typemap_loc;warn("Warning: ignoring non-text typemap file '$typemap_loc'\n"),next unless -T $typemap_loc;$typemap->merge(file=>$typemap_loc,replace=>1)}return$typemap}sub map_type {my ($self,$type,$varname)=@_;$type =~ tr/:/_/ unless$self->{RetainCplusplusHierarchicalTypes};$type =~ s/^array\(([^,]*),(.*)\).*/$1 */s;if ($varname){if ($type =~ / \( \s* \* (?= \s* \) ) /xg){(substr$type,pos$type,0)=" $varname "}else {$type .= "\t$varname"}}return$type}sub standard_XS_defs {print <<"EOF";print <<"EOF";return 1}sub assign_func_args {my ($self,$argsref,$class)=@_;my@func_args=@{$argsref};shift@func_args if defined($class);for my$arg (@func_args){$arg =~ s/^/&/ if$self->{in_out}->{$arg}}return join(", ",@func_args)}sub analyze_preprocessor_statements {my ($self,$statement,$XSS_work_idx,$BootCode_ref)=@_;if ($statement eq 'if'){$XSS_work_idx=@{$self->{XSStack}};push(@{$self->{XSStack}},{type=>'if'})}else {$self->death("Error: '$statement' with no matching 'if'")if$self->{XSStack}->[-1]{type}ne 'if';if ($self->{XSStack}->[-1]{varname}){push(@{$self->{InitFileCode}},"#endif\n");push(@{$BootCode_ref},"#endif")}my(@fns)=keys %{$self->{XSStack}->[-1]{functions}};if ($statement ne 'endif'){@{$self->{XSStack}->[-1]{other_functions}}{@fns}=(1)x @fns;@{$self->{XSStack}->[-1]}{qw(varname functions)}=('',{})}else {my($tmp)=pop(@{$self->{XSStack}});0 while (--$XSS_work_idx && $self->{XSStack}->[$XSS_work_idx]{type}ne 'if');push(@fns,keys %{$tmp->{other_functions}});@{$self->{XSStack}->[$XSS_work_idx]{functions}}{@fns}=(1)x @fns}}return ($self,$XSS_work_idx,$BootCode_ref)}sub set_cond {my ($ellipsis,$min_args,$num_args)=@_;my$cond;if ($ellipsis){$cond=($min_args ? qq(items < $min_args) : 0)}elsif ($min_args==$num_args){$cond=qq(items != $min_args)}else {$cond=qq(items < $min_args || items > $num_args)}return$cond}sub current_line_number {my$self=shift;my$line_number=$self->{line_no}->[@{$self->{line_no}}- @{$self->{line}}-1];return$line_number}sub Warn {my$self=shift;my$warn_line_number=$self->current_line_number();print STDERR "@_ in $self->{filename}, line $warn_line_number\n"}sub blurt {my$self=shift;$self->Warn(@_);$self->{errors}++}sub death {my$self=shift;$self->Warn(@_);exit 1}sub check_conditional_preprocessor_statements {my ($self)=@_;my@cpp=grep(/^\#\s*(?:if|e\w+)/,@{$self->{line}});if (@cpp){my$cpplevel;for my$cpp (@cpp){if ($cpp =~ /^\#\s*if/){$cpplevel++}elsif (!$cpplevel){$self->Warn("Warning: #else/elif/endif without #if in this function");print STDERR "    (precede it with a blank line if the matching #if is outside the function)\n" if$self->{XSStack}->[-1]{type}eq 'if';return}elsif ($cpp =~ /^\#\s*endif/){$cpplevel--}}$self->Warn("Warning: #if without #endif in this function")if$cpplevel}}sub escape_file_for_line_directive {my$string=shift;$string =~ s/\\/\\\\/g;$string =~ s/"/\\"/g;return$string}sub report_typemap_failure {my ($self,$tm,$ctype,$error_method)=@_;$error_method ||= 'blurt';my@avail_ctypes=$tm->list_mapped_ctypes;my$err="Could not find a typemap for C type '$ctype'.\n" ."The following C types are mapped by the current typemap:\n'" .join("', '",@avail_ctypes)."'\n";$self->$error_method($err);return()}1;
  #ifndef PERL_UNUSED_VAR
  #  define PERL_UNUSED_VAR(var) if (0) var = var
  #endif
  
  #ifndef dVAR
  #  define dVAR		dNOOP
  #endif
  
  
  /* This stuff is not part of the API! You have been warned. */
  #ifndef PERL_VERSION_DECIMAL
  #  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
  #endif
  #ifndef PERL_DECIMAL_VERSION
  #  define PERL_DECIMAL_VERSION \\
  	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
  #endif
  #ifndef PERL_VERSION_GE
  #  define PERL_VERSION_GE(r,v,s) \\
  	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
  #endif
  #ifndef PERL_VERSION_LE
  #  define PERL_VERSION_LE(r,v,s) \\
  	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
  #endif
  
  /* XS_INTERNAL is the explicit static-linkage variant of the default
   * XS macro.
   *
   * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
   * "STATIC", ie. it exports XSUB symbols. You probably don't want that
   * for anything but the BOOT XSUB.
   *
   * See XSUB.h in core!
   */
  
  
  /* TODO: This might be compatible further back than 5.10.0. */
  #if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
  #  undef XS_EXTERNAL
  #  undef XS_INTERNAL
  #  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
  #    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
  #    define XS_INTERNAL(name) STATIC XSPROTO(name)
  #  endif
  #  if defined(__SYMBIAN32__)
  #    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
  #    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
  #  endif
  #  ifndef XS_EXTERNAL
  #    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
  #      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
  #      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
  #    else
  #      ifdef __cplusplus
  #        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
  #        define XS_INTERNAL(name) static XSPROTO(name)
  #      else
  #        define XS_EXTERNAL(name) XSPROTO(name)
  #        define XS_INTERNAL(name) STATIC XSPROTO(name)
  #      endif
  #    endif
  #  endif
  #endif
  
  /* perl >= 5.10.0 && perl <= 5.15.1 */
  
  
  /* The XS_EXTERNAL macro is used for functions that must not be static
   * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
   * macro defined, the best we can do is assume XS is the same.
   * Dito for XS_INTERNAL.
   */
  #ifndef XS_EXTERNAL
  #  define XS_EXTERNAL(name) XS(name)
  #endif
  #ifndef XS_INTERNAL
  #  define XS_INTERNAL(name) XS(name)
  #endif
  
  /* Now, finally, after all this mess, we want an ExtUtils::ParseXS
   * internal macro that we're free to redefine for varying linkage due
   * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
   * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
   */
  
  #undef XS_EUPXS
  #if defined(PERL_EUPXS_ALWAYS_EXPORT)
  #  define XS_EUPXS(name) XS_EXTERNAL(name)
  #else
     /* default to internal */
  #  define XS_EUPXS(name) XS_INTERNAL(name)
  #endif
  
  EOF
  #ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
  #define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)
  
  /* prototype to pass -Wmissing-prototypes */
  STATIC void
  S_croak_xs_usage(const CV *const cv, const char *const params);
  
  STATIC void
  S_croak_xs_usage(const CV *const cv, const char *const params)
  {
      const GV *const gv = CvGV(cv);
  
      PERL_ARGS_ASSERT_CROAK_XS_USAGE;
  
      if (gv) {
          const char *const gvname = GvNAME(gv);
          const HV *const stash = GvSTASH(gv);
          const char *const hvname = stash ? HvNAME(stash) : NULL;
  
          if (hvname)
  	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
          else
  	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
      } else {
          /* Pants. I don't think that it should be possible to get here. */
  	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
      }
  }
  #undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE
  
  #define croak_xs_usage        S_croak_xs_usage
  
  #endif
  
  /* NOTE: the prototype of newXSproto() is different in versions of perls,
   * so we define a portable version of newXSproto()
   */
  #ifdef newXS_flags
  #define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
  #else
  #define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
  #endif /* !defined(newXS_flags) */
  
  #if PERL_VERSION_LE(5, 21, 5)
  #  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
  #else
  #  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
  #endif
  
  EOF
EXTUTILS_PARSEXS_UTILITIES

$fatpacked{"ExtUtils/Typemaps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_TYPEMAPS';
  package ExtUtils::Typemaps;use 5.006001;use strict;use warnings;our$VERSION='3.35';require ExtUtils::ParseXS;require ExtUtils::ParseXS::Constants;require ExtUtils::Typemaps::InputMap;require ExtUtils::Typemaps::OutputMap;require ExtUtils::Typemaps::Type;sub new {my$class=shift;my%args=@_;if (defined$args{file}and defined$args{string}){die("Cannot handle both 'file' and 'string' arguments to constructor")}my$self=bless {file=>undef,%args,typemap_section=>[],typemap_lookup=>{},input_section=>[],input_lookup=>{},output_section=>[],output_lookup=>{},}=>$class;$self->_init();return$self}sub _init {my$self=shift;if (defined$self->{string}){$self->_parse(\($self->{string}),$self->{lineno_offset},$self->{fake_filename});delete$self->{string}}elsif (defined$self->{file}and -e $self->{file}){open my$fh,'<',$self->{file}or die "Cannot open typemap file '" .$self->{file}."' for reading: $!";local $/=undef;my$string=<$fh>;$self->_parse(\$string,$self->{lineno_offset},$self->{file})}}sub file {$_[0]->{file}=$_[1]if @_ > 1;$_[0]->{file}}sub add_typemap {my$self=shift;my$type;my%args;if ((@_ % 2)==1){my$orig=shift;$type=$orig->new();%args=@_}else {%args=@_;my$ctype=$args{ctype};die("Need ctype argument")if not defined$ctype;my$xstype=$args{xstype};die("Need xstype argument")if not defined$xstype;$type=ExtUtils::Typemaps::Type->new(xstype=>$xstype,'prototype'=>$args{'prototype'},ctype=>$ctype,)}if ($args{skip}and $args{replace}){die("Cannot use both 'skip' and 'replace'")}if ($args{replace}){$self->remove_typemap(ctype=>$type->ctype)}elsif ($args{skip}){return()if exists$self->{typemap_lookup}{$type->ctype}}else {$self->validate(typemap_xstype=>$type->xstype,ctype=>$type->ctype)}push @{$self->{typemap_section}},$type;$self->{typemap_lookup}{$type->tidy_ctype}=$#{$self->{typemap_section}};return 1}sub add_inputmap {my$self=shift;my$input;my%args;if ((@_ % 2)==1){my$orig=shift;$input=$orig->new();%args=@_}else {%args=@_;my$xstype=$args{xstype};die("Need xstype argument")if not defined$xstype;my$code=$args{code};die("Need code argument")if not defined$code;$input=ExtUtils::Typemaps::InputMap->new(xstype=>$xstype,code=>$code,)}if ($args{skip}and $args{replace}){die("Cannot use both 'skip' and 'replace'")}if ($args{replace}){$self->remove_inputmap(xstype=>$input->xstype)}elsif ($args{skip}){return()if exists$self->{input_lookup}{$input->xstype}}else {$self->validate(inputmap_xstype=>$input->xstype)}push @{$self->{input_section}},$input;$self->{input_lookup}{$input->xstype}=$#{$self->{input_section}};return 1}sub add_outputmap {my$self=shift;my$output;my%args;if ((@_ % 2)==1){my$orig=shift;$output=$orig->new();%args=@_}else {%args=@_;my$xstype=$args{xstype};die("Need xstype argument")if not defined$xstype;my$code=$args{code};die("Need code argument")if not defined$code;$output=ExtUtils::Typemaps::OutputMap->new(xstype=>$xstype,code=>$code,)}if ($args{skip}and $args{replace}){die("Cannot use both 'skip' and 'replace'")}if ($args{replace}){$self->remove_outputmap(xstype=>$output->xstype)}elsif ($args{skip}){return()if exists$self->{output_lookup}{$output->xstype}}else {$self->validate(outputmap_xstype=>$output->xstype)}push @{$self->{output_section}},$output;$self->{output_lookup}{$output->xstype}=$#{$self->{output_section}};return 1}sub add_string {my$self=shift;my%args=@_;die("Need 'string' argument")if not defined$args{string};my$other=ExtUtils::Typemaps->new(string=>$args{string});$self->merge(typemap=>$other)}sub remove_typemap {my$self=shift;my$ctype;if (@_ > 1){my%args=@_;$ctype=$args{ctype};die("Need ctype argument")if not defined$ctype;$ctype=tidy_type($ctype)}else {$ctype=$_[0]->tidy_ctype}return$self->_remove($ctype,$self->{typemap_section},$self->{typemap_lookup})}sub remove_inputmap {my$self=shift;my$xstype;if (@_ > 1){my%args=@_;$xstype=$args{xstype};die("Need xstype argument")if not defined$xstype}else {$xstype=$_[0]->xstype}return$self->_remove($xstype,$self->{input_section},$self->{input_lookup})}sub remove_outputmap {my$self=shift;my$xstype;if (@_ > 1){my%args=@_;$xstype=$args{xstype};die("Need xstype argument")if not defined$xstype}else {$xstype=$_[0]->xstype}return$self->_remove($xstype,$self->{output_section},$self->{output_lookup})}sub _remove {my$self=shift;my$rm=shift;my$array=shift;my$lookup=shift;my$index=$lookup->{$rm};return()if not defined$index;splice(@$array,$index,1);for my$key (keys %$lookup){if ($lookup->{$key}> $index){$lookup->{$key}--}}return()}sub get_typemap {my$self=shift;die("Need named parameters, got uneven number")if @_ % 2;my%args=@_;my$ctype=$args{ctype};die("Need ctype argument")if not defined$ctype;$ctype=tidy_type($ctype);my$index=$self->{typemap_lookup}{$ctype};return()if not defined$index;return$self->{typemap_section}[$index]}sub get_inputmap {my$self=shift;die("Need named parameters, got uneven number")if @_ % 2;my%args=@_;my$xstype=$args{xstype};my$ctype=$args{ctype};die("Need xstype or ctype argument")if not defined$xstype and not defined$ctype;die("Need xstype OR ctype arguments, not both")if defined$xstype and defined$ctype;if (defined$ctype){my$tm=$self->get_typemap(ctype=>$ctype);$xstype=$tm && $tm->xstype;return()if not defined$xstype}my$index=$self->{input_lookup}{$xstype};return()if not defined$index;return$self->{input_section}[$index]}sub get_outputmap {my$self=shift;die("Need named parameters, got uneven number")if @_ % 2;my%args=@_;my$xstype=$args{xstype};my$ctype=$args{ctype};die("Need xstype or ctype argument")if not defined$xstype and not defined$ctype;die("Need xstype OR ctype arguments, not both")if defined$xstype and defined$ctype;if (defined$ctype){my$tm=$self->get_typemap(ctype=>$ctype);$xstype=$tm && $tm->xstype;return()if not defined$xstype}my$index=$self->{output_lookup}{$xstype};return()if not defined$index;return$self->{output_section}[$index]}sub write {my$self=shift;my%args=@_;my$file=defined$args{file}? $args{file}: $self->file();die("write() needs a file argument (or set the file name of the typemap using the 'file' method)")if not defined$file;open my$fh,'>',$file or die "Cannot open typemap file '$file' for writing: $!";print$fh $self->as_string();close$fh}sub as_string {my$self=shift;my$typemap=$self->{typemap_section};my@code;push@code,"TYPEMAP\n";for my$entry (@$typemap){push@code,$entry->ctype ."\t" .$entry->xstype .($entry->proto ne '' ? "\t".$entry->proto : '')."\n"}my$input=$self->{input_section};if (@$input){push@code,"\nINPUT\n";for my$entry (@$input){push@code,$entry->xstype,"\n",$entry->code,"\n"}}my$output=$self->{output_section};if (@$output){push@code,"\nOUTPUT\n";for my$entry (@$output){push@code,$entry->xstype,"\n",$entry->code,"\n"}}return join '',@code}sub as_embedded_typemap {my$self=shift;my$string=$self->as_string;my@ident_cand=qw(END_TYPEMAP END_OF_TYPEMAP END);my$icand=0;my$cand_suffix="";while ($string =~ /^\Q$ident_cand[$icand]$cand_suffix\E\s*$/m){$icand++;if ($icand==@ident_cand){$icand=0;++$cand_suffix}}my$marker="$ident_cand[$icand]$cand_suffix";return "TYPEMAP: <<$marker;\n$string\n$marker\n"}sub merge {my$self=shift;my%args=@_;if (exists$args{typemap}and exists$args{file}){die("Need {file} OR {typemap} argument. Not both!")}elsif (not exists$args{typemap}and not exists$args{file}){die("Need {file} or {typemap} argument!")}my@params;push@params,'replace'=>$args{replace}if exists$args{replace};push@params,'skip'=>$args{skip}if exists$args{skip};my$typemap=$args{typemap};if (not defined$typemap){$typemap=ref($self)->new(file=>$args{file},@params)}for my$entry (@{$typemap->{typemap_section}}){$self->add_typemap($entry,@params)}for my$entry (@{$typemap->{input_section}}){$self->add_inputmap($entry,@params)}for my$entry (@{$typemap->{output_section}}){$self->add_outputmap($entry,@params)}return 1}sub is_empty {my$self=shift;return @{$self->{typemap_section}}==0 && @{$self->{input_section}}==0 && @{$self->{output_section}}==0}sub list_mapped_ctypes {my$self=shift;return sort keys %{$self->{typemap_lookup}}}sub _get_typemap_hash {my$self=shift;my$lookup=$self->{typemap_lookup};my$storage=$self->{typemap_section};my%rv;for my$ctype (keys %$lookup){$rv{$ctype}=$storage->[$lookup->{$ctype}]->xstype}return \%rv}sub _get_inputmap_hash {my$self=shift;my$lookup=$self->{input_lookup};my$storage=$self->{input_section};my%rv;for my$xstype (keys %$lookup){$rv{$xstype}=$storage->[$lookup->{$xstype}]->code;$rv{$xstype}=~ s/\s*\z/\n/}return \%rv}sub _get_outputmap_hash {my$self=shift;my$lookup=$self->{output_lookup};my$storage=$self->{output_section};my%rv;for my$xstype (keys %$lookup){$rv{$xstype}=$storage->[$lookup->{$xstype}]->code;$rv{$xstype}=~ s/\s*\z/\n/}return \%rv}sub _get_prototype_hash {my$self=shift;my$lookup=$self->{typemap_lookup};my$storage=$self->{typemap_section};my%rv;for my$ctype (keys %$lookup){$rv{$ctype}=$storage->[$lookup->{$ctype}]->proto || '$'}return \%rv}sub validate {my$self=shift;my%args=@_;if (exists$args{ctype}and exists$self->{typemap_lookup}{tidy_type($args{ctype})}){die("Multiple definition of ctype '$args{ctype}' in TYPEMAP section")}if (exists$args{inputmap_xstype}and exists$self->{input_lookup}{$args{inputmap_xstype}}){die("Multiple definition of xstype '$args{inputmap_xstype}' in INPUTMAP section")}if (exists$args{outputmap_xstype}and exists$self->{output_lookup}{$args{outputmap_xstype}}){die("Multiple definition of xstype '$args{outputmap_xstype}' in OUTPUTMAP section")}return 1}sub clone {my$proto=shift;my%args=@_;my$self;if ($args{shallow}){$self=bless({%$proto,typemap_section=>[@{$proto->{typemap_section}}],typemap_lookup=>{%{$proto->{typemap_lookup}}},input_section=>[@{$proto->{input_section}}],input_lookup=>{%{$proto->{input_lookup}}},output_section=>[@{$proto->{output_section}}],output_lookup=>{%{$proto->{output_lookup}}},}=>ref($proto))}else {$self=bless({%$proto,typemap_section=>[map $_->new,@{$proto->{typemap_section}}],typemap_lookup=>{%{$proto->{typemap_lookup}}},input_section=>[map $_->new,@{$proto->{input_section}}],input_lookup=>{%{$proto->{input_lookup}}},output_section=>[map $_->new,@{$proto->{output_section}}],output_lookup=>{%{$proto->{output_lookup}}},}=>ref($proto))}return$self}sub tidy_type {local $_=shift;if (/[<>]/){s/\s*([<>])\s*/$1/g;s/>>/> >/g}s#\s*(\*+)\s*#$1#g;s#(\*+)# $1 #g ;s/^\s+//;s/\s+$//;s/\s+/ /g;$_}sub _parse {my$self=shift;my$stringref=shift;my$lineno_offset=shift;$lineno_offset=0 if not defined$lineno_offset;my$filename=shift;$filename='<string>' if not defined$filename;my$replace=$self->{replace};my$skip=$self->{skip};die "Can only replace OR skip" if$replace and $skip;my@add_params;push@add_params,replace=>1 if$replace;push@add_params,skip=>1 if$skip;my$section='typemap';my$lineno=$lineno_offset;my$junk="";my$current=\$junk;my@input_expr;my@output_expr;while ($$stringref =~ /^(.*)$/gcm){local $_=$1;++$lineno;chomp;next if /^\s*#/;if (/^INPUT\s*$/){$section='input';$current=\$junk;next}elsif (/^OUTPUT\s*$/){$section='output';$current=\$junk;next}elsif (/^TYPEMAP\s*$/){$section='typemap';$current=\$junk;next}if ($section eq 'typemap'){my$line=$_;s/^\s+//;s/\s+$//;next if $_ eq '' or /^#/;my($type,$kind,$proto)=/^(.*?\S)\s+(\S+)\s*($ExtUtils::ParseXS::Constants::PrototypeRegexp*)$/o or warn("Warning: File '$filename' Line $lineno '$line' TYPEMAP entry needs 2 or 3 columns\n"),next;$proto='$' unless$proto;warn("Warning: File '$filename' Line $lineno '$line' Invalid prototype '$proto'\n")unless _valid_proto_string($proto);$self->add_typemap(ExtUtils::Typemaps::Type->new(xstype=>$kind,proto=>$proto,ctype=>$type),@add_params)}elsif (/^\s/){s/\s+$//;$$current .= $$current eq '' ? $_ : "\n".$_}elsif ($_ eq ''){next}elsif ($section eq 'input'){s/\s+$//;push@input_expr,{xstype=>$_,code=>''};$current=\$input_expr[-1]{code}}else {s/\s+$//;push@output_expr,{xstype=>$_,code=>''};$current=\$output_expr[-1]{code}}}for my$inexpr (@input_expr){$self->add_inputmap(ExtUtils::Typemaps::InputMap->new(%$inexpr),@add_params)}for my$outexpr (@output_expr){$self->add_outputmap(ExtUtils::Typemaps::OutputMap->new(%$outexpr),@add_params)}return 1}sub _valid_proto_string {my$string=shift;if ($string =~ /^$ExtUtils::ParseXS::Constants::PrototypeRegexp+$/o){return$string}return 0 }sub _escape_backslashes {my$string=shift;$string =~ s[\\][\\\\]g;$string}1;
EXTUTILS_TYPEMAPS

$fatpacked{"ExtUtils/Typemaps/Cmd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_TYPEMAPS_CMD';
  package ExtUtils::Typemaps::Cmd;use 5.006001;use strict;use warnings;our$VERSION='3.35';use ExtUtils::Typemaps;require Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(embeddable_typemap);our%EXPORT_TAGS=(all=>\@EXPORT);sub embeddable_typemap {my@tms=@_;my@tm_objs=map [$_,_intuit_typemap_source($_)],@tms;my$final_tm;if (@tm_objs==1){$final_tm=shift(@tm_objs)->[1]}else {$final_tm=ExtUtils::Typemaps->new;for my$other_tm (@tm_objs){my ($tm_ident,$tm_obj)=@$other_tm;eval {$final_tm->merge(typemap=>$tm_obj);1}or do {my$err=$@ || 'Zombie error';die "Failed to merge typ"}}}return$final_tm->as_embedded_typemap()}sub _load_module {my$name=shift;return eval "require $name; 1"}SCOPE: {my%sources=(module=>sub {my$ident=shift;my$tm;if (/::/){for my$module ($ident,"ExtUtils::Typemaps::$ident"){if (_load_module($module)){eval {$tm=$module->new}and return$tm}}}else {for my$module ("ExtUtils::Typemaps::$ident","$ident"){if (_load_module($module)){eval {$tm=$module->new}and return$tm}}}return()},file=>sub {my$ident=shift;return unless -e $ident and -r _;return ExtUtils::Typemaps->new(file=>$ident)},);sub _intuit_typemap_source {my$identifier=shift;my@locate_attempts;if ($identifier =~ /::/ || $identifier !~ /[^\w_]/){@locate_attempts=qw(module file)}else {@locate_attempts=qw(file module)}for my$source (@locate_attempts){my$tm=$sources{$source}->($identifier);return$tm if defined$tm}die "Unable to find typemap for '$identifier': " ."Tried to load both as file or module and failed.\n"}}1;
EXTUTILS_TYPEMAPS_CMD

$fatpacked{"ExtUtils/Typemaps/InputMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_TYPEMAPS_INPUTMAP';
  package ExtUtils::Typemaps::InputMap;use 5.006001;use strict;use warnings;our$VERSION='3.35';sub new {my$prot=shift;my$class=ref($prot)||$prot;my%args=@_;if (!ref($prot)){if (not defined$args{xstype}or not defined$args{code}){die("Need xstype and code parameters")}}my$self=bless((ref($prot)? {%$prot}: {})=>$class);$self->{xstype}=$args{xstype}if defined$args{xstype};$self->{code}=$args{code}if defined$args{code};$self->{code}=~ s/^(?=\S)/\t/mg;return$self}sub code {$_[0]->{code}=$_[1]if @_ > 1;return $_[0]->{code}}sub xstype {return $_[0]->{xstype}}sub cleaned_code {my$self=shift;my$code=$self->code;$code =~ s/(?:;+\s*|;*\s+)\z//s;$code =~ s/^\s+#/#/mg;$code =~ s/\s*\z/\n/;return$code}1;
EXTUTILS_TYPEMAPS_INPUTMAP

$fatpacked{"ExtUtils/Typemaps/OutputMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_TYPEMAPS_OUTPUTMAP';
  package ExtUtils::Typemaps::OutputMap;use 5.006001;use strict;use warnings;our$VERSION='3.35';sub new {my$prot=shift;my$class=ref($prot)||$prot;my%args=@_;if (!ref($prot)){if (not defined$args{xstype}or not defined$args{code}){die("Need xstype and code parameters")}}my$self=bless((ref($prot)? {%$prot}: {})=>$class);$self->{xstype}=$args{xstype}if defined$args{xstype};$self->{code}=$args{code}if defined$args{code};$self->{code}=~ s/^(?=\S)/\t/mg;return$self}sub code {$_[0]->{code}=$_[1]if @_ > 1;return $_[0]->{code}}sub xstype {return $_[0]->{xstype}}sub cleaned_code {my$self=shift;my$code=$self->code;$code =~ s/^\s+#/#/mg;$code =~ s/\s*\z/\n/;return$code}sub targetable {my$self=shift;return$self->{targetable}if exists$self->{targetable};our$bal;$bal=qr[
      (?:
        (?>[^()]+)
        |
        \( (??{ $bal }) \)
      )*
    ]x;my$bal_no_comma=qr[
      (?:
        (?>[^(),]+)
        |
        \( (??{ $bal }) \)
      )+
    ]x;my$sv_cast=qr[
      (?:
        \( \s* SV \s* \* \s* \) \s*
      )?
    ]x;my$size=qr[ # Third arg (to setpvn)
      , \s* (??{ $bal })
    ]xo;my$code=$self->code;use re 'eval';my ($type,$with_size,$arg,$sarg)=($code =~ m[^
          \s+
          sv_set([iunp])v(n)?    # Type, is_setpvn
          \s*
          \( \s*
            $sv_cast \$arg \s* , \s*
            ( $bal_no_comma )    # Set from
            ( $size )?           # Possible sizeof set-from
          \s* \) \s* ; \s* $
        ]xo);my$rv=undef;if ($type){$rv={type=>$type,with_size=>$with_size,what=>$arg,what_size=>$sarg,}}$self->{targetable}=$rv;return$rv}1;
EXTUTILS_TYPEMAPS_OUTPUTMAP

$fatpacked{"ExtUtils/Typemaps/Type.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_TYPEMAPS_TYPE';
  package ExtUtils::Typemaps::Type;use 5.006001;use strict;use warnings;require ExtUtils::Typemaps;our$VERSION='3.35';sub new {my$prot=shift;my$class=ref($prot)||$prot;my%args=@_;if (!ref($prot)){if (not defined$args{xstype}or not defined$args{ctype}){die("Need xstype and ctype parameters")}}my$self=bless((ref($prot)? {%$prot}: {proto=>''})=>$class);$self->{xstype}=$args{xstype}if defined$args{xstype};$self->{ctype}=$args{ctype}if defined$args{ctype};$self->{tidy_ctype}=ExtUtils::Typemaps::tidy_type($self->{ctype});$self->{proto}=$args{'prototype'}if defined$args{'prototype'};return$self}sub proto {$_[0]->{proto}=$_[1]if @_ > 1;return $_[0]->{proto}}sub xstype {return $_[0]->{xstype}}sub ctype {return defined($_[0]->{ctype})? $_[0]->{ctype}: $_[0]->{tidy_ctype}}sub tidy_ctype {return $_[0]->{tidy_ctype}}1;
EXTUTILS_TYPEMAPS_TYPE

$fatpacked{"ExtUtils/testlib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_TESTLIB';
  package ExtUtils::testlib;use strict;use warnings;our$VERSION='7.38';$VERSION =~ tr/_//d;use Cwd;use File::Spec;my$cwd;BEGIN {($cwd)=getcwd()=~ /(.*)/}use lib map {File::Spec->rel2abs($_,$cwd)}qw(blib/arch blib/lib);1;
EXTUTILS_TESTLIB

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;use strict;use warnings;use Exporter ();use File::Spec ();our$VERSION='1.23';our@ISA='Exporter';our@EXPORT='which';our@EXPORT_OK='where';use constant IS_VMS=>($^O eq 'VMS');use constant IS_MAC=>($^O eq 'MacOS');use constant IS_WIN=>($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');use constant IS_DOS=>IS_WIN();use constant IS_CYG=>($^O eq 'cygwin' || $^O eq 'msys');our$IMPLICIT_CURRENT_DIR=IS_WIN || IS_VMS || IS_MAC;my@PATHEXT=('');if (IS_WIN){if ($ENV{PATHEXT}){push@PATHEXT,split ';',$ENV{PATHEXT}}else {push@PATHEXT,qw{.com .exe .bat}}}elsif (IS_VMS){push@PATHEXT,qw{.exe .com}}elsif (IS_CYG){push@PATHEXT,qw{.exe .com}}sub which {my ($exec)=@_;return undef unless defined$exec;return undef if$exec eq '';my$all=wantarray;my@results=();if (IS_VMS){my$symbol=`SHOW SYMBOL $exec`;chomp($symbol);unless ($?){return$symbol unless$all;push@results,$symbol}}if (IS_MAC){my@aliases=split /\,/,$ENV{Aliases};for my$alias (@aliases){if (lc($alias)eq lc($exec)){chomp(my$file=`Alias $alias`);last unless$file;return$file unless$all;push@results,$file;last}}}return$exec if!IS_VMS and!IS_MAC and!IS_WIN and $exec =~ /\// and -f $exec and -x $exec;my@path;if($^O eq 'MSWin32'){@path=split(';',$ENV{PATH});s/"//g for@path;@path=grep length,@path}else {@path=File::Spec->path}if ($IMPLICIT_CURRENT_DIR){unshift@path,File::Spec->curdir}for my$base (map {File::Spec->catfile($_,$exec)}@path){for my$ext (@PATHEXT){my$file=$base.$ext;next if -d $file;if (-x _ or (IS_MAC || ((IS_WIN or IS_CYG)and grep {$file =~ /$_\z/i}@PATHEXT[1..$#PATHEXT])and -e _)){return$file unless$all;push@results,$file}}}if ($all){return@results}else {return undef}}sub where {my@res=which($_[0]);return@res}1;
FILE_WHICH

$fatpacked{"File/pushd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PUSHD';
  use strict;use warnings;package File::pushd;our$VERSION='1.016';our@EXPORT=qw(pushd tempd);our@ISA=qw(Exporter);use Exporter;use Carp;use Cwd qw(getcwd abs_path);use File::Path qw(rmtree);use File::Temp qw();use File::Spec;use overload q{""}=>sub {File::Spec->canonpath($_[0]->{_pushd})},fallback=>1;sub pushd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::pushd in void context');return}my ($target_dir,$options)=@_;$options->{untaint_pattern}||= qr{^([-+@\w./]+)$};$target_dir="." unless defined$target_dir;croak "Can't locate directory $target_dir" unless -d $target_dir;my$tainted_orig=getcwd;my$orig;if ($tainted_orig =~ $options->{untaint_pattern}){$orig=$1}else {$orig=$tainted_orig}my$tainted_dest;eval {$tainted_dest=$target_dir ? abs_path($target_dir): $orig};croak "Can't locate absolute path for $target_dir: $@" if $@;my$dest;if ($tainted_dest =~ $options->{untaint_pattern}){$dest=$1}else {$dest=$tainted_dest}if ($dest ne $orig){chdir$dest or croak "Can't chdir to $dest\: $!"}my$self=bless {_pushd=>$dest,_original=>$orig },__PACKAGE__;return$self}sub tempd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::tempd in void context');return}my ($options)=@_;my$dir;eval {$dir=pushd(File::Temp::tempdir(CLEANUP=>0),$options)};croak $@ if $@;$dir->{_tempd}=1;$dir->{_owner}=$$;return$dir}sub preserve {my$self=shift;return 1 if!$self->{"_tempd"};if (@_==0){return$self->{_preserve}=1}else {return$self->{_preserve}=$_[0]? 1 : 0}}sub DESTROY {my ($self)=@_;my$orig=$self->{_original};chdir$orig if$orig;if ($self->{_tempd}&& $self->{_owner}==$$ &&!$self->{_preserve}){my$err=do {local $@;eval {rmtree($self->{_pushd})};$@};carp$err if$err}}1;
FILE_PUSHD

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  use 5.004;use strict;use warnings;package Getopt::Long;use vars qw($VERSION);$VERSION=2.51;use vars qw($VERSION_STRING);$VERSION_STRING="2.51";use Exporter;use vars qw(@ISA @EXPORT @EXPORT_OK);@ISA=qw(Exporter);sub GetOptions(@);sub GetOptionsFromArray(@);sub GetOptionsFromString(@);sub Configure(@);sub HelpMessage(@);sub VersionMessage(@);BEGIN {@EXPORT=qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);@EXPORT_OK=qw(&HelpMessage &VersionMessage &Configure &GetOptionsFromArray &GetOptionsFromString)}use vars@EXPORT,@EXPORT_OK;use vars qw($error $debug $major_version $minor_version);use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order $passthrough);use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);my$bundling_values;sub config(@);sub ConfigDefaults();sub ParseOptionSpec($$);sub OptCtl($);sub FindOption($$$$$);sub ValidValue ($$$$$);my$requested_version=0;sub ConfigDefaults() {if (defined$ENV{"POSIXLY_CORRECT"}){$genprefix="(--|-)";$autoabbrev=0;$bundling=0;$getopt_compat=0;$order=$REQUIRE_ORDER}else {$genprefix="(--|-|\\+)";$autoabbrev=1;$bundling=0;$getopt_compat=1;$order=$PERMUTE}$debug=0;$error=0;$ignorecase=1;$passthrough=0;$gnu_compat=0;$longprefix="(--)";$bundling_values=0}sub import {my$pkg=shift;my@syms=();my@config=();my$dest=\@syms;for (@_){if ($_ eq ':config'){$dest=\@config;next}push(@$dest,$_)}local$Exporter::ExportLevel=1;push(@syms,qw(&GetOptions))if@syms;$requested_version=0;$pkg->SUPER::import(@syms);Configure(@config)if@config}($REQUIRE_ORDER,$PERMUTE,$RETURN_IN_ORDER)=(0..2);($major_version,$minor_version)=$VERSION =~ /^(\d+)\.(\d+)/;ConfigDefaults();package Getopt::Long::Parser;my$default_config=do {Getopt::Long::Configure ()};sub new {my$that=shift;my$class=ref($that)|| $that;my%atts=@_;my$self={caller_pkg=>(caller)[0]};bless ($self,$class);if (defined$atts{config}){my$save=Getopt::Long::Configure ($default_config,@{$atts{config}});$self->{settings}=Getopt::Long::Configure ($save);delete ($atts{config})}else {$self->{settings}=$default_config}if (%atts){die(__PACKAGE__.": unhandled attributes: ".join(" ",sort(keys(%atts)))."\n")}$self}sub configure {my ($self)=shift;my$save=Getopt::Long::Configure ($self->{settings},@_);$self->{settings}=Getopt::Long::Configure ($save)}sub getoptions {my ($self)=shift;return$self->getoptionsfromarray(\@ARGV,@_)}sub getoptionsfromarray {my ($self)=shift;my$save=Getopt::Long::Configure ($self->{settings});my$ret=0;$Getopt::Long::caller=$self->{caller_pkg};eval {local ($SIG{__DIE__})='DEFAULT';$ret=Getopt::Long::GetOptionsFromArray (@_)};Getopt::Long::Configure ($save);die ($@)if $@;return$ret}package Getopt::Long;use constant CTL_TYPE=>0;use constant CTL_CNAME=>1;use constant CTL_DEFAULT=>2;use constant CTL_DEST=>3;use constant CTL_DEST_SCALAR=>0;use constant CTL_DEST_ARRAY=>1;use constant CTL_DEST_HASH=>2;use constant CTL_DEST_CODE=>3;use constant CTL_AMIN=>4;use constant CTL_AMAX=>5;use constant PAT_INT=>"[-+]?_*[0-9][0-9_]*";use constant PAT_XINT=>"(?:"."[-+]?_*[1-9][0-9_]*"."|"."0x_*[0-9a-f][0-9a-f_]*"."|"."0b_*[01][01_]*"."|"."0[0-7_]*".")";use constant PAT_FLOAT=>"[-+]?"."(?=[0-9.])"."[0-9_]*"."(\.[0-9_]+)?"."([eE][-+]?[0-9_]+)?";sub GetOptions(@) {unshift(@_,\@ARGV);goto&GetOptionsFromArray}sub GetOptionsFromString(@) {my ($string)=shift;require Text::ParseWords;my$args=[Text::ParseWords::shellwords($string)];$caller ||= (caller)[0];my$ret=GetOptionsFromArray($args,@_);return ($ret,$args)if wantarray;if (@$args){$ret=0;warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n")}$ret}sub GetOptionsFromArray(@) {my ($argv,@optionlist)=@_;my$argend='--';my%opctl=();my$pkg=$caller || (caller)[0];my@ret=();my%linkage;my$userlinkage;my$opt;my$prefix=$genprefix;$error='';if ($debug){local ($^W)=0;print STDERR ("Getopt::Long $Getopt::Long::VERSION_STRING ","called from package \"$pkg\".","\n  ","argv: ",defined($argv)? UNIVERSAL::isa($argv,'ARRAY')? "(@$argv)" : $argv : "<undef>","\n  ","autoabbrev=$autoabbrev,"."bundling=$bundling,","bundling_values=$bundling_values,","getopt_compat=$getopt_compat,","gnu_compat=$gnu_compat,","order=$order,","\n  ","ignorecase=$ignorecase,","requested_version=$requested_version,","passthrough=$passthrough,","genprefix=\"$genprefix\",","longprefix=\"$longprefix\".","\n")}$userlinkage=undef;if (@optionlist && ref($optionlist[0])and UNIVERSAL::isa($optionlist[0],'HASH')){$userlinkage=shift (@optionlist);print STDERR ("=> user linkage: $userlinkage\n")if$debug}if (@optionlist && $optionlist[0]=~ /^\W+$/ &&!($optionlist[0]eq '<>' && @optionlist > 0 && ref($optionlist[1]))){$prefix=shift (@optionlist);$prefix =~ s/(\W)/\\$1/g;$prefix="([" .$prefix ."])";print STDERR ("=> prefix=\"$prefix\"\n")if$debug}%opctl=();while (@optionlist){my$opt=shift (@optionlist);unless (defined($opt)){$error .= "Undefined argument in option spec\n";next}$opt=$+ if$opt =~ /^$prefix+(.*)$/s;if ($opt eq '<>'){if ((defined$userlinkage)&&!(@optionlist > 0 && ref($optionlist[0]))&& (exists$userlinkage->{$opt})&& ref($userlinkage->{$opt})){unshift (@optionlist,$userlinkage->{$opt})}unless (@optionlist > 0 && ref($optionlist[0])&& ref($optionlist[0])eq 'CODE'){$error .= "Option spec <> requires a reference to a subroutine\n";shift (@optionlist)if@optionlist && ref($optionlist[0]);next}$linkage{'<>'}=shift (@optionlist);next}my ($name,$orig)=ParseOptionSpec ($opt,\%opctl);unless (defined$name){$error .= $orig;shift (@optionlist)if@optionlist && ref($optionlist[0]);next}if (defined$userlinkage){unless (@optionlist > 0 && ref($optionlist[0])){if (exists$userlinkage->{$orig}&& ref($userlinkage->{$orig})){print STDERR ("=> found userlinkage for \"$orig\": ","$userlinkage->{$orig}\n")if$debug;unshift (@optionlist,$userlinkage->{$orig})}else {next}}}if (@optionlist > 0 && ref($optionlist[0])){print STDERR ("=> link \"$orig\" to $optionlist[0]\n")if$debug;my$rl=ref($linkage{$orig}=shift (@optionlist));if ($rl eq "ARRAY"){$opctl{$name}[CTL_DEST]=CTL_DEST_ARRAY}elsif ($rl eq "HASH"){$opctl{$name}[CTL_DEST]=CTL_DEST_HASH}elsif ($rl eq "SCALAR" || $rl eq "REF"){}elsif ($rl eq "CODE"){}else {$error .= "Invalid option linkage for \"$opt\"\n"}}else {my$ov=$orig;$ov =~ s/\W/_/g;if ($opctl{$name}[CTL_DEST]==CTL_DEST_ARRAY){print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;")}elsif ($opctl{$name}[CTL_DEST]==CTL_DEST_HASH){print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;")}else {print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")if$debug;eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;")}}if ($opctl{$name}[CTL_TYPE]eq 'I' && ($opctl{$name}[CTL_DEST]==CTL_DEST_ARRAY || $opctl{$name}[CTL_DEST]==CTL_DEST_HASH)){$error .= "Invalid option linkage for \"$opt\"\n"}}$error .= "GetOptionsFromArray: 1st parameter is not an array reference\n" unless$argv && UNIVERSAL::isa($argv,'ARRAY');die ($error)if$error;$error=0;if (defined($auto_version)? $auto_version : ($requested_version >= 2.3203)){if (!defined($opctl{version})){$opctl{version}=['','version',0,CTL_DEST_CODE,undef];$linkage{version}=\&VersionMessage}$auto_version=1}if (defined($auto_help)? $auto_help : ($requested_version >= 2.3203)){if (!defined($opctl{help})&&!defined($opctl{'?'})){$opctl{help}=$opctl{'?'}=['','help',0,CTL_DEST_CODE,undef];$linkage{help}=\&HelpMessage}$auto_help=1}if ($debug){my ($arrow,$k,$v);$arrow="=> ";while (($k,$v)=each(%opctl)){print STDERR ($arrow,"\$opctl{$k} = $v ",OptCtl($v),"\n");$arrow="   "}}my$goon=1;while ($goon && @$argv > 0){$opt=shift (@$argv);print STDERR ("=> arg \"",$opt,"\"\n")if$debug;if (defined($opt)&& $opt eq $argend){push (@ret,$argend)if$passthrough;last}my$tryopt=$opt;my$found;my$key;my$arg;my$ctl;($found,$opt,$ctl,$arg,$key)=FindOption ($argv,$prefix,$argend,$opt,\%opctl);if ($found){next unless defined$opt;my$argcnt=0;while (defined$arg){print STDERR ("=> cname for \"$opt\" is ")if$debug;$opt=$ctl->[CTL_CNAME];print STDERR ("\"$ctl->[CTL_CNAME]\"\n")if$debug;if (defined$linkage{$opt}){print STDERR ("=> ref(\$L{$opt}) -> ",ref($linkage{$opt}),"\n")if$debug;if (ref($linkage{$opt})eq 'SCALAR' || ref($linkage{$opt})eq 'REF'){if ($ctl->[CTL_TYPE]eq '+'){print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")if$debug;if (defined ${$linkage{$opt}}){${$linkage{$opt}}+= $arg}else {${$linkage{$opt}}=$arg}}elsif ($ctl->[CTL_DEST]==CTL_DEST_ARRAY){print STDERR ("=> ref(\$L{$opt}) auto-vivified"," to ARRAY\n")if$debug;my$t=$linkage{$opt};$$t=$linkage{$opt}=[];print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")if$debug;push (@{$linkage{$opt}},$arg)}elsif ($ctl->[CTL_DEST]==CTL_DEST_HASH){print STDERR ("=> ref(\$L{$opt}) auto-vivified"," to HASH\n")if$debug;my$t=$linkage{$opt};$$t=$linkage{$opt}={};print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")if$debug;$linkage{$opt}->{$key}=$arg}else {print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")if$debug;${$linkage{$opt}}=$arg}}elsif (ref($linkage{$opt})eq 'ARRAY'){print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")if$debug;push (@{$linkage{$opt}},$arg)}elsif (ref($linkage{$opt})eq 'HASH'){print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")if$debug;$linkage{$opt}->{$key}=$arg}elsif (ref($linkage{$opt})eq 'CODE'){print STDERR ("=> &L{$opt}(\"$opt\"",$ctl->[CTL_DEST]==CTL_DEST_HASH ? ", \"$key\"" : "",", \"$arg\")\n")if$debug;my$eval_error=do {local $@;local$SIG{__DIE__}='DEFAULT';eval {&{$linkage{$opt}}(Getopt::Long::CallBack->new (name=>$opt,ctl=>$ctl,opctl=>\%opctl,linkage=>\%linkage,prefix=>$prefix,),$ctl->[CTL_DEST]==CTL_DEST_HASH ? ($key): (),$arg)};$@};print STDERR ("=> die($eval_error)\n")if$debug && $eval_error ne '';if ($eval_error =~ /^!/){if ($eval_error =~ /^!FINISH\b/){$goon=0}}elsif ($eval_error ne ''){warn ($eval_error);$error++}}else {print STDERR ("Invalid REF type \"",ref($linkage{$opt}),"\" in linkage\n");die("Getopt::Long -- internal error!\n")}}elsif ($ctl->[CTL_DEST]==CTL_DEST_ARRAY){if (defined$userlinkage->{$opt}){print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")if$debug;push (@{$userlinkage->{$opt}},$arg)}else {print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")if$debug;$userlinkage->{$opt}=[$arg]}}elsif ($ctl->[CTL_DEST]==CTL_DEST_HASH){if (defined$userlinkage->{$opt}){print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")if$debug;$userlinkage->{$opt}->{$key}=$arg}else {print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")if$debug;$userlinkage->{$opt}={$key=>$arg}}}else {if ($ctl->[CTL_TYPE]eq '+'){print STDERR ("=> \$L{$opt} += \"$arg\"\n")if$debug;if (defined$userlinkage->{$opt}){$userlinkage->{$opt}+= $arg}else {$userlinkage->{$opt}=$arg}}else {print STDERR ("=>\$L{$opt} = \"$arg\"\n")if$debug;$userlinkage->{$opt}=$arg}}$argcnt++;last if$argcnt >= $ctl->[CTL_AMAX]&& $ctl->[CTL_AMAX]!=-1;undef($arg);if ($argcnt < $ctl->[CTL_AMIN]){if (@$argv){if (ValidValue($ctl,$argv->[0],1,$argend,$prefix)){$arg=shift(@$argv);if ($ctl->[CTL_TYPE]=~ /^[iIo]$/){$arg =~ tr/_//d;$arg=$ctl->[CTL_TYPE]eq 'o' && $arg =~ /^0/ ? oct($arg): 0+$arg}($key,$arg)=$arg =~ /^([^=]+)=(.*)/ if$ctl->[CTL_DEST]==CTL_DEST_HASH;next}warn("Value \"$$argv[0]\" invalid for option $opt\n");$error++}else {warn("Insufficient arguments for option $opt\n");$error++}}if (@$argv && ValidValue($ctl,$argv->[0],0,$argend,$prefix)){$arg=shift(@$argv);if ($ctl->[CTL_TYPE]=~ /^[iIo]$/){$arg =~ tr/_//d;$arg=$ctl->[CTL_TYPE]eq 'o' && $arg =~ /^0/ ? oct($arg): 0+$arg}($key,$arg)=$arg =~ /^([^=]+)=(.*)/ if$ctl->[CTL_DEST]==CTL_DEST_HASH;next}}}elsif ($order==$PERMUTE){my$cb;if (defined ($cb=$linkage{'<>'})){print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")if$debug;my$eval_error=do {local $@;local$SIG{__DIE__}='DEFAULT';eval {&$cb($tryopt)};$@};print STDERR ("=> die($eval_error)\n")if$debug && $eval_error ne '';if ($eval_error =~ /^!/){if ($eval_error =~ /^!FINISH\b/){$goon=0}}elsif ($eval_error ne ''){warn ($eval_error);$error++}}else {print STDERR ("=> saving \"$tryopt\" ","(not an option, may permute)\n")if$debug;push (@ret,$tryopt)}next}else {unshift (@$argv,$tryopt);return ($error==0)}}if (@ret && ($order==$PERMUTE || $passthrough)){print STDERR ("=> restoring \"",join('" "',@ret),"\"\n")if$debug;unshift (@$argv,@ret)}return ($error==0)}sub OptCtl ($) {my ($v)=@_;my@v=map {defined($_)? ($_): ("<undef>")}@$v;"[".join(",","\"$v[CTL_TYPE]\"","\"$v[CTL_CNAME]\"","\"$v[CTL_DEFAULT]\"",("\$","\@","\%","\&")[$v[CTL_DEST]|| 0],$v[CTL_AMIN]|| '',$v[CTL_AMAX]|| '',)."]"}sub ParseOptionSpec ($$) {my ($opt,$opctl)=@_;if ($opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Aliases
  		     (?: \| (?: . [^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x){return (undef,"Error in option spec: \"$opt\"\n")}my ($names,$spec)=($1,$2);$spec='' unless defined$spec;my$orig;my@names;if (defined$names){@names=split (/\|/,$names);$orig=$names[0]}else {@names=('');$orig=''}my$entry;if ($spec eq '' || $spec eq '+' || $spec eq '!'){$entry=[$spec,$orig,undef,CTL_DEST_SCALAR,0,0]}elsif ($spec =~ /^:(-?\d+|\+)([@%])?$/){my$def=$1;my$dest=$2;my$type=$def eq '+' ? 'I' : 'i';$dest ||= '$';$dest=$dest eq '@' ? CTL_DEST_ARRAY : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;$entry=[$type,$orig,$def eq '+' ? undef : $def,$dest,0,1]}else {my ($mand,$type,$dest)=$spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;return (undef,"Cannot repeat while bundling: \"$opt\"\n")if$bundling && defined($4);my ($mi,$cm,$ma)=($5,$6,$7);return (undef,"{0} is useless in option spec: \"$opt\"\n")if defined($mi)&&!$mi &&!defined($ma)&&!defined($cm);$type='i' if$type eq 'n';$dest ||= '$';$dest=$dest eq '@' ? CTL_DEST_ARRAY : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;$mi=$mand eq '=' ? 1 : 0 unless defined$mi;$mand=$mi ? '=' : ':';$ma=$mi ? $mi : 1 unless defined$ma || defined$cm;return (undef,"Max must be greater than zero in option spec: \"$opt\"\n")if defined($ma)&&!$ma;return (undef,"Max less than min in option spec: \"$opt\"\n")if defined($ma)&& $ma < $mi;$entry=[$type,$orig,undef,$dest,$mi,$ma||-1]}my$dups='';for (@names){$_=lc ($_)if$ignorecase > (($bundling && length($_)==1)? 1 : 0);if (exists$opctl->{$_}){$dups .= "Duplicate specification \"$opt\" for option \"$_\"\n"}if ($spec eq '!'){$opctl->{"no$_"}=$entry;$opctl->{"no-$_"}=$entry;$opctl->{$_}=[@$entry];$opctl->{$_}->[CTL_TYPE]=''}else {$opctl->{$_}=$entry}}if ($dups && $^W){for (split(/\n+/,$dups)){warn($_."\n")}}($names[0],$orig)}sub FindOption ($$$$$) {my ($argv,$prefix,$argend,$opt,$opctl)=@_;print STDERR ("=> find \"$opt\"\n")if$debug;return (0)unless defined($opt);return (0)unless$opt =~ /^($prefix)(.*)$/s;return (0)if$opt eq "-" &&!defined$opctl->{''};$opt=substr($opt,length($1));my$starter=$1;print STDERR ("=> split \"$starter\"+\"$opt\"\n")if$debug;my$optarg;my$rest;if (($starter=~/^$longprefix$/ || ($getopt_compat && ($bundling==0 || $bundling==2)))&& (my$oppos=index($opt,'=',1))> 0){my$optorg=$opt;$opt=substr($optorg,0,$oppos);$optarg=substr($optorg,$oppos + 1);print STDERR ("=> option \"",$opt,"\", optarg = \"$optarg\"\n")if$debug}my$tryopt=$opt;if (($bundling || $bundling_values)&& $starter eq '-'){$tryopt=$ignorecase ? lc($opt): $opt;if ($bundling==2 && length($tryopt)> 1 && defined ($opctl->{$tryopt})){print STDERR ("=> $starter$tryopt overrides unbundling\n")if$debug}elsif ($bundling_values){$tryopt=$opt;$rest=length ($tryopt)> 0 ? substr ($tryopt,1): '';$tryopt=substr ($tryopt,0,1);$tryopt=lc ($tryopt)if$ignorecase > 1;print STDERR ("=> $starter$tryopt unbundled from ","$starter$tryopt$rest\n")if$debug;$optarg=$rest eq '' ? undef : $rest;$rest=undef}else {$tryopt=$opt;$rest=length ($tryopt)> 0 ? substr ($tryopt,1): '';$tryopt=substr ($tryopt,0,1);$tryopt=lc ($tryopt)if$ignorecase > 1;print STDERR ("=> $starter$tryopt unbundled from ","$starter$tryopt$rest\n")if$debug;$rest=undef unless$rest ne ''}}elsif ($autoabbrev && $opt ne ""){my@names=sort(keys (%$opctl));$opt=lc ($opt)if$ignorecase;$tryopt=$opt;my$pat=quotemeta ($opt);my@hits=grep (/^$pat/,@names);print STDERR ("=> ",scalar(@hits)," hits (@hits) with \"$pat\" ","out of ",scalar(@names),"\n")if$debug;unless ((@hits <= 1)|| (grep ($_ eq $opt,@hits)==1)){my%hit;for (@hits){my$hit=$opctl->{$_}->[CTL_CNAME]if defined$opctl->{$_}->[CTL_CNAME];$hit="no" .$hit if$opctl->{$_}->[CTL_TYPE]eq '!';$hit{$hit}=1}if (keys(%hit)==2){if ($auto_version && exists($hit{version})){delete$hit{version}}elsif ($auto_help && exists($hit{help})){delete$hit{help}}}unless (keys(%hit)==1){return (0)if$passthrough;warn ("Option ",$opt," is ambiguous (",join(", ",@hits),")\n");$error++;return (1,undef)}@hits=keys(%hit)}if (@hits==1 && $hits[0]ne $opt){$tryopt=$hits[0];$tryopt=lc ($tryopt)if$ignorecase > (($bundling && length($tryopt)==1)? 1 : 0);print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")if$debug}}elsif ($ignorecase){$tryopt=lc ($opt)}my$ctl=$opctl->{$tryopt};unless (defined$ctl){return (0)if$passthrough;if ($bundling==1 && length($starter)==1){$opt=substr($opt,0,1);unshift (@$argv,$starter.$rest)if defined$rest}if ($opt eq ""){warn ("Missing option after ",$starter,"\n")}else {warn ("Unknown option: ",$opt,"\n")}$error++;return (1,undef)}$opt=$tryopt;print STDERR ("=> found ",OptCtl($ctl)," for \"",$opt,"\"\n")if$debug;my$type=$ctl->[CTL_TYPE];my$arg;if ($type eq '' || $type eq '!' || $type eq '+'){if (defined$optarg){return (0)if$passthrough;warn ("Option ",$opt," does not take an argument\n");$error++;undef$opt;undef$optarg if$bundling_values}elsif ($type eq '' || $type eq '+'){$arg=1}else {$opt =~ s/^no-?//i;$arg=0}unshift (@$argv,$starter.$rest)if defined$rest;return (1,$opt,$ctl,$arg)}my$mand=$ctl->[CTL_AMIN];if ($gnu_compat){my$optargtype=0;if (defined($optarg)){$optargtype=(length($optarg)==0)? 1 : 2}elsif (defined$rest || @$argv > 0){$optargtype=3}if(($optargtype==0)&&!$mand){if ($type eq 'I'){my@c=@$ctl;$c[CTL_TYPE]='+';return (1,$opt,\@c,1)}my$val =defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: $type eq 's' ? '' : 0;return (1,$opt,$ctl,$val)}return (1,$opt,$ctl,$type eq 's' ? '' : 0)if$optargtype==1}if (defined$optarg ? ($optarg eq ''):!(defined$rest || @$argv > 0)){if ($mand){return (0)if$passthrough;warn ("Option ",$opt," requires an argument\n");$error++;return (1,undef)}if ($type eq 'I'){my@c=@$ctl;$c[CTL_TYPE]='+';return (1,$opt,\@c,1)}return (1,$opt,$ctl,defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: $type eq 's' ? '' : 0)}$arg=(defined$rest ? $rest : (defined$optarg ? $optarg : shift (@$argv)));my$key;if ($ctl->[CTL_DEST]==CTL_DEST_HASH && defined$arg){($key,$arg)=($arg =~ /^([^=]*)=(.*)$/s)? ($1,$2): ($arg,defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: ($mand ? undef : ($type eq 's' ? "" : 1)));if (!defined$arg){warn ("Option $opt, key \"$key\", requires a value\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}}my$key_valid=$ctl->[CTL_DEST]==CTL_DEST_HASH ? "[^=]+=" : "";if ($type eq 's'){return (1,$opt,$ctl,$arg,$key)if$mand;return (1,$opt,$ctl,$arg,$key)if$ctl->[CTL_DEST]==CTL_DEST_HASH;return (1,$opt,$ctl,$arg,$key)if defined$optarg || defined$rest;return (1,$opt,$ctl,$arg,$key)if$arg eq "-";if ($arg eq $argend || $arg =~ /^$prefix.+/){unshift (@$argv,$arg);$arg=''}}elsif ($type eq 'i' || $type eq 'I' || $type eq 'o'){my$o_valid=$type eq 'o' ? PAT_XINT : PAT_INT;if ($bundling && defined$rest && $rest =~ /^($key_valid)($o_valid)(.*)$/si){($key,$arg,$rest)=($1,$2,$+);chop($key)if$key;$arg=($type eq 'o' && $arg =~ /^0/)? oct($arg): 0+$arg;unshift (@$argv,$starter.$rest)if defined$rest && $rest ne ''}elsif ($arg =~ /^$o_valid$/si){$arg =~ tr/_//d;$arg=($type eq 'o' && $arg =~ /^0/)? oct($arg): 0+$arg}else {if (defined$optarg || $mand){if ($passthrough){unshift (@$argv,defined$rest ? $starter.$rest : $arg)unless defined$optarg;return (0)}warn ("Value \"",$arg,"\" invalid for option ",$opt," (",$type eq 'o' ? "extended " : '',"number expected)\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}else {unshift (@$argv,defined$rest ? $starter.$rest : $arg);if ($type eq 'I'){my@c=@$ctl;$c[CTL_TYPE]='+';return (1,$opt,\@c,1)}$arg=defined($ctl->[CTL_DEFAULT])? $ctl->[CTL_DEFAULT]: 0}}}elsif ($type eq 'f'){my$o_valid=PAT_FLOAT;if ($bundling && defined$rest && $rest =~ /^($key_valid)($o_valid)(.*)$/s){$arg =~ tr/_//d;($key,$arg,$rest)=($1,$2,$+);chop($key)if$key;unshift (@$argv,$starter.$rest)if defined$rest && $rest ne ''}elsif ($arg =~ /^$o_valid$/){$arg =~ tr/_//d}else {if (defined$optarg || $mand){if ($passthrough){unshift (@$argv,defined$rest ? $starter.$rest : $arg)unless defined$optarg;return (0)}warn ("Value \"",$arg,"\" invalid for option ",$opt," (real number expected)\n");$error++;unshift (@$argv,$starter.$rest)if defined$rest;return (1,undef)}else {unshift (@$argv,defined$rest ? $starter.$rest : $arg);$arg=0.0}}}else {die("Getopt::Long internal error (Can't happen)\n")}return (1,$opt,$ctl,$arg,$key)}sub ValidValue ($$$$$) {my ($ctl,$arg,$mand,$argend,$prefix)=@_;if ($ctl->[CTL_DEST]==CTL_DEST_HASH){return 0 unless$arg =~ /[^=]+=(.*)/;$arg=$1}my$type=$ctl->[CTL_TYPE];if ($type eq 's'){return (1)if$mand;return (1)if$arg eq "-";return 0 if$arg eq $argend || $arg =~ /^$prefix.+/;return 1}elsif ($type eq 'i' || $type eq 'I' || $type eq 'o'){my$o_valid=$type eq 'o' ? PAT_XINT : PAT_INT;return$arg =~ /^$o_valid$/si}elsif ($type eq 'f'){my$o_valid=PAT_FLOAT;return$arg =~ /^$o_valid$/}die("ValidValue: Cannot happen\n")}sub Configure (@) {my (@options)=@_;my$prevconfig=[$error,$debug,$major_version,$minor_version,$caller,$autoabbrev,$getopt_compat,$ignorecase,$bundling,$order,$gnu_compat,$passthrough,$genprefix,$auto_version,$auto_help,$longprefix,$bundling_values ];if (ref($options[0])eq 'ARRAY'){($error,$debug,$major_version,$minor_version,$caller,$autoabbrev,$getopt_compat,$ignorecase,$bundling,$order,$gnu_compat,$passthrough,$genprefix,$auto_version,$auto_help,$longprefix,$bundling_values)=@{shift(@options)}}my$opt;for$opt (@options){my$try=lc ($opt);my$action=1;if ($try =~ /^no_?(.*)$/s){$action=0;$try=$+}if (($try eq 'default' or $try eq 'defaults')&& $action){ConfigDefaults ()}elsif (($try eq 'posix_default' or $try eq 'posix_defaults')){local$ENV{POSIXLY_CORRECT};$ENV{POSIXLY_CORRECT}=1 if$action;ConfigDefaults ()}elsif ($try eq 'auto_abbrev' or $try eq 'autoabbrev'){$autoabbrev=$action}elsif ($try eq 'getopt_compat'){$getopt_compat=$action;$genprefix=$action ? "(--|-|\\+)" : "(--|-)"}elsif ($try eq 'gnu_getopt'){if ($action){$gnu_compat=1;$bundling=1;$getopt_compat=0;$genprefix="(--|-)";$order=$PERMUTE;$bundling_values=0}}elsif ($try eq 'gnu_compat'){$gnu_compat=$action;$bundling=0;$bundling_values=1}elsif ($try =~ /^(auto_?)?version$/){$auto_version=$action}elsif ($try =~ /^(auto_?)?help$/){$auto_help=$action}elsif ($try eq 'ignorecase' or $try eq 'ignore_case'){$ignorecase=$action}elsif ($try eq 'ignorecase_always' or $try eq 'ignore_case_always'){$ignorecase=$action ? 2 : 0}elsif ($try eq 'bundling'){$bundling=$action;$bundling_values=0 if$action}elsif ($try eq 'bundling_override'){$bundling=$action ? 2 : 0;$bundling_values=0 if$action}elsif ($try eq 'bundling_values'){$bundling_values=$action;$bundling=0 if$action}elsif ($try eq 'require_order'){$order=$action ? $REQUIRE_ORDER : $PERMUTE}elsif ($try eq 'permute'){$order=$action ? $PERMUTE : $REQUIRE_ORDER}elsif ($try eq 'pass_through' or $try eq 'passthrough'){$passthrough=$action}elsif ($try =~ /^prefix=(.+)$/ && $action){$genprefix=$1;$genprefix="(" .quotemeta($genprefix).")";eval {'' =~ /$genprefix/};die("Getopt::Long: invalid pattern \"$genprefix\"\n")if $@}elsif ($try =~ /^prefix_pattern=(.+)$/ && $action){$genprefix=$1;$genprefix="(" .$genprefix .")" unless$genprefix =~ /^\(.*\)$/;eval {'' =~ m"$genprefix"};die("Getopt::Long: invalid pattern \"$genprefix\"\n")if $@}elsif ($try =~ /^long_prefix_pattern=(.+)$/ && $action){$longprefix=$1;$longprefix="(" .$longprefix .")" unless$longprefix =~ /^\(.*\)$/;eval {'' =~ m"$longprefix"};die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n")if $@}elsif ($try eq 'debug'){$debug=$action}else {die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")}}$prevconfig}sub config (@) {Configure (@_)}sub VersionMessage(@) {my$pa=setup_pa_args("version",@_);my$v=$main::VERSION;my$fh=$pa->{-output}|| (($pa->{-exitval}eq "NOEXIT" || $pa->{-exitval}< 2)? \*STDOUT : \*STDERR);print$fh (defined($pa->{-message})? $pa->{-message}: (),$0,defined$v ? " version $v" : (),"\n","(",__PACKAGE__,"::","GetOptions"," version ",defined($Getopt::Long::VERSION_STRING)? $Getopt::Long::VERSION_STRING : $VERSION,";"," Perl version ",$] >= 5.006 ? sprintf("%vd",$^V): $],")\n");exit($pa->{-exitval})unless$pa->{-exitval}eq "NOEXIT"}sub HelpMessage(@) {eval {require Pod::Usage;import Pod::Usage;1}|| die("Cannot provide help: cannot load Pod::Usage\n");pod2usage(setup_pa_args("help",@_))}sub setup_pa_args($@) {my$tag=shift;@_=()if @_==2 && $_[0]eq $tag;my$pa;if (@_ > 1){$pa={@_ }}else {$pa=shift || {}}if (UNIVERSAL::isa($pa,'HASH')){$pa->{-message}=$pa->{-msg};delete($pa->{-msg})}elsif ($pa =~ /^-?\d+$/){$pa={-exitval=>$pa }}else {$pa={-message=>$pa }}$pa->{-verbose}=0 unless exists($pa->{-verbose});$pa->{-exitval}=0 unless exists($pa->{-exitval});$pa}sub VERSION {$requested_version=$_[1]if @_ > 1;shift->SUPER::VERSION(@_)}package Getopt::Long::CallBack;sub new {my ($pkg,%atts)=@_;bless {%atts },$pkg}sub name {my$self=shift;''.$self->{name}}use overload '""'=>\&name,fallback=>1;1;
GETOPT_LONG

$fatpacked{"HTTP/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINY';
  package HTTP::Tiny;use strict;use warnings;our$VERSION='0.076';sub _croak {require Carp;Carp::croak(@_)}my@attributes;BEGIN {@attributes=qw(cookie_jar default_headers http_proxy https_proxy keep_alive local_address max_redirect max_size proxy no_proxy SSL_options verify_SSL);my%persist_ok=map {;$_=>1}qw(cookie_jar default_headers max_redirect max_size);no strict 'refs';no warnings 'uninitialized';for my$accessor (@attributes){*{$accessor}=sub {@_ > 1 ? do {delete $_[0]->{handle}if!$persist_ok{$accessor}&& $_[1]ne $_[0]->{$accessor};$_[0]->{$accessor}=$_[1]}: $_[0]->{$accessor}}}}sub agent {my($self,$agent)=@_;if(@_ > 1){$self->{agent}=(defined$agent && $agent =~ / $/)? $agent .$self->_agent : $agent}return$self->{agent}}sub timeout {my ($self,$timeout)=@_;if (@_ > 1){$self->{timeout}=$timeout;if ($self->{handle}){$self->{handle}->timeout($timeout)}}return$self->{timeout}}sub new {my($class,%args)=@_;my$self={max_redirect=>5,timeout=>defined$args{timeout}? $args{timeout}: 60,keep_alive=>1,verify_SSL=>$args{verify_SSL}|| $args{verify_ssl}|| 0,no_proxy=>$ENV{no_proxy},};bless$self,$class;$class->_validate_cookie_jar($args{cookie_jar})if$args{cookie_jar};for my$key (@attributes){$self->{$key}=$args{$key}if exists$args{$key}}$self->agent(exists$args{agent}? $args{agent}: $class->_agent);$self->_set_proxies;return$self}sub _set_proxies {my ($self)=@_;if (!exists$self->{proxy}){$self->{proxy}=$ENV{all_proxy}|| $ENV{ALL_PROXY}}if (defined$self->{proxy}){$self->_split_proxy('generic proxy'=>$self->{proxy})}else {delete$self->{proxy}}if (!exists$self->{http_proxy}){local$ENV{HTTP_PROXY}if$ENV{REQUEST_METHOD};$self->{http_proxy}=$ENV{http_proxy}|| $ENV{HTTP_PROXY}|| $self->{proxy}}if (defined$self->{http_proxy}){$self->_split_proxy(http_proxy=>$self->{http_proxy});$self->{_has_proxy}{http}=1}else {delete$self->{http_proxy}}if (!exists$self->{https_proxy}){$self->{https_proxy}=$ENV{https_proxy}|| $ENV{HTTPS_PROXY}|| $self->{proxy}}if ($self->{https_proxy}){$self->_split_proxy(https_proxy=>$self->{https_proxy});$self->{_has_proxy}{https}=1}else {delete$self->{https_proxy}}unless (ref$self->{no_proxy}eq 'ARRAY'){$self->{no_proxy}=(defined$self->{no_proxy})? [split /\s*,\s*/,$self->{no_proxy}]: []}return}for my$sub_name (qw/get head put post delete/){my$req_method=uc$sub_name;no strict 'refs';eval <<"HERE"}sub post_form {my ($self,$url,$data,$args)=@_;(@_==3 || @_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ ."\n");my$headers={};while (my ($key,$value)=each %{$args->{headers}|| {}}){$headers->{lc$key}=$value}delete$args->{headers};return$self->request('POST',$url,{%$args,content=>$self->www_form_urlencode($data),headers=>{%$headers,'content-type'=>'application/x-www-form-urlencoded' },})}sub mirror {my ($self,$url,$file,$args)=@_;@_==3 || (@_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ ."\n");if (exists$args->{headers}){my$headers={};while (my ($key,$value)=each %{$args->{headers}|| {}}){$headers->{lc$key}=$value}$args->{headers}=$headers}if (-e $file and my$mtime=(stat($file))[9]){$args->{headers}{'if-modified-since'}||= $self->_http_date($mtime)}my$tempfile=$file .int(rand(2**31));require Fcntl;sysopen my$fh,$tempfile,Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()or _croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);binmode$fh;$args->{data_callback}=sub {print {$fh}$_[0]};my$response=$self->request('GET',$url,$args);close$fh or _croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);if ($response->{success}){rename$tempfile,$file or _croak(qq/Error replacing $file with $tempfile: $!\n/);my$lm=$response->{headers}{'last-modified'};if ($lm and my$mtime=$self->_parse_http_date($lm)){utime$mtime,$mtime,$file}}$response->{success}||= $response->{status}eq '304';unlink$tempfile;return$response}my%idempotent=map {$_=>1}qw/GET HEAD PUT DELETE OPTIONS TRACE/;sub request {my ($self,$method,$url,$args)=@_;@_==3 || (@_==4 && ref$args eq 'HASH')or _croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ ."\n");$args ||= {};my$response;for (0 .. 1){$response=eval {$self->_request($method,$url,$args)};last unless $@ && $idempotent{$method}&& $@ =~ m{^(?:Socket closed|Unexpected end)}}if (my$e=$@){if (ref$e eq 'HASH' && exists$e->{status}){$e->{redirects}=delete$args->{_redirects}if @{$args->{_redirects}|| []};return$e}$e="$e";$response={url=>$url,success=>q{},status=>599,reason=>'Internal Exception',content=>$e,headers=>{'content-type'=>'text/plain','content-length'=>length$e,},(@{$args->{_redirects}|| []}? (redirects=>delete$args->{_redirects}): ()),}}return$response}sub www_form_urlencode {my ($self,$data)=@_;(@_==2 && ref$data)or _croak(q/Usage: $http->www_form_urlencode(DATAREF)/ ."\n");(ref$data eq 'HASH' || ref$data eq 'ARRAY')or _croak("form data must be a hash or array reference\n");my@params=ref$data eq 'HASH' ? %$data : @$data;@params % 2==0 or _croak("form data reference must have an even number of terms\n");my@terms;while(@params){my ($key,$value)=splice(@params,0,2);if (ref$value eq 'ARRAY'){unshift@params,map {$key=>$_}@$value}else {push@terms,join("=",map {$self->_uri_escape($_)}$key,$value)}}return join("&",(ref$data eq 'ARRAY')? (@terms): (sort@terms))}sub can_ssl {my ($self)=@_;my($ok,$reason)=(1,'');local@INC=@INC;pop@INC if$INC[-1]eq '.';unless (eval {require IO::Socket::SSL;IO::Socket::SSL->VERSION(1.42)}){$ok=0;$reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/}unless (eval {require Net::SSLeay;Net::SSLeay->VERSION(1.49)}){$ok=0;$reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/}if (ref($self)&& ($self->{verify_SSL}|| $self->{SSL_options}{SSL_verify_mode})){my$handle=HTTP::Tiny::Handle->new(SSL_options=>$self->{SSL_options},verify_SSL=>$self->{verify_SSL},);unless (eval {$handle->_find_CA_file;1}){$ok=0;$reason .= "$@"}}wantarray ? ($ok,$reason): $ok}sub connected {my ($self)=@_;if ($self->{handle}&& $self->{handle}{fh}){my$socket=$self->{handle}{fh};if ($socket->connected){return wantarray ? ($socket->peerhost,$socket->peerport): join(':',$socket->peerhost,$socket->peerport)}}return}my%DefaultPort=(http=>80,https=>443,);sub _agent {my$class=ref($_[0])|| $_[0];(my$default_agent=$class)=~ s{::}{-}g;return$default_agent ."/" .$class->VERSION}sub _request {my ($self,$method,$url,$args)=@_;my ($scheme,$host,$port,$path_query,$auth)=$self->_split_url($url);my$request={method=>$method,scheme=>$scheme,host=>$host,port=>$port,host_port=>($port==$DefaultPort{$scheme}? $host : "$host:$port"),uri=>$path_query,headers=>{},};my$peer=$args->{peer}|| $host;if ('CODE' eq ref$peer){$peer=$peer->($host)}my$handle=delete$self->{handle};if ($handle){unless ($handle->can_reuse($scheme,$host,$port,$peer)){$handle->close;undef$handle}}$handle ||= $self->_open_handle($request,$scheme,$host,$port,$peer);$self->_prepare_headers_and_cb($request,$args,$url,$auth);$handle->write_request($request);my$response;do {$response=$handle->read_response_header}until (substr($response->{status},0,1)ne '1');$self->_update_cookie_jar($url,$response)if$self->{cookie_jar};my@redir_args=$self->_maybe_redirect($request,$response,$args);my$known_message_length;if ($method eq 'HEAD' || $response->{status}=~ /^[23]04/){$known_message_length=1}else {my$cb_args=@redir_args ? +{}: $args;my$data_cb=$self->_prepare_data_cb($response,$cb_args);$known_message_length=$handle->read_body($data_cb,$response)}if ($self->{keep_alive}&& $known_message_length && $response->{protocol}eq 'HTTP/1.1' && ($response->{headers}{connection}|| '')ne 'close'){$self->{handle}=$handle}else {$handle->close}$response->{success}=substr($response->{status},0,1)eq '2';$response->{url}=$url;if (@redir_args){push @{$args->{_redirects}},$response;return$self->_request(@redir_args,$args)}$response->{redirects}=delete$args->{_redirects}if @{$args->{_redirects}};return$response}sub _open_handle {my ($self,$request,$scheme,$host,$port,$peer)=@_;my$handle=HTTP::Tiny::Handle->new(timeout=>$self->{timeout},SSL_options=>$self->{SSL_options},verify_SSL=>$self->{verify_SSL},local_address=>$self->{local_address},keep_alive=>$self->{keep_alive});if ($self->{_has_proxy}{$scheme}&&!grep {$host =~ /\Q$_\E$/}@{$self->{no_proxy}}){return$self->_proxy_connect($request,$handle)}else {return$handle->connect($scheme,$host,$port,$peer)}}sub _proxy_connect {my ($self,$request,$handle)=@_;my@proxy_vars;if ($request->{scheme}eq 'https'){_croak(qq{No https_proxy defined})unless$self->{https_proxy};@proxy_vars=$self->_split_proxy(https_proxy=>$self->{https_proxy});if ($proxy_vars[0]eq 'https'){_croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}})}}else {_croak(qq{No http_proxy defined})unless$self->{http_proxy};@proxy_vars=$self->_split_proxy(http_proxy=>$self->{http_proxy})}my ($p_scheme,$p_host,$p_port,$p_auth)=@proxy_vars;if (length$p_auth &&!defined$request->{headers}{'proxy-authorization'}){$self->_add_basic_auth_header($request,'proxy-authorization'=>$p_auth)}$handle->connect($p_scheme,$p_host,$p_port,$p_host);if ($request->{scheme}eq 'https'){$self->_create_proxy_tunnel($request,$handle)}else {$request->{uri}="$request->{scheme}://$request->{host_port}$request->{uri}"}return$handle}sub _split_proxy {my ($self,$type,$proxy)=@_;my ($scheme,$host,$port,$path_query,$auth)=eval {$self->_split_url($proxy)};unless(defined($scheme)&& length($scheme)&& length($host)&& length($port)&& $path_query eq '/'){_croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n})}return ($scheme,$host,$port,$auth)}sub _create_proxy_tunnel {my ($self,$request,$handle)=@_;$handle->_assert_ssl;my$agent=exists($request->{headers}{'user-agent'})? $request->{headers}{'user-agent'}: $self->{agent};my$connect_request={method=>'CONNECT',uri=>"$request->{host}:$request->{port}",headers=>{host=>"$request->{host}:$request->{port}",'user-agent'=>$agent,}};if ($request->{headers}{'proxy-authorization'}){$connect_request->{headers}{'proxy-authorization'}=delete$request->{headers}{'proxy-authorization'}}$handle->write_request($connect_request);my$response;do {$response=$handle->read_response_header}until (substr($response->{status},0,1)ne '1');unless (substr($response->{status},0,1)eq '2'){die$response}$handle->start_ssl($request->{host});return}sub _prepare_headers_and_cb {my ($self,$request,$args,$url,$auth)=@_;for ($self->{default_headers},$args->{headers}){next unless defined;while (my ($k,$v)=each %$_){$request->{headers}{lc$k}=$v;$request->{header_case}{lc$k}=$k}}if (exists$request->{headers}{'host'}){die(qq/The 'Host' header must not be provided as header option\n/)}$request->{headers}{'host'}=$request->{host_port};$request->{headers}{'user-agent'}||= $self->{agent};$request->{headers}{'connection'}="close" unless$self->{keep_alive};if (defined$args->{content}){if (ref$args->{content}eq 'CODE'){$request->{headers}{'content-type'}||= "application/octet-stream";$request->{headers}{'transfer-encoding'}='chunked' unless$request->{headers}{'content-length'}|| $request->{headers}{'transfer-encoding'};$request->{cb}=$args->{content}}elsif (length$args->{content}){my$content=$args->{content};if ($] ge '5.008'){utf8::downgrade($content,1)or die(qq/Wide character in request message body\n/)}$request->{headers}{'content-type'}||= "application/octet-stream";$request->{headers}{'content-length'}=length$content unless$request->{headers}{'content-length'}|| $request->{headers}{'transfer-encoding'};$request->{cb}=sub {substr$content,0,length$content,''}}$request->{trailer_cb}=$args->{trailer_callback}if ref$args->{trailer_callback}eq 'CODE'}if ($self->{cookie_jar}){my$cookies=$self->cookie_jar->cookie_header($url);$request->{headers}{cookie}=$cookies if length$cookies}if (length$auth &&!defined$request->{headers}{authorization}){$self->_add_basic_auth_header($request,'authorization'=>$auth)}return}sub _add_basic_auth_header {my ($self,$request,$header,$auth)=@_;require MIME::Base64;$request->{headers}{$header}="Basic " .MIME::Base64::encode_base64($auth,"");return}sub _prepare_data_cb {my ($self,$response,$args)=@_;my$data_cb=$args->{data_callback};$response->{content}='';if (!$data_cb || $response->{status}!~ /^2/){if (defined$self->{max_size}){$data_cb=sub {$_[1]->{content}.= $_[0];die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)if length $_[1]->{content}> $self->{max_size}}}else {$data_cb=sub {$_[1]->{content}.= $_[0]}}}return$data_cb}sub _update_cookie_jar {my ($self,$url,$response)=@_;my$cookies=$response->{headers}->{'set-cookie'};return unless defined$cookies;my@cookies=ref$cookies ? @$cookies : $cookies;$self->cookie_jar->add($url,$_)for@cookies;return}sub _validate_cookie_jar {my ($class,$jar)=@_;for my$method (qw/add cookie_header/){_croak(qq/Cookie jar must provide the '$method' method\n/)unless ref($jar)&& ref($jar)->can($method)}return}sub _maybe_redirect {my ($self,$request,$response,$args)=@_;my$headers=$response->{headers};my ($status,$method)=($response->{status},$request->{method});$args->{_redirects}||= [];if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))and $headers->{location}and @{$args->{_redirects}}< $self->{max_redirect}){my$location=($headers->{location}=~ /^\//)? "$request->{scheme}://$request->{host_port}$headers->{location}" : $headers->{location};return (($status eq '303' ? 'GET' : $method),$location)}return}sub _split_url {my$url=pop;my ($scheme,$host,$path_query)=$url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)> or die(qq/Cannot parse URL: '$url'\n/);$scheme=lc$scheme;$path_query="/$path_query" unless$path_query =~ m<\A/>;my$auth='';if ((my$i=index$host,'@')!=-1){$auth=substr$host,0,$i,'';substr$host,0,1,'';$auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg}my$port=$host =~ s/:(\d*)\z// && length $1 ? $1 : $scheme eq 'http' ? 80 : $scheme eq 'https' ? 443 : undef;return ($scheme,(length$host ? lc$host : "localhost"),$port,$path_query,$auth)}my$DoW="Sun|Mon|Tue|Wed|Thu|Fri|Sat";my$MoY="Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";sub _http_date {my ($sec,$min,$hour,$mday,$mon,$year,$wday)=gmtime($_[1]);return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",substr($DoW,$wday*4,3),$mday,substr($MoY,$mon*4,3),$year+1900,$hour,$min,$sec)}sub _parse_http_date {my ($self,$str)=@_;require Time::Local;my@tl_parts;if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/){@tl_parts=($6,$5,$4,$1,(index($MoY,$2)/4),$3)}elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/){@tl_parts=($6,$5,$4,$1,(index($MoY,$2)/4),$3)}elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/){@tl_parts=($5,$4,$3,$2,(index($MoY,$1)/4),$6)}return eval {my$t=@tl_parts ? Time::Local::timegm(@tl_parts): -1;$t < 0 ? undef : $t}}my%escapes=map {chr($_)=>sprintf("%%%02X",$_)}0..255;$escapes{' '}="+";my$unsafe_char=qr/[^A-Za-z0-9\-\._~]/;sub _uri_escape {my ($self,$str)=@_;if ($] ge '5.008'){utf8::encode($str)}else {$str=pack("U*",unpack("C*",$str))if (length$str==do {use bytes;length$str});$str=pack("C*",unpack("C*",$str))}$str =~ s/($unsafe_char)/$escapes{$1}/g;return$str}package HTTP::Tiny::Handle;use strict;use warnings;use Errno qw[EINTR EPIPE];use IO::Socket qw[SOCK_STREAM];use Socket qw[SOL_SOCKET SO_KEEPALIVE];my$SOCKET_CLASS=$ENV{PERL_HTTP_TINY_IPV4_ONLY}? 'IO::Socket::INET' : eval {require IO::Socket::IP;IO::Socket::IP->VERSION(0.25)}? 'IO::Socket::IP' : 'IO::Socket::INET';sub BUFSIZE () {32768}my$Printable=sub {local $_=shift;s/\r/\\r/g;s/\n/\\n/g;s/\t/\\t/g;s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;$_};my$Token=qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;my$Field_Content=qr/[[:print:]]+ (?: [\x20\x09]+ [[:print:]]+ )*/x;sub new {my ($class,%args)=@_;return bless {rbuf=>'',timeout=>60,max_line_size=>16384,max_header_lines=>64,verify_SSL=>0,SSL_options=>{},%args },$class}sub timeout {my ($self,$timeout)=@_;if (@_ > 1){$self->{timeout}=$timeout;if ($self->{fh}&& $self->{fh}->can('timeout')){$self->{fh}->timeout($timeout)}}return$self->{timeout}}sub connect {@_==5 || die(q/Usage: $handle->connect(scheme, host, port, peer)/ ."\n");my ($self,$scheme,$host,$port,$peer)=@_;if ($scheme eq 'https'){$self->_assert_ssl}elsif ($scheme ne 'http'){die(qq/Unsupported URL scheme '$scheme'\n/)}$self->{fh}=$SOCKET_CLASS->new(PeerHost=>$peer,PeerPort=>$port,$self->{local_address}? (LocalAddr=>$self->{local_address}): (),Proto=>'tcp',Type=>SOCK_STREAM,Timeout=>$self->{timeout},)or die(qq/Could not connect to '$host:$port': $@\n/);binmode($self->{fh})or die(qq/Could not binmode() socket: '$!'\n/);if ($self->{keep_alive}){unless (defined($self->{fh}->setsockopt(SOL_SOCKET,SO_KEEPALIVE,1))){CORE::close($self->{fh});die(qq/Could not set SO_KEEPALIVE on socket: '$!'\n/)}}$self->start_ssl($host)if$scheme eq 'https';$self->{scheme}=$scheme;$self->{host}=$host;$self->{peer}=$peer;$self->{port}=$port;$self->{pid}=$$;$self->{tid}=_get_tid();return$self}sub start_ssl {my ($self,$host)=@_;if (ref($self->{fh})eq 'IO::Socket::SSL'){unless ($self->{fh}->stop_SSL){my$ssl_err=IO::Socket::SSL->errstr;die(qq/Error halting prior SSL connection: $ssl_err/)}}my$ssl_args=$self->_ssl_args($host);IO::Socket::SSL->start_SSL($self->{fh},%$ssl_args,SSL_create_ctx_callback=>sub {my$ctx=shift;Net::SSLeay::CTX_set_mode($ctx,Net::SSLeay::MODE_AUTO_RETRY())},);unless (ref($self->{fh})eq 'IO::Socket::SSL'){my$ssl_err=IO::Socket::SSL->errstr;die(qq/SSL connection failed for $host: $ssl_err\n/)}}sub close {@_==1 || die(q/Usage: $handle->close()/ ."\n");my ($self)=@_;CORE::close($self->{fh})or die(qq/Could not close socket: '$!'\n/)}sub write {@_==2 || die(q/Usage: $handle->write(buf)/ ."\n");my ($self,$buf)=@_;if ($] ge '5.008'){utf8::downgrade($buf,1)or die(qq/Wide character in write()\n/)}my$len=length$buf;my$off=0;local$SIG{PIPE}='IGNORE';while (){$self->can_write or die(qq/Timed out while waiting for socket to become ready for writing\n/);my$r=syswrite($self->{fh},$buf,$len,$off);if (defined$r){$len -= $r;$off += $r;last unless$len > 0}elsif ($!==EPIPE){die(qq/Socket closed by remote server: $!\n/)}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not write to SSL socket: '$err'\n /)}else {die(qq/Could not write to socket: '$!'\n/)}}}return$off}sub read {@_==2 || @_==3 || die(q/Usage: $handle->read(len [, allow_partial])/ ."\n");my ($self,$len,$allow_partial)=@_;my$buf='';my$got=length$self->{rbuf};if ($got){my$take=($got < $len)? $got : $len;$buf=substr($self->{rbuf},0,$take,'');$len -= $take}while ($len > 0){$self->can_read or die(q/Timed out while waiting for socket to become ready for reading/ ."\n");my$r=sysread($self->{fh},$buf,$len,length$buf);if (defined$r){last unless$r;$len -= $r}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not read from SSL socket: '$err'\n /)}else {die(qq/Could not read from socket: '$!'\n/)}}}if ($len &&!$allow_partial){die(qq/Unexpected end of stream\n/)}return$buf}sub readline {@_==1 || die(q/Usage: $handle->readline()/ ."\n");my ($self)=@_;while (){if ($self->{rbuf}=~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x){return $1}if (length$self->{rbuf}>= $self->{max_line_size}){die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/)}$self->can_read or die(qq/Timed out while waiting for socket to become ready for reading\n/);my$r=sysread($self->{fh},$self->{rbuf},BUFSIZE,length$self->{rbuf});if (defined$r){last unless$r}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not read from SSL socket: '$err'\n /)}else {die(qq/Could not read from socket: '$!'\n/)}}}die(qq/Unexpected end of stream while looking for line\n/)}sub read_header_lines {@_==1 || @_==2 || die(q/Usage: $handle->read_header_lines([headers])/ ."\n");my ($self,$headers)=@_;$headers ||= {};my$lines=0;my$val;while (){my$line=$self->readline;if (++$lines >= $self->{max_header_lines}){die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/)}elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x){my ($field_name)=lc $1;if (exists$headers->{$field_name}){for ($headers->{$field_name}){$_=[$_]unless ref $_ eq "ARRAY";push @$_,$2;$val=\$_->[-1]}}else {$val=\($headers->{$field_name}=$2)}}elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x){$val or die(qq/Unexpected header continuation line\n/);next unless length $1;$$val .= ' ' if length $$val;$$val .= $1}elsif ($line =~ /\A \x0D?\x0A \z/x){last}else {die(q/Malformed header line: / .$Printable->($line)."\n")}}return$headers}sub write_request {@_==2 || die(q/Usage: $handle->write_request(request)/ ."\n");my($self,$request)=@_;$self->write_request_header(@{$request}{qw/method uri headers header_case/});$self->write_body($request)if$request->{cb};return}my@rfc_request_headers=qw(Accept Accept-Charset Accept-Encoding Accept-Language Authorization Cache-Control Connection Content-Length Expect From Host If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since Max-Forwards Pragma Proxy-Authorization Range Referer TE Trailer Transfer-Encoding Upgrade User-Agent Via);my@other_request_headers=qw(Content-Encoding Content-MD5 Content-Type Cookie DNT Date Origin X-XSS-Protection);my%HeaderCase=map {lc($_)=>$_}@rfc_request_headers,@other_request_headers;sub write_header_lines {(@_ >= 2 && @_ <= 4 && ref $_[1]eq 'HASH')|| die(q/Usage: $handle->write_header_lines(headers, [header_case, prefix])/ ."\n");my($self,$headers,$header_case,$prefix_data)=@_;$header_case ||= {};my$buf=(defined$prefix_data ? $prefix_data : '');my%seen;for my$k (qw/host cache-control expect max-forwards pragma range te/){next unless exists$headers->{$k};$seen{$k}++;my$field_name=$HeaderCase{$k};my$v=$headers->{$k};for (ref$v eq 'ARRAY' ? @$v : $v){$_='' unless defined $_;$buf .= "$field_name: $_\x0D\x0A"}}while (my ($k,$v)=each %$headers){my$field_name=lc$k;next if$seen{$field_name};if (exists$HeaderCase{$field_name}){$field_name=$HeaderCase{$field_name}}else {if (exists$header_case->{$field_name}){$field_name=$header_case->{$field_name}}else {$field_name =~ s/\b(\w)/\u$1/g}$field_name =~ /\A $Token+ \z/xo or die(q/Invalid HTTP header field name: / .$Printable->($field_name)."\n");$HeaderCase{lc$field_name}=$field_name}for (ref$v eq 'ARRAY' ? @$v : $v){s/\x0D?\x0A\s+/ /g;die(qq/Invalid HTTP header field value ($field_name): / .$Printable->($_)."\n")unless $_ eq '' || /\A $Field_Content \z/xo;$_='' unless defined $_;$buf .= "$field_name: $_\x0D\x0A"}}$buf .= "\x0D\x0A";return$self->write($buf)}sub read_body {@_==3 || die(q/Usage: $handle->read_body(callback, response)/ ."\n");my ($self,$cb,$response)=@_;my$te=$response->{headers}{'transfer-encoding'}|| '';my$chunked=grep {/chunked/i}(ref$te eq 'ARRAY' ? @$te : $te);return$chunked ? $self->read_chunked_body($cb,$response): $self->read_content_body($cb,$response)}sub write_body {@_==2 || die(q/Usage: $handle->write_body(request)/ ."\n");my ($self,$request)=@_;if ($request->{headers}{'content-length'}){return$self->write_content_body($request)}else {return$self->write_chunked_body($request)}}sub read_content_body {@_==3 || @_==4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ ."\n");my ($self,$cb,$response,$content_length)=@_;$content_length ||= $response->{headers}{'content-length'};if (defined$content_length){my$len=$content_length;while ($len > 0){my$read=($len > BUFSIZE)? BUFSIZE : $len;$cb->($self->read($read,0),$response);$len -= $read}return length($self->{rbuf})==0}my$chunk;$cb->($chunk,$response)while length($chunk=$self->read(BUFSIZE,1));return}sub write_content_body {@_==2 || die(q/Usage: $handle->write_content_body(request)/ ."\n");my ($self,$request)=@_;my ($len,$content_length)=(0,$request->{headers}{'content-length'});while (){my$data=$request->{cb}->();defined$data && length$data or last;if ($] ge '5.008'){utf8::downgrade($data,1)or die(qq/Wide character in write_content()\n/)}$len += $self->write($data)}$len==$content_length or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);return$len}sub read_chunked_body {@_==3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ ."\n");my ($self,$cb,$response)=@_;while (){my$head=$self->readline;$head =~ /\A ([A-Fa-f0-9]+)/x or die(q/Malformed chunk head: / .$Printable->($head)."\n");my$len=hex($1)or last;$self->read_content_body($cb,$response,$len);$self->read(2)eq "\x0D\x0A" or die(qq/Malformed chunk: missing CRLF after chunk data\n/)}$self->read_header_lines($response->{headers});return 1}sub write_chunked_body {@_==2 || die(q/Usage: $handle->write_chunked_body(request)/ ."\n");my ($self,$request)=@_;my$len=0;while (){my$data=$request->{cb}->();defined$data && length$data or last;if ($] ge '5.008'){utf8::downgrade($data,1)or die(qq/Wide character in write_chunked_body()\n/)}$len += length$data;my$chunk=sprintf '%X',length$data;$chunk .= "\x0D\x0A";$chunk .= $data;$chunk .= "\x0D\x0A";$self->write($chunk)}$self->write("0\x0D\x0A");if (ref$request->{trailer_cb}eq 'CODE'){$self->write_header_lines($request->{trailer_cb}->())}else {$self->write("\x0D\x0A")}return$len}sub read_response_header {@_==1 || die(q/Usage: $handle->read_response_header()/ ."\n");my ($self)=@_;my$line=$self->readline;$line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) [\x09\x20]+ ([^\x0D\x0A]*) \x0D?\x0A/x or die(q/Malformed Status-Line: / .$Printable->($line)."\n");my ($protocol,$version,$status,$reason)=($1,$2,$3,$4);die (qq/Unsupported HTTP protocol: $protocol\n/)unless$version =~ /0*1\.0*[01]/;return {status=>$status,reason=>$reason,headers=>$self->read_header_lines,protocol=>$protocol,}}sub write_request_header {@_==5 || die(q/Usage: $handle->write_request_header(method, request_uri, headers, header_case)/ ."\n");my ($self,$method,$request_uri,$headers,$header_case)=@_;return$self->write_header_lines($headers,$header_case,"$method $request_uri HTTP/1.1\x0D\x0A")}sub _do_timeout {my ($self,$type,$timeout)=@_;$timeout=$self->{timeout}unless defined$timeout && $timeout >= 0;my$fd=fileno$self->{fh};defined$fd && $fd >= 0 or die(qq/select(2): 'Bad file descriptor'\n/);my$initial=time;my$pending=$timeout;my$nfound;vec(my$fdset='',$fd,1)=1;while (){$nfound=($type eq 'read')? select($fdset,undef,undef,$pending): select(undef,$fdset,undef,$pending);if ($nfound==-1){$!==EINTR or die(qq/select(2): '$!'\n/);redo if!$timeout || ($pending=$timeout - (time - $initial))> 0;$nfound=0}last}$!=0;return$nfound}sub can_read {@_==1 || @_==2 || die(q/Usage: $handle->can_read([timeout])/ ."\n");my$self=shift;if (ref($self->{fh})eq 'IO::Socket::SSL'){return 1 if$self->{fh}->pending}return$self->_do_timeout('read',@_)}sub can_write {@_==1 || @_==2 || die(q/Usage: $handle->can_write([timeout])/ ."\n");my$self=shift;return$self->_do_timeout('write',@_)}sub _assert_ssl {my($ok,$reason)=HTTP::Tiny->can_ssl();die$reason unless$ok}sub can_reuse {my ($self,$scheme,$host,$port,$peer)=@_;return 0 if $self->{pid}!=$$ || $self->{tid}!=_get_tid()|| length($self->{rbuf})|| $scheme ne $self->{scheme}|| $host ne $self->{host}|| $port ne $self->{port}|| $peer ne $self->{peer}|| eval {$self->can_read(0)}|| $@ ;return 1}sub _find_CA_file {my$self=shift();my$ca_file=defined($self->{SSL_options}->{SSL_ca_file})? $self->{SSL_options}->{SSL_ca_file}: $ENV{SSL_CERT_FILE};if (defined$ca_file){unless (-r $ca_file){die qq/SSL_ca_file '$ca_file' not found or not readable\n/}return$ca_file}local@INC=@INC;pop@INC if$INC[-1]eq '.';return Mozilla::CA::SSL_ca_file()if eval {require Mozilla::CA;1};for my$ca_bundle ("/etc/ssl/certs/ca-certificates.crt","/etc/pki/tls/certs/ca-bundle.crt","/etc/ssl/ca-bundle.pem","/etc/openssl/certs/ca-certificates.crt","/etc/ssl/cert.pem","/usr/local/share/certs/ca-root-nss.crt","/etc/pki/tls/cacert.pem","/etc/certs/ca-certificates.crt",){return$ca_bundle if -e $ca_bundle}die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/ .qq/Try installing Mozilla::CA from CPAN\n/}sub _get_tid {no warnings 'reserved';return threads->can("tid")? threads->tid : 0}sub _ssl_args {my ($self,$host)=@_;my%ssl_args;if (Net::SSLeay::OPENSSL_VERSION_NUMBER()>= 0x01000000){$ssl_args{SSL_hostname}=$host,}if ($self->{verify_SSL}){$ssl_args{SSL_verifycn_scheme}='http';$ssl_args{SSL_verifycn_name}=$host;$ssl_args{SSL_verify_mode}=0x01;$ssl_args{SSL_ca_file}=$self->_find_CA_file}else {$ssl_args{SSL_verifycn_scheme}='none';$ssl_args{SSL_verify_mode}=0x00}for my$k (keys %{$self->{SSL_options}}){$ssl_args{$k}=$self->{SSL_options}{$k}if$k =~ m/^SSL_/}return \%ssl_args}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or _croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  HERE
HTTP_TINY

$fatpacked{"HTTP/Tinyish.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH';
  package HTTP::Tinyish;use strict;use warnings;use Carp ();our$VERSION='0.15';our$PreferredBackend;our@Backends=map "HTTP::Tinyish::$_",qw(LWP HTTPTiny Curl Wget);my%configured;sub new {my($class,%attr)=@_;bless \%attr,$class}for my$method (qw/get head put post delete mirror/){no strict 'refs';eval <<"HERE"}sub request {my$self=shift;$self->_backend_for($_[1])->request(@_)}sub _backend_for {my($self,$url)=@_;my($scheme)=$url =~ m!^(https?):!;Carp::croak "URL Scheme '$url' not supported." unless$scheme;for my$backend ($self->backends){$self->configure_backend($backend)or next;if ($backend->supports($scheme)){return$backend->new(%$self)}}Carp::croak "No backend configured for scheme $scheme"}sub backends {$PreferredBackend ? ($PreferredBackend): @Backends}sub configure_backend {my($self,$backend)=@_;unless (exists$configured{$backend}){$configured{$backend}=eval {require_module($backend);$backend->configure}}$configured{$backend}}sub require_module {local $_=shift;s!::!/!g;require "$_.pm"}1;
      sub $method {
          my \$self = shift;
          \$self->_backend_for(\$_[0])->$method(\@_);
      }
  HERE
HTTP_TINYISH

$fatpacked{"HTTP/Tinyish/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_BASE';
  package HTTP::Tinyish::Base;use strict;use warnings;for my$sub_name (qw/get head put post delete/){my$req_method=uc$sub_name;eval <<"HERE"}sub parse_http_header {my($self,$header,$res)=@_;$header =~ s/.*^(HTTP\/\d(?:\.\d)?)/$1/ms;if ($header =~ /^(.*?\x0d?\x0a\x0d?\x0a)/){$header=$1}my@header=split /\x0d?\x0a/,$header;my$status_line=shift@header;my@out;for (@header){if(/^[ \t]+/){return -1 unless@out;$out[-1].= $_}else {push@out,$_}}my($proto,$status,$reason)=split / /,$status_line,3;return unless$proto and $proto =~ /^HTTP\/(\d+)(\.(\d+))?$/i;$res->{status}=$status;$res->{reason}=$reason;$res->{success}=$status =~ /^(?:2|304)/;$res->{protocol}=$proto;my$token=qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;my$k;for my$header (@out){if ($header =~ s/^($token): ?//){$k=lc $1}elsif ($header =~ /^\s+/){}else {return -1}if (exists$res->{headers}{$k}){$res->{headers}{$k}=[$res->{headers}{$k}]unless ref$res->{headers}{$k};push @{$res->{headers}{$k}},$header}else {$res->{headers}{$k}=$header}}}sub internal_error {my($self,$url,$message)=@_;return {content=>$message,headers=>{"content-length"=>length($message),"content-type"=>"text/plain" },reason=>"Internal Exception",status=>599,success=>"",url=>$url,}}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  
  HERE
HTTP_TINYISH_BASE

$fatpacked{"HTTP/Tinyish/Curl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_CURL';
  package HTTP::Tinyish::Curl;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);use File::Temp ();my%supports;my$curl;sub _slurp {open my$fh,"<",shift or die $!;local $/;<$fh>}sub configure {my$class=shift;my%meta;$curl=which('curl');eval {run3([$curl,'--version'],\undef,\my$version,\my$error);if ($version =~ /^Protocols: (.*)/m){my%protocols=map {$_=>1}split /\s/,$1;$supports{http}=1 if$protocols{http};$supports{https}=1 if$protocols{https}}$meta{$curl}=$version};\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;bless \%attr,$class}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my(undef,$temp)=File::Temp::tempfile(UNLINK=>1);my($output,$error);eval {run3 [$curl,'-X',$method,($method eq 'HEAD' ? ('--head'): ()),$self->build_options($url,$opts),'--dump-header',$temp,$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub mirror {my($self,$url,$file,$opts)=@_;$opts ||= {};my(undef,$temp)=File::Temp::tempfile(UNLINK=>1);my($output,$error);eval {run3 [$curl,$self->build_options($url,$opts),'-z',$file,'-o',$file,'--dump-header',$temp,'--remote-time',$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub build_options {my($self,$url,$opts)=@_;my@options=('--location','--silent','--max-time',($self->{timeout}|| 60),'--max-redirs',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);unless ($self->{verify_SSL}){push@options,'--insecure'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}push@options,'--data',$content}@options}sub _translate_headers {my($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,map {('-H',"$field:$_")}@$value}else {push @$options,'-H',"$field:$value"}}}1;
HTTP_TINYISH_CURL

$fatpacked{"HTTP/Tinyish/HTTPTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_HTTPTINY';
  package HTTP::Tinyish::HTTPTiny;use strict;use parent qw(HTTP::Tinyish::Base);use HTTP::Tiny;my%supports=(http=>1);sub configure {my%meta=("HTTP::Tiny"=>$HTTP::Tiny::VERSION);$supports{https}=HTTP::Tiny->can_ssl;\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attrs)=@_;bless {tiny=>HTTP::Tiny->new(%attrs),},$class}sub request {my$self=shift;$self->{tiny}->request(@_)}sub mirror {my$self=shift;$self->{tiny}->mirror(@_)}1;
HTTP_TINYISH_HTTPTINY

$fatpacked{"HTTP/Tinyish/LWP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_LWP';
  package HTTP::Tinyish::LWP;use strict;use parent qw(HTTP::Tinyish::Base);use LWP 5.802;use LWP::UserAgent;my%supports=(http=>1);sub configure {my%meta=(LWP=>$LWP::VERSION,);if (eval {require LWP::Protocol::https;require Mozilla::CA;1}){$supports{https}=1;$meta{"LWP::Protocol::https"}=$LWP::Protocol::https::VERSION}\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;my$ua=LWP::UserAgent->new;bless {ua=>$class->translate_lwp($ua,%attr),},$class}sub _headers_to_hashref {my($self,$hdrs)=@_;my%headers;for my$field ($hdrs->header_field_names){$headers{lc$field}=$hdrs->header($field)}\%headers}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my$req=HTTP::Request->new($method=>$url);if ($opts->{headers}){$req->header(%{$opts->{headers}})}if ($opts->{content}){$req->content($opts->{content})}my$res=$self->{ua}->request($req);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content(charset=>'none'),success=>$res->is_success,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub mirror {my($self,$url,$file)=@_;my$res=$self->{ua}->mirror($url,$file);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content,success=>$res->is_success || $res->code==304,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub translate_lwp {my($class,$agent,%attr)=@_;$agent->parse_head(0);$agent->env_proxy;$agent->timeout(delete$attr{timeout}|| 60);$agent->max_redirect(delete$attr{max_redirect}|| 5);$agent->agent(delete$attr{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION");unless ($attr{verify_SSL}){if ($agent->can("ssl_opts")){$agent->ssl_opts(verify_hostname=>0)}}if ($attr{default_headers}){$agent->default_headers(HTTP::Headers->new(%{$attr{default_headers}}))}$agent}sub is_internal_response {my($self,$res)=@_;$res->code==500 && ($res->header('Client-Warning')|| '')eq 'Internal response'}1;
HTTP_TINYISH_LWP

$fatpacked{"HTTP/Tinyish/Wget.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_WGET';
  package HTTP::Tinyish::Wget;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);my%supports;my$wget;my$method_supported;sub _run_wget {run3([$wget,@_],\undef,\my$out,\my$err);wantarray ? ($out,$err): $out}sub configure {my$class=shift;my%meta;$wget=which('wget');eval {local$ENV{LC_ALL}='en_US';$meta{$wget}=_run_wget('--version');unless ($meta{$wget}=~ /GNU Wget 1\.(\d+)/ and $1 >= 12){die "Wget version is too old. $meta{$wget}"}my$config=$class->new(agent=>__PACKAGE__);my@options=grep {$_ ne '--quiet'}$config->build_options("GET");my(undef,$err)=_run_wget(@options,'https://');if ($err && $err =~ /HTTPS support not compiled/){$supports{http}=1}elsif ($err && $err =~ /Invalid host/){$supports{http}=$supports{https}=1}(undef,$err)=_run_wget('--method','GET','http://');if ($err && $err =~ /Invalid host/){$method_supported=$meta{method_supported}=1}};\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;bless \%attr,$class}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my($stdout,$stderr);eval {run3 [$wget,$self->build_options($method,$url,$opts),$url,'-O','-',],\undef,\$stdout,\$stderr};if ($@ or $? && ($? >> 8)<= 5){return$self->internal_error($url,$@ || $stderr)}my$header='';$stderr =~ s{^  (\S.*)$}{ $header .= $1."\n" }gem;my$res={url=>$url,content=>$stdout };$self->parse_http_header($header,$res);$res}sub mirror {my($self,$url,$file,$opts)=@_;$opts ||= {};my($stdout,$stderr);eval {run3 [$wget,$self->build_options("GET",$url,$opts),$url,'-O',$file],\undef,\$stdout,\$stderr};if ($@ or $?){return$self->internal_error($url,$@ || $stderr)}$stderr =~ s/^  //gm;my$res={url=>$url,content=>$stdout };$self->parse_http_header($stderr,$res);$res}sub build_options {my($self,$method,$url,$opts)=@_;my@options=('--retry-connrefused','--server-response','--timeout',($self->{timeout}|| 60),'--tries',1,'--max-redirect',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);if ($method_supported){push@options,"--method",$method}else {if ($method eq 'GET' or $method eq 'POST'){}elsif ($method eq 'HEAD'){push@options,'--spider'}else {die "This version of wget doesn't support specifying HTTP method '$method'"}}if ($self->{agent}){push@options,'--user-agent',$self->{agent}}my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);if ($supports{https}&&!$self->{verify_SSL}){push@options,'--no-check-certificate'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}if ($method_supported){push@options,'--body-data',$content}else {push@options,'--post-data',$content}}@options}sub _translate_headers {my($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,'--header',"$field:" .join(",",@$value)}else {push @$options,'--header',"$field:$value"}}}1;
HTTP_TINYISH_WGET

$fatpacked{"IPC/Cmd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_CMD';
  package IPC::Cmd;use strict;BEGIN {use constant IS_VMS=>$^O eq 'VMS' ? 1 : 0;use constant IS_WIN32=>$^O eq 'MSWin32' ? 1 : 0;use constant IS_HPUX=>$^O eq 'hpux' ? 1 : 0;use constant IS_WIN98=>(IS_WIN32 and!Win32::IsWinNT())? 1 : 0;use constant ALARM_CLASS=>__PACKAGE__ .'::TimeOut';use constant SPECIAL_CHARS=>qw[< > | &];use constant QUOTE=>do {IS_WIN32 ? q["] : q[']};use Exporter ();use vars qw[@ISA $VERSION @EXPORT_OK $VERBOSE $DEBUG $USE_IPC_RUN $USE_IPC_OPEN3 $CAN_USE_RUN_FORKED $WARN $INSTANCES $ALLOW_NULL_ARGS $HAVE_MONOTONIC];$VERSION='1.04';$VERBOSE=0;$DEBUG=0;$WARN=1;$USE_IPC_RUN=IS_WIN32 &&!IS_WIN98;$USE_IPC_OPEN3=not IS_VMS;$ALLOW_NULL_ARGS=0;$CAN_USE_RUN_FORKED=0;eval {require POSIX;POSIX->import();require IPC::Open3;IPC::Open3->import();require IO::Select;IO::Select->import();require IO::Handle;IO::Handle->import();require FileHandle;FileHandle->import();require Socket;require Time::HiRes;Time::HiRes->import();require Win32 if IS_WIN32};$CAN_USE_RUN_FORKED=$@ ||!IS_VMS &&!IS_WIN32;eval {my$wait_start_time=Time::HiRes::clock_gettime(&Time::HiRes::CLOCK_MONOTONIC)};if ($@){$HAVE_MONOTONIC=0}else {$HAVE_MONOTONIC=1}@ISA=qw[Exporter];@EXPORT_OK=qw[can_run run run_forked QUOTE]}require Carp;use File::Spec;use Params::Check qw[check];use Text::ParseWords ();use Module::Load::Conditional qw[can_load];use Locale::Maketext::Simple Style=>'gettext';local$Module::Load::Conditional::FORCE_SAFE_INC=1;sub can_use_ipc_run {my$self=shift;my$verbose=shift || 0;return if IS_WIN98;return unless can_load(modules=>{'IPC::Run'=>'0.55' },verbose=>($WARN && $verbose),);return$IPC::Run::VERSION}sub can_use_ipc_open3 {my$self=shift;my$verbose=shift || 0;return if IS_VMS;return unless can_load(modules=>{map {$_=>'0.0'}qw|IPC::Open3 IO::Select Symbol| },verbose=>($WARN && $verbose),);return$IPC::Open3::VERSION}sub can_capture_buffer {my$self=shift;return 1 if$USE_IPC_RUN && $self->can_use_ipc_run;return 1 if$USE_IPC_OPEN3 && $self->can_use_ipc_open3;return}sub can_run {my$command=shift;if ($^O eq 'VMS'){require VMS::DCLsym;my$syms=VMS::DCLsym->new;return$command if scalar$syms->getsym(uc$command)}require File::Spec;require ExtUtils::MakeMaker;my@possibles;if(File::Spec->file_name_is_absolute($command)){return MM->maybe_command($command)}else {for my$dir (File::Spec->path,(IS_WIN32 ? File::Spec->curdir : ())){next if!$dir ||!-d $dir;my$abs=File::Spec->catfile(IS_WIN32 ? Win32::GetShortPathName($dir): $dir,$command);push@possibles,$abs if$abs=MM->maybe_command($abs)}}return@possibles if wantarray and $INSTANCES;return shift@possibles}{my@acc=qw[ok error _fds];for my$key (@acc){no strict 'refs';*{__PACKAGE__."::$key"}=sub {$_[0]->{$key}=$_[1]if @_ > 1;return $_[0]->{$key}}}}sub can_use_run_forked {return$CAN_USE_RUN_FORKED eq "1"}sub get_monotonic_time {if ($HAVE_MONOTONIC){return Time::HiRes::clock_gettime(&Time::HiRes::CLOCK_MONOTONIC)}else {return time()}}sub adjust_monotonic_start_time {my ($ref_vars,$now,$previous)=@_;return if$HAVE_MONOTONIC;return unless$previous;my$time_diff=$now - $previous;if ($time_diff > 5 || $time_diff < 0){for my$ref_var (@{$ref_vars}){if (defined($$ref_var)){$$ref_var=$$ref_var + $time_diff}}}}sub uninstall_signals {return unless defined($IPC::Cmd::{'__old_signals'});for my$sig_name (keys %{$IPC::Cmd::{'__old_signals'}}){$SIG{$sig_name}=$IPC::Cmd::{'__old_signals'}->{$sig_name}}}sub install_layered_signal {my ($s,$handler_code)=@_;my%available_signals=map {$_=>1}keys%SIG;Carp::confess("install_layered_signal got nonexistent signal name [$s]")unless defined($available_signals{$s});Carp::confess("install_layered_signal expects coderef")if!ref($handler_code)|| ref($handler_code)ne 'CODE';$IPC::Cmd::{'__old_signals'}={}unless defined($IPC::Cmd::{'__old_signals'});$IPC::Cmd::{'__old_signals'}->{$s}=$SIG{$s};my$previous_handler=$SIG{$s};my$sig_handler=sub {my ($called_sig_name,@sig_param)=@_;my$signal_name=$s;if ($called_sig_name eq $signal_name){$handler_code->($signal_name)}if (ref($previous_handler)){$previous_handler->($called_sig_name,@sig_param)}};$SIG{$s}=$sig_handler}sub kill_gently {my ($pid,$opts)=@_;require POSIX;$opts={}unless$opts;$opts->{'wait_time'}=2 unless defined($opts->{'wait_time'});$opts->{'first_kill_type'}='just_process' unless$opts->{'first_kill_type'};$opts->{'final_kill_type'}='just_process' unless$opts->{'final_kill_type'};if ($opts->{'first_kill_type'}eq 'just_process'){kill(15,$pid)}elsif ($opts->{'first_kill_type'}eq 'process_group'){kill(-15,$pid)}my$do_wait=1;my$child_finished=0;my$wait_start_time=get_monotonic_time();my$now;my$previous_monotonic_value;while ($do_wait){$previous_monotonic_value=$now;$now=get_monotonic_time();adjust_monotonic_start_time([\$wait_start_time],$now,$previous_monotonic_value);if ($now > $wait_start_time + $opts->{'wait_time'}){$do_wait=0;next}my$waitpid=waitpid($pid,POSIX::WNOHANG);if ($waitpid eq -1){$child_finished=1;$do_wait=0;next}Time::HiRes::usleep(250000)}if (!$child_finished){if ($opts->{'final_kill_type'}eq 'just_process'){kill(9,$pid)}elsif ($opts->{'final_kill_type'}eq 'process_group'){kill(-9,$pid)}}}sub open3_run {my ($cmd,$opts)=@_;$opts={}unless$opts;my$child_in=FileHandle->new;my$child_out=FileHandle->new;my$child_err=FileHandle->new;$child_out->autoflush(1);$child_err->autoflush(1);my$pid=open3($child_in,$child_out,$child_err,$cmd);Time::HiRes::usleep(1)if IS_HPUX;my$original_ppid=$opts->{'original_ppid'};if ($opts->{'parent_info'}){my$ps=$opts->{'parent_info'};print$ps "spawned $pid\n"}if ($child_in && $child_out->opened && $opts->{'child_stdin'}){local$SIG{'PIPE'}=sub {1};print$child_in $opts->{'child_stdin'}}close($child_in);my$child_output={'out'=>$child_out->fileno,'err'=>$child_err->fileno,$child_out->fileno=>{'parent_socket'=>$opts->{'parent_stdout'},'scalar_buffer'=>"",'child_handle'=>$child_out,'block_size'=>($child_out->stat)[11]|| 1024,},$child_err->fileno=>{'parent_socket'=>$opts->{'parent_stderr'},'scalar_buffer'=>"",'child_handle'=>$child_err,'block_size'=>($child_err->stat)[11]|| 1024,},};my$select=IO::Select->new();$select->add($child_out,$child_err);SIGNAL: foreach my$s (keys%SIG){next SIGNAL if$s eq '__WARN__' or $s eq '__DIE__';my$sig_handler;$sig_handler=sub {kill("$s",$pid);$SIG{$s}=$sig_handler};$SIG{$s}=$sig_handler}my$child_finished=0;my$real_exit;my$exit_value;while(!$child_finished){if (getppid()!=$original_ppid){kill(-9,$$);POSIX::_exit 1}my$waitpid=waitpid($pid,POSIX::WNOHANG);if ($waitpid ne 0 && $waitpid ne -1){$real_exit=$?;$exit_value=$? >> 8}if ($waitpid eq -1){$child_finished=1}my$ready_fds=[];push @{$ready_fds},$select->can_read(1/100);READY_FDS: while (scalar(@{$ready_fds})){my$fd=shift @{$ready_fds};$ready_fds=[grep {$_ ne $fd}@{$ready_fds}];my$str=$child_output->{$fd->fileno};Carp::confess("child stream not found: $fd")unless$str;my$data;my$count=$fd->sysread($data,$str->{'block_size'});if ($count){if ($str->{'parent_socket'}){my$ph=$str->{'parent_socket'};print$ph $data}else {$str->{'scalar_buffer'}.= $data}}elsif ($count eq 0){$select->remove($fd);$fd->close()}else {Carp::confess("error during sysread: " .$!)}push @{$ready_fds},$select->can_read(1/100)if$child_finished}Time::HiRes::usleep(1)}if ($opts->{'parent_info'}){my$ps=$opts->{'parent_info'};if ($real_exit & 127){print$ps "$pid killed with " .($real_exit & 127)."\n"}print$ps "reaped $pid\n"}if ($opts->{'parent_stdout'}|| $opts->{'parent_stderr'}){return$exit_value}else {return {'stdout'=>$child_output->{$child_output->{'out'}}->{'scalar_buffer'},'stderr'=>$child_output->{$child_output->{'err'}}->{'scalar_buffer'},'exit_code'=>$exit_value,}}}sub run_forked {my$self=bless {},__PACKAGE__;if (!can_use_run_forked()){Carp::carp("run_forked is not available: $CAN_USE_RUN_FORKED");return}require POSIX;my ($cmd,$opts)=@_;if (ref($cmd)eq 'ARRAY'){$cmd=join(" ",@{$cmd})}if (!$cmd){Carp::carp("run_forked expects command to run");return}$opts={}unless$opts;$opts->{'timeout'}=0 unless$opts->{'timeout'};$opts->{'terminate_wait_time'}=2 unless defined($opts->{'terminate_wait_time'});$opts->{'clean_up_children'}=1 unless defined($opts->{'clean_up_children'});my$child_stdout_socket;my$parent_stdout_socket;my$child_stderr_socket;my$parent_stderr_socket;my$child_info_socket;my$parent_info_socket;socketpair($child_stdout_socket,$parent_stdout_socket,&Socket::AF_UNIX,&Socket::SOCK_STREAM,&Socket::PF_UNSPEC)|| Carp::confess ("socketpair: $!");socketpair($child_stderr_socket,$parent_stderr_socket,&Socket::AF_UNIX,&Socket::SOCK_STREAM,&Socket::PF_UNSPEC)|| Carp::confess ("socketpair: $!");socketpair($child_info_socket,$parent_info_socket,&Socket::AF_UNIX,&Socket::SOCK_STREAM,&Socket::PF_UNSPEC)|| Carp::confess ("socketpair: $!");$child_stdout_socket->autoflush(1);$parent_stdout_socket->autoflush(1);$child_stderr_socket->autoflush(1);$parent_stderr_socket->autoflush(1);$child_info_socket->autoflush(1);$parent_info_socket->autoflush(1);my$start_time=get_monotonic_time();my$pid;my$ppid=$$;if ($pid=fork){close($parent_stdout_socket);close($parent_stderr_socket);close($parent_info_socket);my$flags;$flags=fcntl($child_stdout_socket,POSIX::F_GETFL,0)|| Carp::confess "can't fnctl F_GETFL: $!";$flags |= POSIX::O_NONBLOCK;fcntl($child_stdout_socket,POSIX::F_SETFL,$flags)|| Carp::confess "can't fnctl F_SETFL: $!";$flags=fcntl($child_stderr_socket,POSIX::F_GETFL,0)|| Carp::confess "can't fnctl F_GETFL: $!";$flags |= POSIX::O_NONBLOCK;fcntl($child_stderr_socket,POSIX::F_SETFL,$flags)|| Carp::confess "can't fnctl F_SETFL: $!";$flags=fcntl($child_info_socket,POSIX::F_GETFL,0)|| Carp::confess "can't fnctl F_GETFL: $!";$flags |= POSIX::O_NONBLOCK;fcntl($child_info_socket,POSIX::F_SETFL,$flags)|| Carp::confess "can't fnctl F_SETFL: $!";my$child_output={$child_stdout_socket->fileno=>{'scalar_buffer'=>"",'child_handle'=>$child_stdout_socket,'block_size'=>($child_stdout_socket->stat)[11]|| 1024,'protocol'=>'stdout',},$child_stderr_socket->fileno=>{'scalar_buffer'=>"",'child_handle'=>$child_stderr_socket,'block_size'=>($child_stderr_socket->stat)[11]|| 1024,'protocol'=>'stderr',},$child_info_socket->fileno=>{'scalar_buffer'=>"",'child_handle'=>$child_info_socket,'block_size'=>($child_info_socket->stat)[11]|| 1024,'protocol'=>'info',},};my$select=IO::Select->new();$select->add($child_stdout_socket,$child_stderr_socket,$child_info_socket);my$child_timedout=0;my$child_finished=0;my$child_stdout='';my$child_stderr='';my$child_merged='';my$child_exit_code=0;my$child_killed_by_signal=0;my$parent_died=0;my$last_parent_check=0;my$got_sig_child=0;my$got_sig_quit=0;my$orig_sig_child=$SIG{'CHLD'};$SIG{'CHLD'}=sub {$got_sig_child=get_monotonic_time()};if ($opts->{'terminate_on_signal'}){install_layered_signal($opts->{'terminate_on_signal'},sub {$got_sig_quit=time()})}my$child_child_pid;my$now;my$previous_monotonic_value;while (!$child_finished){$previous_monotonic_value=$now;$now=get_monotonic_time();adjust_monotonic_start_time([\$start_time,\$last_parent_check,\$got_sig_child],$now,$previous_monotonic_value);if ($opts->{'terminate_on_parent_sudden_death'}){if ($now > $last_parent_check + 5){if (getppid()eq "1"){kill_gently ($pid,{'first_kill_type'=>'process_group','final_kill_type'=>'process_group','wait_time'=>$opts->{'terminate_wait_time'}});$parent_died=1}$last_parent_check=$now}}if ($opts->{'timeout'}){if ($now > $start_time + $opts->{'timeout'}){kill_gently ($pid,{'first_kill_type'=>'process_group','final_kill_type'=>'process_group','wait_time'=>$opts->{'terminate_wait_time'}});$child_timedout=1}}if ($got_sig_child){if ($now > $got_sig_child + 10){print STDERR "waitpid did not return -1 for 10 seconds after SIG_CHLD, killing [$pid]\n";kill (-9,$pid);$child_finished=1}}if ($got_sig_quit){kill_gently ($pid,{'first_kill_type'=>'process_group','final_kill_type'=>'process_group','wait_time'=>$opts->{'terminate_wait_time'}});$child_finished=1}my$waitpid=waitpid($pid,POSIX::WNOHANG);if ($waitpid ne 0 && $waitpid ne -1){$child_exit_code=$? >> 8}if ($waitpid eq -1){$child_finished=1}my$ready_fds=[];push @{$ready_fds},$select->can_read(1/100);READY_FDS: while (scalar(@{$ready_fds})){my$fd=shift @{$ready_fds};$ready_fds=[grep {$_ ne $fd}@{$ready_fds}];my$str=$child_output->{$fd->fileno};Carp::confess("child stream not found: $fd")unless$str;my$data="";my$count=$fd->sysread($data,$str->{'block_size'});if ($count){if ($data =~ /(.+\n)([^\n]*)/so){$data=$str->{'scalar_buffer'}.$1;$str->{'scalar_buffer'}=$2 || ""}else {$str->{'scalar_buffer'}.= $data;$data=""}}elsif ($count eq 0){$select->remove($fd);$fd->close();if ($str->{'scalar_buffer'}){$data=$str->{'scalar_buffer'}."\n"}}else {Carp::confess("error during sysread on [$fd]: " .$!)}if ($str->{'protocol'}eq 'info'){if ($data =~ /^spawned ([0-9]+?)\n(.*?)/so){$child_child_pid=$1;$data=$2}if ($data =~ /^reaped ([0-9]+?)\n(.*?)/so){$child_child_pid=undef;$data=$2}if ($data =~ /^[\d]+ killed with ([0-9]+?)\n(.*?)/so){$child_killed_by_signal=$1;$data=$2}if ($data){Carp::confess("info protocol violation: [$data]")}}if ($str->{'protocol'}eq 'stdout'){if (!$opts->{'discard_output'}){$child_stdout .= $data;$child_merged .= $data}if ($opts->{'stdout_handler'}&& ref($opts->{'stdout_handler'})eq 'CODE'){$opts->{'stdout_handler'}->($data)}}if ($str->{'protocol'}eq 'stderr'){if (!$opts->{'discard_output'}){$child_stderr .= $data;$child_merged .= $data}if ($opts->{'stderr_handler'}&& ref($opts->{'stderr_handler'})eq 'CODE'){$opts->{'stderr_handler'}->($data)}}push @{$ready_fds},$select->can_read(1/100)if$child_finished}if ($opts->{'wait_loop_callback'}&& ref($opts->{'wait_loop_callback'})eq 'CODE'){$opts->{'wait_loop_callback'}->()}Time::HiRes::usleep(1)}if ($child_child_pid){kill_gently($child_child_pid)}if ($opts->{'clean_up_children'}){kill(-9,$pid)}close($child_stdout_socket);close($child_stderr_socket);close($child_info_socket);my$o={'stdout'=>$child_stdout,'stderr'=>$child_stderr,'merged'=>$child_merged,'timeout'=>$child_timedout ? $opts->{'timeout'}: 0,'exit_code'=>$child_exit_code,'parent_died'=>$parent_died,'killed_by_signal'=>$child_killed_by_signal,'child_pgid'=>$pid,'cmd'=>$cmd,};my$err_msg='';if ($o->{'exit_code'}){$err_msg .= "exited with code [$o->{'exit_code'}]\n"}if ($o->{'timeout'}){$err_msg .= "ran more than [$o->{'timeout'}] seconds\n"}if ($o->{'parent_died'}){$err_msg .= "parent died\n"}if ($o->{'stdout'}&&!$opts->{'non_empty_stdout_ok'}){$err_msg .= "stdout:\n" .$o->{'stdout'}."\n"}if ($o->{'stderr'}){$err_msg .= "stderr:\n" .$o->{'stderr'}."\n"}if ($o->{'killed_by_signal'}){$err_msg .= "killed by signal [" .$o->{'killed_by_signal'}."]\n"}$o->{'err_msg'}=$err_msg;if ($orig_sig_child){$SIG{'CHLD'}=$orig_sig_child}else {delete($SIG{'CHLD'})}uninstall_signals();return$o}else {Carp::confess("cannot fork: $!")unless defined($pid);POSIX::setsid()==-1 and Carp::confess("Error running setsid: " .$!);if ($opts->{'child_BEGIN'}&& ref($opts->{'child_BEGIN'})eq 'CODE'){$opts->{'child_BEGIN'}->()}close($child_stdout_socket);close($child_stderr_socket);close($child_info_socket);my$child_exit_code;if (!ref($cmd)){$child_exit_code=open3_run($cmd,{'parent_info'=>$parent_info_socket,'parent_stdout'=>$parent_stdout_socket,'parent_stderr'=>$parent_stderr_socket,'child_stdin'=>$opts->{'child_stdin'},'original_ppid'=>$ppid,})}elsif (ref($cmd)eq 'CODE'){open STDOUT,'>&',$parent_stdout_socket || Carp::confess("Unable to reopen STDOUT: $!\n");open STDERR,'>&',$parent_stderr_socket || Carp::confess("Unable to reopen STDERR: $!\n");$child_exit_code=$cmd->({'opts'=>$opts,'parent_info'=>$parent_info_socket,'parent_stdout'=>$parent_stdout_socket,'parent_stderr'=>$parent_stderr_socket,'child_stdin'=>$opts->{'child_stdin'},})}else {print$parent_stderr_socket "Invalid command reference: " .ref($cmd)."\n";$child_exit_code=1}close($parent_stdout_socket);close($parent_stderr_socket);close($parent_info_socket);if ($opts->{'child_END'}&& ref($opts->{'child_END'})eq 'CODE'){$opts->{'child_END'}->()}$|=1;POSIX::_exit$child_exit_code}}sub run {my$self=bless {},__PACKAGE__;my%hash=@_;my$def_buf='';my($verbose,$cmd,$buffer,$timeout);my$tmpl={verbose=>{default=>$VERBOSE,store=>\$verbose },buffer=>{default=>\$def_buf,store=>\$buffer },command=>{required=>1,store=>\$cmd,allow=>sub {!ref($_[0])or ref($_[0])eq 'ARRAY'},},timeout=>{default=>0,store=>\$timeout },};unless(check($tmpl,\%hash,$VERBOSE)){Carp::carp(loc("Could not validate input: %1",Params::Check->last_error));return};$cmd=_quote_args_vms($cmd)if IS_VMS;if ($ALLOW_NULL_ARGS){$cmd=[grep {defined}@$cmd ]if ref$cmd}else {$cmd=[grep {defined && length}@$cmd ]if ref$cmd}my$pp_cmd=(ref$cmd ? "@$cmd" : $cmd);print loc("Running [%1]...\n",$pp_cmd)if$verbose;my(@buffer,@buff_err,@buff_out);my$_out_handler=sub {my$buf=shift;return unless defined$buf;print STDOUT$buf if$verbose;push@buffer,$buf;push@buff_out,$buf};my$_err_handler=sub {my$buf=shift;return unless defined$buf;print STDERR$buf if$verbose;push@buffer,$buf;push@buff_err,$buf};my$have_buffer=$self->can_capture_buffer ? 1 : 0;my$ok;local $?;local $@;local $!;eval {local$SIG{ALRM}=sub {die bless sub {ALARM_CLASS .qq[: Command '$pp_cmd' aborted by alarm after $timeout seconds]},ALARM_CLASS}if$timeout;alarm$timeout || 0;if(!IS_WIN32 and $USE_IPC_RUN and $self->can_use_ipc_run(1)){$self->_debug("# Using IPC::Run. Have buffer: $have_buffer")if$DEBUG;$ok=$self->_ipc_run($cmd,$_out_handler,$_err_handler)}elsif ($USE_IPC_OPEN3 and $self->can_use_ipc_open3(1)){$self->_debug("# Using IPC::Open3. Have buffer: $have_buffer")if$DEBUG;my$method=IS_WIN32 ? '_open3_run_win32' : '_open3_run';$ok=$self->$method($cmd,$_out_handler,$_err_handler,$verbose)}else {$self->_debug("# Using system(). Have buffer: $have_buffer")if$DEBUG;$ok=$self->_system_run($cmd,$verbose)}alarm 0};$self->__reopen_fds(@{$self->_fds})if$self->_fds;my$err;unless($ok){if ($@ and ref $@ and $@->isa(ALARM_CLASS)){$err=$@->()}else {$err=$self->error}}$$buffer=join '',@buffer if@buffer;return wantarray ? $have_buffer ? ($ok,$err,\@buffer,\@buff_out,\@buff_err): ($ok,$err): $ok}sub _open3_run_win32 {my$self=shift;my$cmd=shift;my$outhand=shift;my$errhand=shift;require Socket;my$pipe=sub {socketpair($_[0],$_[1],&Socket::AF_UNIX,&Socket::SOCK_STREAM,&Socket::PF_UNSPEC)or return undef;shutdown($_[0],1);shutdown($_[1],0);return 1};my$open3=sub {local (*TO_CHLD_R,*TO_CHLD_W);local (*FR_CHLD_R,*FR_CHLD_W);local (*FR_CHLD_ERR_R,*FR_CHLD_ERR_W);$pipe->(*TO_CHLD_R,*TO_CHLD_W)or die $^E;$pipe->(*FR_CHLD_R,*FR_CHLD_W)or die $^E;$pipe->(*FR_CHLD_ERR_R,*FR_CHLD_ERR_W)or die $^E;my$pid=IPC::Open3::open3('>&TO_CHLD_R','<&FR_CHLD_W','<&FR_CHLD_ERR_W',@_);return ($pid,*TO_CHLD_W,*FR_CHLD_R,*FR_CHLD_ERR_R)};$cmd=[grep {defined && length}@$cmd ]if ref$cmd;$cmd=$self->__fix_cmd_whitespace_and_special_chars($cmd);my ($pid,$to_chld,$fr_chld,$fr_chld_err)=$open3->((ref$cmd ? @$cmd : $cmd));my$in_sel=IO::Select->new();my$out_sel=IO::Select->new();my%objs;$objs{fileno($fr_chld)}=$outhand;$objs{fileno($fr_chld_err)}=$errhand;$in_sel->add($fr_chld);$in_sel->add($fr_chld_err);close($to_chld);while ($in_sel->count()+ $out_sel->count()){my ($ins,$outs)=IO::Select::select($in_sel,$out_sel,undef);for my$fh (@$ins){my$obj=$objs{fileno($fh)};my$buf;my$bytes_read=sysread($fh,$buf,64*1024);if (!$bytes_read){$in_sel->remove($fh)}else {$obj->("$buf")}}for my$fh (@$outs){}}waitpid($pid,0);if($?){$self->error($self->_pp_child_error($cmd,$?));$self->ok(0);return}else {return$self->ok(1)}}sub _open3_run {my$self=shift;my$cmd=shift;my$_out_handler=shift;my$_err_handler=shift;my$verbose=shift || 0;use Symbol;my$kidout=Symbol::gensym();my$kiderror=Symbol::gensym();my@fds_to_dup=(IS_WIN32 &&!$verbose ? qw[STDIN STDOUT STDERR] : qw[STDIN]);$self->_fds(\@fds_to_dup);$self->__dup_fds(@fds_to_dup);$cmd=$self->__fix_cmd_whitespace_and_special_chars($cmd);my$pid=eval {IPC::Open3::open3('<&STDIN',(IS_WIN32 ? '>&STDOUT' : $kidout),(IS_WIN32 ? '>&STDERR' : $kiderror),(ref$cmd ? @$cmd : $cmd),)};if($@ and $@ =~ /^open3:/){$self->ok(0);$self->error($@);return};my$selector=IO::Select->new((IS_WIN32 ? \*STDERR : $kiderror),\*STDIN,(IS_WIN32 ? \*STDOUT : $kidout));STDOUT->autoflush(1);STDERR->autoflush(1);STDIN->autoflush(1);$kidout->autoflush(1)if UNIVERSAL::can($kidout,'autoflush');$kiderror->autoflush(1)if UNIVERSAL::can($kiderror,'autoflush');my$stdout_done=0;my$stderr_done=0;OUTER: while (my@ready=$selector->can_read){for my$h (@ready){my$buf;my$len=sysread($h,$buf,4096);if(not defined$len){warn(loc("Error reading from process: %1",$!));last OUTER}$_out_handler->("$buf")if$len && $h==$kidout;$_err_handler->("$buf")if$len && $h==$kiderror;$stdout_done=1 if$h==$kidout and $len==0;$stderr_done=1 if$h==$kiderror and $len==0;last OUTER if ($stdout_done && $stderr_done)}}waitpid$pid,0;if($?){$self->error($self->_pp_child_error($cmd,$?));$self->ok(0);return}else {return$self->ok(1)}}{my$parse_sub=IS_WIN32 ? __PACKAGE__->can('_split_like_shell_win32'): Text::ParseWords->can('shellwords');sub _ipc_run {my$self=shift;my$cmd=shift;my$_out_handler=shift;my$_err_handler=shift;STDOUT->autoflush(1);STDERR->autoflush(1);my@command;my$special_chars;my$re=do {my$x=join '',SPECIAL_CHARS;qr/([$x])/};if(ref$cmd){my$aref=[];for my$item (@$cmd){if($item =~ $re){push@command,$aref,$item;$aref=[];$special_chars .= $1}else {push @$aref,$item}}push@command,$aref}else {@command=map {if($_ =~ $re){$special_chars .= $1;$_}else {[map {m/[ ]/ ? qq{'$_'} : $_}$parse_sub->($_)]}}split(/\s*$re\s*/,$cmd)}my$ok=eval {IPC::Run::run(@command,fileno(STDOUT).'>',$_out_handler,fileno(STDERR).'>',$_err_handler)};if($ok){return$self->ok($ok)}else {$self->ok(0);if($@ and not UNIVERSAL::isa($@,ALARM_CLASS)){$self->error($@)}elsif($@){die $@}else {$self->error($self->_pp_child_error($cmd,$?))}return}}}sub _system_run {my$self=shift;my$cmd=shift;my$verbose=shift || 0;$cmd=$self->__fix_cmd_whitespace_and_special_chars($cmd);my@fds_to_dup=$verbose ? (): qw[STDOUT STDERR];$self->_fds(\@fds_to_dup);$self->__dup_fds(@fds_to_dup);$self->ok(1);system(ref$cmd ? @$cmd : $cmd)==0 or do {$self->error($self->_pp_child_error($cmd,$?));$self->ok(0)};return unless$self->ok;return$self->ok}{my%sc_lookup=map {$_=>$_}SPECIAL_CHARS;sub __fix_cmd_whitespace_and_special_chars {my$self=shift;my$cmd=shift;if(ref$cmd and grep {$sc_lookup{$_}}@$cmd){my$fixed;my@cmd=map {/ / ? do {$fixed++;QUOTE.$_.QUOTE}: $_}@$cmd;$self->_debug("# Quoted $fixed arguments containing whitespace")if$DEBUG && $fixed;$cmd=join ' ',@cmd}return$cmd}}sub _quote_args_vms {my@args=@_;my$got_arrayref=(scalar(@args)==1 && UNIVERSAL::isa($args[0],'ARRAY'))? 1 : 0;@args=split(/\s+/,$args[0])unless$got_arrayref || scalar(@args)> 1;my$cmd=$got_arrayref ? shift @{$args[0]}: shift@args;map {if (/^[^\/\"]/){$_ =~ s/\"/""/g;$_=q(").$_.q(")}}($got_arrayref ? @{$args[0]}: @args);$got_arrayref ? unshift(@{$args[0]},$cmd): unshift(@args,$cmd);return$got_arrayref ? $args[0]: join(' ',@args)}sub _split_like_shell_win32 {local $_=shift;my@argv;return@argv unless defined()&& length();my$arg='';my($i,$quote_mode)=(0,0);while ($i < length()){my$ch=substr($_,$i,1);my$next_ch=substr($_,$i+1,1);if ($ch eq '\\' && $next_ch eq '"'){$arg .= '"';$i++}elsif ($ch eq '\\' && $next_ch eq '\\'){$arg .= '\\';$i++}elsif ($ch eq '"' && $next_ch eq '"' && $quote_mode){$quote_mode=!$quote_mode;$arg .= '"';$i++}elsif ($ch eq '"' && $next_ch eq '"' &&!$quote_mode && ($i + 2==length()|| substr($_,$i + 2,1)eq ' ')){push(@argv,$arg);$arg='';$i += 2}elsif ($ch eq '"'){$quote_mode=!$quote_mode}elsif ($ch eq ' ' &&!$quote_mode){push(@argv,$arg)if defined($arg)&& length($arg);$arg='';++$i while substr($_,$i + 1,1)eq ' '}else {$arg .= $ch}$i++}push(@argv,$arg)if defined($arg)&& length($arg);return@argv}{use File::Spec;use Symbol;my%Map=(STDOUT=>[qw|>&|,\*STDOUT,Symbol::gensym()],STDERR=>[qw|>&|,\*STDERR,Symbol::gensym()],STDIN=>[qw|<&|,\*STDIN,Symbol::gensym()],);sub __dup_fds {my$self=shift;my@fds=@_;__PACKAGE__->_debug("# Closing the following fds: @fds")if$DEBUG;for my$name (@fds){my($redir,$fh,$glob)=@{$Map{$name}}or (Carp::carp(loc("No such FD: '%1'",$name)),next);open$glob,$redir .fileno($fh)or (Carp::carp(loc("Could not dup '$name': %1",$!)),return);if($redir eq '>&'){open($fh,'>' .File::Spec->devnull)or (Carp::carp(loc("Could not reopen '$name': %1",$!)),return)}}return 1}sub __reopen_fds {my$self=shift;my@fds=@_;__PACKAGE__->_debug("# Reopening the following fds: @fds")if$DEBUG;for my$name (@fds){my($redir,$fh,$glob)=@{$Map{$name}}or (Carp::carp(loc("No such FD: '%1'",$name)),next);open($fh,$redir .fileno($glob))or (Carp::carp(loc("Could not restore '$name': %1",$!)),return);close$glob}return 1}}sub _debug {my$self=shift;my$msg=shift or return;my$level=shift || 0;local$Carp::CarpLevel += $level;Carp::carp($msg);return 1}sub _pp_child_error {my$self=shift;my$cmd=shift or return;my$ce=shift or return;my$pp_cmd=ref$cmd ? "@$cmd" : $cmd;my$str;if($ce==-1){$str="Failed to execute '$pp_cmd': $!"}elsif ($ce & 127){$str=loc("'%1' died with signal %2, %3 coredump",$pp_cmd,($ce & 127),($ce & 128)? 'with' : 'without')}else {$str="'$pp_cmd' exited with value " .($ce >> 8)}$self->_debug("# Child error '$ce' translated to: $str")if$DEBUG;return$str}1;
IPC_CMD

$fatpacked{"IPC/Run3.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3';
  package IPC::Run3;BEGIN {require 5.006_000}use strict;our$VERSION='0.048';use Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(run3);our%EXPORT_TAGS=(all=>\@EXPORT);use constant debugging=>$ENV{IPCRUN3DEBUG}|| $ENV{IPCRUNDEBUG}|| 0;use constant profiling=>$ENV{IPCRUN3PROFILE}|| $ENV{IPCRUNPROFILE}|| 0;use constant is_win32=>0 <= index $^O,"Win32";BEGIN {if (is_win32){eval "use Win32 qw( GetOSName ); use Win32::ShellQuote qw(quote_native); 1" or die $@}}use Carp qw(croak);use File::Temp qw(tempfile);use POSIX qw(dup dup2);my%fh_cache;my$fh_cache_pid=$$;my$profiler;sub _profiler {$profiler}BEGIN {if (profiling){eval "use Time::HiRes qw( gettimeofday ); 1" or die $@;if ($ENV{IPCRUN3PROFILE}=~ /\A\d+\z/){require IPC::Run3::ProfPP;IPC::Run3::ProfPP->import;$profiler=IPC::Run3::ProfPP->new(Level=>$ENV{IPCRUN3PROFILE})}else {my ($dest,undef,$class)=reverse split /(=)/,$ENV{IPCRUN3PROFILE},2;$class="IPC::Run3::ProfLogger" unless defined$class && length$class;if (not eval "require $class"){my$e=$@;$class="IPC::Run3::$class";eval "require IPC::Run3::$class" or die$e}$profiler=$class->new(Destination=>$dest)}$profiler->app_call([$0,@ARGV ],scalar gettimeofday())}}END {$profiler->app_exit(scalar gettimeofday())if profiling}sub _binmode {my ($fh,$mode,$what)=@_;my$layer=!$mode ? (is_win32 ? ":crlf" : ":raw"): ($mode =~ /^:/ ? $mode : ":raw");warn "binmode $what, $layer\n" if debugging >= 2;binmode$fh,":raw" unless$layer eq ":raw";binmode$fh,$layer or croak "binmode $layer failed: $!"}sub _spool_data_to_child {my ($type,$source,$binmode_it)=@_;return undef unless defined$source;my$fh;if (!$type){open$fh,"<",$source or croak "$!: $source";_binmode($fh,$binmode_it,"STDIN");warn "run3(): feeding file '$source' to child STDIN\n" if debugging >= 2}elsif ($type eq "FH"){$fh=$source;warn "run3(): feeding filehandle '$source' to child STDIN\n" if debugging >= 2}else {$fh=$fh_cache{in}||= tempfile;truncate$fh,0;seek$fh,0,0;_binmode($fh,$binmode_it,"STDIN");my$seekit;if ($type eq "SCALAR"){return$fh unless defined $$source;warn "run3(): feeding SCALAR to child STDIN",debugging >= 3 ? (": '",$$source,"' (",length $$source," chars)"): (),"\n" if debugging >= 2;$seekit=length $$source;print$fh $$source or die "$! writing to temp file"}elsif ($type eq "ARRAY"){warn "run3(): feeding ARRAY to child STDIN",debugging >= 3 ? (": '",@$source,"'"): (),"\n" if debugging >= 2;print$fh @$source or die "$! writing to temp file";$seekit=grep length,@$source}elsif ($type eq "CODE"){warn "run3(): feeding output of CODE ref '$source' to child STDIN\n" if debugging >= 2;my$parms=[];while (1){my$data=$source->(@$parms);last unless defined$data;print$fh $data or die "$! writing to temp file";$seekit=length$data}}seek$fh,0,0 or croak "$! seeking on temp file for child's stdin" if$seekit}croak "run3() can't redirect $type to child stdin" unless defined$fh;return$fh}sub _fh_for_child_output {my ($what,$type,$dest,$options)=@_;my$fh;if ($type eq "SCALAR" && $dest==\undef){warn "run3(): redirecting child $what to oblivion\n" if debugging >= 2;$fh=$fh_cache{nul}||= do {open$fh,">",File::Spec->devnull;$fh}}elsif ($type eq "FH"){$fh=$dest;warn "run3(): redirecting $what to filehandle '$dest'\n" if debugging >= 3}elsif (!$type){warn "run3(): feeding child $what to file '$dest'\n" if debugging >= 2;open$fh,$options->{"append_$what"}? ">>" : ">",$dest or croak "$!: $dest"}else {warn "run3(): capturing child $what\n" if debugging >= 2;$fh=$fh_cache{$what}||= tempfile;seek$fh,0,0;truncate$fh,0}my$binmode_it=$options->{"binmode_$what"};_binmode($fh,$binmode_it,uc$what);return$fh}sub _read_child_output_fh {my ($what,$type,$dest,$fh,$options)=@_;return if$type eq "SCALAR" && $dest==\undef;seek$fh,0,0 or croak "$! seeking on temp file for child $what";if ($type eq "SCALAR"){warn "run3(): reading child $what to SCALAR\n" if debugging >= 3;my$count=read$fh,$$dest,10_000,$options->{"append_$what"}? length $$dest : 0;while (1){croak "$! reading child $what from temp file" unless defined$count;last unless$count;warn "run3(): read $count bytes from child $what",debugging >= 3 ? (": '",substr($$dest,-$count),"'"): (),"\n" if debugging >= 2;$count=read$fh,$$dest,10_000,length $$dest}}elsif ($type eq "ARRAY"){if ($options->{"append_$what"}){push @$dest,<$fh>}else {@$dest=<$fh>}if (debugging >= 2){my$count=0;$count += length for @$dest;warn "run3(): read ",scalar @$dest," records, $count bytes from child $what",debugging >= 3 ? (": '",@$dest,"'"): (),"\n"}}elsif ($type eq "CODE"){warn "run3(): capturing child $what to CODE ref\n" if debugging >= 3;local $_;while (<$fh>){warn "run3(): read ",length," bytes from child $what",debugging >= 3 ? (": '",$_,"'"): (),"\n" if debugging >= 2;$dest->($_)}}else {croak "run3() can't redirect child $what to a $type"}}sub _type {my ($redir)=@_;return "FH" if eval {local$SIG{'__DIE__'};$redir->isa("IO::Handle")};my$type=ref$redir;return$type eq "GLOB" ? "FH" : $type}sub _max_fd {my$fd=dup(0);POSIX::close$fd;return$fd}my$run_call_time;my$sys_call_time;my$sys_exit_time;sub run3 {$run_call_time=gettimeofday()if profiling;my$options=@_ && ref $_[-1]eq "HASH" ? pop : {};my ($cmd,$stdin,$stdout,$stderr)=@_;print STDERR "run3(): running ",join(" ",map "'$_'",ref$cmd ? @$cmd : $cmd),"\n" if debugging;if (ref$cmd){croak "run3(): empty command" unless @$cmd;croak "run3(): undefined command" unless defined$cmd->[0];croak "run3(): command name ('')" unless length$cmd->[0]}else {croak "run3(): missing command" unless @_;croak "run3(): undefined command" unless defined$cmd;croak "run3(): command ('')" unless length$cmd}for (qw/binmode_stdin binmode_stdout binmode_stderr/){if (my$mode=$options->{$_}){croak qq[option $_ must be a number or a proper layer string: "$mode"] unless$mode =~ /^(:|\d+$)/}}my$in_type=_type$stdin;my$out_type=_type$stdout;my$err_type=_type$stderr;if ($fh_cache_pid!=$$){close $_ foreach values%fh_cache;%fh_cache=();$fh_cache_pid=$$}my$in_fh=_spool_data_to_child$in_type,$stdin,$options->{binmode_stdin}if defined$stdin;my$out_fh=_fh_for_child_output "stdout",$out_type,$stdout,$options if defined$stdout;my$tie_err_to_out=defined$stderr && defined$stdout && $stderr eq $stdout;my$err_fh=$tie_err_to_out ? $out_fh : _fh_for_child_output "stderr",$err_type,$stderr,$options if defined$stderr;local*STDOUT_SAVE;local*STDERR_SAVE;my$saved_fd0=dup(0)if defined$in_fh;open STDOUT_SAVE,">&STDOUT" or croak "run3(): $! saving STDOUT" if defined$out_fh;open STDERR_SAVE,">&STDERR" or croak "run3(): $! saving STDERR" if defined$err_fh;my$errno;my$ok=eval {dup2(fileno$in_fh,0)or croak "run3(): $! redirecting STDIN" if defined$in_fh;open STDOUT,">&" .fileno$out_fh or croak "run3(): $! redirecting STDOUT" if defined$out_fh;open STDERR,">&" .fileno$err_fh or croak "run3(): $! redirecting STDERR" if defined$err_fh;$sys_call_time=gettimeofday()if profiling;my$r=ref$cmd ? system {$cmd->[0]}is_win32 ? quote_native(@$cmd): @$cmd : system$cmd;$errno=$!;$sys_exit_time=gettimeofday()if profiling;if (debugging){my$err_fh=defined$err_fh ? \*STDERR_SAVE : \*STDERR;if (defined$r && $r!=-1){print$err_fh "run3(): \$? is $?\n"}else {print$err_fh "run3(): \$? is $?, \$! is $errno\n"}}if (defined$r && ($r==-1 || (is_win32 && $r==0xFF00))&&!$options->{return_if_system_error}){croak($errno)}1};my$x=$@;my@errs;if (defined$saved_fd0){dup2($saved_fd0,0);POSIX::close($saved_fd0)}open STDOUT,">&STDOUT_SAVE" or push@errs,"run3(): $! restoring STDOUT" if defined$out_fh;open STDERR,">&STDERR_SAVE" or push@errs,"run3(): $! restoring STDERR" if defined$err_fh;croak join ", ",@errs if@errs;die$x unless$ok;_read_child_output_fh "stdout",$out_type,$stdout,$out_fh,$options if defined$out_fh && $out_type && $out_type ne "FH";_read_child_output_fh "stderr",$err_type,$stderr,$err_fh,$options if defined$err_fh && $err_type && $err_type ne "FH" &&!$tie_err_to_out;$profiler->run_exit($cmd,$run_call_time,$sys_call_time,$sys_exit_time,scalar gettimeofday())if profiling;$!=$errno;return 1}1;
IPC_RUN3

$fatpacked{"IPC/Run3/ProfArrayBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFARRAYBUFFER';
  package IPC::Run3::ProfArrayBuffer;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Events}=[];return$self}for my$subname (qw(app_call app_exit run_exit)){no strict 'refs';*{$subname}=sub {push @{shift->{Events}},[$subname=>@_ ]}}sub get_events {my$self=shift;@{$self->{Events}}}1;
IPC_RUN3_PROFARRAYBUFFER

$fatpacked{"IPC/Run3/ProfLogReader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGREADER';
  package IPC::Run3::ProfLogReader;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Source}="run3.out" unless defined$self->{Source}&& length$self->{Source};my$source=$self->{Source};if (ref$source eq "GLOB" || UNIVERSAL::isa($source,"IO::Handle")){$self->{FH}=$source}elsif ($source eq "-"){$self->{FH}=\*STDIN}else {open PROFILE,"<$self->{Source}" or die "$!: $self->{Source}\n";$self->{FH}=*PROFILE{IO}}return$self}sub set_handler {$_[0]->{Handler}=$_[1]}sub get_handler {$_[0]->{Handler}}sub read {my$self=shift;my$fh=$self->{FH};my@ln=split / /,<$fh>;return 0 unless@ln;return 1 unless$self->{Handler};chomp$ln[-1];return 1 if@ln==1 &&!length$ln[0]|| 0==index$ln[0],"#";if ($ln[0]eq "\\app_call"){shift@ln;my@times=split /,/,pop@ln;$self->{Handler}->app_call([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}elsif ($ln[0]eq "\\app_exit"){shift@ln;$self->{Handler}->app_exit(pop@ln,@ln)}else {my@times=split /,/,pop@ln;$self->{Handler}->run_exit([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}return 1}sub read_all {my$self=shift;1 while$self->read;return 1}1;
IPC_RUN3_PROFLOGREADER

$fatpacked{"IPC/Run3/ProfLogger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGGER';
  package IPC::Run3::ProfLogger;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Destination}="run3.out" unless defined$self->{Destination}&& length$self->{Destination};open PROFILE,">$self->{Destination}" or die "$!: $self->{Destination}\n";binmode PROFILE;$self->{FH}=*PROFILE{IO};$self->{times}=[];return$self}sub run_exit {my$self=shift;my$fh=$self->{FH};print($fh join(" ",(map {my$s=$_;$s =~ s/\\/\\\\/g;$s =~ s/ /_/g;$s}@{shift()}),join(",",@{$self->{times}},@_,),),"\n")}sub app_exit {my$self=shift;my$fh=$self->{FH};print$fh "\\app_exit ",shift,"\n"}sub app_call {my$self=shift;my$fh=$self->{FH};my$t=shift;print($fh join(" ","\\app_call",(map {my$s=$_;$s =~ s/\\\\/\\/g;$s =~ s/ /\\_/g;$s}@_),$t,),"\n")}1;
IPC_RUN3_PROFLOGGER

$fatpacked{"IPC/Run3/ProfPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFPP';
  package IPC::Run3::ProfPP;$VERSION=0.048;require IPC::Run3::ProfReporter;@ISA=qw(IPC::Run3::ProfReporter);use strict;use POSIX qw(floor);sub _emit {shift;warn @_}sub _t {sprintf "%10.6f secs",@_}sub _r {my ($num,$denom)=@_;return ()unless$denom;sprintf "%10.6f",$num / $denom}sub _pct {my ($num,$denom)=@_;return ()unless$denom;sprintf " (%3d%%)",floor(100 * $num / $denom + 0.5)}sub handle_app_call {my$self=shift;$self->_emit("IPC::Run3 parent: ",join(" ",@{$self->get_app_cmd}),"\n",);$self->{NeedNL}=1}sub handle_app_exit {my$self=shift;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=1;$self->_emit("IPC::Run3 total elapsed:             ",_t($self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 calls to run3():    ",sprintf("%10d",$self->get_run_count),"\n");$self->_emit("IPC::Run3 total spent in run3():     ",_t($self->get_run_cumulative_time),_pct($self->get_run_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_run_cumulative_time,$self->get_run_count)," per call","\n");my$exclusive=$self->get_app_cumulative_time - $self->get_run_cumulative_time;$self->_emit("IPC::Run3 total spent not in run3(): ",_t($exclusive),_pct($exclusive,$self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 total spent in children:   ",_t($self->get_sys_cumulative_time),_pct($self->get_sys_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_sys_cumulative_time,$self->get_run_count)," per call","\n");my$overhead=$self->get_run_cumulative_time - $self->get_sys_cumulative_time;$self->_emit("IPC::Run3 total overhead:            ",_t($overhead),_pct($overhead,$self->get_sys_cumulative_time),", ",_r($overhead,$self->get_run_count)," per call","\n")}sub handle_run_exit {my$self=shift;my$overhead=$self->get_run_time - $self->get_sys_time;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=2;$self->{NeedNL}=3;$self->_emit("IPC::Run3 child: ",join(" ",@{$self->get_run_cmd}),"\n");$self->_emit("IPC::Run3 run3()  : ",_t($self->get_run_time),"\n","IPC::Run3 child   : ",_t($self->get_sys_time),"\n","IPC::Run3 overhead: ",_t($overhead),_pct($overhead,$self->get_sys_time),"\n")}1;
IPC_RUN3_PROFPP

$fatpacked{"IPC/Run3/ProfReporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFREPORTER';
  package IPC::Run3::ProfReporter;$VERSION=0.048;use strict;my$loaded_by;sub import {$loaded_by=shift}END {my@caller;for (my$i=0;;++$i ){my@c=caller$i;last unless@c;@caller=@c}if ($caller[0]eq "main" && $caller[1]eq "-e"){require IPC::Run3::ProfLogReader;require Getopt::Long;my ($app,$run);Getopt::Long::GetOptions("app"=>\$app,"run"=>\$run,);$app=1,$run=1 unless$app || $run;for (@ARGV ? @ARGV : ""){my$r=IPC::Run3::ProfLogReader->new(Source=>$_,Handler=>$loaded_by->new(Source=>$_,app_report=>$app,run_report=>$run,),);$r->read_all}}}sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{app_report}=1,$self->{run_report}=1 unless$self->{app_report}|| $self->{run_report};return$self}sub handle_app_call {}sub handle_app_exit {}sub handle_run_exit {}sub app_call {my$self=shift;($self->{app_cmd},$self->{app_call_time})=@_;$self->handle_app_call if$self->{app_report}}sub app_exit {my$self=shift;$self->{app_exit_time}=shift;$self->handle_app_exit if$self->{app_report}}sub run_exit {my$self=shift;@{$self}{qw(run_cmd run_call_time sys_call_time sys_exit_time run_exit_time)}=@_;++$self->{run_count};$self->{run_cumulative_time}+= $self->get_run_time;$self->{sys_cumulative_time}+= $self->get_sys_time;$self->handle_run_exit if$self->{run_report}}sub get_run_count {shift->{run_count}}sub get_app_call_time {shift->{app_call_time}}sub get_app_exit_time {shift->{app_exit_time}}sub get_app_cmd {shift->{app_cmd}}sub get_app_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_app_cumulative_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_run_call_time {shift->{run_call_time}}sub get_run_exit_time {shift->{run_exit_time}}sub get_run_time {my$self=shift;$self->get_run_exit_time - $self->get_run_call_time}sub get_run_cumulative_time {shift->{run_cumulative_time}}sub get_sys_call_time {shift->{sys_call_time}}sub get_sys_exit_time {shift->{sys_exit_time}}sub get_sys_time {my$self=shift;$self->get_sys_exit_time - $self->get_sys_call_time}sub get_sys_cumulative_time {shift->{sys_cumulative_time}}sub get_run_cmd {shift->{run_cmd}}1;
IPC_RUN3_PROFREPORTER

$fatpacked{"JSON/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP';
  package JSON::PP;use 5.005;use strict;use Exporter ();BEGIN {@JSON::PP::ISA=('Exporter')}use overload ();use JSON::PP::Boolean;use Carp ();$JSON::PP::VERSION='4.04';@JSON::PP::EXPORT=qw(encode_json decode_json from_json to_json);use constant P_ASCII=>0;use constant P_LATIN1=>1;use constant P_UTF8=>2;use constant P_INDENT=>3;use constant P_CANONICAL=>4;use constant P_SPACE_BEFORE=>5;use constant P_SPACE_AFTER=>6;use constant P_ALLOW_NONREF=>7;use constant P_SHRINK=>8;use constant P_ALLOW_BLESSED=>9;use constant P_CONVERT_BLESSED=>10;use constant P_RELAXED=>11;use constant P_LOOSE=>12;use constant P_ALLOW_BIGNUM=>13;use constant P_ALLOW_BAREKEY=>14;use constant P_ALLOW_SINGLEQUOTE=>15;use constant P_ESCAPE_SLASH=>16;use constant P_AS_NONBLESSED=>17;use constant P_ALLOW_UNKNOWN=>18;use constant P_ALLOW_TAGS=>19;use constant OLD_PERL=>$] < 5.008 ? 1 : 0;use constant USE_B=>$ENV{PERL_JSON_PP_USE_B}|| 0;BEGIN {if (USE_B){require B}}BEGIN {my@xs_compati_bit_properties=qw(latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink allow_blessed convert_blessed relaxed allow_unknown allow_tags);my@pp_bit_properties=qw(allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed);if (OLD_PERL){my$helper=$] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';eval qq| require $helper |;if ($@){Carp::croak $@}}for my$name (@xs_compati_bit_properties,@pp_bit_properties){my$property_id='P_' .uc($name);eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$property_id] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$property_id] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$property_id] ? 1 : '';
              }
          /}}my$JSON;sub encode_json ($) {($JSON ||= __PACKAGE__->new->utf8)->encode(@_)}sub decode_json {($JSON ||= __PACKAGE__->new->utf8)->decode(@_)}sub to_json($) {Carp::croak ("JSON::PP::to_json has been renamed to encode_json.")}sub from_json($) {Carp::croak ("JSON::PP::from_json has been renamed to decode_json.")}sub new {my$class=shift;my$self={max_depth=>512,max_size=>0,indent_length=>3,};$self->{PROPS}[P_ALLOW_NONREF]=1;bless$self,$class}sub encode {return $_[0]->PP_encode_json($_[1])}sub decode {return $_[0]->PP_decode_json($_[1],0x00000000)}sub decode_prefix {return $_[0]->PP_decode_json($_[1],0x00000001)}sub pretty {my ($self,$v)=@_;my$enable=defined$v ? $v : 1;if ($enable){$self->indent(1)->space_before(1)->space_after(1)}else {$self->indent(0)->space_before(0)->space_after(0)}$self}sub max_depth {my$max=defined $_[1]? $_[1]: 0x80000000;$_[0]->{max_depth}=$max;$_[0]}sub get_max_depth {$_[0]->{max_depth}}sub max_size {my$max=defined $_[1]? $_[1]: 0;$_[0]->{max_size}=$max;$_[0]}sub get_max_size {$_[0]->{max_size}}sub boolean_values {my$self=shift;if (@_){my ($false,$true)=@_;$self->{false}=$false;$self->{true}=$true;return ($false,$true)}else {delete$self->{false};delete$self->{true};return}}sub get_boolean_values {my$self=shift;if (exists$self->{true}and exists$self->{false}){return @$self{qw/false true/}}return}sub filter_json_object {if (defined $_[1]and ref $_[1]eq 'CODE'){$_[0]->{cb_object}=$_[1]}else {delete $_[0]->{cb_object}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub filter_json_single_key_object {if (@_==1 or @_ > 3){Carp::croak("Usage: JSON::PP::filter_json_single_key_object(self, key, callback = undef)")}if (defined $_[2]and ref $_[2]eq 'CODE'){$_[0]->{cb_sk_object}->{$_[1]}=$_[2]}else {delete $_[0]->{cb_sk_object}->{$_[1]};delete $_[0]->{cb_sk_object}unless %{$_[0]->{cb_sk_object}|| {}}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub indent_length {if (!defined $_[1]or $_[1]> 15 or $_[1]< 0){Carp::carp "The acceptable range of indent_length() is 0 to 15."}else {$_[0]->{indent_length}=$_[1]}$_[0]}sub get_indent_length {$_[0]->{indent_length}}sub sort_by {$_[0]->{sort_by}=defined $_[1]? $_[1]: 1;$_[0]}sub allow_bigint {Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");$_[0]->allow_bignum}{my$max_depth;my$indent;my$ascii;my$latin1;my$utf8;my$space_before;my$space_after;my$canonical;my$allow_blessed;my$convert_blessed;my$indent_length;my$escape_slash;my$bignum;my$as_nonblessed;my$allow_tags;my$depth;my$indent_count;my$keysort;sub PP_encode_json {my$self=shift;my$obj=shift;$indent_count=0;$depth=0;my$props=$self->{PROPS};($ascii,$latin1,$utf8,$indent,$canonical,$space_before,$space_after,$allow_blessed,$convert_blessed,$escape_slash,$bignum,$as_nonblessed,$allow_tags)=@{$props}[P_ASCII .. P_SPACE_AFTER,P_ALLOW_BLESSED,P_CONVERT_BLESSED,P_ESCAPE_SLASH,P_ALLOW_BIGNUM,P_AS_NONBLESSED,P_ALLOW_TAGS];($max_depth,$indent_length)=@{$self}{qw/max_depth indent_length/};$keysort=$canonical ? sub {$a cmp $b}: undef;if ($self->{sort_by}){$keysort=ref($self->{sort_by})eq 'CODE' ? $self->{sort_by}: $self->{sort_by}=~ /\D+/ ? $self->{sort_by}: sub {$a cmp $b}}encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")if(!ref$obj and!$props->[P_ALLOW_NONREF ]);my$str=$self->object_to_json($obj);$str .= "\n" if ($indent);unless ($ascii or $latin1 or $utf8){utf8::upgrade($str)}if ($props->[P_SHRINK ]){utf8::downgrade($str,1)}return$str}sub object_to_json {my ($self,$obj)=@_;my$type=ref($obj);if($type eq 'HASH'){return$self->hash_to_json($obj)}elsif($type eq 'ARRAY'){return$self->array_to_json($obj)}elsif ($type){if (blessed($obj)){return$self->value_to_json($obj)if ($obj->isa('JSON::PP::Boolean'));if ($allow_tags and $obj->can('FREEZE')){my$obj_class=ref$obj || $obj;$obj=bless$obj,$obj_class;my@results=$obj->FREEZE('JSON');if (@results and ref$results[0]){if (refaddr($obj)eq refaddr($results[0])){encode_error(sprintf("%s::FREEZE method returned same object as was passed instead of a new one",ref$obj))}}return '("'.$obj_class.'")['.join(',',@results).']'}if ($convert_blessed and $obj->can('TO_JSON')){my$result=$obj->TO_JSON();if (defined$result and ref($result)){if (refaddr($obj)eq refaddr($result)){encode_error(sprintf("%s::TO_JSON method returned same object as was passed instead of a new one",ref$obj))}}return$self->object_to_json($result)}return "$obj" if ($bignum and _is_bignum($obj));if ($allow_blessed){return$self->blessed_to_json($obj)if ($as_nonblessed);return 'null'}encode_error(sprintf("encountered object '%s', but neither allow_blessed, convert_blessed nor allow_tags settings are enabled (or TO_JSON/FREEZE method missing)",$obj))}else {return$self->value_to_json($obj)}}else{return$self->value_to_json($obj)}}sub hash_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');my$del=($space_before ? ' ' : '').':' .($space_after ? ' ' : '');for my$k (_sort($obj)){if (OLD_PERL){utf8::decode($k)}push@res,$self->string_to_json($k).$del .(ref$obj->{$k}? $self->object_to_json($obj->{$k}): $self->value_to_json($obj->{$k}))}--$depth;$self->_down_indent()if ($indent);return '{}' unless@res;return '{' .$pre .join(",$pre",@res).$post .'}'}sub array_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');for my$v (@$obj){push@res,ref($v)? $self->object_to_json($v): $self->value_to_json($v)}--$depth;$self->_down_indent()if ($indent);return '[]' unless@res;return '[' .$pre .join(",$pre",@res).$post .']'}sub _looks_like_number {my$value=shift;if (USE_B){my$b_obj=B::svref_2object(\$value);my$flags=$b_obj->FLAGS;return 1 if$flags & (B::SVp_IOK()| B::SVp_NOK())and!($flags & B::SVp_POK());return}else {no warnings 'numeric';return if utf8::is_utf8($value);return unless length((my$dummy="")& $value);return unless 0 + $value eq $value;return 1 if$value * 0==0;return -1}}sub value_to_json {my ($self,$value)=@_;return 'null' if(!defined$value);my$type=ref($value);if (!$type){if (_looks_like_number($value)){return$value}return$self->string_to_json($value)}elsif(blessed($value)and $value->isa('JSON::PP::Boolean')){return $$value==1 ? 'true' : 'false'}else {if ((overload::StrVal($value)=~ /=(\w+)/)[0]){return$self->value_to_json("$value")}if ($type eq 'SCALAR' and defined $$value){return $$value eq '1' ? 'true' : $$value eq '0' ? 'false' : $self->{PROPS}->[P_ALLOW_UNKNOWN ]? 'null' : encode_error("cannot encode reference to scalar")}if ($self->{PROPS}->[P_ALLOW_UNKNOWN ]){return 'null'}else {if ($type eq 'SCALAR' or $type eq 'REF'){encode_error("cannot encode reference to scalar")}else {encode_error("encountered $value, but JSON can only represent references to arrays or hashes")}}}}my%esc=("\n"=>'\n',"\r"=>'\r',"\t"=>'\t',"\f"=>'\f',"\b"=>'\b',"\""=>'\"',"\\"=>'\\\\',"\'"=>'\\\'',);sub string_to_json {my ($self,$arg)=@_;$arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;$arg =~ s/\//\\\//g if ($escape_slash);$arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;if ($ascii){$arg=JSON_PP_encode_ascii($arg)}if ($latin1){$arg=JSON_PP_encode_latin1($arg)}if ($utf8){utf8::encode($arg)}return '"' .$arg .'"'}sub blessed_to_json {my$reftype=reftype($_[1])|| '';if ($reftype eq 'HASH'){return $_[0]->hash_to_json($_[1])}elsif ($reftype eq 'ARRAY'){return $_[0]->array_to_json($_[1])}else {return 'null'}}sub encode_error {my$error=shift;Carp::croak "$error"}sub _sort {defined$keysort ? (sort$keysort (keys %{$_[0]})): keys %{$_[0]}}sub _up_indent {my$self=shift;my$space=' ' x $indent_length;my ($pre,$post)=('','');$post="\n" .$space x $indent_count;$indent_count++;$pre="\n" .$space x $indent_count;return ($pre,$post)}sub _down_indent {$indent_count--}sub PP_encode_box {{depth=>$depth,indent_count=>$indent_count,}}}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_surrogates {my$uni=$_[0]- 0x10000;return ($uni / 0x400 + 0xD800,$uni % 0x400 + 0xDC00)}sub _is_bignum {$_[0]->isa('Math::BigInt')or $_[0]->isa('Math::BigFloat')}my$max_intsize;BEGIN {my$checkint=1111;for my$d (5..64){$checkint .= 1;my$int=eval qq| $checkint |;if ($int =~ /[eE]/){$max_intsize=$d - 1;last}}}{my%escapes=(b=>"\x8",t=>"\x9",n=>"\xA",f=>"\xC",r=>"\xD",'\\'=>'\\','"'=>'"','/'=>'/',);my$text;my$at;my$ch;my$len;my$depth;my$encoding;my$is_valid_utf8;my$utf8_len;my$utf8;my$max_depth;my$max_size;my$relaxed;my$cb_object;my$cb_sk_object;my$F_HOOK;my$allow_bignum;my$singlequote;my$loose;my$allow_barekey;my$allow_tags;my$alt_true;my$alt_false;sub _detect_utf_encoding {my$text=shift;my@octets=unpack('C4',$text);return 'unknown' unless defined$octets[3];return ($octets[0]and $octets[1])? 'UTF-8' : (!$octets[0]and $octets[1])? 'UTF-16BE' : (!$octets[0]and!$octets[1])? 'UTF-32BE' : ($octets[2])? 'UTF-16LE' : (!$octets[2])? 'UTF-32LE' : 'unknown'}sub PP_decode_json {my ($self,$want_offset);($self,$text,$want_offset)=@_;($at,$ch,$depth)=(0,'',0);if (!defined$text or ref$text){decode_error("malformed JSON string, neither array, object, number, string or atom")}my$props=$self->{PROPS};($utf8,$relaxed,$loose,$allow_bignum,$allow_barekey,$singlequote,$allow_tags)=@{$props}[P_UTF8,P_RELAXED,P_LOOSE .. P_ALLOW_SINGLEQUOTE,P_ALLOW_TAGS];($alt_true,$alt_false)=@$self{qw/true false/};if ($utf8){$encoding=_detect_utf_encoding($text);if ($encoding ne 'UTF-8' and $encoding ne 'unknown'){require Encode;Encode::from_to($text,$encoding,'utf-8')}else {utf8::downgrade($text,1)or Carp::croak("Wide character in subroutine entry")}}else {utf8::upgrade($text);utf8::encode($text)}$len=length$text;($max_depth,$max_size,$cb_object,$cb_sk_object,$F_HOOK)=@{$self}{qw/max_depth max_size cb_object cb_sk_object F_HOOK/};if ($max_size > 1){use bytes;my$bytes=length$text;decode_error(sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s" ,$bytes,$max_size),1)if ($bytes > $max_size)}white();decode_error("malformed JSON string, neither array, object, number, string or atom")unless defined$ch;my$result=value();if (!$props->[P_ALLOW_NONREF ]and!ref$result){decode_error('JSON text must be an object or array (but found number, string, true, false or null,' .' use allow_nonref to allow this)',1)}Carp::croak('something wrong.')if$len < $at;my$consumed=defined$ch ? $at - 1 : $at;white();return ($result,$consumed)if$want_offset;decode_error("garbage after JSON object")if defined$ch;$result}sub next_chr {return$ch=undef if($at >= $len);$ch=substr($text,$at++,1)}sub value {white();return if(!defined$ch);return object()if($ch eq '{');return array()if($ch eq '[');return tag()if($ch eq '(');return string()if($ch eq '"' or ($singlequote and $ch eq "'"));return number()if($ch =~ /[0-9]/ or $ch eq '-');return word()}sub string {my$utf16;my$is_utf8;($is_valid_utf8,$utf8_len)=('',0);my$s='';if($ch eq '"' or ($singlequote and $ch eq "'")){my$boundChar=$ch;OUTER: while(defined(next_chr())){if($ch eq $boundChar){next_chr();if ($utf16){decode_error("missing low surrogate character in surrogate pair")}utf8::decode($s)if($is_utf8);return$s}elsif($ch eq '\\'){next_chr();if(exists$escapes{$ch}){$s .= $escapes{$ch}}elsif($ch eq 'u'){my$u='';for(1..4){$ch=next_chr();last OUTER if($ch !~ /[0-9a-fA-F]/);$u .= $ch}if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/){$utf16=$u}elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/){unless (defined$utf16){decode_error("missing high surrogate character in surrogate pair")}$is_utf8=1;$s .= JSON_PP_decode_surrogates($utf16,$u)|| next;$utf16=undef}else {if (defined$utf16){decode_error("surrogate pair expected")}if ((my$hex=hex($u))> 127){$is_utf8=1;$s .= JSON_PP_decode_unicode($u)|| next}else {$s .= chr$hex}}}else{unless ($loose){$at -= 2;decode_error('illegal backslash escape sequence in string')}$s .= $ch}}else{if (ord$ch > 127){unless($ch=is_valid_utf8($ch)){$at -= 1;decode_error("malformed UTF-8 character in JSON string")}else {$at += $utf8_len - 1}$is_utf8=1}if (!$loose){if ($ch =~ /[\x00-\x1f\x22\x5c]/){if (!$relaxed or $ch ne "\t"){$at--;decode_error('invalid character encountered while parsing JSON string')}}}$s .= $ch}}}decode_error("unexpected end of string while parsing JSON string")}sub white {while(defined$ch){if($ch eq '' or $ch =~ /\A[ \t\r\n]\z/){next_chr()}elsif($relaxed and $ch eq '/'){next_chr();if(defined$ch and $ch eq '/'){1 while(defined(next_chr())and $ch ne "\n" and $ch ne "\r")}elsif(defined$ch and $ch eq '*'){next_chr();while(1){if(defined$ch){if($ch eq '*'){if(defined(next_chr())and $ch eq '/'){next_chr();last}}else{next_chr()}}else{decode_error("Unterminated comment")}}next}else{$at--;decode_error("malformed JSON string, neither array, object, number, string or atom")}}else{if ($relaxed and $ch eq '#'){pos($text)=$at;$text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;$at=pos($text);next_chr;next}last}}}sub array {my$a=$_[0]|| [];decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq ']'){--$depth;next_chr();return$a}else {while(defined($ch)){push @$a,value();white();if (!defined$ch){last}if($ch eq ']'){--$depth;next_chr();return$a}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq ']'){--$depth;next_chr();return$a}}}$at-- if defined$ch and $ch ne '';decode_error(", or ] expected while parsing array")}sub tag {decode_error('malformed JSON string, neither array, object, number, string or atom')unless$allow_tags;next_chr();white();my$tag=value();return unless defined$tag;decode_error('malformed JSON string, (tag) must be a string')if ref$tag;white();if (!defined$ch or $ch ne ')'){decode_error(') expected after tag')}next_chr();white();my$val=value();return unless defined$val;decode_error('malformed JSON string, tag value must be an array')unless ref$val eq 'ARRAY';if (!eval {$tag->can('THAW')}){decode_error('cannot decode perl-object (package does not exist)')if $@;decode_error('cannot decode perl-object (package does not have a THAW method)')}$tag->THAW('JSON',@$val)}sub object {my$o=$_[0]|| {};my$k;decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}else {while (defined$ch){$k=($allow_barekey and $ch ne '"' and $ch ne "'")? bareKey(): string();white();if(!defined$ch or $ch ne ':'){$at--;decode_error("':' expected")}next_chr();$o->{$k}=value();white();last if (!defined$ch);if($ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}}}$at-- if defined$ch and $ch ne '';decode_error(", or } expected while parsing object/hash")}sub bareKey {my$key;while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){$key .= $ch;next_chr()}return$key}sub word {my$word=substr($text,$at-1,4);if($word eq 'true'){$at += 3;next_chr;return defined$alt_true ? $alt_true : $JSON::PP::true}elsif($word eq 'null'){$at += 3;next_chr;return undef}elsif($word eq 'fals'){$at += 3;if(substr($text,$at,1)eq 'e'){$at++;next_chr;return defined$alt_false ? $alt_false : $JSON::PP::false}}$at--;decode_error("'null' expected")if ($word =~ /^n/);decode_error("'true' expected")if ($word =~ /^t/);decode_error("'false' expected")if ($word =~ /^f/);decode_error("malformed JSON string, neither array, object, number, string or atom")}sub number {my$n='';my$v;my$is_dec;my$is_exp;if($ch eq '-'){$n='-';next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after initial minus)")}}if($ch eq '0'){my$peek=substr($text,$at,1);if($peek =~ /^[0-9a-dfA-DF]/){decode_error("malformed number (leading zero must not be followed by another digit)")}$n .= $ch;next_chr}while(defined$ch and $ch =~ /\d/){$n .= $ch;next_chr}if(defined$ch and $ch eq '.'){$n .= '.';$is_dec=1;next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after decimal point)")}else {$n .= $ch}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}if(defined$ch and ($ch eq 'e' or $ch eq 'E')){$n .= $ch;$is_exp=1;next_chr;if(defined($ch)and ($ch eq '+' or $ch eq '-')){$n .= $ch;next_chr;if (!defined$ch or $ch =~ /\D/){decode_error("malformed number (no digits after exp sign)")}$n .= $ch}elsif(defined($ch)and $ch =~ /\d/){$n .= $ch}else {decode_error("malformed number (no digits after exp sign)")}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}$v .= $n;if ($is_dec or $is_exp){if ($allow_bignum){require Math::BigFloat;return Math::BigFloat->new($v)}}else {if (length$v > $max_intsize){if ($allow_bignum){require Math::BigInt;return Math::BigInt->new($v)}else {return "$v"}}}return$is_dec ? $v/1.0 : 0+$v}sub is_valid_utf8 {$utf8_len=$_[0]=~ /[\x00-\x7F]/ ? 1 : $_[0]=~ /[\xC2-\xDF]/ ? 2 : $_[0]=~ /[\xE0-\xEF]/ ? 3 : $_[0]=~ /[\xF0-\xF4]/ ? 4 : 0 ;return unless$utf8_len;my$is_valid_utf8=substr($text,$at - 1,$utf8_len);return ($is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x)? $is_valid_utf8 : ''}sub decode_error {my$error=shift;my$no_rep=shift;my$str=defined$text ? substr($text,$at): '';my$mess='';my$type='U*';if (OLD_PERL){my$type=$] < 5.006 ? 'C*' : utf8::is_utf8($str)? 'U*' : 'C*' }for my$c (unpack($type,$str)){$mess .= $c==0x07 ? '\a' : $c==0x09 ? '\t' : $c==0x0a ? '\n' : $c==0x0d ? '\r' : $c==0x0c ? '\f' : $c < 0x20 ? sprintf('\x{%x}',$c): $c==0x5c ? '\\\\' : $c < 0x80 ? chr($c): sprintf('\x{%x}',$c);if (length$mess >= 20){$mess .= '...';last}}unless (length$mess){$mess='(end of string)'}Carp::croak ($no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")")}sub _json_object_hook {my$o=$_[0];my@ks=keys %{$o};if ($cb_sk_object and @ks==1 and exists$cb_sk_object->{$ks[0]}and ref$cb_sk_object->{$ks[0]}){my@val=$cb_sk_object->{$ks[0]}->($o->{$ks[0]});if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_single_key_object callbacks must not return more than one scalar")}}my@val=$cb_object->($o)if ($cb_object);if (@val==0){return$o}elsif (@val==1){return$val[0]}else {Carp::croak("filter_json_object callbacks must not return more than one scalar")}}sub PP_decode_box {{text=>$text,at=>$at,ch=>$ch,len=>$len,depth=>$depth,encoding=>$encoding,is_valid_utf8=>$is_valid_utf8,}}}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$un=pack('U*',$uni);utf8::encode($un);return$un}sub _decode_unicode {my$un=pack('U',hex shift);utf8::encode($un);return$un}BEGIN {unless (defined&utf8::is_utf8){require Encode;*utf8::is_utf8=*Encode::is_utf8}if (!OLD_PERL){*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&_decode_unicode;if ($] < 5.008003){package JSON::PP;require subs;subs->import('join');eval q|
                  sub join {
                      return '' if (@_ < 2);
                      my $j   = shift;
                      my $str = shift;
                      for (@_) { $str .= $j . $_; }
                      return $str;
                  }
              |}}sub JSON::PP::incr_parse {local$Carp::CarpLevel=1;($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_parse(@_)}sub JSON::PP::incr_skip {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_skip}sub JSON::PP::incr_reset {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_reset}eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_pos} ) {
                  Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ($] >= 5.006)}BEGIN {eval 'require Scalar::Util';unless($@){*JSON::PP::blessed=\&Scalar::Util::blessed;*JSON::PP::reftype=\&Scalar::Util::reftype;*JSON::PP::refaddr=\&Scalar::Util::refaddr}else{eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';*JSON::PP::blessed=sub {local($@,$SIG{__DIE__},$SIG{__WARN__});ref($_[0])? eval {$_[0]->a_sub_not_likely_to_be_here}: undef};require B;my%tmap=qw(B::NULL SCALAR B::HV HASH B::AV ARRAY B::CV CODE B::IO IO B::GV GLOB B::REGEXP REGEXP);*JSON::PP::reftype=sub {my$r=shift;return undef unless length(ref($r));my$t=ref(B::svref_2object($r));return exists$tmap{$t}? $tmap{$t}: length(ref($$r))? 'REF' : 'SCALAR'};*JSON::PP::refaddr=sub {return undef unless length(ref($_[0]));my$addr;if(defined(my$pkg=blessed($_[0]))){$addr .= bless $_[0],'Scalar::Util::Fake';bless $_[0],$pkg}else {$addr .= $_[0]}$addr =~ /0x(\w+)/;local $^W;hex($1)}}}$JSON::PP::true=do {bless \(my$dummy=1),"JSON::PP::Boolean"};$JSON::PP::false=do {bless \(my$dummy=0),"JSON::PP::Boolean"};sub is_bool {blessed $_[0]and ($_[0]->isa("JSON::PP::Boolean")or $_[0]->isa("Types::Serialiser::BooleanBase")or $_[0]->isa("JSON::XS::Boolean"))}sub true {$JSON::PP::true}sub false {$JSON::PP::false}sub null {undef}package JSON::PP::IncrParser;use strict;use constant INCR_M_WS=>0;use constant INCR_M_STR=>1;use constant INCR_M_BS=>2;use constant INCR_M_JSON=>3;use constant INCR_M_C0=>4;use constant INCR_M_C1=>5;use constant INCR_M_TFN=>6;use constant INCR_M_NUM=>7;$JSON::PP::IncrParser::VERSION='1.01';sub new {my ($class)=@_;bless {incr_nest=>0,incr_text=>undef,incr_pos=>0,incr_mode=>0,},$class}sub incr_parse {my ($self,$coder,$text)=@_;$self->{incr_text}='' unless (defined$self->{incr_text});if (defined$text){if (utf8::is_utf8($text)and!utf8::is_utf8($self->{incr_text})){utf8::upgrade($self->{incr_text});utf8::decode($self->{incr_text})}$self->{incr_text}.= $text}if (defined wantarray){my$max_size=$coder->get_max_size;my$p=$self->{incr_pos};my@ret;{do {unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){$self->_incr_parse($coder);if ($max_size and $self->{incr_pos}> $max_size){Carp::croak("attempted decode of JSON text of $self->{incr_pos} bytes size, but max_size is set to $max_size")}unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){if ($self->{incr_mode}==INCR_M_WS and $self->{incr_pos}){$self->{incr_pos}=0;$self->{incr_text}=''}last}}my ($obj,$offset)=$coder->PP_decode_json($self->{incr_text},0x00000001);push@ret,$obj;use bytes;$self->{incr_text}=substr($self->{incr_text},$offset || 0);$self->{incr_pos}=0;$self->{incr_nest}=0;$self->{incr_mode}=0;last unless wantarray}while (wantarray)}if (wantarray){return@ret}else {return defined$ret[0]? $ret[0]: undef}}}sub _incr_parse {my ($self,$coder)=@_;my$text=$self->{incr_text};my$len=length$text;my$p=$self->{incr_pos};INCR_PARSE: while ($len > $p){my$s=substr($text,$p,1);last INCR_PARSE unless defined$s;my$mode=$self->{incr_mode};if ($mode==INCR_M_WS){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if (ord($s)> 0x20){if ($s eq '#'){$self->{incr_mode}=INCR_M_C0;redo INCR_PARSE}else {$self->{incr_mode}=INCR_M_JSON;redo INCR_PARSE}}$p++}}elsif ($mode==INCR_M_BS){$p++;$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($mode==INCR_M_C0 or $mode==INCR_M_C1){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq "\n"){$self->{incr_mode}=$self->{incr_mode}==INCR_M_C0 ? INCR_M_WS : INCR_M_JSON;last}$p++}next}elsif ($mode==INCR_M_TFN){while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[rueals]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_NUM){while ($len > $p){$s=substr($text,$p++,1);next if defined$s and $s =~ /[0-9eE.+\-]/;last}$p--;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($mode==INCR_M_STR){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq '"'){$p++;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($s eq '\\'){$p++;if (!defined substr($text,$p,1)){$self->{incr_mode}=INCR_M_BS;last INCR_PARSE}}$p++}}elsif ($mode==INCR_M_JSON){while ($len > $p){$s=substr($text,$p++,1);if ($s eq "\x00"){$p--;last INCR_PARSE}elsif ($s eq "\x09" or $s eq "\x0a" or $s eq "\x0d" or $s eq "\x20"){if (!$self->{incr_nest}){$p--;last INCR_PARSE}next}elsif ($s eq 't' or $s eq 'f' or $s eq 'n'){$self->{incr_mode}=INCR_M_TFN;redo INCR_PARSE}elsif ($s =~ /^[0-9\-]$/){$self->{incr_mode}=INCR_M_NUM;redo INCR_PARSE}elsif ($s eq '"'){$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($s eq '[' or $s eq '{'){if (++$self->{incr_nest}> $coder->get_max_depth){Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')}next}elsif ($s eq ']' or $s eq '}'){if (--$self->{incr_nest}<= 0){last INCR_PARSE}}elsif ($s eq '#'){$self->{incr_mode}=INCR_M_C1;redo INCR_PARSE}}}}$self->{incr_pos}=$p;$self->{incr_parsing}=$p ? 1 : 0}sub incr_text {if ($_[0]->{incr_pos}){Carp::croak("incr_text cannot be called when the incremental parser already started parsing")}$_[0]->{incr_text}}sub incr_skip {my$self=shift;$self->{incr_text}=substr($self->{incr_text},$self->{incr_pos});$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}sub incr_reset {my$self=shift;$self->{incr_text}=undef;$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}1;
JSON_PP

$fatpacked{"JSON/PP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP_BOOLEAN';
  package JSON::PP::Boolean;use strict;require overload;local $^W;overload::import('overload',"0+"=>sub {${$_[0]}},"++"=>sub {$_[0]=${$_[0]}+ 1},"--"=>sub {$_[0]=${$_[0]}- 1},fallback=>1,);$JSON::PP::Boolean::VERSION='4.04';1;
JSON_PP_BOOLEAN

$fatpacked{"Locale/Maketext/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCALE_MAKETEXT_SIMPLE';
  package Locale::Maketext::Simple;$Locale::Maketext::Simple::VERSION='0.21';use strict;use 5.005;sub import {my ($class,%args)=@_;$args{Class}||= caller;$args{Style}||= 'maketext';$args{Export}||= 'loc';$args{Subclass}||= 'I18N';my ($loc,$loc_lang)=$class->load_loc(%args);$loc ||= $class->default_loc(%args);no strict 'refs';*{caller(0)."::$args{Export}"}=$loc if$args{Export};*{caller(0)."::$args{Export}_lang"}=$loc_lang || sub {1}}my%Loc;sub reload_loc {%Loc=()}sub load_loc {my ($class,%args)=@_;my$pkg=join('::',grep {defined and length}$args{Class},$args{Subclass});return$Loc{$pkg}if exists$Loc{$pkg};eval {require Locale::Maketext::Lexicon;1}or return;$Locale::Maketext::Lexicon::VERSION > 0.20 or return;eval {require File::Spec;1}or return;my$path=$args{Path}|| $class->auto_path($args{Class})or return;my$pattern=File::Spec->catfile($path,'*.[pm]o');my$decode=$args{Decode}|| 0;my$encoding=$args{Encoding}|| undef;$decode=1 if$encoding;$pattern =~ s{\\}{/}g;eval "
  	package $pkg;
  	use base 'Locale::Maketext';
  	Locale::Maketext::Lexicon->import({
  	    'i-default' => [ 'Auto' ],
  	    '*'	=> [ Gettext => \$pattern ],
  	    _decode => \$decode,
  	    _encoding => \$encoding,
  	});
  	*${pkg}::Lexicon = \\%${pkg}::i_default::Lexicon;
  	*tense = sub { \$_[1] . ((\$_[2] eq 'present') ? 'ing' : 'ed') }
  	    unless defined &tense;
  
  	1;
      " or die $@;my$lh=eval {$pkg->get_handle}or return;my$style=lc($args{Style});if ($style eq 'maketext'){$Loc{$pkg}=sub {$lh->maketext(@_)}}elsif ($style eq 'gettext'){$Loc{$pkg}=sub {my$str=shift;$str =~ s{([\~\[\]])}{~$1}g;$str =~ s{
                  ([%\\]%)                        # 1 - escaped sequence
              |
                  %   (?:
                          ([A-Za-z#*]\w*)         # 2 - function call
                              \(([^\)]*)\)        # 3 - arguments
                      |
                          ([1-9]\d*|\*)           # 4 - variable
                      )
              }{
                  $1 ? $1
                     : $2 ? "\[$2,"._unescape($3)."]"
                          : "[_$4]"
              }egx;return$lh->maketext($str,@_)}}else {die "Unknown Style: $style"}return$Loc{$pkg},sub {$lh=$pkg->get_handle(@_)}}sub default_loc {my ($self,%args)=@_;my$style=lc($args{Style});if ($style eq 'maketext'){return sub {my$str=shift;$str =~ s{((?<!~)(?:~~)*)\[_([1-9]\d*|\*)\]}
                       {$1%$2}g;$str =~ s{((?<!~)(?:~~)*)\[([A-Za-z#*]\w*),([^\]]+)\]}
                       {"$1%$2(" . _escape($3) . ')'}eg;_default_gettext($str,@_)}}elsif ($style eq 'gettext'){return \&_default_gettext}else {die "Unknown Style: $style"}}sub _default_gettext {my$str=shift;$str =~ s{
  	%			# leading symbol
  	(?:			# either one of
  	    \d+			#   a digit, like %1
  	    |			#     or
  	    (\w+)\(		#   a function call -- 1
  		(?:		#     either
  		    %\d+	#	an interpolation
  		    |		#     or
  		    ([^,]*)	#	some string -- 2
  		)		#     end either
  		(?:		#     maybe followed
  		    ,		#       by a comma
  		    ([^),]*)	#       and a param -- 3
  		)?		#     end maybe
  		(?:		#     maybe followed
  		    ,		#       by another comma
  		    ([^),]*)	#       and a param -- 4
  		)?		#     end maybe
  		[^)]*		#     and other ignorable params
  	    \)			#   closing function call
  	)			# closing either one of
      }{
  	my $digit = $2 || shift;
  	$digit . (
  	    $1 ? (
  		($1 eq 'tense') ? (($3 eq 'present') ? 'ing' : 'ed') :
  		($1 eq 'quant') ? ' ' . (($digit > 1) ? ($4 || "$3s") : $3) :
  		''
  	    ) : ''
  	);
      }egx;return$str};sub _escape {my$text=shift;$text =~ s/\b_([1-9]\d*)/%$1/g;return$text}sub _unescape {join(',',map {/\A(\s*)%([1-9]\d*|\*)(\s*)\z/ ? "$1_$2$3" : $_}split(/,/,$_[0]))}sub auto_path {my ($self,$calldir)=@_;$calldir =~ s#::#/#g;my$path=$INC{$calldir .'.pm'}or return;if ($^O eq 'MacOS'){(my$malldir=$calldir)=~ tr#/#:#;$path =~ s#^(.*)$malldir\.pm\z#$1auto:$malldir:#s}else {$path =~ s#^(.*)$calldir\.pm\z#$1auto/$calldir/#}return$path if -d $path;$path="auto/$calldir/";for my$inc (@INC){return "$inc/$path" if -d "$inc/$path"}return}1;
LOCALE_MAKETEXT_SIMPLE

$fatpacked{"Module/Build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD';
  package Module::Build;use 5.006;use strict;use warnings;use File::Spec ();use File::Path ();use File::Basename ();use Perl::OSType ();use Module::Build::Base;our@ISA=qw(Module::Build::Base);our$VERSION='0.4229';$VERSION=eval$VERSION;sub _interpose_module {my ($self,$mod)=@_;eval "use $mod";die $@ if $@;no strict 'refs';my$top_class=$mod;while (@{"${top_class}::ISA"}){last if ${"${top_class}::ISA"}[0]eq $ISA[0];$top_class=${"${top_class}::ISA"}[0]}@{"${top_class}::ISA"}=@ISA;@ISA=($mod)}if (grep {-e File::Spec->catfile($_,qw(Module Build Platform),$^O).'.pm'}@INC){__PACKAGE__->_interpose_module("Module::Build::Platform::$^O")}elsif (my$ostype=os_type()){__PACKAGE__->_interpose_module("Module::Build::Platform::$ostype")}else {warn "Unknown OS type '$^O' - using default settings\n"}sub os_type {return Perl::OSType::os_type()}sub is_vmsish {return Perl::OSType::is_os_type('VMS')}sub is_windowsish {return Perl::OSType::is_os_type('Windows')}sub is_unixish {return Perl::OSType::is_os_type('Unix')}1;
MODULE_BUILD

$fatpacked{"Module/Build/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_BASE';
  package Module::Build::Base;use 5.006;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Carp;use Cwd ();use File::Copy ();use File::Find ();use File::Path ();use File::Basename ();use File::Spec 0.82 ();use File::Compare ();use Module::Build::Dumper ();use Text::ParseWords ();use Module::Metadata;use Module::Build::Notes;use Module::Build::Config;use version;sub new {my$self=shift()->_construct(@_);$self->{invoked_action}=$self->{action}||= 'Build_PL';$self->cull_args(@ARGV);die "Too early to specify a build action '$self->{action}'.  Do 'Build $self->{action}' instead.\n" if$self->{action}&& $self->{action}ne 'Build_PL';$self->check_manifest;$self->auto_require;if(grep {!$_}$self->check_prereq,$self->check_autofeatures){$self->log_warn(<<EOF);unless ($self->dist_name eq 'Module-Build' || $ENV{PERL5_CPANPLUS_IS_RUNNING}|| $ENV{PERL5_CPAN_IS_RUNNING}){$self->log_warn("Run 'Build installdeps' to install missing prerequisites.\n\n")}}$self->{properties}{_added_to_INC}=[$self->_added_to_INC ];$self->set_bundle_inc;$self->dist_name;$self->dist_version;$self->release_status;$self->_guess_module_name unless$self->module_name;$self->_find_nested_builds;return$self}sub resume {my$package=shift;my$self=$package->_construct(@_);$self->read_config;my@added_earlier=@{$self->{properties}{_added_to_INC}|| []};@INC=($self->_added_to_INC,@added_earlier,$self->_default_INC);unless ($package->isa($self->build_class)){my$build_class=$self->build_class;my$config_dir=$self->config_dir || '_build';my$build_lib=File::Spec->catdir($config_dir,'lib');unshift(@INC,$build_lib);unless ($build_class->can('new')){eval "require $build_class; 1" or die "Failed to re-load '$build_class': $@"}return$build_class->resume(@_)}unless ($self->_perl_is_same($self->{properties}{perl})){my$perl=$self->find_perl_interpreter;die(<<"DIEFATAL")}$self->cull_args(@ARGV);unless ($self->allow_mb_mismatch){my$mb_version=$Module::Build::VERSION;if ($mb_version ne $self->{properties}{mb_version}){$self->log_warn(<<"MISMATCH")}}$self->{invoked_action}=$self->{action}||= 'build';return$self}sub new_from_context {my ($package,%args)=@_;$package->run_perl_script('Build.PL',[],[$package->unparse_args(\%args)]);return$package->resume}sub current {local@ARGV;return shift()->resume}sub _construct {my ($package,%input)=@_;my$args=delete$input{args}|| {};my$config=delete$input{config}|| {};my$self=bless {args=>{%$args},config=>Module::Build::Config->new(values=>$config),properties=>{base_dir=>$package->cwd,mb_version=>$Module::Build::VERSION,%input,},phash=>{},stash=>{},},$package;$self->_set_defaults;my ($p,$ph)=($self->{properties},$self->{phash});for (qw(notes config_data features runtime_params cleanup auto_features)){my$file=File::Spec->catfile($self->config_dir,$_);$ph->{$_}=Module::Build::Notes->new(file=>$file);$ph->{$_}->restore if -e $file;if (exists$p->{$_}){my$vals=delete$p->{$_};for my$k (sort keys %$vals){$self->$_($k,$vals->{$k})}}}$p->{perl}=$self->find_perl_interpreter or $self->log_warn("Warning: Can't locate your perl binary");my$blibdir=sub {File::Spec->catdir($p->{blib},@_)};$p->{bindoc_dirs}||= [$blibdir->("script")];$p->{libdoc_dirs}||= [$blibdir->("lib"),$blibdir->("arch")];$p->{dist_author}=[$p->{dist_author}]if defined$p->{dist_author}and not ref$p->{dist_author};$p->{requires}=delete$p->{prereq}if defined$p->{prereq};$p->{script_files}=delete$p->{scripts}if defined$p->{scripts};for ('extra_compiler_flags','extra_linker_flags'){$p->{$_}=[$self->split_like_shell($p->{$_})]if exists$p->{$_}}for ('include_dirs'){$p->{$_}=[$p->{$_}]if exists$p->{$_}&&!ref$p->{$_}}$self->add_to_cleanup(@{delete$p->{add_to_cleanup}})if$p->{add_to_cleanup};return$self}sub log_info {my$self=shift;print @_ if ref($self)&& ($self->verbose ||!$self->quiet)}sub log_verbose {my$self=shift;print @_ if ref($self)&& $self->verbose}sub log_debug {my$self=shift;print @_ if ref($self)&& $self->debug}sub log_warn {shift;if (@_ and $_[-1]!~ /\n$/){my (undef,$file,$line)=caller();warn @_," at $file line $line.\n"}else {warn @_}}sub _default_install_paths {my$self=shift;my$c=$self->{config};my$p={};my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');my$bindoc=$c->get('installman1dir')|| undef;my$libdoc=$c->get('installman3dir')|| undef;my$binhtml=$c->get('installhtml1dir')|| $c->get('installhtmldir')|| undef;my$libhtml=$c->get('installhtml3dir')|| $c->get('installhtmldir')|| undef;$p->{install_sets}={core=>{lib=>$c->get('installprivlib'),arch=>$c->get('installarchlib'),bin=>$c->get('installbin'),script=>$c->get('installscript'),bindoc=>$bindoc,libdoc=>$libdoc,binhtml=>$binhtml,libhtml=>$libhtml,},site=>{lib=>$c->get('installsitelib'),arch=>$c->get('installsitearch'),bin=>$c->get('installsitebin')|| $c->get('installbin'),script=>$c->get('installsitescript')|| $c->get('installsitebin')|| $c->get('installscript'),bindoc=>$c->get('installsiteman1dir')|| $bindoc,libdoc=>$c->get('installsiteman3dir')|| $libdoc,binhtml=>$c->get('installsitehtml1dir')|| $binhtml,libhtml=>$c->get('installsitehtml3dir')|| $libhtml,},vendor=>{lib=>$c->get('installvendorlib'),arch=>$c->get('installvendorarch'),bin=>$c->get('installvendorbin')|| $c->get('installbin'),script=>$c->get('installvendorscript')|| $c->get('installvendorbin')|| $c->get('installscript'),bindoc=>$c->get('installvendorman1dir')|| $bindoc,libdoc=>$c->get('installvendorman3dir')|| $libdoc,binhtml=>$c->get('installvendorhtml1dir')|| $binhtml,libhtml=>$c->get('installvendorhtml3dir')|| $libhtml,},};$p->{original_prefix}={core=>$c->get('installprefixexp')|| $c->get('installprefix')|| $c->get('prefixexp')|| $c->get('prefix')|| '',site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',};$p->{original_prefix}{site}||= $p->{original_prefix}{core};$p->{install_base_relpaths}={lib=>['lib','perl5'],arch=>['lib','perl5',$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],};$p->{prefix_relpaths}={core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],},};return$p}sub _find_nested_builds {my$self=shift;my$r=$self->recurse_into or return;my ($file,@r);if (!ref($r)&& $r eq 'auto'){local*DH;opendir DH,$self->base_dir or die "Can't scan directory " .$self->base_dir ." for nested builds: $!";while (defined($file=readdir DH)){my$subdir=File::Spec->catdir($self->base_dir,$file);next unless -d $subdir;push@r,$subdir if -e File::Spec->catfile($subdir,'Build.PL')}}$self->recurse_into(\@r)}sub cwd {return Cwd::cwd()}sub _quote_args {my ($self,@args)=@_;my@quoted;for (@args){if (/^[^\s*?!\$<>;\\|'"\[\]\{\}]+$/){push@quoted,$_}else {s/('+)/'"$1"'/g;push@quoted,qq('$_')}}return join " ",@quoted}sub _backticks {my ($self,@cmd)=@_;if ($self->have_forkpipe){local*FH;my$pid=open*FH,"-|";if ($pid){return wantarray ? <FH> : join '',<FH>}else {die "Can't execute @cmd: $!\n" unless defined$pid;exec {$cmd[0]}@cmd}}else {my$cmd=$self->_quote_args(@cmd);return `$cmd`}}sub have_forkpipe {1}sub _perl_is_same {my ($self,$perl)=@_;my@cmd=($perl);if ($ENV{PERL_CORE}){push@cmd,'-I' .File::Spec->catdir(File::Basename::dirname($perl),'lib')}push@cmd,qw(-MConfig=myconfig -e print -e myconfig);return$self->_backticks(@cmd)eq Config->myconfig}{my$known_perl;sub find_perl_interpreter {my$self=shift;return$known_perl if defined($known_perl);return$known_perl=$self->_discover_perl_interpreter}}sub _discover_perl_interpreter {my$proto=shift;my$c=ref($proto)? $proto->{config}: 'Module::Build::Config';my$perl=$^X;my$perl_basename=File::Basename::basename($perl);my@potential_perls;push(@potential_perls,$perl)if File::Spec->file_name_is_absolute($perl);my$abs_perl=File::Spec->rel2abs($perl);push(@potential_perls,$abs_perl);if ($ENV{PERL_CORE}){require ExtUtils::CBuilder;my$perl_src=Cwd::realpath(ExtUtils::CBuilder->perl_src);if (defined($perl_src)&& length($perl_src)){my$uninstperl=File::Spec->rel2abs(File::Spec->catfile($perl_src,$perl_basename));push(@potential_perls,$uninstperl)}}else {push(@potential_perls,$c->get('perlpath'));push(@potential_perls,map File::Spec->catfile($_,$perl_basename),File::Spec->path())}my$exe=$c->get('exe_ext');for my$thisperl (@potential_perls){if (defined$exe){$thisperl .= $exe unless$thisperl =~ m/$exe$/i}if (-f $thisperl && $proto->_perl_is_same($thisperl)){return$thisperl}}my@paths=map File::Basename::dirname($_),@potential_perls;die "Can't locate the perl binary used to run this script " ."in (@paths)\n"}sub find_command {my ($self,$command)=@_;if(File::Spec->file_name_is_absolute($command)){return$self->_maybe_command($command)}else {for my$dir (File::Spec->path){my$abs=File::Spec->catfile($dir,$command);return$abs if$abs=$self->_maybe_command($abs)}}}sub _maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d $file;return}sub _is_interactive {return -t STDIN && (-t STDOUT ||!(-f STDOUT || -c STDOUT))}sub _is_unattended {my$self=shift;return$ENV{PERL_MM_USE_DEFAULT}|| (!$self->_is_interactive && eof STDIN)}sub _readline {my$self=shift;return undef if$self->_is_unattended;my$answer=<STDIN>;chomp$answer if defined$answer;return$answer}sub prompt {my$self=shift;my$mess=shift or die "prompt() called without a prompt message";my@def;@def=(shift)if @_;my@dispdef=scalar(@def)? ('[',(defined($def[0])? $def[0].' ' : ''),']'): (' ','');local $|=1;print "$mess ",@dispdef;if ($self->_is_unattended &&!@def){die <<EOF}my$ans=$self->_readline();if (!defined($ans)or!length($ans)){print "$dispdef[1]\n";$ans=scalar(@def)? $def[0]: ''}return$ans}sub y_n {my$self=shift;my ($mess,$def)=@_;die "y_n() called without a prompt message" unless$mess;die "Invalid default value: y_n() default must be 'y' or 'n'" if$def && $def !~ /^[yn]/i;my$answer;while (1){$answer=$self->prompt(@_);return 1 if$answer =~ /^y/i;return 0 if$answer =~ /^n/i;local $|=1;print "Please answer 'y' or 'n'.\n"}}sub current_action {shift->{action}}sub invoked_action {shift->{invoked_action}}sub notes {shift()->{phash}{notes}->access(@_)}sub config_data {shift()->{phash}{config_data}->access(@_)}sub runtime_params {shift->{phash}{runtime_params}->read(@_ ? shift : ())}sub auto_features {shift()->{phash}{auto_features}->access(@_)}sub features {my$self=shift;my$ph=$self->{phash};if (@_){my$key=shift;if ($ph->{features}->exists($key)){return$ph->{features}->access($key,@_)}if (my$info=$ph->{auto_features}->access($key)){my$disabled;for my$type (@{$self->prereq_action_types}){next if$type eq 'description' || $type eq 'recommends' ||!exists$info->{$type};my$prereqs=$info->{$type};for my$modname (sort keys %$prereqs){my$spec=$prereqs->{$modname};my$status=$self->check_installed_status($modname,$spec);if ((!$status->{ok})xor ($type =~ /conflicts$/)){return 0}if (!eval "require $modname; 1"){return 0}}}return 1}return$ph->{features}->access($key,@_)}my%features;my%auto_features=$ph->{auto_features}->access();while (my ($name,$info)=each%auto_features){my$failures=$self->prereq_failures($info);my$disabled=grep(/^(?:\w+_)?(?:requires|conflicts)$/,keys %$failures)? 1 : 0;$features{$name}=$disabled ? 0 : 1}%features=(%features,$ph->{features}->access());return wantarray ? %features : \%features}BEGIN {*feature=\&features}sub _mb_feature {my$self=shift;if (($self->module_name || '')eq 'Module::Build'){return$self->feature(@_)}else {require Module::Build::ConfigData;return Module::Build::ConfigData->feature(@_)}}sub _warn_mb_feature_deps {my$self=shift;my$name=shift;$self->log_warn("The '$name' feature is not available.  Please install missing\n" ."feature dependencies and try again.\n".$self->_feature_deps_msg($name)."\n")}sub add_build_element {my ($self,$elem)=@_;my$elems=$self->build_elements;push @$elems,$elem unless grep {$_ eq $elem}@$elems}sub ACTION_config_data {my$self=shift;return unless$self->has_config_data;my$module_name=$self->module_name or die "The config_data feature requires that 'module_name' be set";my$notes_name=$module_name .'::ConfigData';my$notes_pm=File::Spec->catfile($self->blib,'lib',split /::/,"$notes_name.pm");return if$self->up_to_date(['Build.PL',$self->config_file('config_data'),$self->config_file('features')],$notes_pm);$self->log_verbose("Writing config notes to $notes_pm\n");File::Path::mkpath(File::Basename::dirname($notes_pm));Module::Build::Notes->write_config_data (file=>$notes_pm,module=>$module_name,config_module=>$notes_name,config_data=>scalar$self->config_data,feature=>scalar$self->{phash}{features}->access(),auto_features=>scalar$self->auto_features,)}{my%valid_properties=(__PACKAGE__,{});my%additive_properties;sub _mb_classes {my$class=ref($_[0])|| $_[0];return ($class,$class->mb_parents)}sub valid_property {my ($class,$prop)=@_;return grep exists($valid_properties{$_}{$prop}),$class->_mb_classes}sub valid_properties {return keys %{shift->valid_properties_defaults()}}sub valid_properties_defaults {my%out;for my$class (reverse shift->_mb_classes){@out{keys %{$valid_properties{$class}}}=map {$_->()}values %{$valid_properties{$class}}}return \%out}sub array_properties {map {exists$additive_properties{$_}->{ARRAY}? @{$additive_properties{$_}->{ARRAY}}: ()}shift->_mb_classes}sub hash_properties {map {exists$additive_properties{$_}->{HASH}? @{$additive_properties{$_}->{HASH}}: ()}shift->_mb_classes}sub add_property {my ($class,$property)=(shift,shift);die "Property '$property' already exists" if$class->valid_property($property);my%p=@_==1 ? (default=>shift): @_;my$type=ref$p{default};$valid_properties{$class}{$property}=$type eq 'CODE' ? $p{default}: $type eq 'HASH' ? sub {return {%{$p{default}}}}: $type eq 'ARRAY'? sub {return [@{$p{default}}]}: sub {return$p{default}};push @{$additive_properties{$class}->{$type}},$property if$type;unless ($class->can($property)){my$sub=$type eq 'HASH' ? _make_hash_accessor($property,\%p): _make_accessor($property,\%p);no strict 'refs';*{"$class\::$property"}=$sub}return$class}sub property_error {my$self=shift;die 'ERROR: ',@_}sub _set_defaults {my$self=shift;$self->{properties}{build_class}||= ref$self;$self->{properties}{orig_dir}||= $self->{properties}{base_dir};my$defaults=$self->valid_properties_defaults;for my$prop (keys %$defaults){$self->{properties}{$prop}=$defaults->{$prop}unless exists$self->{properties}{$prop}}for my$prop ($self->array_properties){$self->{properties}{$prop}=[@{$defaults->{$prop}}]unless exists$self->{properties}{$prop}}for my$prop ($self->hash_properties){$self->{properties}{$prop}={%{$defaults->{$prop}}}unless exists$self->{properties}{$prop}}}}sub _make_hash_accessor {my ($property,$p)=@_;my$check=$p->{check}|| sub {1};return sub {my$self=shift;unless(ref($self)){carp("\n$property not a class method (@_)");return}my$x=$self->{properties};return$x->{$property}unless @_;my$prop=$x->{$property};if (defined $_[0]&&!ref $_[0]){if (@_==1){return exists$prop->{$_[0]}? $prop->{$_[0]}: undef}elsif (@_ % 2==0){my%new=(%{$prop},@_);local $_=\%new;$x->{$property}=\%new if$check->($self);return$x->{$property}}else {die "Unexpected arguments for property '$property'\n"}}else {die "Unexpected arguments for property '$property'\n" if defined $_[0]&& ref $_[0]ne 'HASH';local $_=$_[0];$x->{$property}=shift if$check->($self)}}}sub _make_accessor {my ($property,$p)=@_;my$check=$p->{check}|| sub {1};return sub {my$self=shift;unless(ref($self)){carp("\n$property not a class method (@_)");return}my$x=$self->{properties};return$x->{$property}unless @_;local $_=$_[0];$x->{$property}=shift if$check->($self);return$x->{$property}}}__PACKAGE__->add_property(auto_configure_requires=>1);__PACKAGE__->add_property(blib=>'blib');__PACKAGE__->add_property(build_class=>'Module::Build');__PACKAGE__->add_property(build_elements=>[qw(PL support pm xs share_dir pod script)]);__PACKAGE__->add_property(build_script=>'Build');__PACKAGE__->add_property(build_bat=>0);__PACKAGE__->add_property(bundle_inc=>[]);__PACKAGE__->add_property(bundle_inc_preload=>[]);__PACKAGE__->add_property(config_dir=>'_build');__PACKAGE__->add_property(dynamic_config=>1);__PACKAGE__->add_property(include_dirs=>[]);__PACKAGE__->add_property(license=>'unknown');__PACKAGE__->add_property(metafile=>'META.yml');__PACKAGE__->add_property(mymetafile=>'MYMETA.yml');__PACKAGE__->add_property(metafile2=>'META.json');__PACKAGE__->add_property(mymetafile2=>'MYMETA.json');__PACKAGE__->add_property(recurse_into=>[]);__PACKAGE__->add_property(use_rcfile=>1);__PACKAGE__->add_property(create_packlist=>1);__PACKAGE__->add_property(allow_mb_mismatch=>0);__PACKAGE__->add_property(config=>undef);__PACKAGE__->add_property(test_file_exts=>['.t']);__PACKAGE__->add_property(use_tap_harness=>0);__PACKAGE__->add_property(cpan_client=>'cpan');__PACKAGE__->add_property(tap_harness_args=>{});__PACKAGE__->add_property(pureperl_only=>0);__PACKAGE__->add_property(allow_pureperl=>0);__PACKAGE__->add_property('installdirs',default=>'site',check=>sub {return 1 if /^(core|site|vendor)$/;return shift->property_error($_ eq 'perl' ? 'Perhaps you meant installdirs to be "core" rather than "perl"?' : 'installdirs must be one of "core", "site", or "vendor"');return shift->property_error("Perhaps you meant 'core'?")if $_ eq 'perl';return 0},);{__PACKAGE__->add_property(html_css=>'')}{my@prereq_action_types=qw(requires build_requires test_requires conflicts recommends);for my$type (@prereq_action_types){__PACKAGE__->add_property($type=>{})}__PACKAGE__->add_property(prereq_action_types=>\@prereq_action_types)}__PACKAGE__->add_property($_=>{})for qw(get_options install_base_relpaths install_path install_sets meta_add meta_merge original_prefix prefix_relpaths configure_requires);__PACKAGE__->add_property($_)for qw(PL_files autosplit base_dir bindoc_dirs c_source cover create_license create_makefile_pl create_readme debugger destdir dist_abstract dist_author dist_name dist_suffix dist_version dist_version_from extra_compiler_flags extra_linker_flags has_config_data install_base libdoc_dirs magic_number mb_version module_name needs_compiler orig_dir perl pm_files pod_files pollute prefix program_name quiet recursive_test_files release_status script_files scripts share_dir sign test_files verbose debug xs_files extra_manify_args);sub config {my$self=shift;my$c=ref($self)? $self->{config}: 'Module::Build::Config';return$c->all_config unless @_;my$key=shift;return$c->get($key)unless @_;my$val=shift;return$c->set($key=>$val)}sub mb_parents {my@in_stack=(shift);my%seen=($in_stack[0]=>1);my ($current,@out);while (@in_stack){next unless defined($current=shift@in_stack)&& $current->isa('Module::Build::Base');push@out,$current;next if$current eq 'Module::Build::Base';no strict 'refs';unshift@in_stack,map {my$c=$_;substr($c,0,2)="main::" if substr($c,0,2)eq '::';$seen{$c}++ ? (): $c}@{"$current\::ISA"}}shift@out;return@out}sub extra_linker_flags {shift->_list_accessor('extra_linker_flags',@_)}sub extra_compiler_flags {shift->_list_accessor('extra_compiler_flags',@_)}sub _list_accessor {(my$self,local $_)=(shift,shift);my$p=$self->{properties};$p->{$_}=[@_]if @_;$p->{$_}=[]unless exists$p->{$_};return ref($p->{$_})? $p->{$_}: [$p->{$_}]}sub subclass {my ($pack,%opts)=@_;my$build_dir='_build';$pack->delete_filetree($build_dir)if -e $build_dir;die "Must provide 'code' or 'class' option to subclass()\n" unless$opts{code}or $opts{class};$opts{code}||= '';$opts{class}||= 'MyModuleBuilder';my$filename=File::Spec->catfile($build_dir,'lib',split '::',$opts{class}).'.pm';my$filedir=File::Basename::dirname($filename);$pack->log_verbose("Creating custom builder $filename in $filedir\n");File::Path::mkpath($filedir);die "Can't create directory $filedir: $!" unless -d $filedir;open(my$fh,'>',$filename)or die "Can't create $filename: $!";print$fh <<EOF;close$fh;unshift@INC,File::Spec->catdir(File::Spec->rel2abs($build_dir),'lib');eval "use $opts{class}";die $@ if $@;return$opts{class}}sub _guess_module_name {my$self=shift;my$p=$self->{properties};return if$p->{module_name};if ($p->{dist_version_from}&& -e $p->{dist_version_from}){my$mi=Module::Metadata->new_from_file($self->dist_version_from);$p->{module_name}=$mi->name}else {my$mod_path=my$mod_name=$p->{dist_name};$mod_name =~ s{-}{::}g;$mod_path =~ s{-}{/}g;$mod_path .= ".pm";if (-e $mod_path || -e "lib/$mod_path"){$p->{module_name}=$mod_name}else {$self->log_warn(<< 'END_WARN')}}}sub dist_name {my$self=shift;my$p=$self->{properties};my$me='dist_name';return$p->{$me}if defined$p->{$me};die "Can't determine distribution name, must supply either 'dist_name' or 'module_name' parameter" unless$self->module_name;($p->{$me}=$self->module_name)=~ s/::/-/g;return$p->{$me}}sub release_status {my ($self)=@_;my$me='release_status';my$p=$self->{properties};if (!defined$p->{$me}){$p->{$me}=$self->_is_dev_version ? 'testing' : 'stable'}unless ($p->{$me}=~ qr/\A(?:stable|testing|unstable)\z/){die "Illegal value '$p->{$me}' for $me\n"}if ($p->{$me}eq 'stable' && $self->_is_dev_version){my$version=$self->dist_version;die "Illegal value '$p->{$me}' with version '$version'\n"}return$p->{$me}}sub dist_suffix {my ($self)=@_;my$p=$self->{properties};my$me='dist_suffix';return$p->{$me}if defined$p->{$me};if ($self->release_status eq 'stable'){$p->{$me}=""}else {$p->{$me}=$self->_is_dev_version ? "" : "TRIAL" }return$p->{$me}}sub dist_version_from {my ($self)=@_;my$p=$self->{properties};my$me='dist_version_from';if ($self->module_name){$p->{$me}||= join('/','lib',split(/::/,$self->module_name)).'.pm'}return$p->{$me}|| undef}sub dist_version {my ($self)=@_;my$p=$self->{properties};my$me='dist_version';return$p->{$me}if defined$p->{$me};if (my$dist_version_from=$self->dist_version_from){my$version_from=File::Spec->catfile(split(qr{/},$dist_version_from));my$pm_info=Module::Metadata->new_from_file($version_from)or die "Can't find file $version_from to determine version";$p->{$me}=$self->normalize_version($pm_info->version());unless (defined$p->{$me}){die "Can't determine distribution version from $version_from"}}die ("Can't determine distribution version, must supply either 'dist_version',\n"."'dist_version_from', or 'module_name' parameter")unless defined$p->{$me};return$p->{$me}}sub _is_dev_version {my ($self)=@_;my$dist_version=$self->dist_version;my$version_obj=eval {version->new($dist_version)};return $@ ? 0 : $version_obj->is_alpha}sub dist_author {shift->_pod_parse('author')}sub dist_abstract {shift->_pod_parse('abstract')}sub _pod_parse {my ($self,$part)=@_;my$p=$self->{properties};my$member="dist_$part";return$p->{$member}if defined$p->{$member};my$docfile=$self->_main_docfile or return;open(my$fh,'<',$docfile)or return;require Module::Build::PodParser;my$parser=Module::Build::PodParser->new(fh=>$fh);my$method="get_$part";return$p->{$member}=$parser->$method()}sub version_from_file {return Module::Metadata->new_from_file($_[1])->version()}sub find_module_by_name {return Module::Metadata->find_module_by_name(@_[1,2])}{my%unlink_list_for_pid;sub _unlink_on_exit {my$self=shift;for my$f (@_){push @{$unlink_list_for_pid{$$}},$f if -f $f}return 1}END {for my$f (map glob($_),@{$unlink_list_for_pid{$$}|| []}){next unless -e $f;File::Path::rmtree($f,0,0)}}}sub add_to_cleanup {my$self=shift;my%files=map {$self->localize_file_path($_),1}@_;$self->{phash}{cleanup}->write(\%files)}sub cleanup {my$self=shift;my$all=$self->{phash}{cleanup}->read;return wantarray ? sort keys %$all : keys %$all}sub config_file {my$self=shift;return unless -d $self->config_dir;return File::Spec->catfile($self->config_dir,@_)}sub read_config {my ($self)=@_;my$file=$self->config_file('build_params')or die "Can't find 'build_params' in " .$self->config_dir;open(my$fh,'<',$file)or die "Can't read '$file': $!";my$ref=eval do {local $/;<$fh>};die if $@;close$fh;my$c;($self->{args},$c,$self->{properties})=@$ref;$self->{config}=Module::Build::Config->new(values=>$c)}sub has_config_data {my$self=shift;return scalar grep$self->{phash}{$_}->has_data(),qw(config_data features auto_features)}sub _write_data {my ($self,$filename,$data)=@_;my$file=$self->config_file($filename);open(my$fh,'>',$file)or die "Can't create '$file': $!";unless (ref($data)){print$fh $data;return}print {$fh}Module::Build::Dumper->_data_dump($data);close$fh}sub write_config {my ($self)=@_;File::Path::mkpath($self->{properties}{config_dir});-d $self->{properties}{config_dir}or die "Can't mkdir $self->{properties}{config_dir}: $!";my@items=@{$self->prereq_action_types};$self->_write_data('prereqs',{map {$_,$self->$_()}@items });$self->_write_data('build_params',[$self->{args},$self->{config}->values_set,$self->{properties}]);$self->_write_data('magicnum',$self->magic_number(int rand 1_000_000));$self->{phash}{$_}->write()foreach qw(notes cleanup features auto_features config_data runtime_params)}{my%packlist_map=('^File::Spec'=>'Cwd','^Devel::AssertOS'=>'Devel::CheckOS',);sub _find_packlist {my ($self,$inst,$mod)=@_;my$lookup=$mod;my$packlist=eval {$inst->packlist($lookup)};if (!$packlist){while (my ($re,$new_mod)=each%packlist_map){if ($mod =~ qr/$re/){$lookup=$new_mod;$packlist=eval {$inst->packlist($lookup)};last}}}return$packlist ? $lookup : undef}sub set_bundle_inc {my$self=shift;my$bundle_inc=$self->{properties}{bundle_inc};my$bundle_inc_preload=$self->{properties}{bundle_inc_preload};return unless inc::latest->can('loaded_modules');require ExtUtils::Installed;my$inst=eval {ExtUtils::Installed->new(extra_libs=>[@INC])};if ($@){$self->log_warn(<< "EUI_ERROR");return}my@bundle_list=map {[$_,0 ]}inc::latest->loaded_modules;while(@bundle_list){my ($mod,$prereq)=@{shift@bundle_list};my$lookup=$self->_find_packlist($inst,$mod);if (!$lookup){die << "NO_PACKLIST"}else {push @{$prereq ? $bundle_inc_preload : $bundle_inc},$lookup}}}}sub check_autofeatures {my ($self)=@_;my$features=$self->auto_features;return 1 unless %$features;my$longest=sub {my@str=@_ or croak("no strings given");my@len=map({length($_)}@str);my$max=0;my$longest;for my$i (0..$#len){($max,$longest)=($len[$i],$str[$i])if($len[$i]> $max)}return($longest)};my$max_name_len=length($longest->(keys %$features));my ($num_disabled,$log_text)=(0,"\nChecking optional features...\n");for my$name (sort keys %$features){$log_text .= $self->_feature_deps_msg($name,$max_name_len)}$num_disabled=()=$log_text =~ /disabled/g;if ($num_disabled){$self->log_warn($log_text);return 0}else {$self->log_verbose($log_text);return 1}}sub _feature_deps_msg {my ($self,$name,$max_name_len)=@_;$max_name_len ||= length$name;my$features=$self->auto_features;my$info=$features->{$name};my$feature_text="$name" .'.' x ($max_name_len - length($name)+ 4);my ($log_text,$disabled)=('','');if (my$failures=$self->prereq_failures($info)){$disabled=grep(/^(?:\w+_)?(?:requires|conflicts)$/,keys %$failures)? 1 : 0;$feature_text .= $disabled ? "disabled\n" : "enabled\n";for my$type (@{$self->prereq_action_types}){next unless exists$failures->{$type};$feature_text .= "  $type:\n";my$prereqs=$failures->{$type};for my$module (sort keys %$prereqs){my$status=$prereqs->{$module};my$required=($type =~ /^(?:\w+_)?(?:requires|conflicts)$/)? 1 : 0;my$prefix=($required)? '!' : '*';$feature_text .= "    $prefix $status->{message}\n"}}}else {$feature_text .= "enabled\n"}$log_text .= $feature_text if$disabled || $self->verbose;return$log_text}sub auto_config_requires {my ($self)=@_;my$p=$self->{properties};if ($self->dist_name ne 'Module-Build' && $self->auto_configure_requires &&!exists$p->{configure_requires}{'Module::Build'}){(my$ver=$VERSION)=~ s/^(\d+\.\d\d).*$/$1/;$self->log_warn(<<EOM);$self->_add_prereq('configure_requires','Module::Build',$ver)}if (inc::latest->can('loaded_module')){for my$mod (inc::latest->loaded_modules){next if exists$p->{configure_requires}{$mod};$self->_add_prereq('configure_requires',$mod,$mod->VERSION)}}return}sub auto_require {my ($self)=@_;my$p=$self->{properties};my$xs_files=$self->find_xs_files;if (!defined$p->{needs_compiler}){if ($self->pureperl_only && $self->allow_pureperl){$self->needs_compiler(0)}else {$self->needs_compiler(keys %$xs_files || defined$self->c_source)}}if ($self->needs_compiler){$self->_add_prereq('build_requires','ExtUtils::CBuilder',0);if (!$self->have_c_compiler){$self->log_warn(<<'EOM')}}if ($self->share_dir){$self->_add_prereq('requires','File::ShareDir','1.00')}return}sub _add_prereq {my ($self,$type,$module,$version)=@_;my$p=$self->{properties};$version=0 unless defined$version;if (exists$p->{$type}{$module}){return if$self->compare_versions($version,'<=',$p->{$type}{$module})}$self->log_verbose("Adding to $type\: $module => $version\n");$p->{$type}{$module}=$version;return 1}sub prereq_failures {my ($self,$info)=@_;my@types=@{$self->prereq_action_types};$info ||= {map {$_,$self->$_()}@types};my$out;for my$type (@types){my$prereqs=$info->{$type};for my$modname (keys %$prereqs){my$spec=$prereqs->{$modname};my$status=$self->check_installed_status($modname,$spec);if ($type =~ /^(?:\w+_)?conflicts$/){next if!$status->{ok};$status->{conflicts}=delete$status->{need};$status->{message}="$modname ($status->{have}) conflicts with this distribution"}elsif ($type =~ /^(?:\w+_)?recommends$/){next if$status->{ok};$status->{message}=(!ref($status->{have})&& $status->{have}eq '<none>' ? "$modname is not installed" : "$modname ($status->{have}) is installed, but we prefer to have $spec")}else {next if$status->{ok}}$out->{$type}{$modname}=$status}}return$out}sub _enum_prereqs {my$self=shift;my%prereqs;for my$type (@{$self->prereq_action_types}){if ($self->can($type)){my$prereq=$self->$type()|| {};$prereqs{$type}=$prereq if %$prereq}}return \%prereqs}sub check_prereq {my$self=shift;my$info=$self->_enum_prereqs;return 1 unless$info;my$log_text="Checking prerequisites...\n";my$failures=$self->prereq_failures($info);if ($failures){$self->log_warn($log_text);for my$type (@{$self->prereq_action_types}){my$prereqs=$failures->{$type};$self->log_warn("  ${type}:\n")if keys %$prereqs;for my$module (sort keys %$prereqs){my$status=$prereqs->{$module};my$prefix=($type =~ /^(?:\w+_)?recommends$/)? "* " : "! ";$self->log_warn("    $prefix $status->{message}\n")}}return 0}else {$self->log_verbose($log_text ."Looks good\n\n");return 1}}sub perl_version {my ($self)=@_;return $^V ? $self->perl_version_to_float(sprintf "%vd",$^V): $]}sub perl_version_to_float {my ($self,$version)=@_;return$version if grep(/\./,$version)< 2;$version =~ s/\./../;$version =~ s/\.(\d+)/sprintf '%03d', $1/eg;return$version}sub _parse_conditions {my ($self,$spec)=@_;return ">= 0" if not defined$spec;if ($spec =~ /^\s*([\w.]+)\s*$/){return (">= $spec")}else {return split /\s*,\s*/,$spec}}sub try_require {my ($self,$modname,$spec)=@_;my$status=$self->check_installed_status($modname,defined($spec)? $spec : 0);return unless$status->{ok};my$path=$modname;$path =~ s{::}{/}g;$path .= ".pm";if (defined$INC{$path}){return 1}elsif (exists$INC{$path}){return}else {return eval "require $modname"}}sub check_installed_status {my ($self,$modname,$spec)=@_;my%status=(need=>$spec);if ($modname eq 'perl'){$status{have}=$self->perl_version}elsif (eval {no strict;$status{have}=${"${modname}::VERSION"}}){}else {my$pm_info=Module::Metadata->new_from_module($modname);unless (defined($pm_info)){@status{qw(have message) }=('<none>',"$modname is not installed");return \%status}$status{have}=eval {$pm_info->version()};if ($spec and!defined($status{have})){@status{qw(have message) }=(undef,"Couldn't find a \$VERSION in prerequisite $modname");return \%status}}my@conditions=$self->_parse_conditions($spec);for (@conditions){my ($op,$version)=/^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x or die "Invalid prerequisite condition '$_' for $modname";$version=$self->perl_version_to_float($version)if$modname eq 'perl';next if$op eq '>=' and!$version;unless ($self->compare_versions($status{have},$op,$version)){$status{message}="$modname ($status{have}) is installed, but we need version $op $version";return \%status}}$status{ok}=1;return \%status}sub compare_versions {my$self=shift;my ($v1,$op,$v2)=@_;$v1=version->new($v1)unless eval {$v1->isa('version')};my$eval_str="\$v1 $op \$v2";my$result=eval$eval_str;$self->log_warn("error comparing versions: '$eval_str' $@")if $@;return$result}sub check_installed_version {my ($self,$modname,$spec)=@_;my$status=$self->check_installed_status($modname,$spec);if ($status->{ok}){return$status->{have}if$status->{have}and "$status->{have}" ne '<none>';return '0 but true'}$@=$status->{message};return 0}sub make_executable {my$self=shift;for (@_){my$current_mode=(stat $_)[2];chmod$current_mode | oct(111),$_}}sub is_executable {my ($self,$file)=@_;return -x $file}sub _startperl {shift()->config('startperl')}sub _added_to_INC {my$self=shift;my%seen;$seen{$_}++ foreach$self->_default_INC;return grep!$seen{$_}++,@INC}{my@default_inc;sub _default_INC {my$self=shift;return@default_inc if@default_inc;local$ENV{PERL5LIB};my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;my@inc=$self->_backticks($perl,'-le','print for @INC');chomp@inc;return@default_inc=@inc}}sub print_build_script {my ($self,$fh)=@_;my$build_package=$self->build_class;my$closedata="";my$config_requires;if (-f $self->metafile){my$meta=eval {$self->read_metafile($self->metafile)};$config_requires=$meta && $meta->{prereqs}{configure}{requires}{'Module::Build'}}$config_requires ||= 0;my%q=map {$_,$self->$_()}qw(config_dir base_dir);$q{base_dir}=Win32::GetShortPathName($q{base_dir})if$self->is_windowsish;$q{magic_numfile}=$self->config_file('magicnum');my@myINC=$self->_added_to_INC;for (@myINC,values%q){$_=File::Spec->canonpath($_)unless$self->is_vmsish;s/([\\\'])/\\$1/g}my$quoted_INC=join ",\n",map "     '$_'",@myINC;my$shebang=$self->_startperl;my$magic_number=$self->magic_number;my$dot_in_inc_code=$INC[-1]eq '.' ? <<'END' : '';print$fh <<EOF}sub create_mymeta {my ($self)=@_;my ($meta_obj,$mymeta);my@metafiles=($self->metafile2,$self->metafile,);my@mymetafiles=($self->mymetafile2,$self->mymetafile,);for my$f (@mymetafiles){if ($self->delete_filetree($f)){$self->log_verbose("Removed previous '$f'\n")}}if ($self->try_require("CPAN::Meta","2.142060")){for my$file (@metafiles){next unless -f $file;$meta_obj=eval {CPAN::Meta->load_file($file,{lazy_validation=>0 })};last if$meta_obj}}my$mymeta_obj;if ($meta_obj){my%updated=(%{$meta_obj->as_struct({version=>2.0 })},prereqs=>$self->_normalize_prereqs,dynamic_config=>0,generated_by=>"Module::Build version $Module::Build::VERSION",);$mymeta_obj=CPAN::Meta->new(\%updated,{lazy_validation=>0 })}else {$mymeta_obj=$self->_get_meta_object(quiet=>0,dynamic=>0,fatal=>1,auto=>0)}my@created=$self->_write_meta_files($mymeta_obj,'MYMETA');$self->log_warn("Could not create MYMETA files\n")unless@created;return 1}sub create_build_script {my ($self)=@_;$self->write_config;$self->create_mymeta;my ($build_script,$dist_name,$dist_version)=map$self->$_(),qw(build_script dist_name dist_version);if ($self->delete_filetree($build_script)){$self->log_verbose("Removed previous script '$build_script'\n")}$self->log_info("Creating new '$build_script' script for ","'$dist_name' version '$dist_version'\n");open(my$fh,'>',$build_script)or die "Can't create '$build_script': $!";$self->print_build_script($fh);close$fh;$self->make_executable($build_script);return 1}sub check_manifest {my$self=shift;return unless -e 'MANIFEST';require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);$self->log_verbose("Checking whether your kit is complete...\n");if (my@missed=ExtUtils::Manifest::manicheck()){$self->log_warn("WARNING: the following files are missing in your kit:\n","\t",join("\n\t",@missed),"\n","Please inform the author.\n\n")}else {$self->log_verbose("Looks good\n\n")}}sub dispatch {my$self=shift;local$self->{_completed_actions}={};if (@_){my ($action,%p)=@_;my$args=$p{args}? delete($p{args}): {};local$self->{invoked_action}=$action;local$self->{args}={%{$self->{args}},%$args};local$self->{properties}={%{$self->{properties}},%p};return$self->_call_action($action)}die "No build action specified" unless$self->{action};local$self->{invoked_action}=$self->{action};$self->_call_action($self->{action})}sub _call_action {my ($self,$action)=@_;return if$self->{_completed_actions}{$action}++;local$self->{action}=$action;my$method=$self->can_action($action);die "No action '$action' defined, try running the 'help' action.\n" unless$method;$self->log_debug("Starting ACTION_$action\n");my$rc=$self->$method();$self->log_debug("Finished ACTION_$action\n");return$rc}sub can_action {my ($self,$action)=@_;return$self->can("ACTION_$action")}sub cull_options {my$self=shift;my (@argv)=@_;return({},@argv)unless(ref($self));my$specs=$self->get_options;return({},@argv)unless($specs and %$specs);require Getopt::Long;my@specs;my$args={};for my$k (sort keys %$specs){my$v=$specs->{$k};die "Option specification '$k' conflicts with a " .ref$self ." option of the same name" if$self->valid_property($k);push@specs,$k .(defined$v->{type}? $v->{type}: '');push@specs,$v->{store}if exists$v->{store};$args->{$k}=$v->{default}if exists$v->{default}}local@ARGV=@argv;if (@specs){Getopt::Long::Configure('pass_through');Getopt::Long::GetOptions($args,@specs)}return$args,@ARGV}sub unparse_args {my ($self,$args)=@_;my@out;for my$k (sort keys %$args){my$v=$args->{$k};push@out,(ref$v eq 'HASH' ? map {+"--$k","$_=$v->{$_}"}sort keys %$v : ref$v eq 'ARRAY' ? map {+"--$k",$_}@$v : ("--$k",$v))}return@out}sub args {my$self=shift;return wantarray ? %{$self->{args}}: $self->{args}unless @_;my$key=shift;$self->{args}{$key}=shift if @_;return$self->{args}{$key}}sub _translate_option {my$self=shift;my$opt=shift;(my$tr_opt=$opt)=~ tr/-/_/;return$tr_opt if grep$tr_opt =~ /^(?:no_?)?$_$/,qw(create_license create_makefile_pl create_readme extra_compiler_flags extra_linker_flags install_base install_path meta_add meta_merge test_files use_rcfile use_tap_harness tap_harness_args cpan_client pureperl_only allow_pureperl);return$opt}my%singular_argument=map {($_=>1)}qw/install_base prefix destdir installdirs verbose quiet uninst debug sign/;sub _read_arg {my ($self,$args,$key,$val)=@_;$key=$self->_translate_option($key);if (exists$args->{$key}and not $singular_argument{$key}){$args->{$key}=[$args->{$key}]unless ref$args->{$key};push @{$args->{$key}},$val}else {$args->{$key}=$val}}sub _optional_arg {my$self=shift;my$opt=shift;my$argv=shift;$opt=$self->_translate_option($opt);my@bool_opts=qw(build_bat create_license create_readme pollute quiet uninst use_rcfile verbose debug sign use_tap_harness pureperl_only allow_pureperl);if (grep$opt =~ /^no[-_]?$_$/,@bool_opts){$opt =~ s/^no-?//;return ($opt,0)}return ($opt,shift(@$argv))unless grep $_ eq $opt,@bool_opts;my$arg=1;$arg=shift(@$argv)if @$argv && $argv->[0]=~ /^\d+$/;return ($opt,$arg)}sub read_args {my$self=shift;(my$args,@_)=$self->cull_options(@_);my%args=%$args;my$opt_re=qr/[\w\-]+/;my ($action,@argv);while (@_){local $_=shift;if (/^(?:--)?($opt_re)=(.*)$/){$self->_read_arg(\%args,$1,$2)}elsif (/^--($opt_re)$/){my($opt,$arg)=$self->_optional_arg($1,\@_);$self->_read_arg(\%args,$opt,$arg)}elsif (/^($opt_re)$/ and!defined($action)){$action=$1}else {push@argv,$_}}$args{ARGV}=\@argv;for ('extra_compiler_flags','extra_linker_flags'){$args{$_}=[$self->split_like_shell($args{$_})]if exists$args{$_}}for ('include_dirs'){$args{$_}=[$args{$_}]if exists$args{$_}&&!ref$args{$_}}for ($self->hash_properties,'config'){next unless exists$args{$_};my%hash;$args{$_}||= [];$args{$_}=[$args{$_}]unless ref$args{$_};for my$arg (@{$args{$_}}){$arg =~ /($opt_re)=(.*)/ or die "Malformed '$_' argument: '$arg' should be something like 'foo=bar'";$hash{$1}=$2}$args{$_}=\%hash}for my$key (qw(prefix install_base destdir)){next if!defined$args{$key};$args{$key}=$self->_detildefy($args{$key})}for my$key (qw(install_path)){next if!defined$args{$key};for my$subkey (keys %{$args{$key}}){next if!defined$args{$key}{$subkey};my$subkey_ext=$self->_detildefy($args{$key}{$subkey});if ($subkey eq 'html'){$args{$key}{binhtml}=$subkey_ext;$args{$key}{libhtml}=$subkey_ext}else {$args{$key}{$subkey}=$subkey_ext}}}if ($args{makefile_env_macros}){require Module::Build::Compat;%args=(%args,Module::Build::Compat->makefile_to_build_macros)}return \%args,$action}sub _detildefy {}sub _merge_arglist {my($self,$opts1,$opts2)=@_;$opts1 ||= {};$opts2 ||= {};my%new_opts=%$opts1;while (my ($key,$val)=each %$opts2){if (exists($opts1->{$key})){if (ref($val)eq 'HASH'){while (my ($k,$v)=each %$val){$new_opts{$key}{$k}=$v unless exists($opts1->{$key}{$k})}}}else {$new_opts{$key}=$val}}return%new_opts}sub _home_dir {my@home_dirs;push(@home_dirs,$ENV{HOME})if$ENV{HOME};push(@home_dirs,File::Spec->catpath($ENV{HOMEDRIVE},$ENV{HOMEPATH},''))if$ENV{HOMEDRIVE}&& $ENV{HOMEPATH};my@other_home_envs=qw(USERPROFILE APPDATA WINDIR SYS$LOGIN);push(@home_dirs,map$ENV{$_},grep$ENV{$_},@other_home_envs);my@real_home_dirs=grep -d,@home_dirs;return wantarray ? @real_home_dirs : shift(@real_home_dirs)}sub _find_user_config {my$self=shift;my$file=shift;for my$dir ($self->_home_dir){my$path=File::Spec->catfile($dir,$file);return$path if -e $path}return undef}sub read_modulebuildrc {my($self,$action)=@_;return ()unless$self->use_rcfile;my$modulebuildrc;if (exists($ENV{MODULEBUILDRC})&& $ENV{MODULEBUILDRC}eq 'NONE'){return ()}elsif (exists($ENV{MODULEBUILDRC})&& -e $ENV{MODULEBUILDRC}){$modulebuildrc=$ENV{MODULEBUILDRC}}elsif (exists($ENV{MODULEBUILDRC})){$self->log_warn("WARNING: Can't find resource file " ."'$ENV{MODULEBUILDRC}' defined in environment.\n" ."No options loaded\n");return ()}else {$modulebuildrc=$self->_find_user_config('.modulebuildrc');return ()unless$modulebuildrc}open(my$fh,'<',$modulebuildrc)or die "Can't open $modulebuildrc: $!";my%options;my$buffer='';while (defined(my$line=<$fh>)){chomp($line);$line =~ s/#.*$//;next unless length($line);if ($line =~ /^\S/){if ($buffer){my($action,$options)=split(/\s+/,$buffer,2);$options{$action}.= $options .' ';$buffer=''}$buffer=$line}else {$buffer .= $line}}if ($buffer){my($action,$options)=split(/\s+/,$buffer,2);$options{$action}.= $options .' '}my ($global_opts)=$self->read_args($self->split_like_shell($options{'*'}|| ''));if ($action eq 'fakeinstall' &&!exists$options{fakeinstall}){$action='install'}my ($action_opts)=$self->read_args($self->split_like_shell($options{$action}|| ''));return$self->_merge_arglist($action_opts,$global_opts)}sub merge_modulebuildrc {my($self,$action,%cmdline_opts)=@_;my%rc_opts=$self->read_modulebuildrc($action || $self->{action}|| 'build');my%new_opts=$self->_merge_arglist(\%cmdline_opts,\%rc_opts);$self->merge_args($action,%new_opts)}sub merge_args {my ($self,$action,%args)=@_;$self->{action}=$action if defined$action;my%additive=map {$_=>1}$self->hash_properties;while (my ($key,$val)=each%args){$self->{phash}{runtime_params}->access($key=>$val)if$self->valid_property($key);if ($key eq 'config'){$self->config($_=>$val->{$_})foreach keys %$val}else {my$add_to=$additive{$key}? $self->{properties}{$key}: $self->valid_property($key)? $self->{properties}: $self->{args};if ($additive{$key}){$add_to->{$_}=$val->{$_}foreach keys %$val}else {$add_to->{$key}=$val}}}}sub cull_args {my$self=shift;my@arg_list=@_;unshift@arg_list,$self->split_like_shell($ENV{PERL_MB_OPT})if$ENV{PERL_MB_OPT};my ($args,$action)=$self->read_args(@arg_list);$self->merge_args($action,%$args);$self->merge_modulebuildrc($action,%$args)}sub super_classes {my ($self,$class,$seen)=@_;$class ||= ref($self)|| $self;$seen ||= {};no strict 'refs';my@super=grep {not $seen->{$_}++}$class,@{$class .'::ISA'};return@super,map {$self->super_classes($_,$seen)}@super}sub known_actions {my ($self)=@_;my%actions;no strict 'refs';for my$class ($self->super_classes){for (keys %{$class .'::'}){$actions{$1}++ if /^ACTION_(\w+)/}}return wantarray ? sort keys%actions : \%actions}sub get_action_docs {my ($self,$action)=@_;my$actions=$self->known_actions;die "No known action '$action'" unless$actions->{$action};my ($files_found,@docs)=(0);for my$class ($self->super_classes){(my$file=$class)=~ s{::}{/}g;$file=$INC{$file .'.pm'}or next;open(my$fh,'<',$file)or next;$files_found++;local $_;while (<$fh>){last if /^=head1 ACTIONS\s/}my$style;while (<$fh>){last if /^=head1 /;if(/^=(item|head2)\s+\Q$action\E\b/){$style=$1;push@docs,$_;last}}$style or next;if($style eq 'item'){my ($found,$inlist)=(0,0);while (<$fh>){if (/^=(item|back)/){last unless$inlist}push@docs,$_;++$inlist if /^=over/;--$inlist if /^=back/}}else {while (<$fh>){last if(/^=(?:head[12]|cut)/);push@docs,$_}}}unless ($files_found){$@="Couldn't find any documentation to search";return}unless (@docs){$@="Couldn't find any docs for action '$action'";return}return join '',@docs}sub ACTION_prereq_report {my$self=shift;$self->log_info($self->prereq_report)}sub ACTION_prereq_data {my$self=shift;$self->log_info(Module::Build::Dumper->_data_dump($self->prereq_data))}sub prereq_data {my$self=shift;my@types=('configure_requires',@{$self->prereq_action_types});my$info={map {$_=>$self->$_()}grep {%{$self->$_()}}@types };return$info}sub prereq_report {my$self=shift;my$info=$self->prereq_data;my$output='';for my$type (sort keys %$info){my$prereqs=$info->{$type};$output .= "\n$type:\n";my$mod_len=2;my$ver_len=4;my%mods;for my$modname (sort keys %$prereqs){my$spec=$prereqs->{$modname};my$len=length$modname;$mod_len=$len if$len > $mod_len;$spec ||= '0';$len=length$spec;$ver_len=$len if$len > $ver_len;my$mod=$self->check_installed_status($modname,$spec);$mod->{name}=$modname;$mod->{ok}||= 0;$mod->{ok}=!$mod->{ok}if$type =~ /^(\w+_)?conflicts$/;$mods{lc$modname}=$mod}my$space=q{ } x ($mod_len - 3);my$vspace=q{ } x ($ver_len - 3);my$sline=q{-} x ($mod_len - 3);my$vline=q{-} x ($ver_len - 3);my$disposition=($type =~ /^(\w+_)?conflicts$/)? 'Clash' : 'Need';$output .= "    Module $space  $disposition $vspace  Have\n"."    ------$sline+------$vline-+----------\n";for my$k (sort keys%mods){my$mod=$mods{$k};my$space=q{ } x ($mod_len - length$k);my$vspace=q{ } x ($ver_len - length$mod->{need});my$f=$mod->{ok}? ' ' : '!';$output .= "  $f $mod->{name} $space     $mod->{need}  $vspace   ".(defined($mod->{have})? $mod->{have}: "")."\n"}}return$output}sub ACTION_help {my ($self)=@_;my$actions=$self->known_actions;if (@{$self->{args}{ARGV}}){my$msg=eval {$self->get_action_docs($self->{args}{ARGV}[0],$actions)};print $@ ? "$@\n" : $msg;return}print <<EOF;print$self->_action_listing($actions);print "\nRun `Build help <action>` for details on an individual action.\n";print "See `perldoc Module::Build` for complete documentation.\n"}sub _action_listing {my ($self,$actions)=@_;my@actions=sort keys %$actions;@actions=map$actions[($_ + ($_ % 2)* @actions)/ 2],0..$#actions;my$out='';while (my ($one,$two)=splice@actions,0,2){$out .= sprintf("  %-12s                   %-12s\n",$one,$two||'')}$out =~ s{\s*$}{}mg;return$out}sub ACTION_retest {my ($self)=@_;local@INC=@INC;@INC=grep {ref()|| -d}@INC if@INC > 100;$self->do_tests}sub ACTION_testall {my ($self)=@_;my@types;for my$action (grep {$_ ne 'all'}$self->get_test_types){push(@types,$action)}$self->generic_test(types=>['default',@types])}sub get_test_types {my ($self)=@_;my$t=$self->{properties}->{test_types};return (defined$t ? (wantarray ? sort keys %$t : keys %$t): ())}sub ACTION_test {my ($self)=@_;$self->generic_test(type=>'default')}sub generic_test {my$self=shift;(@_ % 2)and croak('Odd number of elements in argument hash');my%args=@_;my$p=$self->{properties};my@types=((exists($args{type})? $args{type}: ()),(exists($args{types})? @{$args{types}}: ()),);@types or croak "need some types of tests to check";my%test_types=(default=>$p->{test_file_exts},(defined($p->{test_types})? %{$p->{test_types}}: ()),);for my$type (@types){croak "$type not defined in test_types!" unless defined$test_types{$type }}local$p->{test_file_exts}=[map {ref $_ ? @$_ : $_}@test_types{@types}];$self->depends_on('code');local@INC=@INC;unshift@INC,(File::Spec->catdir($p->{base_dir},$self->blib,'lib'),File::Spec->catdir($p->{base_dir},$self->blib,'arch'));@INC=grep {ref()|| -d}@INC if@INC > 100;$self->do_tests}sub do_tests {my$self=shift;my$tests=$self->find_test_files;local$ENV{PERL_DL_NONLAZY}=1;if(@$tests){my$args=$self->tap_harness_args;if($self->use_tap_harness or ($args and %$args)){my$aggregate=$self->run_tap_harness($tests);if ($aggregate->has_errors){die "Errors in testing.  Cannot continue.\n"}}else {$self->run_test_harness($tests)}}else {$self->log_info("No tests defined.\n")}$self->run_visual_script}sub run_tap_harness {my ($self,$tests)=@_;require TAP::Harness::Env;my$aggregate=TAP::Harness::Env->create({lib=>[@INC],verbosity=>$self->{properties}{verbose},switches=>[$self->harness_switches ],%{$self->tap_harness_args},})->runtests(@$tests);return$aggregate}sub run_test_harness {my ($self,$tests)=@_;require Test::Harness;local$Test::Harness::verbose=$self->verbose || 0;local$Test::Harness::switches=join ' ',$self->harness_switches;Test::Harness::runtests(@$tests)}sub run_visual_script {my$self=shift;$self->run_perl_script('visual.pl','-Mblib='.$self->blib)if -e 'visual.pl'}sub harness_switches {my$self=shift;my@res;push@res,qw(-w -d) if$self->{properties}{debugger};push@res,'-MDevel::Cover' if$self->{properties}{cover};return@res}sub test_files {my$self=shift;my$p=$self->{properties};if (@_){return$p->{test_files}=(@_==1 ? shift : [@_])}return$self->find_test_files}sub expand_test_dir {my ($self,$dir)=@_;my$exts=$self->{properties}{test_file_exts};return sort map {@{$self->rscan_dir($dir,qr{^[^.].*\Q$_\E$})}}@$exts if$self->recursive_test_files;return sort map {glob File::Spec->catfile($dir,"*$_")}@$exts}sub ACTION_testdb {my ($self)=@_;local$self->{properties}{debugger}=1;$self->depends_on('test')}sub ACTION_testcover {my ($self)=@_;unless (Module::Metadata->find_module_by_name('Devel::Cover')){warn("Cannot run testcover action unless Devel::Cover is installed.\n");return}$self->add_to_cleanup('coverage','cover_db');$self->depends_on('code');if (-e 'cover_db'){my$pm_files=$self->rscan_dir (File::Spec->catdir($self->blib,'lib'),$self->file_qr('\.pm$'));my$cover_files=$self->rscan_dir('cover_db',sub {-f $_ and not /\.html$/});$self->do_system(qw(cover -delete))unless$self->up_to_date($pm_files,$cover_files)&& $self->up_to_date($self->test_files,$cover_files)}local$self->{properties}{cover}=1;$self->depends_on('test');$self->do_system('cover')}sub ACTION_code {my ($self)=@_;my$blib=$self->blib;$self->add_to_cleanup($blib);File::Path::mkpath(File::Spec->catdir($blib,'arch'));if (my$split=$self->autosplit){$self->autosplit_file($_,$blib)for ref($split)? @$split : ($split)}for my$element (@{$self->build_elements}){my$method="process_${element}_files";$method="process_files_by_extension" unless$self->can($method);$self->$method($element)}$self->depends_on('config_data')}sub ACTION_build {my$self=shift;$self->log_info("Building " .$self->dist_name ."\n");$self->depends_on('code');$self->depends_on('docs')}sub process_files_by_extension {my ($self,$ext)=@_;my$method="find_${ext}_files";my$files=$self->can($method)? $self->$method(): $self->_find_file_by_type($ext,'lib');for my$file (sort keys %$files){$self->copy_if_modified(from=>$file,to=>File::Spec->catfile($self->blib,$files->{$file}))}}sub process_support_files {my$self=shift;my$p=$self->{properties};return unless$p->{c_source};return if$self->pureperl_only && $self->allow_pureperl;my$files;if (ref($p->{c_source})eq "ARRAY"){push @{$p->{include_dirs}},@{$p->{c_source}};for my$path (@{$p->{c_source}}){push @$files,@{$self->rscan_dir($path,$self->file_qr('\.c(c|p|pp|xx|\+\+)?$'))}}}else {push @{$p->{include_dirs}},$p->{c_source};$files=$self->rscan_dir($p->{c_source},$self->file_qr('\.c(c|p|pp|xx|\+\+)?$'))}for my$file (@$files){push @{$p->{objects}},$self->compile_c($file)}}sub process_share_dir_files {my$self=shift;my$files=$self->_find_share_dir_files;return unless$files;my$share_prefix=File::Spec->catdir($self->blib,qw/lib auto share/);for my$file (sort keys %$files){$self->copy_if_modified(from=>$file,to=>File::Spec->catfile($share_prefix,$files->{$file}))}}sub _find_share_dir_files {my$self=shift;my$share_dir=$self->share_dir;return unless$share_dir;my@file_map;if ($share_dir->{dist}){my$prefix="dist/".$self->dist_name;push@file_map,$self->_share_dir_map($prefix,$share_dir->{dist})}if ($share_dir->{module}){for my$mod (sort keys %{$share_dir->{module}}){(my$altmod=$mod)=~ s{::}{-}g;my$prefix="module/$altmod";push@file_map,$self->_share_dir_map($prefix,$share_dir->{module}{$mod})}}return {@file_map }}sub _share_dir_map {my ($self,$prefix,$list)=@_;my%files;for my$dir (@$list){for my$f (@{$self->rscan_dir($dir,sub {-f})}){$f =~ s{\A.*?\Q$dir\E/}{};$files{"$dir/$f"}="$prefix/$f"}}return%files}sub process_PL_files {my ($self)=@_;my$files=$self->find_PL_files;for my$file (sort keys %$files){my$to=$files->{$file};unless ($self->up_to_date($file,$to)){$self->run_perl_script($file,[],[@$to])or die "$file failed";$self->add_to_cleanup(@$to)}}}sub process_xs_files {my$self=shift;return if$self->pureperl_only && $self->allow_pureperl;my$files=$self->find_xs_files;croak 'Can\'t build xs files under --pureperl-only' if %$files && $self->pureperl_only;for my$from (sort keys %$files){my$to=$files->{$from};unless ($from eq $to){$self->add_to_cleanup($to);$self->copy_if_modified(from=>$from,to=>$to)}$self->process_xs($to)}}sub process_pod_files {shift()->process_files_by_extension(shift())}sub process_pm_files {shift()->process_files_by_extension(shift())}sub process_script_files {my$self=shift;my$files=$self->find_script_files;return unless keys %$files;my$script_dir=File::Spec->catdir($self->blib,'script');File::Path::mkpath($script_dir);for my$file (sort keys %$files){my$result=$self->copy_if_modified($file,$script_dir,'flatten')or next;$self->fix_shebang_line($result)unless$self->is_vmsish;$self->make_executable($result)}}sub find_PL_files {my$self=shift;if (my$files=$self->{properties}{PL_files}){if (ref$files eq 'ARRAY'){return {map {$_,[/^(.*)\.PL$/]}map$self->localize_file_path($_),@$files }}elsif (ref$files eq 'HASH'){my%out;while (my ($file,$to)=each %$files){$out{$self->localize_file_path($file)}=[map$self->localize_file_path($_),ref$to ? @$to : ($to)]}return \%out}else {die "'PL_files' must be a hash reference or array reference"}}return unless -d 'lib';return {map {$_,[/^(.*)\.PL$/i ]}@{$self->rscan_dir('lib',$self->file_qr('\.PL$'))}}}sub find_pm_files {shift->_find_file_by_type('pm','lib')}sub find_pod_files {shift->_find_file_by_type('pod','lib')}sub find_xs_files {shift->_find_file_by_type('xs','lib')}sub find_script_files {my$self=shift;if (my$files=$self->script_files){return {map {$self->localize_file_path($_),$files->{$_}}keys %$files }}return {}}sub find_test_files {my$self=shift;my$p=$self->{properties};if (my$files=$p->{test_files}){$files=[sort keys %$files]if ref$files eq 'HASH';$files=[map {-d $_ ? $self->expand_test_dir($_): $_}map glob,$self->split_like_shell($files)];return [map$self->localize_file_path($_),@$files ]}else {my@tests;push@tests,'test.pl' if -e 'test.pl';push@tests,$self->expand_test_dir('t')if -e 't' and -d _;return \@tests}}sub _find_file_by_type {my ($self,$type,$dir)=@_;if (my$files=$self->{properties}{"${type}_files"}){return {map$self->localize_file_path($_),%$files }}return {}unless -d $dir;return {map {$_,$_}map$self->localize_file_path($_),grep!/\.\#/,@{$self->rscan_dir($dir,$self->file_qr("\\.$type\$"))}}}sub localize_file_path {my ($self,$path)=@_;return File::Spec->catfile(split m{/},$path)}sub localize_dir_path {my ($self,$path)=@_;return File::Spec->catdir(split m{/},$path)}sub fix_shebang_line {my ($self,@files)=@_;my$c=ref($self)? $self->{config}: 'Module::Build::Config';my ($does_shbang)=$c->get('sharpbang')=~ /^\s*\#\!/;for my$file (@files){open(my$FIXIN,'<',$file)or die "Can't process '$file': $!";local $/="\n";chomp(my$line=<$FIXIN>);next unless$line =~ s/^\s*\#!\s*//;my ($cmd,$arg)=(split(' ',$line,2),'');next unless$cmd =~ /perl/i;my$interpreter=$self->{properties}{perl};$self->log_verbose("Changing sharpbang in $file to $interpreter\n");my$shb='';$shb .= $c->get('sharpbang')."$interpreter $arg\n" if$does_shbang;open(my$FIXOUT,'>',"$file.new")or die "Can't create new $file: $!\n";local $\;undef $/;print$FIXOUT $shb,<$FIXIN>;close$FIXIN;close$FIXOUT;rename($file,"$file.bak")or die "Can't rename $file to $file.bak: $!";rename("$file.new",$file)or die "Can't rename $file.new to $file: $!";$self->delete_filetree("$file.bak")or $self->log_warn("Couldn't clean up $file.bak, leaving it there");$self->do_system($c->get('eunicefix'),$file)if$c->get('eunicefix')ne ':'}}sub ACTION_testpod {my$self=shift;$self->depends_on('docs');eval q{use Test::Pod 0.95; 1} or die "The 'testpod' action requires Test::Pod version 0.95";my@files=sort keys %{$self->_find_pods($self->libdoc_dirs)},keys %{$self->_find_pods ($self->bindoc_dirs,exclude=>[$self->file_qr('\.bat$')])}or die "Couldn't find any POD files to test\n";{package Module::Build::PodTester;Test::Pod->import(tests=>scalar@files);pod_file_ok($_)foreach@files}}sub ACTION_testpodcoverage {my$self=shift;$self->depends_on('docs');eval q{use Test::Pod::Coverage 1.00; 1} or die "The 'testpodcoverage' action requires ","Test::Pod::Coverage version 1.00";local@INC=@INC;my$p=$self->{properties};unshift(@INC,File::Spec->catdir($p->{base_dir},$self->blib,'lib'),);all_pod_coverage_ok()}sub ACTION_docs {my$self=shift;$self->depends_on('code');$self->depends_on('manpages','html')}sub _is_default_installable {my$self=shift;my$type=shift;return ($self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs)->{$type}))? 1 : 0}sub _is_ActivePerl {my$self=shift;unless (exists($self->{_is_ActivePerl})){$self->{_is_ActivePerl}=(eval {require ActivePerl::DocTools}|| 0)}return$self->{_is_ActivePerl}}sub _is_ActivePPM {my$self=shift;unless (exists($self->{_is_ActivePPM})){$self->{_is_ActivePPM}=(eval {require ActivePerl::PPM}|| 0)}return$self->{_is_ActivePPM}}sub ACTION_manpages {my$self=shift;return unless$self->_mb_feature('manpage_support');$self->depends_on('code');my%extra_manify_args=$self->{properties}{'extra_manify_args'}? %{$self->{properties}{'extra_manify_args'}}: ();for my$type (qw(bin lib)){next unless ($self->invoked_action eq 'manpages' || $self->_is_default_installable("${type}doc"));my$files=$self->_find_pods($self->{properties}{"${type}doc_dirs"},exclude=>[$self->file_qr('\.bat$')]);next unless %$files;my$sub=$self->can("manify_${type}_pods");$self->$sub(%extra_manify_args)if defined($sub)}}sub manify_bin_pods {my$self=shift;my%podman_args=(section=>1,@_);my$files=$self->_find_pods($self->{properties}{bindoc_dirs},exclude=>[$self->file_qr('\.bat$')]);return unless keys %$files;my$mandir=File::Spec->catdir($self->blib,'bindoc');File::Path::mkpath($mandir,0,oct(777));require Pod::Man;for my$file (sort keys %$files){my$parser=Pod::Man->new(%podman_args);my$manpage=$self->man1page_name($file).'.' .$self->config('man1ext');my$outfile=File::Spec->catfile($mandir,$manpage);next if$self->up_to_date($file,$outfile);$self->log_verbose("Manifying $file -> $outfile\n");eval {$parser->parse_from_file($file,$outfile);1}or $self->log_warn("Error creating '$outfile': $@\n");$files->{$file}=$outfile}}sub manify_lib_pods {my$self=shift;my%podman_args=(section=>3,@_);my$files=$self->_find_pods($self->{properties}{libdoc_dirs});return unless keys %$files;my$mandir=File::Spec->catdir($self->blib,'libdoc');File::Path::mkpath($mandir,0,oct(777));require Pod::Man;for my$file (sort keys %$files){my$parser=Pod::Man->new(%podman_args);my$manpage=$self->man3page_name($files->{$file}).'.' .$self->config('man3ext');my$outfile=File::Spec->catfile($mandir,$manpage);next if$self->up_to_date($file,$outfile);$self->log_verbose("Manifying $file -> $outfile\n");eval {$parser->parse_from_file($file,$outfile);1}or $self->log_warn("Error creating '$outfile': $@\n");$files->{$file}=$outfile}}sub _find_pods {my ($self,$dirs,%args)=@_;my%files;for my$spec (@$dirs){my$dir=$self->localize_dir_path($spec);next unless -e $dir;FILE: foreach my$file (@{$self->rscan_dir($dir)}){for my$regexp (@{$args{exclude}}){next FILE if$file =~ $regexp}$file=$self->localize_file_path($file);$files{$file}=File::Spec->abs2rel($file,$dir)if$self->contains_pod($file)}}return \%files}sub contains_pod {my ($self,$file)=@_;return '' unless -T $file;open(my$fh,'<',$file)or die "Can't open $file: $!";while (my$line=<$fh>){return 1 if$line =~ /^\=(?:head|pod|item)/}return ''}sub ACTION_html {my$self=shift;return unless$self->_mb_feature('HTML_support');$self->depends_on('code');for my$type (qw(bin lib)){next unless ($self->invoked_action eq 'html' || $self->_is_default_installable("${type}html"));$self->htmlify_pods($type)}}sub htmlify_pods {my$self=shift;my$type=shift;my$htmldir=shift || File::Spec->catdir($self->blib,"${type}html");$self->add_to_cleanup('pod2htm*');my$pods=$self->_find_pods($self->{properties}{"${type}doc_dirs"},exclude=>[$self->file_qr('\.(?:bat|com|html)$')]);return unless %$pods;unless (-d $htmldir){File::Path::mkpath($htmldir,0,oct(755))or die "Couldn't mkdir $htmldir: $!"}my@rootdirs=($type eq 'bin')? qw(bin) : $self->installdirs eq 'core' ? qw(lib) : qw(site lib);my$podroot=$ENV{PERL_CORE}? File::Basename::dirname($ENV{PERL_CORE}): $self->original_prefix('core');my$htmlroot=$self->install_sets('core')->{libhtml};my$podpath;unless (defined$self->args('html_links')and!$self->args('html_links')){my@podpath=((map {File::Spec->abs2rel($_,$podroot)}grep {-d}($self->install_sets('core','lib'),$self->install_sets('core','bin'),$self->install_sets('site','lib'),)),File::Spec->rel2abs($self->blib));$podpath=$ENV{PERL_CORE}? File::Spec->catdir($podroot,'lib'): join(":",map {tr,:\\,|/,;$_}@podpath)}my$blibdir=join('/',File::Spec->splitdir((File::Spec->splitpath(File::Spec->rel2abs($htmldir),1))[1]),'');my ($with_ActiveState,$htmltool);if ($with_ActiveState=$self->_is_ActivePerl && eval {require ActivePerl::DocTools::Pod;1}){my$tool_v=ActiveState::DocTools::Pod->VERSION;$htmltool="ActiveState::DocTools::Pod";$htmltool .= " $tool_v" if$tool_v && length$tool_v}else {require Module::Build::PodParser;require Pod::Html;$htmltool="Pod::Html " .Pod::Html->VERSION}$self->log_verbose("Converting Pod to HTML with $htmltool\n");my$errors=0;POD: foreach my$pod (sort keys %$pods){my ($name,$path)=File::Basename::fileparse($pods->{$pod},$self->file_qr('\.(?:pm|plx?|pod)$'));my@dirs=File::Spec->splitdir(File::Spec->canonpath($path));pop(@dirs)if scalar(@dirs)&& $dirs[-1]eq File::Spec->curdir;my$fulldir=File::Spec->catdir($htmldir,@rootdirs,@dirs);my$tmpfile=File::Spec->catfile($fulldir,"${name}.tmp");my$outfile=File::Spec->catfile($fulldir,"${name}.html");my$infile=File::Spec->abs2rel($pod);next if$self->up_to_date($infile,$outfile);unless (-d $fulldir){File::Path::mkpath($fulldir,0,oct(755))or die "Couldn't mkdir $fulldir: $!"}$self->log_verbose("HTMLifying $infile -> $outfile\n");if ($with_ActiveState){my$depth=@rootdirs + @dirs;my%opts=(infile=>$infile,outfile=>$tmpfile,(defined($podpath)? (podpath=>$podpath): ()),podroot=>$podroot,index=>1,depth=>$depth,);eval {ActivePerl::DocTools::Pod::pod2html(map {($_,$opts{$_})}sort keys%opts);1}or $self->log_warn("[$htmltool] pod2html (" .join(", ",map {"q{$_} => q{$opts{$_}}"}(sort keys%opts)).") failed: $@")}else {my$path2root=File::Spec->catdir((File::Spec->updir)x @dirs);open(my$fh,'<',$infile)or die "Can't read $infile: $!";my$abstract=Module::Build::PodParser->new(fh=>$fh)->get_abstract();my$title=join('::',(@dirs,$name));$title .= " - $abstract" if$abstract;my@opts=("--title=$title",(defined($podpath)? "--podpath=$podpath" : ()),"--infile=$infile","--outfile=$tmpfile","--podroot=$podroot",($path2root ? "--htmlroot=$path2root" : ()),);unless (eval{Pod::Html->VERSION(1.12)}){push(@opts,('--flush'))}if (eval{Pod::Html->VERSION(1.12)}){push(@opts,('--header','--backlink'))}elsif (eval{Pod::Html->VERSION(1.03)}){push(@opts,('--header','--backlink=Back to Top'))}$self->log_verbose("P::H::pod2html @opts\n");{my$orig=Cwd::getcwd();eval {Pod::Html::pod2html(@opts);1}or $self->log_warn("[$htmltool] pod2html( " .join(", ",map {"q{$_}"}@opts).") failed: $@");chdir($orig)}}if (!-r $tmpfile){$errors++;next POD}open(my$fh,'<',$tmpfile)or die "Can't read $tmpfile: $!";my$html=join('',<$fh>);close$fh;if (!$self->_is_ActivePerl){$html =~ s#^<!DOCTYPE .*?>#<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">#im;$html =~ s#<html xmlns="http://www.w3.org/1999/xhtml">#<html>#i;$html =~ s#<head>#<head>\n<!-- saved from url=(0017)http://localhost/ -->#i}$html =~ s/\Q$blibdir\E//g;open($fh,'>',$outfile)or die "Can't write $outfile: $!";print$fh $html;close$fh;unlink($tmpfile)}return!$errors}sub man1page_name {my$self=shift;return File::Basename::basename(shift)}sub man3page_name {my$self=shift;my ($vol,$dirs,$file)=File::Spec->splitpath(shift);my@dirs=File::Spec->splitdir(File::Spec->canonpath($dirs));$file =~ s/\.p(?:od|m|l)\z//i;return join($self->manpage_separator,@dirs,$file)}sub manpage_separator {return '::'}sub ACTION_diff {my$self=shift;$self->depends_on('build');my$local_lib=File::Spec->rel2abs('lib');my@myINC=grep {$_ ne $local_lib}@INC;push@myINC,map$self->install_destination($_),qw(lib arch);my@flags=@{$self->{args}{ARGV}};@flags=$self->split_like_shell($self->{args}{flags}|| '')unless@flags;my$installmap=$self->install_map;delete$installmap->{read};delete$installmap->{write};my$text_suffix=$self->file_qr('\.(pm|pod)$');for my$localdir (sort keys %$installmap){my@localparts=File::Spec->splitdir($localdir);my$files=$self->rscan_dir($localdir,sub {-f});for my$file (@$files){my@parts=File::Spec->splitdir($file);@parts=@parts[@localparts .. $#parts];my$installed=Module::Metadata->find_module_by_name(join('::',@parts),\@myINC);if (not $installed){print "Only in lib: $file\n";next}my$status=File::Compare::compare($installed,$file);next if$status==0;die "Can't compare $installed and $file: $!" if$status==-1;if ($file =~ $text_suffix){$self->do_system('diff',@flags,$installed,$file)}else {print "Binary files $file and $installed differ\n"}}}}sub ACTION_pure_install {shift()->depends_on('install')}sub ACTION_install {my ($self)=@_;require ExtUtils::Install;$self->depends_on('build');$self->_do_in_dir(".",sub {ExtUtils::Install::install($self->install_map,$self->verbose,0,$self->{args}{uninst}||0)});if ($self->_is_ActivePerl && $self->{_completed_actions}{html}){$self->log_info("Building ActivePerl Table of Contents\n");eval {ActivePerl::DocTools::WriteTOC(verbose=>$self->verbose ? 1 : 0);1}or $self->log_warn("AP::DT:: WriteTOC() failed: $@")}if ($self->_is_ActivePPM){my$F_perllocal=File::Spec->catfile($self->install_sets('core','lib'),'perllocal.pod');my$dt_stamp=time;$self->log_info("For ActivePerl's PPM: touch '$F_perllocal'\n");open my$perllocal,">>",$F_perllocal;close$perllocal;utime($dt_stamp,$dt_stamp,$F_perllocal)}}sub ACTION_fakeinstall {my ($self)=@_;require ExtUtils::Install;my$eui_version=ExtUtils::Install->VERSION;if ($eui_version < 1.32){$self->log_warn("The 'fakeinstall' action requires Extutils::Install 1.32 or later.\n" ."(You only have version $eui_version).");return}$self->depends_on('build');ExtUtils::Install::install($self->install_map,!$self->quiet,1,$self->{args}{uninst}||0)}sub ACTION_versioninstall {my ($self)=@_;die "You must have only.pm 0.25 or greater installed for this operation: $@\n" unless eval {require only;'only'->VERSION(0.25);1};$self->depends_on('build');my%onlyargs=map {exists($self->{args}{$_})? ($_=>$self->{args}{$_}): ()}qw(version versionlib);only::install::install(%onlyargs)}sub ACTION_installdeps {my ($self)=@_;my$info=$self->_enum_prereqs;if (!$info){$self->log_info("No prerequisites detected\n");return}my$failures=$self->prereq_failures($info);if (!$failures){$self->log_info("All prerequisites satisfied\n");return}my@install;for my$type (sort keys %$failures){my$prereqs=$failures->{$type};if($type =~ m/^(?:\w+_)?requires$/){push(@install,sort keys %$prereqs);next}$self->log_info("Checking optional dependencies:\n");for my$module (sort keys %$prereqs){push(@install,$module)if($self->y_n("Install $module?",'y'))}}return unless@install;my ($command,@opts)=$self->split_like_shell($self->cpan_client);if (!File::Spec->file_name_is_absolute($command)){my@loc=('site','vendor','');my@bindirs=File::Basename::dirname($self->perl);push@bindirs,map {($self->config->{"install${_}bin"},$self->config->{"install${_}script"})}@loc;for my$d (@bindirs){my$abs_cmd=$self->find_command(File::Spec->catfile($d,$command));if (defined$abs_cmd){$command=$abs_cmd;last}}}$self->do_system($command,@opts,@install)}sub ACTION_clean {my ($self)=@_;$self->log_info("Cleaning up build files\n");for my$item (map glob($_),$self->cleanup){$self->delete_filetree($item)}}sub ACTION_realclean {my ($self)=@_;$self->depends_on('clean');$self->log_info("Cleaning up configuration files\n");$self->delete_filetree($self->config_dir,$self->mymetafile,$self->mymetafile2,$self->build_script)}sub ACTION_ppd {my ($self)=@_;require Module::Build::PPMMaker;my$ppd=Module::Build::PPMMaker->new();my$file=$ppd->make_ppd(%{$self->{args}},build=>$self);$self->add_to_cleanup($file)}sub ACTION_ppmdist {my ($self)=@_;$self->depends_on('build');my$ppm=$self->ppm_name;$self->delete_filetree($ppm);$self->log_info("Creating $ppm\n");$self->add_to_cleanup($ppm,"$ppm.tar.gz");my%types=(lib=>'lib',arch=>'arch',bin=>'bin',script=>'script',bindoc=>'man1',libdoc=>'man3',binhtml=>undef,libhtml=>undef,);for my$type ($self->install_types){next if exists($types{$type})&&!defined($types{$type});my$dir=File::Spec->catdir($self->blib,$type);next unless -e $dir;my$files=$self->rscan_dir($dir);for my$file (@$files){next unless -f $file;my$rel_file=File::Spec->abs2rel(File::Spec->rel2abs($file),File::Spec->rel2abs($dir));my$to_file=File::Spec->catfile($ppm,'blib',exists($types{$type})? $types{$type}: $type,$rel_file);$self->copy_if_modified(from=>$file,to=>$to_file)}}for my$type (qw(bin lib)){$self->htmlify_pods($type,File::Spec->catdir($ppm,'blib','html'))}my$target=File::Spec->catfile(File::Spec->updir,$ppm);$self->_do_in_dir($ppm,sub {$self->make_tarball('blib',$target)});$self->depends_on('ppd');$self->delete_filetree($ppm)}sub ACTION_pardist {my ($self)=@_;if (not eval {require PAR::Dist;PAR::Dist->VERSION(0.17)}){$self->log_warn("In order to create .par distributions, you need to\n" ."install PAR::Dist first.");return()}$self->depends_on('build');return PAR::Dist::blib_to_par(name=>$self->dist_name,version=>$self->dist_version,)}sub ACTION_dist {my ($self)=@_;$self->dispatch('distdir');my$dist_dir=$self->dist_dir;$self->make_tarball($dist_dir);$self->delete_filetree($dist_dir)}sub ACTION_distcheck {my ($self)=@_;$self->_check_manifest_skip unless$self->invoked_action eq 'distclean';require ExtUtils::Manifest;local $^W;my ($missing,$extra)=ExtUtils::Manifest::fullcheck();return unless @$missing || @$extra;my$msg="MANIFEST appears to be out of sync with the distribution\n";if ($self->invoked_action eq 'distcheck'){die$msg}else {warn$msg}}sub _check_mymeta_skip {my$self=shift;my$maniskip=shift || 'MANIFEST.SKIP';require ExtUtils::Manifest;local $^W;my$skip_factory=ExtUtils::Manifest->can('maniskip')|| ExtUtils::Manifest->can('_maniskip');my$mymetafile=$self->mymetafile;for my$file ($self->mymetafile,$self->mymetafile2){unless ($skip_factory && $skip_factory->($maniskip)->($file)){$self->log_warn("File '$maniskip' does not include '$file'. Adding it now.\n");my$safe=quotemeta($file);$self->_append_maniskip("^$safe\$",$maniskip)}}}sub _add_to_manifest {my ($self,$manifest,$lines)=@_;$lines=[$lines]unless ref$lines;my$existing_files=$self->_read_manifest($manifest);return unless defined($existing_files);@$lines=grep {!exists$existing_files->{$_}}@$lines or return;my$mode=(stat$manifest)[2];chmod($mode | oct(222),$manifest)or die "Can't make $manifest writable: $!";open(my$fh,'<',$manifest)or die "Can't read $manifest: $!";my$last_line=(<$fh>)[-1]|| "\n";my$has_newline=$last_line =~ /\n$/;close$fh;open($fh,'>>',$manifest)or die "Can't write to $manifest: $!";print$fh "\n" unless$has_newline;print$fh map "$_\n",@$lines;close$fh;chmod($mode,$manifest);$self->log_verbose(map "Added to $manifest: $_\n",@$lines)}sub _sign_dir {my ($self,$dir)=@_;unless (eval {require Module::Signature;1}){$self->log_warn("Couldn't load Module::Signature for 'distsign' action:\n $@\n");return}{my$manifest=File::Spec->catfile($dir,'MANIFEST');die "Signing a distribution requires a MANIFEST file" unless -e $manifest;$self->_add_to_manifest($manifest,"SIGNATURE    Added here by Module::Build")}$self->_do_in_dir($dir,sub {local$Module::Signature::Quiet=1;Module::Signature::sign()})}sub _do_in_dir {my ($self,$dir,$do)=@_;my$start_dir=File::Spec->rel2abs($self->cwd);chdir$dir or die "Can't chdir() to $dir: $!";eval {$do->()};my@err=$@ ? ($@): ();chdir$start_dir or push@err,"Can't chdir() back to $start_dir: $!";die join "\n",@err if@err}sub ACTION_distsign {my ($self)=@_;{local$self->{properties}{sign}=0;$self->depends_on('distdir')unless -d $self->dist_dir}$self->_sign_dir($self->dist_dir)}sub ACTION_skipcheck {my ($self)=@_;require ExtUtils::Manifest;local $^W;ExtUtils::Manifest::skipcheck()}sub ACTION_distclean {my ($self)=@_;$self->depends_on('realclean');$self->depends_on('distcheck')}sub do_create_makefile_pl {my$self=shift;require Module::Build::Compat;$self->log_info("Creating Makefile.PL\n");eval {Module::Build::Compat->create_makefile_pl($self->create_makefile_pl,$self,@_)};if ($@){1 while unlink 'Makefile.PL';die "$@\n"}$self->_add_to_manifest('MANIFEST','Makefile.PL')}sub do_create_license {my$self=shift;$self->log_info("Creating LICENSE file\n");if (!$self->_mb_feature('license_creation')){$self->_warn_mb_feature_deps('license_creation');die "Aborting.\n"}my$l=$self->license or die "Can't create LICENSE file: No license specified\n";my$license=$self->_software_license_object or die << "HERE";$self->delete_filetree('LICENSE');open(my$fh,'>','LICENSE')or die "Can't write LICENSE file: $!";print$fh $license->fulltext;close$fh;$self->_add_to_manifest('MANIFEST','LICENSE')}sub do_create_readme {my$self=shift;$self->delete_filetree('README');my$docfile=$self->_main_docfile;unless ($docfile){$self->log_warn(<<EOF);return}if (eval {require Pod::Readme;Pod::Readme->can('new')}){$self->log_info("Creating README using Pod::Readme\n");my$parser=Pod::Readme->new;$parser->parse_from_file($docfile,'README',@_)}elsif (eval {require Pod::Text;1}){$self->log_info("Creating README using Pod::Text\n");if (open(my$fh,'>','README')){local $^W=0;no strict "refs";my$old_parse_file;$old_parse_file=\&{"Pod::Simple::parse_file"}and local *{"Pod::Simple::parse_file"}=sub {my$self=shift;$self->output_fh($_[1])if $_[1];$self->$old_parse_file($_[0])}if$Pod::Text::VERSION ==3.01;Pod::Text::pod2text($docfile,$fh);close$fh}else {$self->log_warn("Cannot create 'README' file: Can't open file for writing\n");return}}else {$self->log_warn("Can't load Pod::Readme or Pod::Text to create README\n");return}$self->_add_to_manifest('MANIFEST','README')}sub _main_docfile {my$self=shift;if (my$pm_file=$self->dist_version_from){(my$pod_file=$pm_file)=~ s/.pm$/.pod/;return (-e $pod_file ? $pod_file : $pm_file)}else {return undef}}sub do_create_bundle_inc {my$self=shift;my$dist_inc=File::Spec->catdir($self->dist_dir,'inc');require inc::latest;inc::latest->write($dist_inc,@{$self->bundle_inc_preload});inc::latest->bundle_module($_,$dist_inc)for @{$self->bundle_inc};return 1}sub ACTION_distdir {my ($self)=@_;if (@{$self->bundle_inc}&&!$self->_mb_feature('inc_bundling_support')){$self->_warn_mb_feature_deps('inc_bundling_support');die "Aborting.\n"}$self->depends_on('distmeta');my$dist_files=$self->_read_manifest('MANIFEST')or die "Can't create distdir without a MANIFEST file - run 'manifest' action first.\n";delete$dist_files->{SIGNATURE};die "No files found in MANIFEST - try running 'manifest' action?\n" unless ($dist_files and keys %$dist_files);my$metafile=$self->metafile;$self->log_warn("*** Did you forget to add $metafile to the MANIFEST?\n")unless exists$dist_files->{$metafile};my$dist_dir=$self->dist_dir;$self->delete_filetree($dist_dir);$self->log_info("Creating $dist_dir\n");$self->add_to_cleanup($dist_dir);for my$file (sort keys %$dist_files){next if$file =~ m{^MYMETA\.};my$new=$self->copy_if_modified(from=>$file,to_dir=>$dist_dir,verbose=>0)}$self->do_create_bundle_inc if @{$self->bundle_inc};$self->_sign_dir($dist_dir)if$self->{properties}{sign}}sub ACTION_disttest {my ($self)=@_;$self->depends_on('distdir');$self->_do_in_dir ($self->dist_dir,sub {local$ENV{AUTHOR_TESTING}=1;local$ENV{RELEASE_TESTING}=1;$self->run_perl_script('Build.PL')or die "Error executing 'Build.PL' in dist directory: $!";$self->run_perl_script($self->build_script)or die "Error executing $self->build_script in dist directory: $!";$self->run_perl_script($self->build_script,[],['test'])or die "Error executing 'Build test' in dist directory"})}sub ACTION_distinstall {my ($self,@args)=@_;$self->depends_on('distdir');$self->_do_in_dir ($self->dist_dir,sub {$self->run_perl_script('Build.PL')or die "Error executing 'Build.PL' in dist directory: $!";$self->run_perl_script($self->build_script)or die "Error executing $self->build_script in dist directory: $!";$self->run_perl_script($self->build_script,[],['install'])or die "Error executing 'Build install' in dist directory"})}sub _eumanifest_has_include {my$self=shift;require ExtUtils::Manifest;return eval {ExtUtils::Manifest->VERSION(1.50);1}}sub _default_maniskip {my$self=shift;my$default_maniskip;for my$dir (@INC){$default_maniskip=File::Spec->catfile($dir,"ExtUtils","MANIFEST.SKIP");last if -r $default_maniskip}return$default_maniskip}sub _slurp {my$self=shift;my$file=shift;my$mode=shift || "";open my$fh,"<$mode",$file or croak "Can't open $file for reading: $!";local $/;return <$fh>}sub _spew {my$self=shift;my$file=shift;my$content=shift || "";my$mode=shift || "";open my$fh,">$mode",$file or croak "Can't open $file for writing: $!";print {$fh}$content;close$fh}sub _case_tolerant {my$self=shift;if (ref$self){$self->{_case_tolerant}=File::Spec->case_tolerant unless defined($self->{_case_tolerant});return$self->{_case_tolerant}}else {return File::Spec->case_tolerant}}sub _append_maniskip {my$self=shift;my$skip=shift;my$file=shift || 'MANIFEST.SKIP';return unless defined$skip && length$skip;open(my$fh,'>>',$file)or die "Can't open $file: $!";print$fh "$skip\n";close$fh}sub _write_default_maniskip {my$self=shift;my$file=shift || 'MANIFEST.SKIP';open(my$fh,'>',$file)or die "Can't open $file: $!";my$content=$self->_eumanifest_has_include ? "#!include_default\n" : $self->_slurp($self->_default_maniskip);$content .= <<'EOF';$content .= '\b'.$self->dist_name.'-[\d\.\_]+'."\n";print$fh $content;close$fh;return}sub _check_manifest_skip {my ($self)=@_;my$maniskip='MANIFEST.SKIP';if (!-e $maniskip){$self->log_warn("File '$maniskip' does not exist: Creating a temporary '$maniskip'\n");$self->_write_default_maniskip($maniskip);$self->_unlink_on_exit($maniskip)}else {$self->_check_mymeta_skip($maniskip)}return}sub ACTION_manifest {my ($self)=@_;$self->_check_manifest_skip;require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);ExtUtils::Manifest::mkmanifest()}sub ACTION_manifest_skip {my ($self)=@_;if (-e 'MANIFEST.SKIP'){$self->log_warn("MANIFEST.SKIP already exists.\n");return 0}$self->log_info("Creating a new MANIFEST.SKIP file\n");return$self->_write_default_maniskip;return -e 'MANIFEST.SKIP'}sub file_qr {return shift->{_case_tolerant}? qr($_[0])i : qr($_[0])}sub dist_dir {my ($self)=@_;my$dir=join "-",$self->dist_name,$self->dist_version;$dir .= "-" .$self->dist_suffix if$self->dist_suffix;return$dir}sub ppm_name {my$self=shift;return 'PPM-' .$self->dist_dir}sub _files_in {my ($self,$dir)=@_;return unless -d $dir;local*DH;opendir DH,$dir or die "Can't read directory $dir: $!";my@files;while (defined (my$file=readdir DH)){my$full_path=File::Spec->catfile($dir,$file);next if -d $full_path;push@files,$full_path}return@files}sub share_dir {my$self=shift;my$p=$self->{properties};$p->{share_dir}=shift if @_;if (!defined$p->{share_dir}){return}elsif (!ref$p->{share_dir}){$p->{share_dir}={dist=>[$p->{share_dir}]}}elsif (ref$p->{share_dir}eq 'ARRAY'){$p->{share_dir}={dist=>$p->{share_dir}}}elsif (ref$p->{share_dir}eq 'HASH'){my$share_dir=$p->{share_dir};if (defined$share_dir->{dist}){if (!ref$share_dir->{dist}){$share_dir->{dist}=[$share_dir->{dist}]}elsif (ref$share_dir->{dist}ne 'ARRAY'){die "'dist' key in 'share_dir' must be scalar or arrayref"}}if (defined$share_dir->{module}){my$mod_hash=$share_dir->{module};if (ref$mod_hash eq 'HASH'){for my$k (sort keys %$mod_hash){if (!ref$mod_hash->{$k}){$mod_hash->{$k}=[$mod_hash->{$k}]}elsif(ref$mod_hash->{$k}ne 'ARRAY'){die "modules in 'module' key of 'share_dir' must be scalar or arrayref"}}}else {die "'module' key in 'share_dir' must be hashref"}}}else {die "'share_dir' must be hashref, arrayref or string"}return$p->{share_dir}}sub script_files {my$self=shift;for ($self->{properties}{script_files}){$_=shift if @_;next unless $_;return $_ if ref $_ eq 'HASH';return $_={map {$_,1}@$_ }if ref $_ eq 'ARRAY';die "'script_files' must be a hashref, arrayref, or string" if ref();return $_={map {$_,1}$self->_files_in($_)}if -d $_;return $_={$_=>1}}my%pl_files=map {File::Spec->canonpath($_)=>1}keys %{$self->PL_files || {}};my@bin_files=$self->_files_in('bin');my%bin_map=map {$_=>File::Spec->canonpath($_)}@bin_files;return $_={map {$_=>1}grep!$pl_files{$bin_map{$_}},@bin_files }}BEGIN {*scripts=\&script_files}{my%licenses=(perl=>'Perl_5',apache=>'Apache_2_0',apache_1_1=>'Apache_1_1',artistic=>'Artistic_1',artistic_2=>'Artistic_2',lgpl=>'LGPL_2_1',lgpl2=>'LGPL_2_1',lgpl3=>'LGPL_3_0',bsd=>'BSD',gpl=>'GPL_1',gpl2=>'GPL_2',gpl3=>'GPL_3',mit=>'MIT',mozilla=>'Mozilla_1_1',restrictive=>'Restricted',open_source=>undef,unrestricted=>undef,unknown=>undef,);my%license_urls=(perl=>'http://dev.perl.org/licenses/',apache=>'http://apache.org/licenses/LICENSE-2.0',apache_1_1=>'http://apache.org/licenses/LICENSE-1.1',artistic=>'http://opensource.org/licenses/artistic-license.php',artistic_2=>'http://opensource.org/licenses/artistic-license-2.0.php',lgpl=>'http://opensource.org/licenses/lgpl-license.php',lgpl2=>'http://opensource.org/licenses/lgpl-2.1.php',lgpl3=>'http://opensource.org/licenses/lgpl-3.0.html',bsd=>'http://opensource.org/licenses/bsd-license.php',gpl=>'http://opensource.org/licenses/gpl-license.php',gpl2=>'http://opensource.org/licenses/gpl-2.0.php',gpl3=>'http://opensource.org/licenses/gpl-3.0.html',mit=>'http://opensource.org/licenses/mit-license.php',mozilla=>'http://opensource.org/licenses/mozilla1.1.php',restrictive=>undef,open_source=>undef,unrestricted=>undef,unknown=>undef,);sub valid_licenses {return \%licenses}sub _license_url {return$license_urls{$_[1]}}}sub _software_license_class {my ($self,$license)=@_;if ($self->valid_licenses->{$license}&& eval {require Software::LicenseUtils;Software::LicenseUtils->VERSION(0.103009)}){my@classes=Software::LicenseUtils->guess_license_from_meta_key($license,1);if (@classes==1){eval "require $classes[0]";return$classes[0]}}LICENSE: for my$l ($self->valid_licenses->{$license },$license){next unless defined$l;my$trial="Software::License::" .$l;if (eval "require Software::License; Software::License->VERSION(0.014); require $trial; 1"){return$trial}}return}sub _software_license_object {my ($self)=@_;return unless defined(my$license=$self->license);my$class=$self->_software_license_class($license)or return;my$author=join(" & ",@{$self->dist_author})|| 'unknown';my$sl=eval {$class->new({holder=>$author})};if ($@){$self->log_warn("Error getting '$class' object: $@")}return$sl}sub _hash_merge {my ($self,$h,$k,$v)=@_;if (ref$h->{$k}eq 'ARRAY'){push @{$h->{$k}},ref$v ? @$v : $v}elsif (ref$h->{$k}eq 'HASH'){$h->{$k}{$_}=$v->{$_}foreach keys %$v}else {$h->{$k}=$v}}sub ACTION_distmeta {my ($self)=@_;$self->do_create_makefile_pl if$self->create_makefile_pl;$self->do_create_readme if$self->create_readme;$self->do_create_license if$self->create_license;$self->do_create_metafile}sub do_create_metafile {my$self=shift;return if$self->{wrote_metadata};my$p=$self->{properties};unless ($p->{license}){$self->log_warn("No license specified, setting license = 'unknown'\n");$p->{license}='unknown'}my@metafiles=($self->metafile,$self->metafile2);$self->delete_filetree($_)for@metafiles;local@INC=@INC;if (($self->module_name || '')eq 'Module::Build'){$self->depends_on('config_data');push@INC,File::Spec->catdir($self->blib,'lib')}my$meta_obj=$self->_get_meta_object(quiet=>1,fatal=>1,auto=>1);my@created=$self->_write_meta_files($meta_obj,'META');if (@created){$self->{wrote_metadata}=1;$self->_add_to_manifest('MANIFEST',$_)for@created}return 1}sub _write_meta_files {my$self=shift;my ($meta,$file)=@_;$file =~ s{\.(?:yml|json)$}{};my@created;push@created,"$file\.yml" if$meta && $meta->save("$file\.yml",{version=>"1.4"});push@created,"$file\.json" if$meta && $meta->save("$file\.json");if (@created){$self->log_info("Created " .join(" and ",@created)."\n")}return@created}sub _get_meta_object {my$self=shift;my%args=@_;return unless$self->try_require("CPAN::Meta","2.142060");my$meta;eval {my$data=$self->get_metadata(fatal=>$args{fatal},auto=>$args{auto},);$data->{dynamic_config}=$args{dynamic}if defined$args{dynamic};$meta=CPAN::Meta->create($data)};if ($@ &&!$args{quiet}){$self->log_warn("Could not get valid metadata. Error is: $@\n")}return$meta}sub read_metafile {my$self=shift;my ($metafile)=@_;return unless$self->try_require("CPAN::Meta","2.110420");my$meta=CPAN::Meta->load_file($metafile);return$meta->as_struct({version=>"2.0"})}sub normalize_version {my ($self,$version)=@_;$version=0 unless defined$version and length$version;if ($version =~ /[=<>!,]/){}elsif (ref$version eq 'version'){$version=$version->is_qv ? $version->normal : $version->stringify}elsif ($version =~ /^[^v][^.]*\.[^.]+\./){$version="v$version"}else {}return$version}my%prereq_map=(requires=>[qw/runtime requires/],configure_requires=>[qw/configure requires/],build_requires=>[qw/build requires/ ],test_requires=>[qw/test requires/ ],test_recommends=>[qw/test recommends/ ],recommends=>[qw/runtime recommends/ ],conflicts=>[qw/runtime conflicts/ ],);sub _normalize_prereqs {my ($self)=@_;my$p=$self->{properties};my%prereq_types;for my$type ('configure_requires',@{$self->prereq_action_types}){if (exists$p->{$type}and keys %{$p->{$type}}){my ($phase,$relation)=@{$prereq_map{$type}};for my$mod (keys %{$p->{$type}}){$prereq_types{$phase}{$relation}{$mod}=$self->normalize_version($p->{$type}{$mod})}}}return \%prereq_types}sub _get_license {my$self=shift;my$license=$self->license;my ($meta_license,$meta_license_url);my$valid_licenses=$self->valid_licenses();if (my$sl=$self->_software_license_object){$meta_license=$sl->meta2_name;$meta_license_url=$sl->url}elsif (exists$valid_licenses->{$license}){$meta_license=$valid_licenses->{$license}? lc$valid_licenses->{$license}: $license;$meta_license_url=$self->_license_url($license)}else {$self->log_warn("Can not determine license type for '" .$self->license ."'\nSetting META license field to 'unknown'.\n");$meta_license='unknown'}return ($meta_license,$meta_license_url)}sub get_metadata {my ($self,%args)=@_;my$fatal=$args{fatal}|| 0;my$p=$self->{properties};$self->auto_config_requires if$args{auto};for my$f (qw(dist_name dist_version dist_author dist_abstract license)){my$field=$self->$f();unless (defined$field and length$field){my$err="ERROR: Missing required field '$f' for metafile\n";if ($fatal){die$err}else {$self->log_warn($err)}}}my%metadata=(name=>$self->dist_name,version=>$self->normalize_version($self->dist_version),author=>$self->dist_author,abstract=>$self->dist_abstract,generated_by=>"Module::Build version $Module::Build::VERSION",'meta-spec'=>{version=>'2',url=>'http://search.cpan.org/perldoc?CPAN::Meta::Spec',},dynamic_config=>exists$p->{dynamic_config}? $p->{dynamic_config}: 1,release_status=>$self->release_status,);my ($meta_license,$meta_license_url)=$self->_get_license;$metadata{license}=[$meta_license ];$metadata{resources}{license}=[$meta_license_url ]if defined$meta_license_url;$metadata{prereqs}=$self->_normalize_prereqs;if (exists$p->{no_index}){$metadata{no_index}=$p->{no_index}}elsif (my$pkgs=eval {$self->find_dist_packages}){$metadata{provides}=$pkgs if %$pkgs}else {$self->log_warn("$@\nWARNING: Possible missing or corrupt 'MANIFEST' file.\n" ."Nothing to enter for 'provides' field in metafile.\n")}if (my$add=$self->meta_add){if (not exists$add->{'meta-spec'}or $add->{'meta-spec'}{version}!=2){require CPAN::Meta::Converter;if (CPAN::Meta::Converter->VERSION('2.141170')){$add=CPAN::Meta::Converter->new($add)->upgrade_fragment;delete$add->{prereqs}}else {$self->log_warn("Can't meta_add without CPAN::Meta 2.141170")}}while (my($k,$v)=each %{$add}){$metadata{$k}=$v}}if (my$merge=$self->meta_merge){if (eval {require CPAN::Meta::Merge}){%metadata=%{CPAN::Meta::Merge->new(default_version=>'1.4')->merge(\%metadata,$merge)}}else {$self->log_warn("Can't merge without CPAN::Meta::Merge")}}return \%metadata}sub prepare_metadata {my ($self,$node,$keys,$args)=@_;unless (ref$node eq 'HASH'){croak "prepare_metadata() requires a hashref argument to hold output\n"}croak 'Keys argument to prepare_metadata is no longer supported' if$keys;%{$node}=%{$self->get_meta(%{$args})};return$node}sub _read_manifest {my ($self,$file)=@_;return undef unless -e $file;require ExtUtils::Manifest;local ($^W,$ExtUtils::Manifest::Quiet)=(0,1);return scalar ExtUtils::Manifest::maniread($file)}sub find_dist_packages {my$self=shift;my$manifest=$self->_read_manifest('MANIFEST')or die "Can't find dist packages without a MANIFEST file\nRun 'Build manifest' to generate one\n";my%dist_files=map {$self->localize_file_path($_)=>$_}keys %$manifest;my@pm_files=sort grep {$_ !~ m{^t}}grep {exists$dist_files{$_}}keys %{$self->find_pm_files};return$self->find_packages_in_files(\@pm_files,\%dist_files)}sub find_packages_in_files {my ($self,$file_list,$filename_map)=@_;my(%prime,%alt);for my$file (@{$file_list}){my$mapped_filename=$filename_map->{$file};my@path=split(/\//,$mapped_filename);(my$prime_package=join('::',@path[1..$#path]))=~ s/\.pm$//;my$pm_info=Module::Metadata->new_from_file($file);for my$package ($pm_info->packages_inside){next if$package eq 'main';next if$package eq 'DB';next if grep /^_/,split(/::/,$package);my$version=$pm_info->version($package);if ($package eq $prime_package){if (exists($prime{$package})){die "Unexpected conflict in '$package'; multiple versions found.\n"}else {$prime{$package}{file}=$mapped_filename;$prime{$package}{version}=$version if defined($version)}}else {push(@{$alt{$package}},{file=>$mapped_filename,version=>$version,})}}}for my$package (sort keys(%alt)){my$result=$self->_resolve_module_versions($alt{$package});if (exists($prime{$package})){if ($result->{err}){$self->log_warn("Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" .$result->{err})}elsif (defined($result->{version})){if (exists($prime{$package}{version})&& defined($prime{$package}{version})){if ($self->compare_versions($prime{$package}{version},'!=',$result->{version})){$self->log_warn("Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" ."  $result->{file} ($result->{version})\n")}}else {$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}}}else {}}else {if ($result->{err}){$self->log_warn("Found conflicting versions for package '$package'\n" .$result->{err})}$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}if defined($result->{version})}}for my$provides (values%prime){if ($provides->{version}){$provides->{version}=$self->normalize_version($provides->{version})}else {delete$provides->{version}}}return \%prime}sub _resolve_module_versions {my$self=shift;my$packages=shift;my($file,$version);my$err='';for my$p (@$packages){if (defined($p->{version})){if (defined($version)){if ($self->compare_versions($version,'!=',$p->{version})){$err .= "  $p->{file} ($p->{version})\n"}else {}}else {$file=$p->{file};$version=$p->{version}}}$file ||= $p->{file}if defined($p->{file})}if ($err){$err="  $file ($version)\n" .$err}my%result=(file=>$file,version=>$version,err=>$err);return \%result}sub make_tarball {my ($self,$dir,$file)=@_;$file ||= $dir;$self->log_info("Creating $file.tar.gz\n");if ($self->{args}{tar}){my$tar_flags=$self->verbose ? 'cvf' : 'cf';$self->do_system($self->split_like_shell($self->{args}{tar}),$tar_flags,"$file.tar",$dir);$self->do_system($self->split_like_shell($self->{args}{gzip}),"$file.tar")if$self->{args}{gzip}}else {eval {require Archive::Tar && Archive::Tar->VERSION(1.09);1}or die "You must install Archive::Tar 1.09+ to make a distribution tarball\n"."or specify a binary tar program with the '--tar' option.\n"."See the documentation for the 'dist' action.\n";my$files=$self->rscan_dir($dir);$Archive::Tar::DO_NOT_USE_PREFIX=(grep {length($_)>= 100}@$files)? 0 : 1;my$tar=Archive::Tar->new;$tar->add_files(@$files);for my$f ($tar->get_files){$f->mode($f->mode & ~022)}$tar->write("$file.tar.gz",1)}}sub install_path {my$self=shift;my($type,$value)=(@_,'<empty>');Carp::croak('Type argument missing')unless defined($type);my$map=$self->{properties}{install_path};return$map unless @_;unless (defined($value)){delete($map->{$type});return undef}if ($value eq '<empty>'){return undef unless exists$map->{$type};return$map->{$type}}return$map->{$type}=$value}sub install_sets {my ($self,$dirs,$key,$value)=@_;$dirs=$self->installdirs unless defined$dirs;if (@_==4 && defined$dirs && defined$key){$self->{properties}{install_sets}{$dirs}{$key}=$value}my$map={$self->_merge_arglist($self->{properties}{install_sets},$self->_default_install_paths->{install_sets})};if (defined$dirs && defined$key){return$map->{$dirs}{$key}}elsif (defined$dirs){return$map->{$dirs}}else {croak "Can't determine installdirs for install_sets()"}}sub original_prefix {my ($self,$key,$value)=@_;if (@_==3 && defined$key){$self->{properties}{original_prefix}{$key}=$value}my$map={$self->_merge_arglist($self->{properties}{original_prefix},$self->_default_install_paths->{original_prefix})};return$map unless defined$key;return$map->{$key}}sub install_base_relpaths {my$self=shift;if (@_ > 1){$self->_set_relpaths($self->{properties}{install_base_relpaths},@_)}my$map={$self->_merge_arglist($self->{properties}{install_base_relpaths},$self->_default_install_paths->{install_base_relpaths})};return$map unless @_;my$relpath=$map->{$_[0]};return defined$relpath ? File::Spec->catdir(@$relpath): undef}sub prefix_relpaths {my$self=shift;my$installdirs=shift || $self->installdirs or croak "Can't determine installdirs for prefix_relpaths()";if (@_ > 1){$self->{properties}{prefix_relpaths}{$installdirs}||= {};$self->_set_relpaths($self->{properties}{prefix_relpaths}{$installdirs},@_)}my$map={$self->_merge_arglist($self->{properties}{prefix_relpaths}{$installdirs},$self->_default_install_paths->{prefix_relpaths}{$installdirs})};return$map unless @_;my$relpath=$map->{$_[0]};return defined$relpath ? File::Spec->catdir(@$relpath): undef}sub _set_relpaths {my$self=shift;my($map,$type,$value)=@_;Carp::croak('Type argument missing')unless defined($type);if (!defined($value)){$map->{$type}=undef;return}else {Carp::croak("Value must be a relative path")if File::Spec::Unix->file_name_is_absolute($value);my@value=split(/\//,$value);$map->{$type}=\@value}}sub prefix_relative {my ($self,$type)=@_;my$installdirs=$self->installdirs;my$relpath=$self->install_sets($installdirs)->{$type};return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type,)}sub _prefixify {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m|/$|;$self->log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined($path)&& length($path);if(!defined($path)|| (length($path)==0)){$self->log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->log_verbose("    now $path in $rprefix\n");return$path}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return$default}}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,$relpath): undef}if ($self->prefix){my$relpath=$self->prefix_relative($type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs)->{$type}}sub install_types {my$self=shift;my%types;if ($self->install_base){%types=%{$self->install_base_relpaths}}elsif ($self->prefix){%types=%{$self->prefix_relpaths}}else {%types=%{$self->install_sets($self->installdirs)}}%types=(%types,%{$self->install_path});return sort keys%types}sub install_map {my ($self,$blib)=@_;$blib ||= $self->blib;my(%map,@skipping);for my$type ($self->install_types){my$localdir=File::Spec->catdir($blib,$type);next unless -e $localdir;if (my$dest=$self->install_destination($type)){$map{$localdir}=$dest}else {push(@skipping,$type)}}$self->log_warn("WARNING: Can't figure out install path for types: @skipping\n" ."Files will not be installed.\n")if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}sub depends_on {my$self=shift;for my$action (@_){$self->_call_action($action)}}sub rscan_dir {my ($self,$dir,$pattern)=@_;my@result;local $_;my$subr=!$pattern ? sub {push@result,$File::Find::name}: !ref($pattern)|| (ref$pattern eq 'Regexp')? sub {push@result,$File::Find::name if /$pattern/}: ref($pattern)eq 'CODE' ? sub {push@result,$File::Find::name if$pattern->()}: die "Unknown pattern type";File::Find::find({wanted=>$subr,no_chdir=>1,preprocess=>sub {sort @_}},$dir);return \@result}sub delete_filetree {my$self=shift;my$deleted=0;for (@_){next unless -e $_;$self->log_verbose("Deleting $_\n");File::Path::rmtree($_,0,0);die "Couldn't remove '$_': $!\n" if -e $_;$deleted++}return$deleted}sub autosplit_file {my ($self,$file,$to)=@_;require AutoSplit;my$dir=File::Spec->catdir($to,'lib','auto');AutoSplit::autosplit($file,$dir)}sub cbuilder {my$self=shift;my$s=$self->{stash};return$s->{_cbuilder}if$s->{_cbuilder};require ExtUtils::CBuilder;return$s->{_cbuilder}=ExtUtils::CBuilder->new(config=>$self->config,($self->quiet ? (quiet=>1): ()),)}sub have_c_compiler {my ($self)=@_;my$p=$self->{properties};return$p->{_have_c_compiler}if defined$p->{_have_c_compiler};$self->log_verbose("Checking if compiler tools configured... ");my$b=$self->cbuilder;my$have=$b && eval {$b->have_compiler};$self->log_verbose($have ? "ok.\n" : "failed.\n");return$p->{_have_c_compiler}=$have}sub compile_c {my ($self,$file,%args)=@_;if (!$self->have_c_compiler){die "Error: no compiler detected to compile '$file'.  Aborting\n"}my$b=$self->cbuilder;my$obj_file=$b->object_file($file);$self->add_to_cleanup($obj_file);return$obj_file if$self->up_to_date($file,$obj_file);$b->compile(source=>$file,defines=>$args{defines},object_file=>$obj_file,include_dirs=>$self->include_dirs,extra_compiler_flags=>$self->extra_compiler_flags,);return$obj_file}sub link_c {my ($self,$spec)=@_;my$p=$self->{properties};$self->add_to_cleanup($spec->{lib_file});my$objects=$p->{objects}|| [];return$spec->{lib_file}if$self->up_to_date([$spec->{obj_file},@$objects],$spec->{lib_file});my$module_name=$spec->{module_name}|| $self->module_name;$self->cbuilder->link(module_name=>$module_name,objects=>[$spec->{obj_file},@$objects],lib_file=>$spec->{lib_file},extra_linker_flags=>$self->extra_linker_flags);return$spec->{lib_file}}sub compile_xs {my ($self,$file,%args)=@_;$self->log_verbose("$file -> $args{outfile}\n");if (eval {require ExtUtils::ParseXS;1}){ExtUtils::ParseXS::process_file(filename=>$file,prototypes=>0,output=>$args{outfile},)}else {my$xsubpp=Module::Metadata->find_module_by_name('ExtUtils::xsubpp')or die "Can't find ExtUtils::xsubpp in INC (@INC)";my@typemaps;push@typemaps,Module::Metadata->find_module_by_name('ExtUtils::typemap',\@INC);my$lib_typemap=Module::Metadata->find_module_by_name('typemap',[File::Basename::dirname($file),File::Spec->rel2abs('.')]);push@typemaps,$lib_typemap if$lib_typemap;@typemaps=map {+'-typemap',$_}@typemaps;my$cf=$self->{config};my$perl=$self->{properties}{perl};my@command=($perl,"-I".$cf->get('installarchlib'),"-I".$cf->get('installprivlib'),$xsubpp,'-noprototypes',@typemaps,$file);$self->log_info("@command\n");open(my$fh,'>',$args{outfile})or die "Couldn't write $args{outfile}: $!";print {$fh}$self->_backticks(@command);close$fh}}sub split_like_shell {my ($self,$string)=@_;return ()unless defined($string);return @$string if ref$string eq 'ARRAY';$string =~ s/^\s+|\s+$//g;return ()unless length($string);return Text::ParseWords::shellwords($string)}sub oneliner {my($self,$cmd,$switches,$args)=@_;$switches=[]unless defined$switches;$args=[]unless defined$args;$cmd =~ s{^\n+}{};$cmd =~ s{\n+$}{};my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;return$self->_quote_args($perl,@$switches,'-e',$cmd,@$args)}sub run_perl_script {my ($self,$script,$preargs,$postargs)=@_;for ($preargs,$postargs){$_=[$self->split_like_shell($_)]unless ref()}return$self->run_perl_command([@$preargs,$script,@$postargs])}sub run_perl_command {my ($self,$args)=@_;$args=[$self->split_like_shell($args)]unless ref($args);my$perl=ref($self)? $self->perl : $self->find_perl_interpreter;local$ENV{PERL5LIB}=join$self->config('path_sep'),$self->_added_to_INC;return$self->do_system($perl,@$args)}sub _infer_xs_spec {my$self=shift;my$file=shift;my$cf=$self->{config};my%spec;my($v,$d,$f)=File::Spec->splitpath($file);my@d=File::Spec->splitdir($d);(my$file_base=$f)=~ s/\.[^.]+$//i;$spec{base_name}=$file_base;$spec{src_dir}=File::Spec->catpath($v,$d,'');shift(@d)while@d && ($d[0]eq 'lib' || $d[0]eq '');pop(@d)while@d && $d[-1]eq '';$spec{module_name}=join('::',(@d,$file_base));$spec{archdir}=File::Spec->catdir($self->blib,'arch','auto',@d,$file_base);$spec{c_file}=File::Spec->catfile($spec{src_dir},"${file_base}.c");$spec{obj_file}=File::Spec->catfile($spec{src_dir},"${file_base}".$cf->get('obj_ext'));require DynaLoader;my$modfname=defined&DynaLoader::mod2fname ? DynaLoader::mod2fname([@d,$file_base]): $file_base;$spec{bs_file}=File::Spec->catfile($spec{archdir},"$modfname.bs");$spec{lib_file}=File::Spec->catfile($spec{archdir},"$modfname.".$cf->get('dlext'));return \%spec}sub process_xs {my ($self,$file)=@_;my$spec=$self->_infer_xs_spec($file);(my$file_base=$file)=~ s/\.[^.]+$//;$self->add_to_cleanup($spec->{c_file});unless ($self->up_to_date($file,$spec->{c_file})){$self->compile_xs($file,outfile=>$spec->{c_file})}my$v=$self->dist_version;$self->compile_c($spec->{c_file},defines=>{VERSION=>qq{"$v"},XS_VERSION=>qq{"$v"}});File::Path::mkpath($spec->{archdir},0,oct(777))unless -d $spec->{archdir};$self->add_to_cleanup($spec->{bs_file});unless ($self->up_to_date($file,$spec->{bs_file})){require ExtUtils::Mkbootstrap;$self->log_info("ExtUtils::Mkbootstrap::Mkbootstrap('$spec->{bs_file}')\n");ExtUtils::Mkbootstrap::Mkbootstrap($spec->{bs_file});open(my$fh,'>>',$spec->{bs_file});utime((time)x2,$spec->{bs_file})}$self->link_c($spec)}sub do_system {my ($self,@cmd)=@_;$self->log_verbose("@cmd\n");my%seen;my$sep=$self->config('path_sep');local$ENV{PERL5LIB}=(!exists($ENV{PERL5LIB})? '' : length($ENV{PERL5LIB})< 500 ? $ENV{PERL5LIB}: join$sep,grep {!$seen{$_}++ and -d $_}split($sep,$ENV{PERL5LIB}));my$status=system(@cmd);if ($status and $! =~ /Argument list too long/i){my$env_entries='';for (sort keys%ENV){$env_entries .= "$_=>".length($ENV{$_})."; "}warn "'Argument list' was 'too long', env lengths are $env_entries"}return!$status}sub copy_if_modified {my$self=shift;my%args=(@_ > 3 ? (@_): (from=>shift,to_dir=>shift,flatten=>shift));$args{verbose}=!$self->quiet unless exists$args{verbose};my$file=$args{from};unless (defined$file and length$file){die "No 'from' parameter given to copy_if_modified"}$args{flatten}=1 if File::Spec->file_name_is_absolute($file);my$to_path;if (defined$args{to}and length$args{to}){$to_path=$args{to}}elsif (defined$args{to_dir}and length$args{to_dir}){$to_path=File::Spec->catfile($args{to_dir},$args{flatten}? File::Basename::basename($file): $file)}else {die "No 'to' or 'to_dir' parameter given to copy_if_modified"}return if$self->up_to_date($file,$to_path);{local$self->{properties}{quiet}=1;$self->delete_filetree($to_path)}File::Path::mkpath(File::Basename::dirname($to_path),0,oct(777));$self->log_verbose("Copying $file -> $to_path\n");if ($^O eq 'os2'){chmod 0666,$to_path;File::Copy::syscopy($file,$to_path,0x1)or die "Can't copy('$file', '$to_path'): $!"}else {File::Copy::copy($file,$to_path)or die "Can't copy('$file', '$to_path'): $!"}my$mode=oct(444)| ($self->is_executable($file)? oct(111): 0);chmod($mode,$to_path);return$to_path}sub up_to_date {my ($self,$source,$derived)=@_;$source=[$source]unless ref$source;$derived=[$derived]unless ref$derived;return 0 if @$source &&!@$derived || grep {not -e}@$derived;my$most_recent_source=time / (24*60*60);for my$file (@$source){unless (-e $file){$self->log_warn("Can't find source file $file for up-to-date check");next}$most_recent_source=-M _ if -M _ < $most_recent_source}for my$derived (@$derived){return 0 if -M $derived > $most_recent_source}return 1}sub dir_contains {my ($self,$first,$second)=@_;($first,$second)=map File::Spec->canonpath($_),($first,$second);my@first_dirs=File::Spec->splitdir($first);my@second_dirs=File::Spec->splitdir($second);return 0 if@second_dirs < @first_dirs;my$is_same=($self->_case_tolerant ? sub {lc(shift())eq lc(shift())}: sub {shift()eq shift()});while (@first_dirs){return 0 unless$is_same->(shift@first_dirs,shift@second_dirs)}return 1}1;
  
  ERRORS/WARNINGS FOUND IN PREREQUISITES.  You may wish to install the versions
  of the modules indicated above before proceeding with this installation
  
  EOF
  * FATAL ERROR: Perl interpreter mismatch. Configuration was initially
    created with '$self->{properties}{perl}'
    but we are now using '$perl'.  You must
    run 'Build realclean' or 'make realclean' and re-configure.
  DIEFATAL
  * WARNING: Configuration was initially created with Module::Build
    version '$self->{properties}{mb_version}' but we are now using version '$mb_version'.
    If errors occur, you must re-run the Build.PL or Makefile.PL script.
  MISMATCH
  ERROR: This build seems to be unattended, but there is no default value
  for this question.  Aborting.
  EOF
  package $opts{class};
  use $pack;
  \@ISA = qw($pack);
  $opts{code}
  1;
  EOF
  No 'module_name' was provided and it could not be inferred
  from other properties.  This will prevent a packlist from
  being written for this file.  Please set either 'module_name'
  or 'dist_version_from' in Build.PL.
  END_WARN
  Bundling in inc/ is disabled because ExtUtils::Installed could not
  create a list of your installed modules.  Here is the error:
  $@
  EUI_ERROR
  Could not find a packlist for '$mod'.  If it's a core module, try
  force installing it from CPAN.
  NO_PACKLIST
  Module::Build was not found in configure_requires! Adding it now
  automatically as: configure_requires => { 'Module::Build' => $ver }
  EOM
  Warning: ExtUtils::CBuilder not installed or no compiler detected
  Proceeding with configuration, but compilation may fail during Build
  
  EOM
      if ($INC[-1] ne '.') {
          push @INC, '.';
      }
  END
  $shebang
  
  use strict;
  use Cwd;
  use File::Basename;
  use File::Spec;
  
  sub magic_number_matches {
    return 0 unless -e '$q{magic_numfile}';
    my \$FH;
    open \$FH, '<','$q{magic_numfile}' or return 0;
    my \$filenum = <\$FH>;
    close \$FH;
    return \$filenum == $magic_number;
  }
  
  my \$progname;
  my \$orig_dir;
  BEGIN {
    \$^W = 1;  # Use warnings
    \$progname = basename(\$0);
    \$orig_dir = Cwd::cwd();
    my \$base_dir = '$q{base_dir}';
    if (!magic_number_matches()) {
      unless (chdir(\$base_dir)) {
        die ("Couldn't chdir(\$base_dir), aborting\\n");
      }
      unless (magic_number_matches()) {
        die ("Configuration seems to be out of date, please re-run 'perl Build.PL' again.\\n");
      }
    }
    unshift \@INC,
      (
  $quoted_INC
      );
  $dot_in_inc_code
  }
  
  close(*DATA) unless eof(*DATA); # ensure no open handles to this script
  
  use $build_package;
  Module::Build->VERSION(q{$config_requires});
  
  # Some platforms have problems setting \$^X in shebang contexts, fix it up here
  \$^X = Module::Build->find_perl_interpreter;
  
  if (-e 'Build.PL' and not $build_package->up_to_date('Build.PL', \$progname)) {
     warn "Warning: Build.PL has been altered.  You may need to run 'perl Build.PL' again.\\n";
  }
  
  # This should have just enough arguments to be able to bootstrap the rest.
  my \$build = $build_package->resume (
    properties => {
      config_dir => '$q{config_dir}',
      orig_dir => \$orig_dir,
    },
  );
  
  \$build->dispatch;
  EOF
  
   Usage: $0 <action> --arg1=value --arg2=value ...
   Example: $0 test --verbose=1
  
   Actions defined:
  EOF
  Can't create LICENSE file: '$l' is not a valid license key
  or Software::License subclass;
  HERE
  Cannot create README: can't determine which file contains documentation;
  Must supply either 'dist_version_from', or 'module_name' parameter.
  EOF
  # Avoid configuration metadata file
  ^MYMETA\.
  
  # Avoid Module::Build generated and utility files.
  \bBuild$
  \bBuild.bat$
  \b_build
  \bBuild.COM$
  \bBUILD.COM$
  \bbuild.com$
  ^MANIFEST\.SKIP
  
  # Avoid archives of this distribution
  EOF
MODULE_BUILD_BASE

$fatpacked{"Module/Build/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_COMPAT';
  package Module::Build::Compat;use strict;use warnings;our$VERSION='0.4229';use File::Basename ();use File::Spec;use Config;use Module::Build;use Module::Metadata;use version;use Data::Dumper;my%convert_installdirs=(PERL=>'core',SITE=>'site',VENDOR=>'vendor',);my%makefile_to_build=(TEST_VERBOSE=>'verbose',VERBINST=>'verbose',INC=>sub {map {(extra_compiler_flags=>$_)}Module::Build->split_like_shell(shift)},POLLUTE=>sub {(extra_compiler_flags=>'-DPERL_POLLUTE')},INSTALLDIRS=>sub {(installdirs=>$convert_installdirs{uc shift()})},LIB=>sub {my$lib=shift;my%config=(installprivlib=>$lib,installsitelib=>$lib,installarchlib=>"$lib/$Config{archname}",installsitearch=>"$lib/$Config{archname}");return map {(config=>"$_=$config{$_}")}sort keys%config},(map {my$name=$_;$name=>sub {my@ret=(config=>lc($name)."=" .shift);print STDERR "# Converted to @ret\n";return@ret}}qw(INSTALLARCHLIB INSTALLSITEARCH INSTALLVENDORARCH INSTALLPRIVLIB INSTALLSITELIB INSTALLVENDORLIB INSTALLBIN INSTALLSITEBIN INSTALLVENDORBIN INSTALLSCRIPT INSTALLSITESCRIPT INSTALLVENDORSCRIPT INSTALLMAN1DIR INSTALLSITEMAN1DIR INSTALLVENDORMAN1DIR INSTALLMAN3DIR INSTALLSITEMAN3DIR INSTALLVENDORMAN3DIR)),map {$_,lc($_)}qw(DESTDIR PREFIX INSTALL_BASE UNINST),);my%macro_to_build=%makefile_to_build;delete$macro_to_build{LIB};sub _merge_prereq {my ($req,$breq)=@_;$req ||= {};$breq ||= {};for my$p ($req,$breq){for my$k (sort keys %$p){next if$k eq 'perl';my$v_obj=eval {version->new($p->{$k})};if (!defined$v_obj){die "A prereq of the form '$p->{$k}' for '$k' is not supported by Module::Build::Compat ( use a simpler version like '0.05' or 'v1.4.25' )\n"}if ($v_obj->is_qv){my$proper_ver=$v_obj->numify;warn "Dotted-decimal prereq '$p->{$k}' for '$k' is not portable - converting it to '$proper_ver'\n";$p->{$k}=$proper_ver}}}my$merge={%$req };for my$k (keys %$breq){my$v1=$merge->{$k}|| 0;my$v2=$breq->{$k};$merge->{$k}=$v1 > $v2 ? $v1 : $v2}return %$merge}sub create_makefile_pl {my ($package,$type,$build,%args)=@_;die "Don't know how to build Makefile.PL of type '$type'" unless$type =~ /^(small|passthrough|traditional)$/;if ($type eq 'passthrough'){$build->log_warn(<<"HERE")}my$fh;if ($args{fh}){$fh=$args{fh}}else {$args{file}||= 'Makefile.PL';local$build->{properties}{quiet}=1;$build->delete_filetree($args{file});open($fh,'>',"$args{file}")or die "Can't write $args{file}: $!"}print {$fh}"# Note: this file was auto-generated by ",__PACKAGE__," version $VERSION\n";my$requires=$build->requires;if (my$minimum_perl=$requires->{perl}){my$min_ver=version->new($minimum_perl)->numify;print {$fh}"require $min_ver;\n"}my$subclass_load='';if (ref($build)ne "Module::Build"){my$subclass_dir=$package->subclass_dir($build);if (File::Spec->file_name_is_absolute($subclass_dir)){my$base_dir=$build->base_dir;if ($build->dir_contains($base_dir,$subclass_dir)){$subclass_dir=File::Spec->abs2rel($subclass_dir,$base_dir);$subclass_dir=$package->unixify_dir($subclass_dir);$subclass_load="use lib '$subclass_dir';"}}else {$subclass_dir=$package->unixify_dir($subclass_dir);$subclass_load="use lib '$subclass_dir';"}}if ($type eq 'small'){printf {$fh}<<'EOF',$subclass_load,ref($build),ref($build)}elsif ($type eq 'passthrough'){printf {$fh}<<'EOF',$subclass_load,ref($build),ref($build)}elsif ($type eq 'traditional'){my (%MM_Args,%prereq);if (eval "use Tie::IxHash 1.2; 1"){tie%MM_Args,'Tie::IxHash';tie%prereq,'Tie::IxHash'}my%name=($build->module_name ? (NAME=>$build->module_name): (DISTNAME=>$build->dist_name));my%version=($build->dist_version_from ? (VERSION_FROM=>$build->dist_version_from): (VERSION=>$build->dist_version));%MM_Args=(%name,%version);%prereq=_merge_prereq($build->requires,$build->build_requires);%prereq=map {$_,$prereq{$_}}sort keys%prereq;delete$prereq{perl};$MM_Args{PREREQ_PM}=\%prereq;$MM_Args{INSTALLDIRS}=$build->installdirs eq 'core' ? 'perl' : $build->installdirs;$MM_Args{EXE_FILES}=[sort keys %{$build->script_files}]if$build->script_files;$MM_Args{PL_FILES}=$build->PL_files || {};if ($build->recursive_test_files){$MM_Args{test}={TESTS=>join q{ },$package->_test_globs($build)}}local$Data::Dumper::Terse=1;my$args=Data::Dumper::Dumper(\%MM_Args);$args =~ s/\{(.*)\}/($1)/s;print$fh <<"EOF"}}sub _test_globs {my ($self,$build)=@_;return map {File::Spec->catfile($_,'*.t')}@{$build->rscan_dir('t',sub {-d $File::Find::name})}}sub subclass_dir {my ($self,$build)=@_;return (Module::Metadata->find_module_dir_by_name(ref$build)|| File::Spec->catdir($build->config_dir,'lib'))}sub unixify_dir {my ($self,$path)=@_;return join '/',File::Spec->splitdir($path)}sub makefile_to_build_args {my$class=shift;my@out;for my$arg (@_){next if$arg eq '';my ($key,$val)=($arg =~ /^(\w+)=(.+)/ ? ($1,$2): die "Malformed argument '$arg'");($val)=Module::Build->_detildefy($val)if$val =~ /^~/;if (exists$makefile_to_build{$key}){my$trans=$makefile_to_build{$key};push@out,$class->_argvify(ref($trans)? $trans->($val): ($trans=>$val))}elsif (exists$Config{lc($key)}){push@out,$class->_argvify(config=>lc($key)."=$val")}else {push@out,$class->_argvify("\L$key"=>$val)}}return@out}sub _argvify {my ($self,@pairs)=@_;my@out;while (@pairs){my ($k,$v)=splice@pairs,0,2;push@out,("--$k",$v)}return@out}sub makefile_to_build_macros {my@out;my%config;for my$macro (sort keys%macro_to_build){my$trans=$macro_to_build{$macro};next unless exists$ENV{$macro}&& length$ENV{$macro};my$val=$ENV{$macro};my@args=ref($trans)? $trans->($val): ($trans=>$val);while (@args){my ($k,$v)=splice(@args,0,2);if ($k eq 'config'){if ($v =~ /^([^=]+)=(.*)$/){$config{$1}=$2}else {warn "Couldn't parse config '$v'\n"}}else {push@out,($k=>$v)}}}push@out,(config=>\%config)if%config;return@out}sub run_build_pl {my ($pack,%in)=@_;$in{script}||= 'Build.PL';my@args=$in{args}? $pack->makefile_to_build_args(@{$in{args}}): ();print "# running $in{script} @args\n";Module::Build->run_perl_script($in{script},[],\@args)or die "Couldn't run $in{script}: $!"}sub fake_makefile {my ($self,%args)=@_;unless (exists$args{build_class}){warn "Unknown 'build_class', defaulting to 'Module::Build'\n";$args{build_class}='Module::Build'}my$class=$args{build_class};my$perl=$class->find_perl_interpreter;$perl='MCR ' .$perl if$self->_is_vms_mms;my$noop=($class->is_windowsish ? 'rem>nul' : $self->_is_vms_mms ? 'Continue' : 'true');my$filetype=$class->is_vmsish ? '.COM' : '';my$Build='Build' .$filetype .' --makefile_env_macros 1';my$unlink=$class->oneliner('1 while unlink $ARGV[0]',[],[$args{makefile}]);$unlink =~ s/\$/\$\$/g unless$class->is_vmsish;my$maketext=join '',map {"$_=\n"}sort keys%macro_to_build;$maketext .= ($^O eq 'os2' ? "SHELL = sh\n\n" : $^O eq 'MSWin32' && $Config{make}=~ /gmake/ ? "SHELL = $ENV{COMSPEC}\n\n" : "\n\n");$maketext .= <<"EOF";for my$action ($class->known_actions){next if$action =~ /^(all|distclean|realclean|force_do_it)$/;$maketext .= <<"EOF"}if ($self->_is_vms_mms){$maketext .= "\n.FIRST\n\t\@ $noop\n";for my$macro (sort keys%macro_to_build){$maketext .= ".IFDEF $macro\n\tDEFINE $macro \"\$($macro)\"\n.ENDIF\n"}$maketext .= "\n"}else {$maketext .= "\n.EXPORT : " .join(' ',sort keys%macro_to_build)."\n\n"}return$maketext}sub fake_prereqs {my$file=File::Spec->catfile('_build','prereqs');open(my$fh,'<',"$file")or die "Can't read $file: $!";my$prereqs=eval do {local $/;<$fh>};close$fh;my%merged=_merge_prereq($prereqs->{requires},$prereqs->{build_requires});my@prereq;for (sort keys%merged){next if $_ eq 'perl';push@prereq,"$_=>q[$merged{$_}]"}return unless@prereq;return "#     PREREQ_PM => { " .join(", ",@prereq)." }\n\n"}sub write_makefile {my ($pack,%in)=@_;unless (exists$in{build_class}){warn "Unknown 'build_class', defaulting to 'Module::Build'\n";$in{build_class}='Module::Build'}my$class=$in{build_class};$in{makefile}||= $pack->_is_vms_mms ? 'Descrip.MMS' : 'Makefile';open MAKE,"> $in{makefile}" or die "Cannot write $in{makefile}: $!";print MAKE$pack->fake_prereqs;print MAKE$pack->fake_makefile(%in);close MAKE}sub _is_vms_mms {return Module::Build->is_vmsish && ($Config{make}=~ m/MM[SK]/i)}1;
  
  IMPORTANT NOTE: The '$type' style of Makefile.PL is deprecated and
  may be removed in a future version of Module::Build in favor of the
  'configure_requires' property.  See Module::Build::Compat
  documentation for details.
  
  HERE
      use Module::Build::Compat 0.02;
      %s
      Module::Build::Compat->run_build_pl(args => \@ARGV);
      require %s;
      Module::Build::Compat->write_makefile(build_class => '%s');
  EOF
  
      unless (eval "use Module::Build::Compat 0.02; 1" ) {
        print "This module requires Module::Build to install itself.\n";
  
        require ExtUtils::MakeMaker;
        my $yn = ExtUtils::MakeMaker::prompt
  	('  Install Module::Build now from CPAN?', 'y');
  
        unless ($yn =~ /^y/i) {
  	die " *** Cannot install without Module::Build.  Exiting ...\n";
        }
  
        require Cwd;
        require File::Spec;
        require CPAN;
  
        # Save this 'cause CPAN will chdir all over the place.
        my $cwd = Cwd::cwd();
  
        CPAN::Shell->install('Module::Build::Compat');
        CPAN::Shell->expand("Module", "Module::Build::Compat")->uptodate
  	or die "Couldn't install Module::Build, giving up.\n";
  
        chdir $cwd or die "Cannot chdir() back to $cwd: $!";
      }
      eval "use Module::Build::Compat 0.02; 1" or die $@;
      %s
      Module::Build::Compat->run_build_pl(args => \@ARGV);
      my $build_script = 'Build';
      $build_script .= '.com' if $^O eq 'VMS';
      exit(0) unless(-e $build_script); # cpantesters convention
      require %s;
      Module::Build::Compat->write_makefile(build_class => '%s');
  EOF
  use ExtUtils::MakeMaker;
  WriteMakefile
  $args;
  EOF
  all : force_do_it
  	$perl $Build
  realclean : force_do_it
  	$perl $Build realclean
  	$unlink
  distclean : force_do_it
  	$perl $Build distclean
  	$unlink
  
  
  force_do_it :
  	@ $noop
  EOF
  $action : force_do_it
  	$perl $Build $action
  EOF
MODULE_BUILD_COMPAT

$fatpacked{"Module/Build/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_CONFIG';
  package Module::Build::Config;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Config;sub new {my ($pack,%args)=@_;return bless {stack=>{},values=>$args{values}|| {},},$pack}sub get {my ($self,$key)=@_;return$self->{values}{$key}if ref($self)&& exists$self->{values}{$key};return$Config{$key}}sub set {my ($self,$key,$val)=@_;$self->{values}{$key}=$val}sub push {my ($self,$key,$val)=@_;push @{$self->{stack}{$key}},$self->{values}{$key}if exists$self->{values}{$key};$self->{values}{$key}=$val}sub pop {my ($self,$key)=@_;my$val=delete$self->{values}{$key};if (exists$self->{stack}{$key}){$self->{values}{$key}=pop @{$self->{stack}{$key}};delete$self->{stack}{$key}unless @{$self->{stack}{$key}}}return$val}sub values_set {my$self=shift;return undef unless ref($self);return$self->{values}}sub all_config {my$self=shift;my$v=ref($self)? $self->{values}: {};return {%Config,%$v}}1;
MODULE_BUILD_CONFIG

$fatpacked{"Module/Build/ConfigData.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_CONFIGDATA';
  package Module::Build::ConfigData;use strict;my$arrayref=eval do {local $/;<DATA>}or die "Couldn't load ConfigData data: $@";close DATA;my ($config,$features,$auto_features)=@$arrayref;sub config {$config->{$_[1]}}sub set_config {$config->{$_[1]}=$_[2]}sub set_feature {$features->{$_[1]}=0+!!$_[2]}sub auto_feature_names {sort grep!exists$features->{$_},keys %$auto_features}sub feature_names {my@features=(sort keys %$features,auto_feature_names());@features}sub config_names {sort keys %$config}sub write {my$me=__FILE__;require Data::Dumper;my$mode_orig=(stat$me)[2]& 07777;chmod($mode_orig | 0222,$me);open(my$fh,'+<',$me)or die "Can't rewrite $me: $!";seek($fh,0,0);while (<$fh>){last if /^__DATA__$/}die "Couldn't find __DATA__ token in $me" if eof($fh);seek($fh,tell($fh),0);my$data=[$config,$features,$auto_features];print($fh 'do{ my ' .Data::Dumper->new([$data],['x'])->Purity(1)->Dump().'$x; }');truncate($fh,tell($fh));close$fh;chmod($mode_orig,$me)or warn "Couldn't restore permissions on $me: $!"}sub feature {my ($package,$key)=@_;return$features->{$key}if exists$features->{$key};my$info=$auto_features->{$key}or return 0;require Module::Build;for my$type (sort keys %$info){my$prereqs=$info->{$type};next if$type eq 'description' || $type eq 'recommends';for my$modname (sort keys %$prereqs){my$status=Module::Build->check_installed_status($modname,$prereqs->{$modname});if ((!$status->{ok})xor ($type =~ /conflicts$/)){return 0}if (!eval "require $modname; 1"){return 0}}}return 1}__DATA__ do{ my $x = [
         {},
         {},
         {
           'HTML_support' => {
                               'description' => 'Create HTML documentation',
                               'requires' => {
                                               'Pod::Html' => 0
                                             }
                             },
           'PPM_support' => {
                              'description' => 'Generate PPM files for distributions'
                            },
           'dist_authoring' => {
                                 'description' => 'Create new distributions',
                                 'recommends' => {
                                                   'Module::Signature' => '0.21',
                                                   'Pod::Readme' => '0.04'
                                                 },
                                 'requires' => {
                                                 'Archive::Tar' => '1.09'
                                               }
                               },
           'inc_bundling_support' => {
                                       'description' => 'Bundle Module::Build in inc/',
                                       'requires' => {
                                                       'ExtUtils::Install' => '1.54',
                                                       'ExtUtils::Installed' => '1.999',
                                                       'inc::latest' => '0.5'
                                                     }
                                     },
           'license_creation' => {
                                   'description' => 'Create licenses automatically in distributions',
                                   'requires' => {
                                                   'Software::License' => '0.103009'
                                                 }
                                 },
           'manpage_support' => {
                                  'description' => 'Create Unix man pages',
                                  'requires' => {
                                                  'Pod::Man' => 0
                                                }
                                }
         }
       ];
  $x; }
MODULE_BUILD_CONFIGDATA

$fatpacked{"Module/Build/Cookbook.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_COOKBOOK';
  package Module::Build::Cookbook;use strict;use warnings;our$VERSION='0.4229';
MODULE_BUILD_COOKBOOK

$fatpacked{"Module/Build/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_DUMPER';
  package Module::Build::Dumper;use strict;use warnings;our$VERSION='0.4229';use Data::Dumper;sub _data_dump {my ($self,$data)=@_;return ("do{ my " .Data::Dumper->new([$data],['x'])->Purity(1)->Terse(0)->Sortkeys(1)->Dump().'$x; }')}1;
MODULE_BUILD_DUMPER

$fatpacked{"Module/Build/Notes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_NOTES';
  package Module::Build::Notes;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Data::Dumper;use Module::Build::Dumper;sub new {my ($class,%args)=@_;my$file=delete$args{file}or die "Missing required parameter 'file' to new()";my$self=bless {disk=>{},new=>{},file=>$file,%args,},$class}sub restore {my$self=shift;open(my$fh,'<',$self->{file})or die "Can't read $self->{file}: $!";$self->{disk}=eval do {local $/;<$fh>};die $@ if $@;close$fh;$self->{new}={}}sub access {my$self=shift;return$self->read()unless @_;my$key=shift;return$self->read($key)unless @_;my$value=shift;$self->write({$key=>$value });return$self->read($key)}sub has_data {my$self=shift;return keys %{$self->read()}> 0}sub exists {my ($self,$key)=@_;return exists($self->{new}{$key})|| exists($self->{disk}{$key})}sub read {my$self=shift;if (@_){my$key=shift;return$self->{new}{$key}if exists$self->{new}{$key};return$self->{disk}{$key}}my$out=(keys %{$self->{new}}? {%{$self->{disk}},%{$self->{new}}}: $self->{disk});return wantarray ? %$out : $out}sub _same {my ($self,$x,$y)=@_;return 1 if!defined($x)and!defined($y);return 0 if!defined($x)or!defined($y);return$x eq $y}sub write {my ($self,$href)=@_;$href ||= {};@{$self->{new}}{keys %$href }=values %$href;for my$key (keys %{$self->{new}}){next if ref$self->{new}{$key};next if ref$self->{disk}{$key}or!exists$self->{disk}{$key};delete$self->{new}{$key}if$self->_same($self->{new}{$key},$self->{disk}{$key})}if (my$file=$self->{file}){my ($vol,$dir,$base)=File::Spec->splitpath($file);$dir=File::Spec->catpath($vol,$dir,'');return unless -e $dir && -d $dir;return if -e $file and!keys %{$self->{new}};@{$self->{disk}}{keys %{$self->{new}}}=values %{$self->{new}};$self->_dump($file,$self->{disk});$self->{new}={}}return$self->read}sub _dump {my ($self,$file,$data)=@_;open(my$fh,'>',$file)or die "Can't create '$file': $!";print {$fh}Module::Build::Dumper->_data_dump($data);close$fh}my$orig_template=do {local $/;<DATA>};close DATA;sub write_config_data {my ($self,%args)=@_;my$template=$orig_template;$template =~ s/NOTES_NAME/$args{config_module}/g;$template =~ s/MODULE_NAME/$args{module}/g;$template =~ s/=begin private\n//;$template =~ s/=end private/=cut/;$template =~ s{$_\n}{} for '=begin private','=end private';open(my$fh,'>',$args{file})or die "Can't create '$args{file}': $!";print {$fh}$template;print {$fh}"\n__DATA__\n";print {$fh}Module::Build::Dumper->_data_dump([$args{config_data},$args{feature},$args{auto_features}]);close$fh}1;__DATA__ package NOTES_NAME;
  use strict;
  my $arrayref = eval do {local $/; <DATA>}
    or die "Couldn't load ConfigData data: $@";
  close DATA;
  my ($config, $features, $auto_features) = @$arrayref;
  
  sub config { $config->{$_[1]} }
  
  sub set_config { $config->{$_[1]} = $_[2] }
  sub set_feature { $features->{$_[1]} = 0+!!$_[2] }  # Constrain to 1 or 0
  
  sub auto_feature_names { sort grep !exists $features->{$_}, keys %$auto_features }
  
  sub feature_names {
    my @features = (sort keys %$features, auto_feature_names());
    @features;
  }
  
  sub config_names  { sort keys %$config }
  
  sub write {
    my $me = __FILE__;
  
    # Can't use Module::Build::Dumper here because M::B is only a
    # build-time prereq of this module
    require Data::Dumper;
  
    my $mode_orig = (stat $me)[2] & 07777;
    chmod($mode_orig | 0222, $me); # Make it writeable
    open(my $fh, '+<', $me) or die "Can't rewrite $me: $!";
    seek($fh, 0, 0);
    while (<$fh>) {
      last if /^__DATA__$/;
    }
    die "Couldn't find __DATA__ token in $me" if eof($fh);
  
    seek($fh, tell($fh), 0);
    my $data = [$config, $features, $auto_features];
    print($fh 'do{ my '
  	      . Data::Dumper->new([$data],['x'])->Purity(1)->Dump()
  	      . '$x; }' );
    truncate($fh, tell($fh));
    close $fh;
  
    chmod($mode_orig, $me)
      or warn "Couldn't restore permissions on $me: $!";
  }
  
  sub feature {
    my ($package, $key) = @_;
    return $features->{$key} if exists $features->{$key};
  
    my $info = $auto_features->{$key} or return 0;
  
    require Module::Build;  # XXX should get rid of this
    foreach my $type (sort keys %$info) {
      my $prereqs = $info->{$type};
      next if $type eq 'description' || $type eq 'recommends';
  
      foreach my $modname (sort keys %$prereqs) {
        my $status = Module::Build->check_installed_status($modname, $prereqs->{$modname});
        if ((!$status->{ok}) xor ($type =~ /conflicts$/)) { return 0; }
        if ( ! eval "require $modname; 1" ) { return 0; }
      }
    }
    return 1;
  }
  
  =begin private
  
  =head1 NAME
  
  NOTES_NAME - Configuration for MODULE_NAME
  
  =head1 SYNOPSIS
  
    use NOTES_NAME;
    $value = NOTES_NAME->config('foo');
    $value = NOTES_NAME->feature('bar');
  
    @names = NOTES_NAME->config_names;
    @names = NOTES_NAME->feature_names;
  
    NOTES_NAME->set_config(foo => $new_value);
    NOTES_NAME->set_feature(bar => $new_value);
    NOTES_NAME->write;  # Save changes
  
  
  =head1 DESCRIPTION
  
  This module holds the configuration data for the C<MODULE_NAME>
  module.  It also provides a programmatic interface for getting or
  setting that configuration data.  Note that in order to actually make
  changes, you'll have to have write access to the C<NOTES_NAME>
  module, and you should attempt to understand the repercussions of your
  actions.
  
  
  =head1 METHODS
  
  =over 4
  
  =item config($name)
  
  Given a string argument, returns the value of the configuration item
  by that name, or C<undef> if no such item exists.
  
  =item feature($name)
  
  Given a string argument, returns the value of the feature by that
  name, or C<undef> if no such feature exists.
  
  =item set_config($name, $value)
  
  Sets the configuration item with the given name to the given value.
  The value may be any Perl scalar that will serialize correctly using
  C<Data::Dumper>.  This includes references, objects (usually), and
  complex data structures.  It probably does not include transient
  things like filehandles or sockets.
  
  =item set_feature($name, $value)
  
  Sets the feature with the given name to the given boolean value.  The
  value will be converted to 0 or 1 automatically.
  
  =item config_names()
  
  Returns a list of all the names of config items currently defined in
  C<NOTES_NAME>, or in scalar context the number of items.
  
  =item feature_names()
  
  Returns a list of all the names of features currently defined in
  C<NOTES_NAME>, or in scalar context the number of features.
  
  =item auto_feature_names()
  
  Returns a list of all the names of features whose availability is
  dynamically determined, or in scalar context the number of such
  features.  Does not include such features that have later been set to
  a fixed value.
  
  =item write()
  
  Commits any changes from C<set_config()> and C<set_feature()> to disk.
  Requires write access to the C<NOTES_NAME> module.
  
  =back
  
  
  =head1 AUTHOR
  
  C<NOTES_NAME> was automatically created using C<Module::Build>.
  C<Module::Build> was written by Ken Williams, but he holds no
  authorship claim or copyright claim to the contents of C<NOTES_NAME>.
  
  =end private
  
MODULE_BUILD_NOTES

$fatpacked{"Module/Build/PPMMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PPMMAKER';
  package Module::Build::PPMMaker;use strict;use warnings;use Config;our$VERSION='0.4229';$VERSION=eval$VERSION;sub new {my$package=shift;return bless {@_},$package}sub make_ppd {my ($self,%args)=@_;my$build=delete$args{build};my@codebase;if (exists$args{codebase}){@codebase=ref$args{codebase}? @{$args{codebase}}: ($args{codebase})}else {my$distfile=$build->ppm_name .'.tar.gz';print "Using default codebase '$distfile'\n";@codebase=($distfile)}my%dist;for my$info (qw(name author abstract version)){my$method="dist_$info";$dist{$info}=$build->$method()or die "Can't determine distribution's $info\n"}$self->_simple_xml_escape($_)foreach$dist{abstract},@{$dist{author}};my$ppd=<<"PPD";for my$type (qw(requires)){my$prereq=$build->$type();for my$modname (sort keys %$prereq){next if$modname eq 'perl';my$min_version='0.0';for my$c ($build->_parse_conditions($prereq->{$modname})){my ($op,$version)=$c =~ /^\s*  (<=?|>=?|==|!=)  \s*  ([\w.]+)  \s*$/x;if ($op eq '>='){$min_version=$version;last}}$modname .= '::' unless$modname =~ /::/;$ppd .= qq!        <REQUIRE NAME="$modname" VERSION="$min_version" />\n!}}if (keys %{$build->find_xs_files}){my$perl_version=$self->_ppd_version($build->perl_version);$ppd .= sprintf(<<'EOF',$self->_varchname($build->config))}for my$codebase (@codebase){$self->_simple_xml_escape($codebase);$ppd .= sprintf(<<'EOF',$codebase)}$ppd .= <<'EOF';my$ppd_file="$dist{name}.ppd";open(my$fh,'>',$ppd_file)or die "Cannot write to $ppd_file: $!";binmode($fh,":utf8")if $] >= 5.008 && $Config{useperlio};print$fh $ppd;close$fh;return$ppd_file}sub _ppd_version {my ($self,$version)=@_;return join ',',(split(/\./,$version),(0)x4)[0..3]}sub _varchname {my ($self,$config)=@_;my$varchname=$config->{archname};if ($] >= 5.008){my$vstring=sprintf "%vd",$^V;$vstring =~ s/\.\d+$//;$varchname .= "-$vstring"}return$varchname}{my%escapes=("\n"=>"\\n",'"'=>'&quot;','&'=>'&amp;','>'=>'&gt;','<'=>'&lt;',);my$rx=join '|',keys%escapes;sub _simple_xml_escape {$_[1]=~ s/($rx)/$escapes{$1}/go}}1;
  <SOFTPKG NAME=\"$dist{name}\" VERSION=\"$dist{version}\">
      <ABSTRACT>$dist{abstract}</ABSTRACT>
  @{[ join "\n", map "    <AUTHOR>$_</AUTHOR>", @{$dist{author}} ]}
      <IMPLEMENTATION>
  PPD
          <ARCHITECTURE NAME="%s" />
  EOF
          <CODEBASE HREF="%s" />
  EOF
      </IMPLEMENTATION>
  </SOFTPKG>
  EOF
MODULE_BUILD_PPMMAKER

$fatpacked{"Module/Build/Platform/Default.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_DEFAULT';
  package Module::Build::Platform::Default;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);1;
MODULE_BUILD_PLATFORM_DEFAULT

$fatpacked{"Module/Build/Platform/MacOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_MACOS';
  package Module::Build::Platform::MacOS;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);use ExtUtils::Install;sub have_forkpipe {0}sub new {my$class=shift;my$self=$class->SUPER::new(@_);for ('sitelib','sitearch'){$self->config($_=>$self->config("install$_"))unless$self->config($_)}(my$sp=$self->config('startperl'))=~ s/.*Exit \{Status\}\s//;$self->config(startperl=>$sp);return$self}sub make_executable {my$self=shift;require MacPerl;for (@_){MacPerl::SetFileInfo('McPL','TEXT',$_)}}sub dispatch {my$self=shift;if(!@_ and!@ARGV){require MacPerl;my@action_list=qw(build test install);my%actions=map {+($_,1)}$self->known_actions;delete@actions{@action_list};push@action_list,sort {$a cmp $b}keys%actions;my%toolserver=map {+$_=>1}qw(test disttest diff testdb);for (@action_list){$_ .= ' *' if$toolserver{$_}}my$cmd=MacPerl::Pick("What build command? ('*' requires ToolServer)",@action_list);return unless defined$cmd;$cmd =~ s/ \*$//;$ARGV[0]=($cmd);my$args=MacPerl::Ask('Any extra arguments?  (ie. verbose=1)','');return unless defined$args;push@ARGV,$self->split_like_shell($args)}$self->SUPER::dispatch(@_)}sub ACTION_realclean {my$self=shift;chmod 0666,$self->{properties}{build_script};$self->SUPER::ACTION_realclean}sub ACTION_install {my$self=shift;return$self->SUPER::ACTION_install(@_)if eval {ExtUtils::Install->VERSION('1.30');1};local $^W=0;local*ExtUtils::Install::find=sub {my ($code,@dirs)=@_;@dirs=map {$_ eq '.' ? File::Spec->curdir : $_}@dirs;return File::Find::find($code,@dirs)};return$self->SUPER::ACTION_install(@_)}1;
MODULE_BUILD_PLATFORM_MACOS

$fatpacked{"Module/Build/Platform/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_UNIX';
  package Module::Build::Platform::Unix;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);sub is_executable {my ($self,$file)=@_;return +(stat$file)[2]& 0100}sub _startperl {"#! " .shift()->perl}sub _construct {my$self=shift()->SUPER::_construct(@_);my$c=$self->{config};for (qw(siteman1 siteman3 vendorman1 vendorman3)){$c->{"install${_}dir"}||= $c->{"install${_}"}}return$self}sub _detildefy {my ($self,$value)=@_;$value =~ s[^~([^/]+)?(?=/|$)]   # tilde with optional username [$1 ? (eval{(getpwnam $1)[7]}|| "~$1"): ($ENV{HOME}|| eval{(getpwuid $>)[7]}|| glob("~"))]ex;return$value}1;
MODULE_BUILD_PLATFORM_UNIX

$fatpacked{"Module/Build/Platform/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_VMS';
  package Module::Build::Platform::VMS;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Base;use Config;our@ISA=qw(Module::Build::Base);sub _set_defaults {my$self=shift;$self->SUPER::_set_defaults(@_);$self->{properties}{build_script}='Build.com'}sub cull_args {my$self=shift;my($action,$args)=$self->SUPER::cull_args(@_);my@possible_actions=grep {lc $_ eq lc$action}$self->known_actions;die "Ambiguous action '$action'.  Could be one of @possible_actions" if@possible_actions > 1;return ($possible_actions[0],$args)}sub manpage_separator {return '__'}sub _catprefix {my($self,$rprefix,$default)=@_;my($rvol,$rdirs)=File::Spec->splitpath($rprefix);if($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->log_verbose("  prefixify $path from $sprefix to $rprefix\n");$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->log_verbose("  rprefix translated to $rprefix\n"."  sprefix translated to $sprefix\n");if(length($path)==0){$self->log_verbose("  no path to prefixify.\n")}elsif(!File::Spec->file_name_is_absolute($path)){$self->log_verbose("    path is relative, not prefixifying.\n")}elsif($sprefix eq $rprefix){$self->log_verbose("  no new prefix.\n")}else {my($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config('vms_prefix');if($path_vol eq $vms_prefix.':'){$self->log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix($rprefix,$path_dirs)}else {$self->log_verbose("    cannot prefixify.\n");return$self->prefix_relpaths($self->installdirs,$type)}}$self->log_verbose("    now $path\n");return$path}sub _quote_args {my ($self,@args)=@_;my$got_arrayref=(scalar(@args)==1 && ref$args[0]eq 'ARRAY')? 1 : 0;map {if (!/^\//){$_ =~ s/\"/""/g;$_=q(").$_.q(")}}($got_arrayref ? @{$args[0]}: @args);return$got_arrayref ? $args[0]: join(' ',@args)}sub have_forkpipe {0}sub _backticks {my ($self,@cmd)=@_;my$cmd=shift@cmd;my$args=$self->_quote_args(@cmd);return `$cmd $args`}sub find_command {my ($self,$command)=@_;if ($^O eq 'VMS'){require VMS::DCLsym;my$syms=VMS::DCLsym->new;return$command if scalar$syms->getsym(uc$command)}$self->SUPER::find_command($command)}sub _maybe_command {my($self,$file)=@_;return$file if -x $file &&!-d _;my(@dirs)=('');my(@exts)=('',$Config{'exe_ext'},'.exe','.com');if ($file !~ m![/:>\]]!){for (my$i=0;defined$ENV{"DCL\$PATH;$i"};$i++){my$dir=$ENV{"DCL\$PATH;$i"};$dir .= ':' unless$dir =~ m%[\]:]$%;push(@dirs,$dir)}push(@dirs,'Sys$System:');for my$dir (@dirs){my$sysfile="$dir$file";for my$ext (@exts){return$file if -x "$sysfile$ext" &&!-d _}}}return}sub do_system {my ($self,@cmd)=@_;$self->log_verbose("@cmd\n");my$cmd=shift@cmd;my$args=$self->_quote_args(@cmd);return!system("$cmd $args")}sub oneliner {my$self=shift;my$oneliner=$self->SUPER::oneliner(@_);$oneliner =~ s/^\"\S+\"//;return "MCR $^X $oneliner"}sub rscan_dir {my ($self,$dir,$pattern)=@_;my$result=$self->SUPER::rscan_dir($dir,$pattern);for my$file (@$result){if (!_efs()&& ($file =~ m#/#)){$file =~ s/\.$//}}return$result}sub dist_dir {my$self=shift;my$dist_dir=$self->SUPER::dist_dir;$dist_dir =~ s/\./_/g unless _efs();return$dist_dir}sub man3page_name {my$self=shift;my$mpname=$self->SUPER::man3page_name(shift);my$sep=$self->manpage_separator;$mpname =~ s/^$sep//;return$mpname}sub expand_test_dir {my ($self,$dir)=@_;my@reldirs=$self->SUPER::expand_test_dir($dir);for my$eachdir (@reldirs){my ($v,$d,$f)=File::Spec->splitpath($eachdir);my$reldir=File::Spec->abs2rel(File::Spec->catpath($v,$d,''));$eachdir=File::Spec->catfile($reldir,$f)}return@reldirs}sub _detildefy {my ($self,$arg)=@_;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}sub find_perl_interpreter {return VMS::Filespec::vmsify($^X)}sub localize_file_path {my ($self,$path)=@_;$path=VMS::Filespec::vmsify($path);$path =~ s/\.\z//;return$path}sub localize_dir_path {my ($self,$path)=@_;return VMS::Filespec::vmspath($path)}sub ACTION_clean {my ($self)=@_;for my$item (map glob(VMS::Filespec::rmsexpand($_,'.;0')),$self->cleanup){$self->delete_filetree($item)}}my$use_feature;BEGIN {if (eval {local$SIG{__DIE__};require VMS::Feature}){$use_feature=1}}sub _unix_rpt {my$unix_rpt;if ($use_feature){$unix_rpt=VMS::Feature::current("filename_unix_report")}else {my$env_unix_rpt=$ENV{'DECC$FILENAME_UNIX_REPORT'}|| '';$unix_rpt=$env_unix_rpt =~ /^[ET1]/i}return$unix_rpt}sub _efs {my$efs;if ($use_feature){$efs=VMS::Feature::current("efs_charset")}else {my$env_efs=$ENV{'DECC$EFS_CHARSET'}|| '';$efs=$env_efs =~ /^[ET1]/i}return$efs}1;
MODULE_BUILD_PLATFORM_VMS

$fatpacked{"Module/Build/Platform/VOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_VOS';
  package Module::Build::Platform::VOS;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Base;our@ISA=qw(Module::Build::Base);1;
MODULE_BUILD_PLATFORM_VOS

$fatpacked{"Module/Build/Platform/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_WINDOWS';
  package Module::Build::Platform::Windows;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Config;use File::Basename;use File::Spec;use Module::Build::Base;our@ISA=qw(Module::Build::Base);sub manpage_separator {return '.'}sub have_forkpipe {0}sub _detildefy {my ($self,$value)=@_;$value =~ s,^~(?= [/\\] | $ ),$ENV{HOME},x if$ENV{HOME};return$value}sub ACTION_realclean {my ($self)=@_;$self->SUPER::ACTION_realclean();my$basename=basename($0);$basename =~ s/(?:\.bat)?$//i;if (lc$basename eq lc$self->build_script){if ($self->build_bat){$self->log_verbose("Deleting $basename.bat\n");my$full_progname=$0;$full_progname =~ s/(?:\.bat)?$/.bat/i;require Win32;my$null_arg=(Win32::IsWinNT())? '""' : '';my$cmd=qq(start $null_arg /min "\%comspec\%" /c del "$full_progname");open(my$fh,'>>',"$basename.bat")or die "Can't create $basename.bat: $!";print$fh $cmd;close$fh }else {$self->delete_filetree($self->build_script .'.bat')}}}sub make_executable {my$self=shift;$self->SUPER::make_executable(@_);for my$script (@_){if ($script =~ /\.(bat|cmd)$/){$self->SUPER::make_executable($script);next}else {my%opts=();if ($script eq $self->build_script){$opts{ntargs}=q(-x -S %0 --build_bat %*);$opts{otherargs}=q(-x -S "%0" --build_bat %1 %2 %3 %4 %5 %6 %7 %8 %9)}my$out=eval {$self->pl2bat(in=>$script,update=>1,%opts)};if ($@){$self->log_warn("WARNING: Unable to convert file '$script' to an executable script:\n$@")}else {$self->SUPER::make_executable($out)}}}}sub pl2bat {my$self=shift;my%opts=@_;$opts{ntargs}='-x -S %0 %*' unless exists$opts{ntargs};$opts{otherargs}='-x -S "%0" %1 %2 %3 %4 %5 %6 %7 %8 %9' unless exists$opts{otherargs};$opts{stripsuffix}='/\\.plx?/' unless exists$opts{stripsuffix};$opts{stripsuffix}=($opts{stripsuffix}=~ m{^/([^/]*[^/\$]|)\$?/?$} ? $1 : "\Q$opts{stripsuffix}\E");unless (exists$opts{out}){$opts{out}=$opts{in};$opts{out}=~ s/$opts{stripsuffix}$//oi;$opts{out}.= '.bat' unless$opts{in}=~ /\.bat$/i or $opts{in}=~ /^-$/}my$head=<<EOT;$head =~ s/^\s+//gm;my$headlines=2 + ($head =~ tr/\n/\n/);my$tail="\n__END__\n:endofperl\n";my$linedone=0;my$taildone=0;my$linenum=0;my$skiplines=0;my$start=$Config{startperl};$start="#!perl" unless$start =~ /^#!.*perl/;open(my$in,'<',"$opts{in}")or die "Can't open $opts{in}: $!";my@file=<$in>;close($in);for my$line (@file){$linenum++;if ($line =~ /^:endofperl\b/){if (!exists$opts{update}){warn "$opts{in} has already been converted to a batch file!\n";return}$taildone++}if (not $linedone and $line =~ /^#!.*perl/){if (exists$opts{update}){$skiplines=$linenum - 1;$line .= "#line ".(1+$headlines)."\n"}else {$line .= "#line ".($linenum+$headlines)."\n"}$linedone++}if ($line =~ /^#\s*line\b/ and $linenum==2 + $skiplines){$line=""}}open(my$out,'>',"$opts{out}")or die "Can't open $opts{out}: $!";print$out $head;print$out $start,($opts{usewarnings}? " -w" : ""),"\n#line ",($headlines+1),"\n" unless$linedone;print$out @file[$skiplines..$#file];print$out $tail unless$taildone;close($out);return$opts{out}}sub _quote_args {my ($self,@args)=@_;my@quoted;for (@args){if (/^[^\s*?!\$<>;|'"\[\]\{\}]+$/){push@quoted,$_}else {s/"/\\"/g;push@quoted,qq("$_")}}return join " ",@quoted}sub split_like_shell {(my$self,local $_)=@_;return @$_ if defined()&& ref()eq 'ARRAY';my@argv;return@argv unless defined()&& length();my$length=length;m/\G\s*/gc;ARGS: until (pos==$length){my$quote_mode;my$arg='';CHARS: until (pos==$length){if (m/\G((?:\\\\)+)(?=\\?(")?)/gc){if (defined $2){$arg .= '\\' x (length($1)/ 2)}else {$arg .= $1}}elsif (m/\G\\"/gc){$arg .= '"'}elsif (m/\G"/gc){if ($quote_mode && m/\G"/gc){$arg .= '"'}$quote_mode=!$quote_mode}elsif (!$quote_mode && m/\G\s+/gc){last}elsif (m/\G(.)/sgc){$arg .= $1}}push@argv,$arg}return@argv}sub do_system {my ($self,@cmd)=@_;my$cmd=$self->_quote_args(@cmd);my$status=system($cmd);if ($status and $! =~ /Argument list too long/i){my$env_entries='';for (sort keys%ENV){$env_entries .= "$_=>".length($ENV{$_})."; "}warn "'Argument list' was 'too long', env lengths are $env_entries"}return!$status}sub _maybe_command {my($self,$file)=@_;my@e=exists($ENV{'PATHEXT'})? split(/;/,$ENV{PATHEXT}): qw(.com .exe .bat .cmd);my$e='';for (@e){$e .= "\Q$_\E|"}chop$e;if ($file =~ /($e)$/i){return$file if -e $file}else {for (@e){return "$file$_" if -e "$file$_"}}return}1;
      \@rem = '--*-Perl-*--
      \@echo off
      if "%OS%" == "Windows_NT" goto WinNT
      perl $opts{otherargs}
      goto endofperl
      :WinNT
      perl $opts{ntargs}
      if NOT "%COMSPEC%" == "%SystemRoot%\\system32\\cmd.exe" goto endofperl
      if %errorlevel% == 9009 echo You do not have Perl in your PATH.
      if errorlevel 1 goto script_failed_so_exit_with_non_zero_val 2>nul
      goto endofperl
      \@rem ';
  EOT
MODULE_BUILD_PLATFORM_WINDOWS

$fatpacked{"Module/Build/Platform/aix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_AIX';
  package Module::Build::Platform::aix;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);1;
MODULE_BUILD_PLATFORM_AIX

$fatpacked{"Module/Build/Platform/cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_CYGWIN';
  package Module::Build::Platform::cygwin;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);sub manpage_separator {'.'}sub _maybe_command {my ($self,$file)=@_;if ($file =~ m{^/cygdrive/}i){require Module::Build::Platform::Windows;return Module::Build::Platform::Windows->_maybe_command($file)}return$self->SUPER::_maybe_command($file)}1;
MODULE_BUILD_PLATFORM_CYGWIN

$fatpacked{"Module/Build/Platform/darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_DARWIN';
  package Module::Build::Platform::darwin;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);1;
MODULE_BUILD_PLATFORM_DARWIN

$fatpacked{"Module/Build/Platform/os2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PLATFORM_OS2';
  package Module::Build::Platform::os2;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;use Module::Build::Platform::Unix;our@ISA=qw(Module::Build::Platform::Unix);sub manpage_separator {'.'}sub have_forkpipe {0}sub _maybe_command {my($self,$file)=@_;$file =~ s,[/\\]+,/,g;return$file if -x $file &&!-d _;return "$file.exe" if -x "$file.exe" &&!-d _;return "$file.cmd" if -x "$file.cmd" &&!-d _;return}1;
MODULE_BUILD_PLATFORM_OS2

$fatpacked{"Module/Build/PodParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_PODPARSER';
  package Module::Build::PodParser;use strict;use warnings;our$VERSION='0.4229';$VERSION=eval$VERSION;sub new {my$package=shift;my$self;$self=bless {have_pod_parser=>0,@_},$package;unless ($self->{fh}){die "No 'file' or 'fh' parameter given" unless$self->{file};open($self->{fh},'<',$self->{file})or die "Couldn't open $self->{file}: $!"}return$self}sub parse_from_filehandle {my ($self,$fh)=@_;local $_;while (<$fh>){next unless /^=(?!cut)/ .. /^=cut/;last if ($self->{abstract})=/^ (?: [a-z_0-9:]+ | [BCIF] < [a-z_0-9:]+ > ) \s+ - \s+ (.*\S) /ix}my@author;while (<$fh>){next unless /^=head1\s+AUTHORS?/i ... /^=/;next if /^=/;push@author,$_ if /\@/}return unless@author;s/^\s+|\s+$//g foreach@author;$self->{author}=\@author;return}sub get_abstract {my$self=shift;return$self->{abstract}if defined$self->{abstract};$self->parse_from_filehandle($self->{fh});return$self->{abstract}}sub get_author {my$self=shift;return$self->{author}if defined$self->{author};$self->parse_from_filehandle($self->{fh});return$self->{author}|| []}
MODULE_BUILD_PODPARSER

$fatpacked{"Module/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE';
  package Module::CPANfile;use strict;use warnings;use Cwd;use Carp ();use Module::CPANfile::Environment;use Module::CPANfile::Requirement;our$VERSION='1.1004';BEGIN {if (${^TAINT}){*untaint=sub {my$str=shift;($str)=$str =~ /^(.+)$/s;$str}}else {*untaint=sub {$_[0]}}}sub new {my($class,$file)=@_;bless {},$class}sub load {my($proto,$file)=@_;my$self=ref$proto ? $proto : $proto->new;$self->parse($file || _default_cpanfile());$self}sub save {my($self,$path)=@_;open my$out,">",$path or die "$path: $!";print {$out}$self->to_string}sub parse {my($self,$file)=@_;my$code=do {open my$fh,"<",$file or die "$file: $!";join '',<$fh>};$code=untaint$code;my$env=Module::CPANfile::Environment->new($file);$env->parse($code)or die $@;$self->{_mirrors}=$env->mirrors;$self->{_prereqs}=$env->prereqs}sub from_prereqs {my($proto,$prereqs)=@_;my$self=$proto->new;$self->{_prereqs}=Module::CPANfile::Prereqs->from_cpan_meta($prereqs);$self}sub mirrors {my$self=shift;$self->{_mirrors}|| []}sub features {my$self=shift;map$self->feature($_),$self->{_prereqs}->identifiers}sub feature {my($self,$identifier)=@_;$self->{_prereqs}->feature($identifier)}sub prereq {shift->prereqs}sub prereqs {my$self=shift;$self->{_prereqs}->as_cpan_meta}sub merged_requirements {my$self=shift;$self->{_prereqs}->merged_requirements}sub effective_prereqs {my($self,$features)=@_;$self->prereqs_with(@{$features || []})}sub prereqs_with {my($self,@feature_identifiers)=@_;my@others=map {$self->feature($_)->prereqs}@feature_identifiers;$self->prereqs->with_merged_prereqs(\@others)}sub prereq_specs {my$self=shift;$self->prereqs->as_string_hash}sub prereq_for_module {my($self,$module)=@_;$self->{_prereqs}->find($module)}sub options_for_module {my($self,$module)=@_;my$prereq=$self->prereq_for_module($module)or return;$prereq->requirement->options}sub merge_meta {my($self,$file,$version)=@_;require CPAN::Meta;$version ||= $file =~ /\.yml$/ ? '1.4' : '2';my$prereq=$self->prereqs;my$meta=CPAN::Meta->load_file($file);my$prereqs_hash=$prereq->with_merged_prereqs($meta->effective_prereqs)->as_string_hash;my$struct={%{$meta->as_struct},prereqs=>$prereqs_hash };CPAN::Meta->new($struct)->save($file,{version=>$version })}sub _d($) {require Data::Dumper;chomp(my$value=Data::Dumper->new([$_[0]])->Terse(1)->Dump);$value}sub _default_cpanfile {my$file=Cwd::abs_path('cpanfile');untaint$file}sub to_string {my($self,$include_empty)=@_;my$mirrors=$self->mirrors;my$prereqs=$self->prereq_specs;my$code='';$code .= $self->_dump_mirrors($mirrors);$code .= $self->_dump_prereqs($prereqs,$include_empty);for my$feature ($self->features){$code .= "feature @{[ _d $feature->{identifier} ]}, @{[ _d $feature->{description} ]} => sub {\n";$code .= $self->_dump_prereqs($feature->{prereqs}->as_string_hash,$include_empty,4);$code .= "};\n\n"}$code =~ s/\n+$/\n/s;$code}sub _dump_mirrors {my($self,$mirrors)=@_;my$code="";for my$url (@$mirrors){$code .= "mirror @{[ _d $url ]};\n"}$code =~ s/\n+$/\n/s;$code}sub _dump_prereqs {my($self,$prereqs,$include_empty,$base_indent)=@_;my$code='';for my$phase (qw(runtime configure build test develop)){my$indent=$phase eq 'runtime' ? '' : '    ';$indent .= (' ' x ($base_indent || 0));my($phase_code,$requirements);$phase_code .= "on $phase => sub {\n" unless$phase eq 'runtime';for my$type (qw(requires recommends suggests conflicts)){for my$mod (sort keys %{$prereqs->{$phase}{$type}}){my$ver=$prereqs->{$phase}{$type}{$mod};$phase_code .= $ver eq '0' ? "${indent}$type @{[ _d $mod ]}" : "${indent}$type @{[ _d $mod ]}, @{[ _d $ver ]}";my$options=$self->options_for_module($mod)|| {};if (%$options){my@opts;for my$key (keys %$options){my$k=$key =~ /^[a-zA-Z0-9_]+$/ ? $key : _d$key;push@opts,"$k => @{[ _d $options->{$k} ]}"}$phase_code .= ",\n" .join(",\n",map "  $indent$_",@opts)}$phase_code .= ";\n";$requirements++}}$phase_code .= "\n" unless$requirements;$phase_code .= "};\n" unless$phase eq 'runtime';$code .= $phase_code ."\n" if$requirements or $include_empty}$code =~ s/\n+$/\n/s;$code}1;
MODULE_CPANFILE

$fatpacked{"Module/CPANfile/Environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_ENVIRONMENT';
  package Module::CPANfile::Environment;use strict;use warnings;use Module::CPANfile::Prereqs;use Carp ();my@bindings=qw(on requires recommends suggests conflicts feature osname mirror configure_requires build_requires test_requires author_requires);my$file_id=1;sub new {my($class,$file)=@_;bless {file=>$file,phase=>'runtime',feature=>undef,features=>{},prereqs=>Module::CPANfile::Prereqs->new,mirrors=>[],},$class}sub bind {my$self=shift;my$pkg=caller;for my$binding (@bindings){no strict 'refs';*{"$pkg\::$binding"}=sub {$self->$binding(@_)}}}sub parse {my($self,$code)=@_;my$err;{local $@;$file_id++;$self->_evaluate(<<EVAL);$err=$@}if ($err){die "Parsing $self->{file} failed: $err"};return 1}sub _evaluate {my$_environment=$_[0];eval $_[1]}sub prereqs {$_[0]->{prereqs}}sub mirrors {$_[0]->{mirrors}}sub on {my($self,$phase,$code)=@_;local$self->{phase}=$phase;$code->()}sub feature {my($self,$identifier,$description,$code)=@_;if (@_==3 && ref($description)eq 'CODE'){$code=$description;$description=$identifier}unless (ref$description eq '' && ref$code eq 'CODE'){Carp::croak("Usage: feature 'identifier', 'Description' => sub { ... }")}local$self->{feature}=$identifier;$self->prereqs->add_feature($identifier,$description);$code->()}sub osname {die "TODO"}sub mirror {my($self,$url)=@_;push @{$self->{mirrors}},$url}sub requirement_for {my($self,$module,@args)=@_;my$requirement=0;$requirement=shift@args if@args % 2;return Module::CPANfile::Requirement->new(name=>$module,version=>$requirement,@args,)}sub requires {my$self=shift;$self->add_prereq(requires=>@_)}sub recommends {my$self=shift;$self->add_prereq(recommends=>@_)}sub suggests {my$self=shift;$self->add_prereq(suggests=>@_)}sub conflicts {my$self=shift;$self->add_prereq(conflicts=>@_)}sub add_prereq {my($self,$type,$module,@args)=@_;$self->prereqs->add(feature=>$self->{feature},phase=>$self->{phase},type=>$type,module=>$module,requirement=>$self->requirement_for($module,@args),)}sub configure_requires {my($self,@args)=@_;$self->on(configure=>sub {$self->requires(@args)})}sub build_requires {my($self,@args)=@_;$self->on(build=>sub {$self->requires(@args)})}sub test_requires {my($self,@args)=@_;$self->on(test=>sub {$self->requires(@args)})}sub author_requires {my($self,@args)=@_;$self->on(develop=>sub {$self->requires(@args)})}1;
  package Module::CPANfile::Sandbox$file_id;
  no warnings;
  BEGIN { \$_environment->bind }
  
  # line 1 "$self->{file}"
  $code;
  EVAL
MODULE_CPANFILE_ENVIRONMENT

$fatpacked{"Module/CPANfile/Prereq.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQ';
  package Module::CPANfile::Prereq;use strict;sub new {my($class,%options)=@_;bless \%options,$class}sub feature {$_[0]->{feature}}sub phase {$_[0]->{phase}}sub type {$_[0]->{type}}sub module {$_[0]->{module}}sub requirement {$_[0]->{requirement}}1;
MODULE_CPANFILE_PREREQ

$fatpacked{"Module/CPANfile/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQS';
  package Module::CPANfile::Prereqs;use strict;use Carp ();use CPAN::Meta::Feature;use Module::CPANfile::Prereq;sub from_cpan_meta {my($class,$prereqs)=@_;my$self=$class->new;for my$phase (keys %$prereqs){for my$type (keys %{$prereqs->{$phase}}){while (my($module,$requirement)=each %{$prereqs->{$phase}{$type}}){$self->add(phase=>$phase,type=>$type,module=>$module,requirement=>Module::CPANfile::Requirement->new(name=>$module,version=>$requirement),)}}}$self}sub new {my$class=shift;bless {prereqs=>{},features=>{},},$class}sub add_feature {my($self,$identifier,$description)=@_;$self->{features}{$identifier}={description=>$description }}sub add {my($self,%args)=@_;my$feature=$args{feature}|| '';push @{$self->{prereqs}{$feature}},Module::CPANfile::Prereq->new(%args)}sub as_cpan_meta {my$self=shift;$self->{cpanmeta}||= $self->build_cpan_meta}sub build_cpan_meta {my($self,$feature)=@_;CPAN::Meta::Prereqs->new($self->specs($feature))}sub specs {my($self,$feature)=@_;$feature='' unless defined$feature;my$prereqs=$self->{prereqs}{$feature}|| [];my$specs={};for my$prereq (@$prereqs){$specs->{$prereq->phase}{$prereq->type}{$prereq->module}=$prereq->requirement->version}return$specs}sub merged_requirements {my$self=shift;my$reqs=CPAN::Meta::Requirements->new;for my$prereq (@{$self->{prereqs}}){$reqs->add_string_requirement($prereq->module,$prereq->requirement->version)}$reqs}sub find {my($self,$module)=@_;for my$feature ('',keys %{$self->{features}}){for my$prereq (@{$self->{prereqs}{$feature}}){return$prereq if$prereq->module eq $module}}return}sub identifiers {my$self=shift;keys %{$self->{features}}}sub feature {my($self,$identifier)=@_;my$data=$self->{features}{$identifier}or Carp::croak("Unknown feature '$identifier'");my$prereqs=$self->build_cpan_meta($identifier);CPAN::Meta::Feature->new($identifier,{description=>$data->{description},prereqs=>$prereqs->as_string_hash,})}1;
MODULE_CPANFILE_PREREQS

$fatpacked{"Module/CPANfile/Requirement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_REQUIREMENT';
  package Module::CPANfile::Requirement;use strict;sub new {my ($class,%args)=@_;$args{version}||= 0;bless +{name=>delete$args{name},version=>delete$args{version},options=>\%args,},$class}sub name {$_[0]->{name}}sub version {$_[0]->{version}}sub options {$_[0]->{options}}sub has_options {keys %{$_[0]->{options}}> 0}1;
MODULE_CPANFILE_REQUIREMENT

$fatpacked{"Module/CoreList.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CORELIST';
  package Module::CoreList;use strict;our (%released,%version,%families,%upstream,%bug_tracker,%deprecated,%delta);use version;our$VERSION='5.20191120';sub PKG_PATTERN () {q#\A[a-zA-Z_][0-9a-zA-Z_]*(?:(::|')[0-9a-zA-Z_]+)*\z#}sub _looks_like_invocant ($) {local $@;!!eval {$_[0]->isa(__PACKAGE__)}}sub _undelta {my ($delta)=@_;my (%expanded,$delta_from,$base,$changed,$removed);for my$v (sort keys %$delta){($delta_from,$changed,$removed)=@{$delta->{$v}}{qw(delta_from changed removed)};$base=$delta_from ? $expanded{$delta_from}: {};my%full=(%$base,%{$changed || {}});delete@full{keys %$removed };$expanded{$v}=\%full}return%expanded}sub _released_order {(substr($released{$a},0,1)eq "?")? ((substr($released{$b},0,1)eq "?")? 0 : 1): ((substr($released{$b},0,1)eq "?")? -1 : $released{$a}cmp $released{$b})}my$dumpinc=0;sub import {my$self=shift;my$what=shift || '';if ($what eq 'dumpinc'){$dumpinc=1}}END {print "---INC---\n",join "\n"=>keys%INC if$dumpinc}sub first_release_raw {shift if defined $_[1]and $_[1]=~ PKG_PATTERN and _looks_like_invocant $_[0];my$module=shift;my$version=shift;my@perls=$version ? grep {defined$version{$_}{$module }&& $version{$_}{$module }ge $version}keys%version : grep {exists$version{$_}{$module }}keys%version;return@perls}sub first_release_by_date {my@perls=&first_release_raw;return unless@perls;return (sort _released_order@perls)[0]}sub first_release {my@perls=&first_release_raw;return unless@perls;return (sort {$a cmp $b}@perls)[0]}sub find_modules {shift if _looks_like_invocant $_[0];my$regex=shift;my@perls=@_ ? @_ : keys%version;my%mods;for (@perls){while (my ($k,$v)=each %{$version{$_}}){$mods{$k}++ if$k =~ $regex}}return sort keys%mods}sub find_version {shift if _looks_like_invocant $_[0];my$v=shift;return$version{$v}if defined$v and defined$version{$v};return}sub is_deprecated {shift if defined $_[1]and $_[1]=~ PKG_PATTERN and _looks_like_invocant $_[0];my$module=shift;my$perl_version=shift || $];return unless$module && exists$deprecated{$perl_version}{$module};return$deprecated{$perl_version}{$module}}sub deprecated_in {shift if defined $_[1]and $_[1]=~ PKG_PATTERN and _looks_like_invocant $_[0];my$module=shift or return;my@perls=grep {exists$deprecated{$_}{$module}}keys%deprecated;return unless@perls;require List::Util;return List::Util::minstr(@perls)}sub removed_from {my@perls=&removed_raw;return shift@perls}sub removed_from_by_date {my@perls=sort _released_order&removed_raw;return shift@perls}sub removed_raw {shift if defined $_[1]and $_[1]=~ PKG_PATTERN and _looks_like_invocant $_[0];my$mod=shift;return unless my@perls=sort {$a cmp $b}first_release_raw($mod);my$last=pop@perls;my@removed=grep {$_ > $last}sort {$a cmp $b}keys%version;return@removed}sub changes_between {shift if _looks_like_invocant $_[0];my$left_ver=shift;my$right_ver=shift;my$left=$version{$left_ver };my$right=$version{$right_ver };my%uniq=(%$left,%$right);my%changes;for my$lib (keys%uniq){my$lhs=exists$left->{$lib }? (defined$left->{$lib }? $left->{$lib }: '(undef)'): '(absent)';my$rhs=exists$right->{$lib }? (defined$right->{$lib }? $right->{$lib }: '(undef)'): '(absent)';next if$lhs eq $rhs;my$change={(exists$left->{$lib}? (left=>$left->{$lib}): ()),(exists$right->{$lib}? (right=>$right->{$lib}): ()),};$changes{$lib}=$change}return%changes}%released=(5.000=>'1994-10-17',5.001=>'1995-03-14',5.002=>'1996-02-29',5.00307=>'1996-10-10',5.004=>'1997-05-15',5.005=>'1998-07-22',5.00503=>'1999-03-28',5.00405=>'1999-04-29',5.006=>'2000-03-22',5.006001=>'2001-04-08',5.007003=>'2002-03-05',5.008=>'2002-07-19',5.008001=>'2003-09-25',5.009=>'2003-10-27',5.008002=>'2003-11-05',5.006002=>'2003-11-15',5.008003=>'2004-01-14',5.00504=>'2004-02-23',5.009001=>'2004-03-16',5.008004=>'2004-04-21',5.008005=>'2004-07-19',5.008006=>'2004-11-27',5.009002=>'2005-04-01',5.008007=>'2005-05-30',5.009003=>'2006-01-28',5.008008=>'2006-01-31',5.009004=>'2006-08-15',5.009005=>'2007-07-07',5.010000=>'2007-12-18',5.008009=>'2008-12-14',5.010001=>'2009-08-22',5.011000=>'2009-10-02',5.011001=>'2009-10-20',5.011002=>'2009-11-20',5.011003=>'2009-12-20',5.011004=>'2010-01-20',5.011005=>'2010-02-20',5.012000=>'2010-04-12',5.013000=>'2010-04-20',5.012001=>'2010-05-16',5.013001=>'2010-05-20',5.013002=>'2010-06-22',5.013003=>'2010-07-20',5.013004=>'2010-08-20',5.012002=>'2010-09-06',5.013005=>'2010-09-19',5.013006=>'2010-10-20',5.013007=>'2010-11-20',5.013008=>'2010-12-20',5.012003=>'2011-01-21',5.013009=>'2011-01-20',5.013010=>'2011-02-20',5.013011=>'2011-03-20',5.014000=>'2011-05-14',5.012004=>'2011-06-20',5.012005=>'2012-11-10',5.014001=>'2011-06-16',5.015000=>'2011-06-20',5.015001=>'2011-07-20',5.015002=>'2011-08-20',5.014002=>'2011-09-26',5.015003=>'2011-09-20',5.015004=>'2011-10-20',5.015005=>'2011-11-20',5.015006=>'2011-12-20',5.015007=>'2012-01-20',5.015008=>'2012-02-20',5.015009=>'2012-03-20',5.016000=>'2012-05-20',5.016001=>'2012-08-08',5.016002=>'2012-11-01',5.017000=>'2012-05-26',5.017001=>'2012-06-20',5.017002=>'2012-07-20',5.017003=>'2012-08-20',5.017004=>'2012-09-20',5.014003=>'2012-10-12',5.017005=>'2012-10-20',5.017006=>'2012-11-20',5.017007=>'2012-12-18',5.017008=>'2013-01-20',5.017009=>'2013-02-20',5.014004=>'2013-03-10',5.016003=>'2013-03-11',5.017010=>'2013-03-21',5.017011=>'2013-04-20',5.018000=>'2013-05-18',5.019000=>'2013-05-20',5.019001=>'2013-06-21',5.019002=>'2013-07-22',5.018001=>'2013-08-12',5.019003=>'2013-08-20',5.019004=>'2013-09-20',5.019005=>'2013-10-20',5.019006=>'2013-11-20',5.019007=>'2013-12-20',5.018002=>'2014-01-06',5.018003=>'2014-10-01',5.018004=>'2014-10-01',5.019008=>'2014-01-20',5.019009=>'2014-02-20',5.01901=>'2014-03-20',5.019011=>'2014-04-20',5.020000=>'2014-05-27',5.021000=>'2014-05-27',5.021001=>'2014-06-20',5.021002=>'2014-07-20',5.021003=>'2014-08-20',5.020001=>'2014-09-14',5.021004=>'2014-09-20',5.021005=>'2014-10-20',5.021006=>'2014-11-20',5.021007=>'2014-12-20',5.021008=>'2015-01-20',5.020002=>'2015-02-14',5.021009=>'2015-02-21',5.021010=>'2015-03-20',5.021011=>'2015-04-20',5.022000=>'2015-06-01',5.023000=>'2015-06-20',5.023001=>'2015-07-20',5.023002=>'2015-08-20',5.020003=>'2015-09-12',5.023003=>'2015-09-20',5.023004=>'2015-10-20',5.023005=>'2015-11-20',5.022001=>'2015-12-13',5.023006=>'2015-12-21',5.023007=>'2016-01-20',5.023008=>'2016-02-20',5.023009=>'2016-03-20',5.022002=>'2016-04-29',5.024000=>'2016-05-09',5.025000=>'2016-05-09',5.025001=>'2016-05-20',5.025002=>'2016-06-20',5.025003=>'2016-07-20',5.025004=>'2016-08-20',5.025005=>'2016-09-20',5.025006=>'2016-10-20',5.025007=>'2016-11-20',5.025008=>'2016-12-20',5.022003=>'2017-01-14',5.024001=>'2017-01-14',5.025009=>'2017-01-20',5.025010=>'2017-02-20',5.025011=>'2017-03-20',5.025012=>'2017-04-20',5.026000=>'2017-05-30',5.027000=>'2017-05-31',5.027001=>'2017-06-20',5.022004=>'2017-07-15',5.024002=>'2017-07-15',5.027002=>'2017-07-20',5.027003=>'2017-08-21',5.027004=>'2017-09-20',5.024003=>'2017-09-22',5.026001=>'2017-09-22',5.027005=>'2017-10-20',5.027006=>'2017-11-20',5.027007=>'2017-12-20',5.027008=>'2018-01-20',5.027009=>'2018-02-20',5.027010=>'2018-03-20',5.024004=>'2018-04-14',5.026002=>'2018-04-14',5.027011=>'2018-04-20',5.028000=>'2018-06-22',5.029000=>'2018-06-26',5.029001=>'2018-07-20',5.029002=>'2018-08-20',5.029003=>'2018-09-20',5.029004=>'2018-10-20',5.029005=>'2018-11-20',5.026003=>'2018-11-29',5.028001=>'2018-11-29',5.029006=>'2018-12-18',5.029007=>'2019-01-20',5.029008=>'2019-02-20',5.029009=>'2019-03-20',5.028002=>'2019-04-19',5.029010=>'2019-04-20',5.030000=>'2019-05-22',5.031000=>'2019-05-24',5.031001=>'2019-06-20',5.031002=>'2019-07-20',5.031003=>'2019-08-20',5.031004=>'2019-09-20',5.031005=>'2019-10-20',5.030001=>'2019-11-10',5.031006=>'2019-11-20',);for my$version (sort {$a <=> $b}keys%released){my$family=int ($version * 1000)/ 1000;push @{$families{$family }},$version}%delta=(5=>{changed=>{'AnyDBM_File'=>undef,'AutoLoader'=>undef,'AutoSplit'=>undef,'Benchmark'=>undef,'Carp'=>undef,'Cwd'=>undef,'DB_File'=>undef,'DynaLoader'=>undef,'English'=>undef,'Env'=>undef,'Exporter'=>undef,'ExtUtils::MakeMaker'=>undef,'Fcntl'=>undef,'File::Basename'=>undef,'File::CheckTree'=>undef,'File::Find'=>undef,'FileHandle'=>undef,'GDBM_File'=>undef,'Getopt::Long'=>undef,'Getopt::Std'=>undef,'I18N::Collate'=>undef,'IPC::Open2'=>undef,'IPC::Open3'=>undef,'Math::BigFloat'=>undef,'Math::BigInt'=>undef,'Math::Complex'=>undef,'NDBM_File'=>undef,'Net::Ping'=>undef,'ODBM_File'=>undef,'POSIX'=>undef,'SDBM_File'=>undef,'Search::Dict'=>undef,'Shell'=>undef,'Socket'=>undef,'Sys::Hostname'=>undef,'Sys::Syslog'=>undef,'Term::Cap'=>undef,'Term::Complete'=>undef,'Test::Harness'=>undef,'Text::Abbrev'=>undef,'Text::ParseWords'=>undef,'Text::Soundex'=>undef,'Text::Tabs'=>undef,'TieHash'=>undef,'Time::Local'=>undef,'integer'=>undef,'less'=>undef,'sigtrap'=>undef,'strict'=>undef,'subs'=>undef,},removed=>{}},5.001=>{delta_from=>5,changed=>{'ExtUtils::Liblist'=>undef,'ExtUtils::Manifest'=>undef,'ExtUtils::Mkbootstrap'=>undef,'File::Path'=>undef,'SubstrHash'=>undef,'lib'=>undef,},removed=>{}},5.002=>{delta_from=>5.001,changed=>{'DB_File'=>'1.01','Devel::SelfStubber'=>'1.01','DirHandle'=>undef,'DynaLoader'=>'1.00','ExtUtils::Install'=>undef,'ExtUtils::MM_OS2'=>undef,'ExtUtils::MM_Unix'=>undef,'ExtUtils::MM_VMS'=>undef,'ExtUtils::MakeMaker'=>'5.21','ExtUtils::Manifest'=>'1.22','ExtUtils::Mksymlists'=>'1.00','Fcntl'=>'1.00','File::Copy'=>'1.5','File::Path'=>'1.01','FileCache'=>undef,'FileHandle'=>'1.00','GDBM_File'=>'1.00','Getopt::Long'=>'2.01','NDBM_File'=>'1.00','Net::Ping'=>'1','ODBM_File'=>'1.00','POSIX'=>'1.00','Pod::Functions'=>undef,'Pod::Text'=>undef,'SDBM_File'=>'1.00','Safe'=>'1.00','SelectSaver'=>undef,'SelfLoader'=>'1.06','Socket'=>'1.5','Symbol'=>undef,'Term::ReadLine'=>undef,'Test::Harness'=>'1.07','Text::Wrap'=>undef,'Tie::Hash'=>undef,'Tie::Scalar'=>undef,'Tie::SubstrHash'=>undef,'diagnostics'=>undef,'overload'=>undef,'vars'=>undef,},removed=>{'SubstrHash'=>1,'TieHash'=>1,}},5.00307=>{delta_from=>5.002,changed=>{'Config'=>undef,'DB_File'=>'1.03','ExtUtils::Embed'=>'1.18','ExtUtils::Install'=>'1.15','ExtUtils::Liblist'=>'1.20','ExtUtils::MM_Unix'=>'1.107','ExtUtils::MakeMaker'=>'5.38','ExtUtils::Manifest'=>'1.27','ExtUtils::Mkbootstrap'=>'1.13','ExtUtils::Mksymlists'=>'1.12','ExtUtils::testlib'=>'1.11','Fatal'=>undef,'File::Basename'=>'2.4','FindBin'=>'1.04','Getopt::Long'=>'2.04','IO'=>undef,'IO::File'=>'1.05','IO::Handle'=>'1.12','IO::Pipe'=>'1.07','IO::Seekable'=>'1.05','IO::Select'=>'1.09','IO::Socket'=>'1.13','Net::Ping'=>'1.01','OS2::ExtAttr'=>'0.01','OS2::PrfDB'=>'0.02','OS2::Process'=>undef,'OS2::REXX'=>undef,'Opcode'=>'1.01','Safe'=>'2.06','Test::Harness'=>'1.13','Text::Tabs'=>'96.051501','Text::Wrap'=>'96.041801','UNIVERSAL'=>undef,'VMS::Filespec'=>undef,'VMS::Stdio'=>'2.0','ops'=>undef,'sigtrap'=>'1.01',},removed=>{}},5.004=>{delta_from=>5.00307,changed=>{'Bundle::CPAN'=>'0.02','CGI'=>'2.36','CGI::Apache'=>'1.01','CGI::Carp'=>'1.06','CGI::Fast'=>'1.00a','CGI::Push'=>'1.00','CGI::Switch'=>'0.05','CPAN'=>'1.2401','CPAN::FirstTime'=>'1.18','CPAN::Nox'=>undef,'Class::Struct'=>undef,'Cwd'=>'2.00','DB_File'=>'1.14','DynaLoader'=>'1.02','ExtUtils::Command'=>'1.00','ExtUtils::Embed'=>'1.2501','ExtUtils::Install'=>'1.16','ExtUtils::Liblist'=>'1.2201','ExtUtils::MM_Unix'=>'1.114','ExtUtils::MM_Win32'=>undef,'ExtUtils::MakeMaker'=>'5.4002','ExtUtils::Manifest'=>'1.33','ExtUtils::Mksymlists'=>'1.13','ExtUtils::XSSymSet'=>'1.0','Fcntl'=>'1.03','File::Basename'=>'2.5','File::Compare'=>'1.1001','File::Copy'=>'2.02','File::Path'=>'1.04','File::stat'=>undef,'FileHandle'=>'2.00','Getopt::Long'=>'2.10','IO::File'=>'1.0602','IO::Handle'=>'1.1504','IO::Pipe'=>'1.0901','IO::Seekable'=>'1.06','IO::Select'=>'1.10','IO::Socket'=>'1.1602','IPC::Open2'=>'1.01','IPC::Open3'=>'1.0101','Math::Complex'=>'1.01','Math::Trig'=>'1','Net::Ping'=>'2.02','Net::hostent'=>undef,'Net::netent'=>undef,'Net::protoent'=>undef,'Net::servent'=>undef,'Opcode'=>'1.04','POSIX'=>'1.02','Pod::Html'=>undef,'Pod::Text'=>'1.0203','SelfLoader'=>'1.07','Socket'=>'1.6','Symbol'=>'1.02','Test::Harness'=>'1.1502','Text::Tabs'=>'96.121201','Text::Wrap'=>'97.011701','Tie::RefHash'=>undef,'Time::gmtime'=>'1.01','Time::localtime'=>'1.01','Time::tm'=>undef,'User::grent'=>undef,'User::pwent'=>undef,'VMS::DCLsym'=>'1.01','VMS::Stdio'=>'2.02','autouse'=>'1.01','blib'=>undef,'constant'=>'1.00','locale'=>undef,'sigtrap'=>'1.02','vmsish'=>undef,},removed=>{'Fatal'=>1,}},5.00405=>{delta_from=>5.004,changed=>{'AutoLoader'=>'5.56','AutoSplit'=>'1.0303','Bundle::CPAN'=>'0.03','CGI'=>'2.42','CGI::Apache'=>'1.1','CGI::Carp'=>'1.10','CGI::Cookie'=>'1.06','CGI::Push'=>'1.01','CGI::Switch'=>'0.06','CPAN'=>'1.40','CPAN::FirstTime'=>'1.30','Cwd'=>'2.01','DB_File'=>'1.15','DynaLoader'=>'1.03','ExtUtils::Command'=>'1.01','ExtUtils::Embed'=>'1.2505','ExtUtils::Install'=>'1.28','ExtUtils::Liblist'=>'1.25','ExtUtils::MM_Unix'=>'1.118','ExtUtils::MakeMaker'=>'5.42','ExtUtils::Mkbootstrap'=>'1.14','ExtUtils::Mksymlists'=>'1.16','File::Basename'=>'2.6','File::DosGlob'=>undef,'File::Path'=>'1.0402','File::Spec'=>'0.6','File::Spec::Mac'=>'1.0','File::Spec::OS2'=>undef,'File::Spec::Unix'=>undef,'File::Spec::VMS'=>undef,'File::Spec::Win32'=>undef,'FindBin'=>'1.41','Getopt::Long'=>'2.19','IO::File'=>'1.06021','IO::Socket'=>'1.1603','IPC::Open3'=>'1.0103','Math::Complex'=>'1.25','NDBM_File'=>'1.01','Pod::Html'=>'1.0101','Pod::Text'=>'1.0204','SelfLoader'=>'1.08','Socket'=>'1.7','Test'=>'1.04','Test::Harness'=>'1.1602','Text::ParseWords'=>'3.1001','Text::Wrap'=>'98.112902','Tie::Handle'=>undef,'attrs'=>'0.1','base'=>undef,'blib'=>'1.00','re'=>undef,'strict'=>'1.01',},removed=>{}},5.005=>{delta_from=>5.00405,changed=>{'AutoLoader'=>undef,'AutoSplit'=>'1.0302','B'=>undef,'B::Asmdata'=>undef,'B::Assembler'=>undef,'B::Bblock'=>undef,'B::Bytecode'=>undef,'B::C'=>undef,'B::CC'=>undef,'B::Debug'=>undef,'B::Deparse'=>'0.56','B::Disassembler'=>undef,'B::Lint'=>undef,'B::Showlex'=>undef,'B::Stackobj'=>undef,'B::Terse'=>undef,'B::Xref'=>undef,'CGI::Carp'=>'1.101','CPAN'=>'1.3901','CPAN::FirstTime'=>'1.29','DB_File'=>'1.60','Data::Dumper'=>'2.09','Errno'=>'1.09','ExtUtils::Installed'=>'0.02','ExtUtils::MM_Unix'=>'1.12601','ExtUtils::MakeMaker'=>'5.4301','ExtUtils::Mkbootstrap'=>'1.13','ExtUtils::Mksymlists'=>'1.17','ExtUtils::Packlist'=>'0.03','Fatal'=>'1.02','File::Path'=>'1.0401','Getopt::Long'=>'2.17','IO::Handle'=>'1.1505','IPC::Msg'=>'1.00','IPC::Open3'=>'1.0102','IPC::Semaphore'=>'1.00','IPC::SysV'=>'1.03','O'=>undef,'OS2::Process'=>'0.2','Pod::Html'=>'1.01','Pod::Text'=>'1.0203','Text::ParseWords'=>'3.1','Text::Wrap'=>'97.02','Thread'=>'1.0','Thread::Queue'=>undef,'Thread::Semaphore'=>undef,'Thread::Signal'=>undef,'Thread::Specific'=>undef,'Tie::Array'=>'1.00','VMS::Stdio'=>'2.1','attrs'=>'1.0','fields'=>'0.02','re'=>'0.02',},removed=>{'Bundle::CPAN'=>1,}},5.00503=>{delta_from=>5.005,changed=>{'AutoSplit'=>'1.0303','CGI'=>'2.46','CGI::Carp'=>'1.13','CGI::Fast'=>'1.01','CPAN'=>'1.48','CPAN::FirstTime'=>'1.36','CPAN::Nox'=>'1.00','DB_File'=>'1.65','Data::Dumper'=>'2.101','Dumpvalue'=>undef,'Errno'=>'1.111','ExtUtils::Install'=>'1.28','ExtUtils::Liblist'=>'1.25','ExtUtils::MM_Unix'=>'1.12602','ExtUtils::MakeMaker'=>'5.4302','ExtUtils::Manifest'=>'1.33','ExtUtils::Mkbootstrap'=>'1.14','ExtUtils::Mksymlists'=>'1.17','ExtUtils::testlib'=>'1.11','FindBin'=>'1.42','Getopt::Long'=>'2.19','Getopt::Std'=>'1.01','IO::Pipe'=>'1.0902','IPC::Open3'=>'1.0103','Math::Complex'=>'1.26','Test'=>'1.122','Text::Wrap'=>'98.112902',},removed=>{}},5.00504=>{delta_from=>5.00503,changed=>{'CPAN::FirstTime'=>'1.36','DB_File'=>'1.807','ExtUtils::Install'=>'1.28','ExtUtils::Liblist'=>'1.25','ExtUtils::MM_Unix'=>'1.12602','ExtUtils::Manifest'=>'1.33','ExtUtils::Miniperl'=>undef,'ExtUtils::Mkbootstrap'=>'1.14','ExtUtils::Mksymlists'=>'1.17','ExtUtils::testlib'=>'1.11','File::Compare'=>'1.1002','File::Spec'=>'0.8','File::Spec::Functions'=>undef,'File::Spec::Mac'=>undef,'Getopt::Long'=>'2.20','Pod::Html'=>'1.02',},removed=>{}},5.006=>{delta_from=>5.00504,changed=>{'AutoLoader'=>'5.57','AutoSplit'=>'1.0305','B::Deparse'=>'0.59','B::Stash'=>undef,'Benchmark'=>'1','ByteLoader'=>'0.03','CGI'=>'2.56','CGI::Apache'=>undef,'CGI::Carp'=>'1.14','CGI::Cookie'=>'1.12','CGI::Fast'=>'1.02','CGI::Pretty'=>'1.03','CGI::Switch'=>undef,'CPAN'=>'1.52','CPAN::FirstTime'=>'1.38','Carp::Heavy'=>undef,'Class::Struct'=>'0.58','Cwd'=>'2.02','DB'=>'1.0','DB_File'=>'1.72','Devel::DProf'=>'20000000.00_00','Devel::Peek'=>'1.00_01','DynaLoader'=>'1.04','Exporter'=>'5.562','Exporter::Heavy'=>undef,'ExtUtils::MM_Cygwin'=>undef,'ExtUtils::MM_Unix'=>'1.12603','ExtUtils::MakeMaker'=>'5.45','File::Copy'=>'2.03','File::Glob'=>'0.991','File::Path'=>'1.0403','GDBM_File'=>'1.03','Getopt::Long'=>'2.23','Getopt::Std'=>'1.02','IO'=>'1.20','IO::Dir'=>'1.03','IO::File'=>'1.08','IO::Handle'=>'1.21','IO::Pipe'=>'1.121','IO::Poll'=>'0.01','IO::Seekable'=>'1.08','IO::Select'=>'1.14','IO::Socket'=>'1.26','IO::Socket::INET'=>'1.25','IO::Socket::UNIX'=>'1.20','JNI'=>'0.01','JPL::AutoLoader'=>undef,'JPL::Class'=>undef,'JPL::Compile'=>undef,'NDBM_File'=>'1.03','ODBM_File'=>'1.02','OS2::DLL'=>undef,'POSIX'=>'1.03','Pod::Checker'=>'1.098','Pod::Find'=>'0.12','Pod::Html'=>'1.03','Pod::InputObjects'=>'1.12','Pod::Man'=>'1.02','Pod::ParseUtils'=>'0.2','Pod::Parser'=>'1.12','Pod::Plainer'=>'0.01','Pod::Select'=>'1.12','Pod::Text'=>'2.03','Pod::Text::Color'=>'0.05','Pod::Text::Termcap'=>'0.04','Pod::Usage'=>'1.12','SDBM_File'=>'1.02','SelfLoader'=>'1.0901','Shell'=>'0.2','Socket'=>'1.72','Sys::Hostname'=>'1.1','Sys::Syslog'=>'0.01','Term::ANSIColor'=>'1.01','Test'=>'1.13','Test::Harness'=>'1.1604','Text::ParseWords'=>'3.2','Text::Soundex'=>'1.0','Text::Tabs'=>'98.112801','Tie::Array'=>'1.01','Tie::Handle'=>'1.0','VMS::Stdio'=>'2.2','XSLoader'=>'0.01','attributes'=>'0.03','autouse'=>'1.02','base'=>'1.01','bytes'=>undef,'charnames'=>undef,'constant'=>'1.02','diagnostics'=>'1.0','fields'=>'1.01','filetest'=>undef,'lib'=>'0.5564','open'=>undef,'utf8'=>undef,'warnings'=>undef,'warnings::register'=>undef,},removed=>{}},5.006001=>{delta_from=>5.006,changed=>{'AutoLoader'=>'5.58','B::Assembler'=>'0.02','B::Concise'=>'0.51','B::Deparse'=>'0.6','ByteLoader'=>'0.04','CGI'=>'2.752','CGI::Carp'=>'1.20','CGI::Cookie'=>'1.18','CGI::Pretty'=>'1.05','CGI::Push'=>'1.04','CGI::Util'=>'1.1','CPAN'=>'1.59_54','CPAN::FirstTime'=>'1.53','Class::Struct'=>'0.59','Cwd'=>'2.04','DB_File'=>'1.75','Data::Dumper'=>'2.102','ExtUtils::Install'=>'1.28','ExtUtils::Liblist'=>'1.26','ExtUtils::MM_Unix'=>'1.12603','ExtUtils::Manifest'=>'1.33','ExtUtils::Mkbootstrap'=>'1.14','ExtUtils::Mksymlists'=>'1.17','ExtUtils::testlib'=>'1.11','File::Path'=>'1.0404','File::Spec'=>'0.82','File::Spec::Epoc'=>undef,'File::Spec::Functions'=>'1.1','File::Spec::Mac'=>'1.2','File::Spec::OS2'=>'1.1','File::Spec::Unix'=>'1.2','File::Spec::VMS'=>'1.1','File::Spec::Win32'=>'1.2','File::Temp'=>'0.12','GDBM_File'=>'1.05','Getopt::Long'=>'2.25','IO::Poll'=>'0.05','JNI'=>'0.1','Math::BigFloat'=>'0.02','Math::BigInt'=>'0.01','Math::Complex'=>'1.31','NDBM_File'=>'1.04','ODBM_File'=>'1.03','OS2::REXX'=>'1.00','Pod::Checker'=>'1.2','Pod::Find'=>'0.21','Pod::InputObjects'=>'1.13','Pod::LaTeX'=>'0.53','Pod::Man'=>'1.15','Pod::ParseUtils'=>'0.22','Pod::Parser'=>'1.13','Pod::Select'=>'1.13','Pod::Text'=>'2.08','Pod::Text::Color'=>'0.06','Pod::Text::Overstrike'=>'1.01','Pod::Text::Termcap'=>'1','Pod::Usage'=>'1.14','SDBM_File'=>'1.03','SelfLoader'=>'1.0902','Shell'=>'0.3','Term::ANSIColor'=>'1.03','Test'=>'1.15','Text::Wrap'=>'2001.0131','Tie::Handle'=>'4.0','Tie::RefHash'=>'1.3',},removed=>{}},5.006002=>{delta_from=>5.006001,changed=>{'CPAN::FirstTime'=>'1.53','DB_File'=>'1.806','Data::Dumper'=>'2.121','ExtUtils::Command'=>'1.05','ExtUtils::Command::MM'=>'0.03','ExtUtils::Install'=>'1.32','ExtUtils::Installed'=>'0.08','ExtUtils::Liblist'=>'1.01','ExtUtils::Liblist::Kid'=>'1.3','ExtUtils::MM'=>'0.04','ExtUtils::MM_Any'=>'0.07','ExtUtils::MM_BeOS'=>'1.04','ExtUtils::MM_Cygwin'=>'1.06','ExtUtils::MM_DOS'=>'0.02','ExtUtils::MM_MacOS'=>'1.07','ExtUtils::MM_NW5'=>'2.06','ExtUtils::MM_OS2'=>'1.04','ExtUtils::MM_UWIN'=>'0.02','ExtUtils::MM_Unix'=>'1.42','ExtUtils::MM_VMS'=>'5.70','ExtUtils::MM_Win32'=>'1.09','ExtUtils::MM_Win95'=>'0.03','ExtUtils::MY'=>'0.01','ExtUtils::MakeMaker'=>'6.17','ExtUtils::MakeMaker::bytes'=>'0.01','ExtUtils::MakeMaker::vmsish'=>'0.01','ExtUtils::Manifest'=>'1.42','ExtUtils::Mkbootstrap'=>'1.15','ExtUtils::Mksymlists'=>'1.19','ExtUtils::Packlist'=>'0.04','ExtUtils::testlib'=>'1.15','File::Spec'=>'0.86','File::Spec::Cygwin'=>'1.1','File::Spec::Epoc'=>'1.1','File::Spec::Functions'=>'1.3','File::Spec::Mac'=>'1.4','File::Spec::OS2'=>'1.2','File::Spec::Unix'=>'1.5','File::Spec::VMS'=>'1.4','File::Spec::Win32'=>'1.4','File::Temp'=>'0.14','Safe'=>'2.10','Test'=>'1.24','Test::Builder'=>'0.17','Test::Harness'=>'2.30','Test::Harness::Assert'=>'0.01','Test::Harness::Iterator'=>'0.01','Test::Harness::Straps'=>'0.15','Test::More'=>'0.47','Test::Simple'=>'0.47','Unicode'=>'3.0.1','if'=>'0.03','ops'=>'1.00',},removed=>{}},5.007003=>{delta_from=>5.006001,changed=>{'AnyDBM_File'=>'1.00','Attribute::Handlers'=>'0.76','AutoLoader'=>'5.59','AutoSplit'=>'1.0307','B'=>'1.00','B::Asmdata'=>'1.00','B::Assembler'=>'0.04','B::Bblock'=>'1.00','B::Bytecode'=>'1.00','B::C'=>'1.01','B::CC'=>'1.00','B::Concise'=>'0.52','B::Debug'=>'1.00','B::Deparse'=>'0.63','B::Disassembler'=>'1.01','B::Lint'=>'1.00','B::Showlex'=>'1.00','B::Stackobj'=>'1.00','B::Stash'=>'1.00','B::Terse'=>'1.00','B::Xref'=>'1.00','Benchmark'=>'1.04','CGI'=>'2.80','CGI::Apache'=>'1.00','CGI::Carp'=>'1.22','CGI::Cookie'=>'1.20','CGI::Fast'=>'1.04','CGI::Pretty'=>'1.05_00','CGI::Switch'=>'1.00','CGI::Util'=>'1.3','CPAN'=>'1.59_56','CPAN::FirstTime'=>'1.54','CPAN::Nox'=>'1.00_01','Carp'=>'1.01','Carp::Heavy'=>'1.01','Class::ISA'=>'0.32','Class::Struct'=>'0.61','Cwd'=>'2.06','DB_File'=>'1.804','Data::Dumper'=>'2.12','Devel::DProf'=>'20000000.00_01','Devel::PPPort'=>'2.0002','Devel::Peek'=>'1.00_03','Devel::SelfStubber'=>'1.03','Digest'=>'1.00','Digest::MD5'=>'2.16','DirHandle'=>'1.00','Dumpvalue'=>'1.10','Encode'=>'0.40','Encode::CN'=>'0.02','Encode::CN::HZ'=>undef,'Encode::Encoding'=>'0.02','Encode::Internal'=>'0.30','Encode::JP'=>'0.02','Encode::JP::Constants'=>'1.02','Encode::JP::H2Z'=>'0.77','Encode::JP::ISO_2022_JP'=>undef,'Encode::JP::JIS'=>undef,'Encode::JP::Tr'=>'0.77','Encode::KR'=>'0.02','Encode::TW'=>'0.02','Encode::Tcl'=>'1.01','Encode::Tcl::Escape'=>'1.01','Encode::Tcl::Extended'=>'1.01','Encode::Tcl::HanZi'=>'1.01','Encode::Tcl::Table'=>'1.01','Encode::Unicode'=>'0.30','Encode::XS'=>'0.40','Encode::iso10646_1'=>'0.30','Encode::usc2_le'=>'0.30','Encode::utf8'=>'0.30','English'=>'1.00','Env'=>'1.00','Exporter'=>'5.566','Exporter::Heavy'=>'5.562','ExtUtils::Command'=>'1.02','ExtUtils::Constant'=>'0.11','ExtUtils::Embed'=>'1.250601','ExtUtils::Install'=>'1.29','ExtUtils::Installed'=>'0.04','ExtUtils::Liblist'=>'1.2701','ExtUtils::MM_BeOS'=>'1.00','ExtUtils::MM_Cygwin'=>'1.00','ExtUtils::MM_OS2'=>'1.00','ExtUtils::MM_Unix'=>'1.12607','ExtUtils::MM_VMS'=>'5.56','ExtUtils::MM_Win32'=>'1.00_02','ExtUtils::MakeMaker'=>'5.48_03','ExtUtils::Manifest'=>'1.35','ExtUtils::Mkbootstrap'=>'1.1401','ExtUtils::Mksymlists'=>'1.18','ExtUtils::Packlist'=>'0.04','ExtUtils::testlib'=>'1.1201','Fatal'=>'1.03','Fcntl'=>'1.04','File::Basename'=>'2.71','File::CheckTree'=>'4.1','File::Compare'=>'1.1003','File::Copy'=>'2.05','File::DosGlob'=>'1.00','File::Find'=>'1.04','File::Glob'=>'1.01','File::Path'=>'1.05','File::Spec'=>'0.83','File::Spec::Cygwin'=>'1.0','File::Spec::Epoc'=>'1.00','File::Spec::Functions'=>'1.2','File::Spec::Mac'=>'1.3','File::Spec::Unix'=>'1.4','File::Spec::VMS'=>'1.2','File::Spec::Win32'=>'1.3','File::Temp'=>'0.13','File::stat'=>'1.00','FileCache'=>'1.00','FileHandle'=>'2.01','Filter::Simple'=>'0.77','Filter::Util::Call'=>'1.06','FindBin'=>'1.43','GDBM_File'=>'1.06','Getopt::Long'=>'2.28','Getopt::Std'=>'1.03','I18N::Collate'=>'1.00','I18N::LangTags'=>'0.27','I18N::LangTags::List'=>'0.25','I18N::Langinfo'=>'0.01','IO::Dir'=>'1.03_00','IO::File'=>'1.09','IO::Handle'=>'1.21_00','IO::Pipe'=>'1.122','IO::Poll'=>'0.06','IO::Seekable'=>'1.08_00','IO::Select'=>'1.15','IO::Socket'=>'1.27','IO::Socket::INET'=>'1.26','IO::Socket::UNIX'=>'1.20_00','IPC::Msg'=>'1.00_00','IPC::Open3'=>'1.0104','IPC::Semaphore'=>'1.00_00','IPC::SysV'=>'1.03_00','List::Util'=>'1.06_00','Locale::Constants'=>'2.01','Locale::Country'=>'2.01','Locale::Currency'=>'2.01','Locale::Language'=>'2.01','Locale::Maketext'=>'1.03','Locale::Script'=>'2.01','MIME::Base64'=>'2.12','MIME::QuotedPrint'=>'2.03','Math::BigFloat'=>'1.30','Math::BigInt'=>'1.54','Math::BigInt::Calc'=>'0.25','Math::Complex'=>'1.34','Math::Trig'=>'1.01','Memoize'=>'0.66','Memoize::AnyDBM_File'=>'0.65','Memoize::Expire'=>'0.66','Memoize::ExpireFile'=>'0.65','Memoize::ExpireTest'=>'0.65','Memoize::NDBM_File'=>'0.65','Memoize::SDBM_File'=>'0.65','Memoize::Storable'=>'0.65','NEXT'=>'0.50','Net::Cmd'=>'2.21','Net::Config'=>'1.10','Net::Domain'=>'2.17','Net::FTP'=>'2.64','Net::FTP::A'=>'1.15','Net::FTP::E'=>'0.01','Net::FTP::I'=>'1.12','Net::FTP::L'=>'0.01','Net::FTP::dataconn'=>'0.10','Net::NNTP'=>'2.21','Net::Netrc'=>'2.12','Net::POP3'=>'2.23','Net::Ping'=>'2.12','Net::SMTP'=>'2.21','Net::Time'=>'2.09','Net::hostent'=>'1.00','Net::netent'=>'1.00','Net::protoent'=>'1.00','Net::servent'=>'1.00','O'=>'1.00','OS2::DLL'=>'1.00','OS2::Process'=>'1.0','OS2::REXX'=>'1.01','Opcode'=>'1.05','POSIX'=>'1.05','PerlIO'=>'1.00','PerlIO::Scalar'=>'0.01','PerlIO::Via'=>'0.01','Pod::Checker'=>'1.3','Pod::Find'=>'0.22','Pod::Functions'=>'1.01','Pod::Html'=>'1.04','Pod::LaTeX'=>'0.54','Pod::Man'=>'1.32','Pod::ParseLink'=>'1.05','Pod::Text'=>'2.18','Pod::Text::Color'=>'1.03','Pod::Text::Overstrike'=>'1.08','Pod::Text::Termcap'=>'1.09','Safe'=>'2.07','Scalar::Util'=>'1.06_00','Search::Dict'=>'1.02','SelectSaver'=>'1.00','SelfLoader'=>'1.0903','Shell'=>'0.4','Socket'=>'1.75','Storable'=>'1.015','Switch'=>'2.06','Symbol'=>'1.04','Sys::Syslog'=>'0.02','Term::ANSIColor'=>'1.04','Term::Cap'=>'1.07','Term::Complete'=>'1.4','Term::ReadLine'=>'1.00','Test'=>'1.18','Test::Builder'=>'0.11','Test::Harness'=>'2.01','Test::Harness::Assert'=>'0.01','Test::Harness::Iterator'=>'0.01','Test::Harness::Straps'=>'0.08','Test::More'=>'0.41','Test::Simple'=>'0.41','Text::Abbrev'=>'1.00','Text::Balanced'=>'1.89','Text::ParseWords'=>'3.21','Text::Soundex'=>'1.01','Text::Wrap'=>'2001.0929','Thread'=>'2.00','Thread::Queue'=>'1.00','Thread::Semaphore'=>'1.00','Thread::Signal'=>'1.00','Thread::Specific'=>'1.00','Tie::Array'=>'1.02','Tie::File'=>'0.17','Tie::Handle'=>'4.1','Tie::Hash'=>'1.00','Tie::Memoize'=>'1.0','Tie::RefHash'=>'1.3_00','Tie::Scalar'=>'1.00','Tie::SubstrHash'=>'1.00','Time::HiRes'=>'1.20_00','Time::Local'=>'1.04','Time::gmtime'=>'1.02','Time::localtime'=>'1.02','Time::tm'=>'1.00','UNIVERSAL'=>'1.00','Unicode::Collate'=>'0.10','Unicode::Normalize'=>'0.14','Unicode::UCD'=>'0.2','User::grent'=>'1.00','User::pwent'=>'1.00','VMS::DCLsym'=>'1.02','VMS::Filespec'=>'1.1','VMS::Stdio'=>'2.3','XS::Typemap'=>'0.01','attributes'=>'0.04_01','attrs'=>'1.01','autouse'=>'1.03','base'=>'1.02','blib'=>'1.01','bytes'=>'1.00','charnames'=>'1.01','constant'=>'1.04','diagnostics'=>'1.1','encoding'=>'1.00','fields'=>'1.02','filetest'=>'1.00','if'=>'0.01','integer'=>'1.00','less'=>'0.01','locale'=>'1.00','open'=>'1.01','ops'=>'1.00','overload'=>'1.00','re'=>'0.03','sort'=>'1.00','strict'=>'1.02','subs'=>'1.00','threads'=>'0.05','threads::shared'=>'0.90','utf8'=>'1.00','vars'=>'1.01','vmsish'=>'1.00','warnings'=>'1.00','warnings::register'=>'1.00',},removed=>{}},5.008=>{delta_from=>5.007003,changed=>{'Attribute::Handlers'=>'0.77','B'=>'1.01','B::Lint'=>'1.01','B::Xref'=>'1.01','CGI'=>'2.81','CGI::Carp'=>'1.23','CPAN'=>'1.61','CPAN::FirstTime'=>'1.56','CPAN::Nox'=>'1.02','Digest::MD5'=>'2.20','Dumpvalue'=>'1.11','Encode'=>'1.75','Encode::Alias'=>'1.32','Encode::Byte'=>'1.22','Encode::CJKConstants'=>'1.00','Encode::CN'=>'1.24','Encode::CN::HZ'=>'1.04','Encode::Config'=>'1.06','Encode::EBCDIC'=>'1.21','Encode::Encoder'=>'0.05','Encode::Encoding'=>'1.30','Encode::Guess'=>'1.06','Encode::JP'=>'1.25','Encode::JP::H2Z'=>'1.02','Encode::JP::JIS7'=>'1.08','Encode::KR'=>'1.22','Encode::KR::2022_KR'=>'1.05','Encode::MIME::Header'=>'1.05','Encode::Symbol'=>'1.22','Encode::TW'=>'1.26','Encode::Unicode'=>'1.37','Exporter::Heavy'=>'5.566','ExtUtils::Command'=>'1.04','ExtUtils::Command::MM'=>'0.01','ExtUtils::Constant'=>'0.12','ExtUtils::Installed'=>'0.06','ExtUtils::Liblist'=>'1.00','ExtUtils::Liblist::Kid'=>'1.29','ExtUtils::MM'=>'0.04','ExtUtils::MM_Any'=>'0.04','ExtUtils::MM_BeOS'=>'1.03','ExtUtils::MM_Cygwin'=>'1.04','ExtUtils::MM_DOS'=>'0.01','ExtUtils::MM_MacOS'=>'1.03','ExtUtils::MM_NW5'=>'2.05','ExtUtils::MM_OS2'=>'1.03','ExtUtils::MM_UWIN'=>'0.01','ExtUtils::MM_Unix'=>'1.33','ExtUtils::MM_VMS'=>'5.65','ExtUtils::MM_Win32'=>'1.05','ExtUtils::MM_Win95'=>'0.02','ExtUtils::MY'=>'0.01','ExtUtils::MakeMaker'=>'6.03','ExtUtils::Manifest'=>'1.38','ExtUtils::Mkbootstrap'=>'1.15','ExtUtils::Mksymlists'=>'1.19','ExtUtils::testlib'=>'1.15','File::CheckTree'=>'4.2','FileCache'=>'1.021','Filter::Simple'=>'0.78','Getopt::Long'=>'2.32','Hash::Util'=>'0.04','List::Util'=>'1.07_00','Locale::Country'=>'2.04','Math::BigFloat'=>'1.35','Math::BigFloat::Trace'=>'0.01','Math::BigInt'=>'1.60','Math::BigInt::Calc'=>'0.30','Math::BigInt::Trace'=>'0.01','Math::BigRat'=>'0.07','Memoize'=>'1.01','Memoize::Expire'=>'1.00','Memoize::ExpireFile'=>'1.01','Net::FTP'=>'2.65','Net::FTP::dataconn'=>'0.11','Net::Ping'=>'2.19','Net::SMTP'=>'2.24','PerlIO'=>'1.01','PerlIO::encoding'=>'0.06','PerlIO::scalar'=>'0.01','PerlIO::via'=>'0.01','PerlIO::via::QuotedPrint'=>'0.04','Pod::Man'=>'1.33','Pod::Text'=>'2.19','Scalar::Util'=>'1.07_00','Storable'=>'2.04','Switch'=>'2.09','Sys::Syslog'=>'0.03','Test'=>'1.20','Test::Builder'=>'0.15','Test::Harness'=>'2.26','Test::Harness::Straps'=>'0.14','Test::More'=>'0.45','Test::Simple'=>'0.45','Thread::Queue'=>'2.00','Thread::Semaphore'=>'2.00','Tie::File'=>'0.93','Tie::RefHash'=>'1.30','Unicode'=>'3.2.0','Unicode::Collate'=>'0.12','Unicode::Normalize'=>'0.17','XS::APItest'=>'0.01','attributes'=>'0.05','base'=>'1.03','bigint'=>'0.02','bignum'=>'0.11','bigrat'=>'0.04','blib'=>'1.02','encoding'=>'1.35','sort'=>'1.01','threads'=>'0.99',},removed=>{'Encode::Internal'=>1,'Encode::JP::Constants'=>1,'Encode::JP::ISO_2022_JP'=>1,'Encode::JP::JIS'=>1,'Encode::JP::Tr'=>1,'Encode::Tcl'=>1,'Encode::Tcl::Escape'=>1,'Encode::Tcl::Extended'=>1,'Encode::Tcl::HanZi'=>1,'Encode::Tcl::Table'=>1,'Encode::XS'=>1,'Encode::iso10646_1'=>1,'Encode::usc2_le'=>1,'Encode::utf8'=>1,'PerlIO::Scalar'=>1,'PerlIO::Via'=>1,}},5.008001=>{delta_from=>5.008,changed=>{'Attribute::Handlers'=>'0.78','AutoLoader'=>'5.60','AutoSplit'=>'1.04','B'=>'1.02','B::Asmdata'=>'1.01','B::Assembler'=>'0.06','B::Bblock'=>'1.02','B::Bytecode'=>'1.01','B::C'=>'1.02','B::Concise'=>'0.56','B::Debug'=>'1.01','B::Deparse'=>'0.64','B::Disassembler'=>'1.03','B::Lint'=>'1.02','B::Terse'=>'1.02','Benchmark'=>'1.051','ByteLoader'=>'0.05','CGI'=>'3.00','CGI::Carp'=>'1.26','CGI::Cookie'=>'1.24','CGI::Fast'=>'1.041','CGI::Pretty'=>'1.07_00','CGI::Util'=>'1.31','CPAN'=>'1.76_01','CPAN::FirstTime'=>'1.60','CPAN::Nox'=>'1.03','Class::Struct'=>'0.63','Cwd'=>'2.08','DB_File'=>'1.806','Data::Dumper'=>'2.121','Devel::DProf'=>'20030813.00','Devel::PPPort'=>'2.007','Devel::Peek'=>'1.01','Digest'=>'1.02','Digest::MD5'=>'2.27','Encode'=>'1.9801','Encode::Alias'=>'1.38','Encode::Byte'=>'1.23','Encode::CJKConstants'=>'1.02','Encode::CN::HZ'=>'1.05','Encode::Config'=>'1.07','Encode::Encoder'=>'0.07','Encode::Encoding'=>'1.33','Encode::Guess'=>'1.09','Encode::JP::JIS7'=>'1.12','Encode::KR'=>'1.23','Encode::KR::2022_KR'=>'1.06','Encode::MIME::Header'=>'1.09','Encode::Unicode'=>'1.40','Encode::Unicode::UTF7'=>'0.02','English'=>'1.01','Errno'=>'1.09_00','Exporter'=>'5.567','Exporter::Heavy'=>'5.567','ExtUtils::Command'=>'1.05','ExtUtils::Command::MM'=>'0.03','ExtUtils::Constant'=>'0.14','ExtUtils::Install'=>'1.32','ExtUtils::Installed'=>'0.08','ExtUtils::Liblist'=>'1.01','ExtUtils::Liblist::Kid'=>'1.3','ExtUtils::MM_Any'=>'0.07','ExtUtils::MM_BeOS'=>'1.04','ExtUtils::MM_Cygwin'=>'1.06','ExtUtils::MM_DOS'=>'0.02','ExtUtils::MM_MacOS'=>'1.07','ExtUtils::MM_NW5'=>'2.06','ExtUtils::MM_OS2'=>'1.04','ExtUtils::MM_UWIN'=>'0.02','ExtUtils::MM_Unix'=>'1.42','ExtUtils::MM_VMS'=>'5.70','ExtUtils::MM_Win32'=>'1.09','ExtUtils::MM_Win95'=>'0.03','ExtUtils::MakeMaker'=>'6.17','ExtUtils::MakeMaker::bytes'=>'0.01','ExtUtils::MakeMaker::vmsish'=>'0.01','ExtUtils::Manifest'=>'1.42','Fcntl'=>'1.05','File::Basename'=>'2.72','File::Copy'=>'2.06','File::Find'=>'1.05','File::Glob'=>'1.02','File::Path'=>'1.06','File::Spec'=>'0.86','File::Spec::Cygwin'=>'1.1','File::Spec::Epoc'=>'1.1','File::Spec::Functions'=>'1.3','File::Spec::Mac'=>'1.4','File::Spec::OS2'=>'1.2','File::Spec::Unix'=>'1.5','File::Spec::VMS'=>'1.4','File::Spec::Win32'=>'1.4','File::Temp'=>'0.14','FileCache'=>'1.03','Filter::Util::Call'=>'1.0601','GDBM_File'=>'1.07','Getopt::Long'=>'2.34','Getopt::Std'=>'1.04','Hash::Util'=>'0.05','I18N::LangTags'=>'0.28','I18N::LangTags::List'=>'0.26','I18N::Langinfo'=>'0.02','IO'=>'1.21','IO::Dir'=>'1.04','IO::File'=>'1.10','IO::Handle'=>'1.23','IO::Seekable'=>'1.09','IO::Select'=>'1.16','IO::Socket'=>'1.28','IO::Socket::INET'=>'1.27','IO::Socket::UNIX'=>'1.21','IPC::Msg'=>'1.02','IPC::Open3'=>'1.0105','IPC::Semaphore'=>'1.02','IPC::SysV'=>'1.04','JNI'=>'0.2','List::Util'=>'1.13','Locale::Country'=>'2.61','Locale::Currency'=>'2.21','Locale::Language'=>'2.21','Locale::Maketext'=>'1.06','Locale::Maketext::Guts'=>undef,'Locale::Maketext::GutsLoader'=>undef,'Locale::Script'=>'2.21','MIME::Base64'=>'2.20','MIME::QuotedPrint'=>'2.20','Math::BigFloat'=>'1.40','Math::BigInt'=>'1.66','Math::BigInt::Calc'=>'0.36','Math::BigInt::Scalar'=>'0.11','Math::BigRat'=>'0.10','Math::Trig'=>'1.02','NDBM_File'=>'1.05','NEXT'=>'0.60','Net::Cmd'=>'2.24','Net::Domain'=>'2.18','Net::FTP'=>'2.71','Net::FTP::A'=>'1.16','Net::NNTP'=>'2.22','Net::POP3'=>'2.24','Net::Ping'=>'2.31','Net::SMTP'=>'2.26','Net::hostent'=>'1.01','Net::servent'=>'1.01','ODBM_File'=>'1.04','OS2::DLL'=>'1.01','OS2::ExtAttr'=>'0.02','OS2::PrfDB'=>'0.03','OS2::Process'=>'1.01','OS2::REXX'=>'1.02','POSIX'=>'1.06','PerlIO'=>'1.02','PerlIO::encoding'=>'0.07','PerlIO::scalar'=>'0.02','PerlIO::via'=>'0.02','PerlIO::via::QuotedPrint'=>'0.05','Pod::Checker'=>'1.41','Pod::Find'=>'0.24','Pod::Functions'=>'1.02','Pod::Html'=>'1.0501','Pod::InputObjects'=>'1.14','Pod::LaTeX'=>'0.55','Pod::Man'=>'1.37','Pod::ParseLink'=>'1.06','Pod::ParseUtils'=>'0.3','Pod::Perldoc'=>'3.10','Pod::Perldoc::BaseTo'=>undef,'Pod::Perldoc::GetOptsOO'=>undef,'Pod::Perldoc::ToChecker'=>undef,'Pod::Perldoc::ToMan'=>undef,'Pod::Perldoc::ToNroff'=>undef,'Pod::Perldoc::ToPod'=>undef,'Pod::Perldoc::ToRtf'=>undef,'Pod::Perldoc::ToText'=>undef,'Pod::Perldoc::ToTk'=>undef,'Pod::Perldoc::ToXml'=>undef,'Pod::PlainText'=>'2.01','Pod::Text'=>'2.21','Pod::Text::Color'=>'1.04','Pod::Text::Overstrike'=>'1.1','Pod::Text::Termcap'=>'1.11','Pod::Usage'=>'1.16','SDBM_File'=>'1.04','Safe'=>'2.10','Scalar::Util'=>'1.13','SelfLoader'=>'1.0904','Shell'=>'0.5','Socket'=>'1.76','Storable'=>'2.08','Switch'=>'2.10','Symbol'=>'1.05','Sys::Hostname'=>'1.11','Sys::Syslog'=>'0.04','Term::ANSIColor'=>'1.07','Term::Cap'=>'1.08','Term::Complete'=>'1.401','Term::ReadLine'=>'1.01','Test'=>'1.24','Test::Builder'=>'0.17','Test::Harness'=>'2.30','Test::Harness::Straps'=>'0.15','Test::More'=>'0.47','Test::Simple'=>'0.47','Text::Abbrev'=>'1.01','Text::Balanced'=>'1.95','Text::Wrap'=>'2001.09291','Thread::Semaphore'=>'2.01','Tie::Array'=>'1.03','Tie::File'=>'0.97','Tie::RefHash'=>'1.31','Time::HiRes'=>'1.51','Time::Local'=>'1.07','UNIVERSAL'=>'1.01','Unicode'=>'4.0.0','Unicode::Collate'=>'0.28','Unicode::Normalize'=>'0.23','Unicode::UCD'=>'0.21','VMS::Filespec'=>'1.11','XS::APItest'=>'0.02','XSLoader'=>'0.02','attributes'=>'0.06','base'=>'2.03','bigint'=>'0.04','bignum'=>'0.14','bigrat'=>'0.06','bytes'=>'1.01','charnames'=>'1.02','diagnostics'=>'1.11','encoding'=>'1.47','fields'=>'2.03','filetest'=>'1.01','if'=>'0.03','lib'=>'0.5565','open'=>'1.02','overload'=>'1.01','re'=>'0.04','sort'=>'1.02','strict'=>'1.03','threads'=>'1.00','threads::shared'=>'0.91','utf8'=>'1.02','vmsish'=>'1.01','warnings'=>'1.03',},removed=>{}},5.008002=>{delta_from=>5.008001,changed=>{'DB_File'=>'1.807','Devel::PPPort'=>'2.009','Digest::MD5'=>'2.30','I18N::LangTags'=>'0.29','I18N::LangTags::List'=>'0.29','MIME::Base64'=>'2.21','MIME::QuotedPrint'=>'2.21','Net::Domain'=>'2.19','Net::FTP'=>'2.72','Pod::Perldoc'=>'3.11','Time::HiRes'=>'1.52','Unicode::Collate'=>'0.30','Unicode::Normalize'=>'0.25',},removed=>{}},5.008003=>{delta_from=>5.008002,changed=>{'Benchmark'=>'1.052','CGI'=>'3.01','CGI::Carp'=>'1.27','CGI::Fast'=>'1.05','CGI::Pretty'=>'1.08','CGI::Util'=>'1.4','Cwd'=>'2.12','DB_File'=>'1.808','Devel::PPPort'=>'2.011','Digest'=>'1.05','Digest::MD5'=>'2.33','Digest::base'=>'1.00','Encode'=>'1.99','Exporter'=>'5.57','File::CheckTree'=>'4.3','File::Copy'=>'2.07','File::Find'=>'1.06','File::Spec'=>'0.87','FindBin'=>'1.44','Getopt::Std'=>'1.05','Math::BigFloat'=>'1.42','Math::BigInt'=>'1.68','Math::BigInt::Calc'=>'0.38','Math::BigInt::CalcEmu'=>'0.02','OS2::DLL'=>'1.02','POSIX'=>'1.07','PerlIO'=>'1.03','PerlIO::via::QuotedPrint'=>'0.06','Pod::Html'=>'1.0502','Pod::Parser'=>'1.14','Pod::Perldoc'=>'3.12','Pod::PlainText'=>'2.02','Storable'=>'2.09','Test::Harness'=>'2.40','Test::Harness::Assert'=>'0.02','Test::Harness::Iterator'=>'0.02','Test::Harness::Straps'=>'0.19','Tie::Hash'=>'1.01','Unicode::Collate'=>'0.33','Unicode::Normalize'=>'0.28','XS::APItest'=>'0.03','base'=>'2.04','diagnostics'=>'1.12','encoding'=>'1.48','threads'=>'1.01','threads::shared'=>'0.92',},removed=>{'Math::BigInt::Scalar'=>1,}},5.008004=>{delta_from=>5.008003,changed=>{'Attribute::Handlers'=>'0.78_01','B::Assembler'=>'0.07','B::Concise'=>'0.60','B::Deparse'=>'0.66','Benchmark'=>'1.06','CGI'=>'3.04','Carp'=>'1.02','Cwd'=>'2.17','DBM_Filter'=>'0.01','DBM_Filter::compress'=>'0.01','DBM_Filter::encode'=>'0.01','DBM_Filter::int32'=>'0.01','DBM_Filter::null'=>'0.01','DBM_Filter::utf8'=>'0.01','Digest'=>'1.06','DynaLoader'=>'1.05','Encode'=>'1.99_01','Encode::CN::HZ'=>'1.0501','Exporter'=>'5.58','Exporter::Heavy'=>'5.57','ExtUtils::Liblist::Kid'=>'1.3001','ExtUtils::MM_NW5'=>'2.07_02','ExtUtils::MM_Win95'=>'0.0301','File::Find'=>'1.07','IO::Handle'=>'1.24','IO::Pipe'=>'1.123','IPC::Open3'=>'1.0106','Locale::Maketext'=>'1.08','MIME::Base64'=>'3.01','MIME::QuotedPrint'=>'3.01','Math::BigFloat'=>'1.44','Math::BigInt'=>'1.70','Math::BigInt::Calc'=>'0.40','Math::BigInt::CalcEmu'=>'0.04','Math::BigRat'=>'0.12','ODBM_File'=>'1.05','POSIX'=>'1.08','Shell'=>'0.5.2','Socket'=>'1.77','Storable'=>'2.12','Sys::Syslog'=>'0.05','Term::ANSIColor'=>'1.08','Time::HiRes'=>'1.59','Unicode'=>'4.0.1','Unicode::UCD'=>'0.22','Win32'=>'0.23','base'=>'2.05','bigint'=>'0.05','bignum'=>'0.15','charnames'=>'1.03','open'=>'1.03','threads'=>'1.03','utf8'=>'1.03',},removed=>{}},5.008005=>{delta_from=>5.008004,changed=>{'B::Concise'=>'0.61','B::Deparse'=>'0.67','CGI'=>'3.05','CGI::Carp'=>'1.28','CGI::Util'=>'1.5','Carp'=>'1.03','Carp::Heavy'=>'1.03','Cwd'=>'2.19','DB_File'=>'1.809','Digest'=>'1.08','Encode'=>'2.01','Encode::Alias'=>'2.00','Encode::Byte'=>'2.00','Encode::CJKConstants'=>'2.00','Encode::CN'=>'2.00','Encode::CN::HZ'=>'2.01','Encode::Config'=>'2.00','Encode::EBCDIC'=>'2.00','Encode::Encoder'=>'2.00','Encode::Encoding'=>'2.00','Encode::Guess'=>'2.00','Encode::JP'=>'2.00','Encode::JP::H2Z'=>'2.00','Encode::JP::JIS7'=>'2.00','Encode::KR'=>'2.00','Encode::KR::2022_KR'=>'2.00','Encode::MIME::Header'=>'2.00','Encode::Symbol'=>'2.00','Encode::TW'=>'2.00','Encode::Unicode'=>'2.00','Encode::Unicode::UTF7'=>'2.01','File::Basename'=>'2.73','File::Copy'=>'2.08','File::Glob'=>'1.03','FileCache'=>'1.04_01','I18N::LangTags'=>'0.33','I18N::LangTags::Detect'=>'1.03','List::Util'=>'1.14','Locale::Constants'=>'2.07','Locale::Country'=>'2.07','Locale::Currency'=>'2.07','Locale::Language'=>'2.07','Locale::Maketext'=>'1.09','Locale::Script'=>'2.07','Net::Cmd'=>'2.26','Net::FTP'=>'2.75','Net::NNTP'=>'2.23','Net::POP3'=>'2.28','Net::SMTP'=>'2.29','Net::Time'=>'2.10','Pod::Checker'=>'1.42','Pod::Find'=>'0.2401','Pod::LaTeX'=>'0.56','Pod::ParseUtils'=>'1.2','Pod::Perldoc'=>'3.13','Safe'=>'2.11','Scalar::Util'=>'1.14','Shell'=>'0.6','Storable'=>'2.13','Term::Cap'=>'1.09','Test'=>'1.25','Test::Harness'=>'2.42','Text::ParseWords'=>'3.22','Text::Wrap'=>'2001.09292','Time::Local'=>'1.10','Unicode::Collate'=>'0.40','Unicode::Normalize'=>'0.30','XS::APItest'=>'0.04','autouse'=>'1.04','base'=>'2.06','charnames'=>'1.04','diagnostics'=>'1.13','encoding'=>'2.00','threads'=>'1.05','utf8'=>'1.04',},removed=>{}},5.008006=>{delta_from=>5.008005,changed=>{'B'=>'1.07','B::C'=>'1.04','B::Concise'=>'0.64','B::Debug'=>'1.02','B::Deparse'=>'0.69','B::Lint'=>'1.03','B::Showlex'=>'1.02','Cwd'=>'3.01','DB_File'=>'1.810','Data::Dumper'=>'2.121_02','Devel::PPPort'=>'3.03','Devel::Peek'=>'1.02','Encode'=>'2.08','Encode::Alias'=>'2.02','Encode::Encoding'=>'2.02','Encode::JP'=>'2.01','Encode::Unicode'=>'2.02','Exporter::Heavy'=>'5.58','ExtUtils::Constant'=>'0.1401','File::Spec'=>'3.01','File::Spec::Win32'=>'1.5','I18N::LangTags'=>'0.35','I18N::LangTags::List'=>'0.35','MIME::Base64'=>'3.05','MIME::QuotedPrint'=>'3.03','Math::BigFloat'=>'1.47','Math::BigInt'=>'1.73','Math::BigInt::Calc'=>'0.43','Math::BigRat'=>'0.13','Text::ParseWords'=>'3.23','Time::HiRes'=>'1.65','XS::APItest'=>'0.05','diagnostics'=>'1.14','encoding'=>'2.01','open'=>'1.04','overload'=>'1.02',},removed=>{}},5.008007=>{delta_from=>5.008006,changed=>{'B'=>'1.09','B::Concise'=>'0.65','B::Deparse'=>'0.7','B::Disassembler'=>'1.04','B::Terse'=>'1.03','Benchmark'=>'1.07','CGI'=>'3.10','CGI::Carp'=>'1.29','CGI::Cookie'=>'1.25','Carp'=>'1.04','Carp::Heavy'=>'1.04','Class::ISA'=>'0.33','Cwd'=>'3.05','DB_File'=>'1.811','Data::Dumper'=>'2.121_04','Devel::DProf'=>'20050310.00','Devel::PPPort'=>'3.06','Digest'=>'1.10','Digest::file'=>'0.01','Encode'=>'2.10','Encode::Alias'=>'2.03','Errno'=>'1.09_01','ExtUtils::Constant'=>'0.16','ExtUtils::Constant::Base'=>'0.01','ExtUtils::Constant::Utils'=>'0.01','ExtUtils::Constant::XS'=>'0.01','File::Find'=>'1.09','File::Glob'=>'1.04','File::Path'=>'1.07','File::Spec'=>'3.05','File::Temp'=>'0.16','FileCache'=>'1.05','IO::File'=>'1.11','IO::Socket::INET'=>'1.28','Math::BigFloat'=>'1.51','Math::BigInt'=>'1.77','Math::BigInt::Calc'=>'0.47','Math::BigInt::CalcEmu'=>'0.05','Math::BigRat'=>'0.15','Pod::Find'=>'1.3','Pod::Html'=>'1.0503','Pod::InputObjects'=>'1.3','Pod::LaTeX'=>'0.58','Pod::ParseUtils'=>'1.3','Pod::Parser'=>'1.3','Pod::Perldoc'=>'3.14','Pod::Select'=>'1.3','Pod::Usage'=>'1.3','SelectSaver'=>'1.01','Symbol'=>'1.06','Sys::Syslog'=>'0.06','Term::ANSIColor'=>'1.09','Term::Complete'=>'1.402','Test::Builder'=>'0.22','Test::Harness'=>'2.48','Test::Harness::Point'=>'0.01','Test::Harness::Straps'=>'0.23','Test::More'=>'0.54','Test::Simple'=>'0.54','Text::ParseWords'=>'3.24','Text::Wrap'=>'2001.09293','Tie::RefHash'=>'1.32','Time::HiRes'=>'1.66','Time::Local'=>'1.11','Unicode'=>'4.1.0','Unicode::Normalize'=>'0.32','Unicode::UCD'=>'0.23','Win32'=>'0.24','XS::APItest'=>'0.06','base'=>'2.07','bigint'=>'0.07','bignum'=>'0.17','bigrat'=>'0.08','bytes'=>'1.02','constant'=>'1.05','overload'=>'1.03','threads::shared'=>'0.93','utf8'=>'1.05',},removed=>{'JNI'=>1,'JPL::AutoLoader'=>1,'JPL::Class'=>1,'JPL::Compile'=>1,}},5.008008=>{delta_from=>5.008007,changed=>{'Attribute::Handlers'=>'0.78_02','B'=>'1.09_01','B::Bblock'=>'1.02_01','B::Bytecode'=>'1.01_01','B::C'=>'1.04_01','B::CC'=>'1.00_01','B::Concise'=>'0.66','B::Debug'=>'1.02_01','B::Deparse'=>'0.71','B::Disassembler'=>'1.05','B::Terse'=>'1.03_01','ByteLoader'=>'0.06','CGI'=>'3.15','CGI::Cookie'=>'1.26','CPAN'=>'1.76_02','Cwd'=>'3.12','DB'=>'1.01','DB_File'=>'1.814','Data::Dumper'=>'2.121_08','Devel::DProf'=>'20050603.00','Devel::PPPort'=>'3.06_01','Devel::Peek'=>'1.03','Digest'=>'1.14','Digest::MD5'=>'2.36','Digest::file'=>'1.00','Dumpvalue'=>'1.12','Encode'=>'2.12','Encode::Alias'=>'2.04','Encode::Config'=>'2.01','Encode::MIME::Header'=>'2.01','Encode::MIME::Header::ISO_2022_JP'=>'1.01','English'=>'1.02','ExtUtils::Command'=>'1.09','ExtUtils::Command::MM'=>'0.05','ExtUtils::Constant'=>'0.17','ExtUtils::Embed'=>'1.26','ExtUtils::Install'=>'1.33','ExtUtils::Liblist::Kid'=>'1.3','ExtUtils::MM'=>'0.05','ExtUtils::MM_AIX'=>'0.03','ExtUtils::MM_Any'=>'0.13','ExtUtils::MM_BeOS'=>'1.05','ExtUtils::MM_Cygwin'=>'1.08','ExtUtils::MM_MacOS'=>'1.08','ExtUtils::MM_NW5'=>'2.08','ExtUtils::MM_OS2'=>'1.05','ExtUtils::MM_QNX'=>'0.02','ExtUtils::MM_Unix'=>'1.50','ExtUtils::MM_VMS'=>'5.73','ExtUtils::MM_VOS'=>'0.02','ExtUtils::MM_Win32'=>'1.12','ExtUtils::MM_Win95'=>'0.04','ExtUtils::MakeMaker'=>'6.30','ExtUtils::MakeMaker::Config'=>'0.02','ExtUtils::Manifest'=>'1.46','File::Basename'=>'2.74','File::Copy'=>'2.09','File::Find'=>'1.10','File::Glob'=>'1.05','File::Path'=>'1.08','File::Spec'=>'3.12','File::Spec::Win32'=>'1.6','FileCache'=>'1.06','Filter::Simple'=>'0.82','FindBin'=>'1.47','GDBM_File'=>'1.08','Getopt::Long'=>'2.35','IO'=>'1.22','IO::Dir'=>'1.05','IO::File'=>'1.13','IO::Handle'=>'1.25','IO::Pipe'=>'1.13','IO::Poll'=>'0.07','IO::Seekable'=>'1.10','IO::Select'=>'1.17','IO::Socket'=>'1.29','IO::Socket::INET'=>'1.29','IO::Socket::UNIX'=>'1.22','IPC::Open2'=>'1.02','IPC::Open3'=>'1.02','List::Util'=>'1.18','MIME::Base64'=>'3.07','MIME::QuotedPrint'=>'3.07','Math::Complex'=>'1.35','Math::Trig'=>'1.03','NDBM_File'=>'1.06','ODBM_File'=>'1.06','OS2::PrfDB'=>'0.04','OS2::Process'=>'1.02','OS2::REXX'=>'1.03','Opcode'=>'1.06','POSIX'=>'1.09','PerlIO'=>'1.04','PerlIO::encoding'=>'0.09','PerlIO::scalar'=>'0.04','PerlIO::via'=>'0.03','Pod::Checker'=>'1.43','Pod::Find'=>'1.34','Pod::Functions'=>'1.03','Pod::Html'=>'1.0504','Pod::ParseUtils'=>'1.33','Pod::Parser'=>'1.32','Pod::Usage'=>'1.33','SDBM_File'=>'1.05','Safe'=>'2.12','Scalar::Util'=>'1.18','Socket'=>'1.78','Storable'=>'2.15','Switch'=>'2.10_01','Sys::Syslog'=>'0.13','Term::ANSIColor'=>'1.10','Term::ReadLine'=>'1.02','Test::Builder'=>'0.32','Test::Builder::Module'=>'0.02','Test::Builder::Tester'=>'1.02','Test::Builder::Tester::Color'=>undef,'Test::Harness'=>'2.56','Test::Harness::Straps'=>'0.26','Test::More'=>'0.62','Test::Simple'=>'0.62','Text::Tabs'=>'2005.0824','Text::Wrap'=>'2005.082401','Tie::Hash'=>'1.02','Time::HiRes'=>'1.86','Unicode::Collate'=>'0.52','Unicode::UCD'=>'0.24','User::grent'=>'1.01','Win32'=>'0.2601','XS::APItest'=>'0.08','XS::Typemap'=>'0.02','XSLoader'=>'0.06','attrs'=>'1.02','autouse'=>'1.05','blib'=>'1.03','charnames'=>'1.05','diagnostics'=>'1.15','encoding'=>'2.02','if'=>'0.05','open'=>'1.05','ops'=>'1.01','overload'=>'1.04','re'=>'0.05','threads'=>'1.07','threads::shared'=>'0.94','utf8'=>'1.06','vmsish'=>'1.02','warnings'=>'1.05','warnings::register'=>'1.01',},removed=>{}},5.008009=>{delta_from=>5.008008,changed=>{'Attribute::Handlers'=>'0.78_03','AutoLoader'=>'5.67','AutoSplit'=>'1.06','B'=>'1.19','B::Asmdata'=>'1.02','B::Assembler'=>'0.08','B::C'=>'1.05','B::Concise'=>'0.76','B::Debug'=>'1.05','B::Deparse'=>'0.87','B::Lint'=>'1.11','B::Lint::Debug'=>undef,'B::Terse'=>'1.05','Benchmark'=>'1.1','CGI'=>'3.42','CGI::Carp'=>'1.30_01','CGI::Cookie'=>'1.29','CGI::Fast'=>'1.07','CGI::Util'=>'1.5_01','CPAN'=>'1.9301','CPAN::Debug'=>'5.5','CPAN::DeferedCode'=>'5.50','CPAN::Distroprefs'=>'6','CPAN::FirstTime'=>'5.5_01','CPAN::HandleConfig'=>'5.5','CPAN::Kwalify'=>'5.50','CPAN::Nox'=>'5.50','CPAN::Queue'=>'5.5','CPAN::Tarzip'=>'5.5','CPAN::Version'=>'5.5','Carp'=>'1.10','Carp::Heavy'=>'1.10','Cwd'=>'3.29','DBM_Filter'=>'0.02','DBM_Filter::compress'=>'0.02','DBM_Filter::encode'=>'0.02','DBM_Filter::int32'=>'0.02','DBM_Filter::null'=>'0.02','DBM_Filter::utf8'=>'0.02','DB_File'=>'1.817','Data::Dumper'=>'2.121_17','Devel::DProf'=>'20080331.00','Devel::InnerPackage'=>'0.3','Devel::PPPort'=>'3.14','Devel::Peek'=>'1.04','Digest'=>'1.15','Digest::MD5'=>'2.37','DirHandle'=>'1.02','DynaLoader'=>'1.09','Encode'=>'2.26','Encode::Alias'=>'2.10','Encode::Byte'=>'2.03','Encode::CJKConstants'=>'2.02','Encode::CN'=>'2.02','Encode::CN::HZ'=>'2.05','Encode::Config'=>'2.05','Encode::EBCDIC'=>'2.02','Encode::Encoder'=>'2.01','Encode::Encoding'=>'2.05','Encode::GSM0338'=>'2.01','Encode::Guess'=>'2.02','Encode::JP'=>'2.03','Encode::JP::H2Z'=>'2.02','Encode::JP::JIS7'=>'2.04','Encode::KR'=>'2.02','Encode::KR::2022_KR'=>'2.02','Encode::MIME::Header'=>'2.05','Encode::MIME::Header::ISO_2022_JP'=>'1.03','Encode::MIME::Name'=>'1.01','Encode::Symbol'=>'2.02','Encode::TW'=>'2.02','Encode::Unicode'=>'2.05','Encode::Unicode::UTF7'=>'2.04','English'=>'1.03','Errno'=>'1.10','Exporter'=>'5.63','Exporter::Heavy'=>'5.63','ExtUtils::Command'=>'1.15','ExtUtils::Command::MM'=>'6.48','ExtUtils::Constant'=>'0.21','ExtUtils::Constant::Base'=>'0.04','ExtUtils::Constant::ProxySubs'=>'0.06','ExtUtils::Constant::Utils'=>'0.02','ExtUtils::Constant::XS'=>'0.02','ExtUtils::Embed'=>'1.28','ExtUtils::Install'=>'1.50_01','ExtUtils::Installed'=>'1.43','ExtUtils::Liblist'=>'6.48','ExtUtils::Liblist::Kid'=>'6.48','ExtUtils::MM'=>'6.48','ExtUtils::MM_AIX'=>'6.48','ExtUtils::MM_Any'=>'6.48','ExtUtils::MM_BeOS'=>'6.48','ExtUtils::MM_Cygwin'=>'6.48','ExtUtils::MM_DOS'=>'6.48','ExtUtils::MM_Darwin'=>'6.48','ExtUtils::MM_MacOS'=>'6.48','ExtUtils::MM_NW5'=>'6.48','ExtUtils::MM_OS2'=>'6.48','ExtUtils::MM_QNX'=>'6.48','ExtUtils::MM_UWIN'=>'6.48','ExtUtils::MM_Unix'=>'6.48','ExtUtils::MM_VMS'=>'6.48','ExtUtils::MM_VOS'=>'6.48','ExtUtils::MM_Win32'=>'6.48','ExtUtils::MM_Win95'=>'6.48','ExtUtils::MY'=>'6.48','ExtUtils::MakeMaker'=>'6.48','ExtUtils::MakeMaker::Config'=>'6.48','ExtUtils::MakeMaker::bytes'=>'6.48','ExtUtils::MakeMaker::vmsish'=>'6.48','ExtUtils::Manifest'=>'1.55','ExtUtils::Mkbootstrap'=>'6.48','ExtUtils::Mksymlists'=>'6.48','ExtUtils::Packlist'=>'1.43','ExtUtils::ParseXS'=>'2.19','ExtUtils::XSSymSet'=>'1.1','ExtUtils::testlib'=>'6.48','Fatal'=>'1.06','Fcntl'=>'1.06','File::Basename'=>'2.77','File::CheckTree'=>'4.4','File::Compare'=>'1.1005','File::Copy'=>'2.13','File::DosGlob'=>'1.01','File::Find'=>'1.13','File::Glob'=>'1.06','File::Path'=>'2.07_02','File::Spec'=>'3.29','File::Spec::Cygwin'=>'3.29','File::Spec::Epoc'=>'3.29','File::Spec::Functions'=>'3.29','File::Spec::Mac'=>'3.29','File::Spec::OS2'=>'3.29','File::Spec::Unix'=>'3.29','File::Spec::VMS'=>'3.29','File::Spec::Win32'=>'3.29','File::Temp'=>'0.20','File::stat'=>'1.01','FileCache'=>'1.07','Filter::Simple'=>'0.83','Filter::Util::Call'=>'1.07','FindBin'=>'1.49','GDBM_File'=>'1.09','Getopt::Long'=>'2.37','Getopt::Std'=>'1.06','Hash::Util'=>'0.06','IO'=>'1.23','IO::Dir'=>'1.06','IO::File'=>'1.14','IO::Handle'=>'1.27','IO::Socket'=>'1.30','IO::Socket::INET'=>'1.31','IO::Socket::UNIX'=>'1.23','IPC::Msg'=>'2.00','IPC::Open2'=>'1.03','IPC::Open3'=>'1.03','IPC::Semaphore'=>'2.00','IPC::SharedMem'=>'2.00','IPC::SysV'=>'2.00','List::Util'=>'1.19','Locale::Maketext'=>'1.13','Locale::Maketext::Guts'=>'1.13','Locale::Maketext::GutsLoader'=>'1.13','Math::BigFloat'=>'1.60','Math::BigInt'=>'1.89','Math::BigInt::Calc'=>'0.52','Math::BigRat'=>'0.22','Math::Complex'=>'1.54','Math::Trig'=>'1.18','Module::CoreList'=>'2.17','Module::Pluggable'=>'3.8','Module::Pluggable::Object'=>'3.6','NDBM_File'=>'1.07','NEXT'=>'0.61','Net::Cmd'=>'2.29','Net::Config'=>'1.11','Net::Domain'=>'2.20','Net::FTP'=>'2.77','Net::FTP::A'=>'1.18','Net::NNTP'=>'2.24','Net::POP3'=>'2.29','Net::Ping'=>'2.35','Net::SMTP'=>'2.31','O'=>'1.01','ODBM_File'=>'1.07','OS2::DLL'=>'1.03','OS2::Process'=>'1.03','Opcode'=>'1.0601','POSIX'=>'1.15','PerlIO'=>'1.05','PerlIO::encoding'=>'0.11','PerlIO::scalar'=>'0.06','PerlIO::via'=>'0.05','Pod::Html'=>'1.09','Pod::ParseUtils'=>'1.35','Pod::Parser'=>'1.35','Pod::Select'=>'1.35','Pod::Usage'=>'1.35','SDBM_File'=>'1.06','Safe'=>'2.16','Scalar::Util'=>'1.19','SelfLoader'=>'1.17','Shell'=>'0.72','Socket'=>'1.81','Storable'=>'2.19','Switch'=>'2.13','Sys::Syslog'=>'0.27','Sys::Syslog::win32::Win32'=>undef,'Term::ANSIColor'=>'1.12','Term::Cap'=>'1.12','Term::ReadLine'=>'1.03','Test::Builder'=>'0.80','Test::Builder::Module'=>'0.80','Test::Builder::Tester'=>'1.13','Test::Harness'=>'2.64','Test::Harness::Results'=>'0.01_01','Test::Harness::Straps'=>'0.26_01','Test::Harness::Util'=>'0.01','Test::More'=>'0.80','Test::Simple'=>'0.80','Text::Balanced'=>'1.98','Text::ParseWords'=>'3.27','Text::Soundex'=>'3.03','Text::Tabs'=>'2007.1117','Text::Wrap'=>'2006.1117','Thread'=>'2.01','Thread::Queue'=>'2.11','Thread::Semaphore'=>'2.09','Tie::Handle'=>'4.2','Tie::Hash'=>'1.03','Tie::Memoize'=>'1.1','Tie::RefHash'=>'1.38','Tie::Scalar'=>'1.01','Tie::StdHandle'=>'4.2','Time::HiRes'=>'1.9715','Time::Local'=>'1.1901','Time::gmtime'=>'1.03','Unicode'=>'5.1.0','Unicode::Normalize'=>'1.02','Unicode::UCD'=>'0.25','VMS::DCLsym'=>'1.03','VMS::Stdio'=>'2.4','Win32'=>'0.38','Win32API::File'=>'0.1001_01','Win32API::File::ExtUtils::Myconst2perl'=>'1','Win32CORE'=>'0.02','XS::APItest'=>'0.15','XS::Typemap'=>'0.03','XSLoader'=>'0.10','attributes'=>'0.09','autouse'=>'1.06','base'=>'2.13','bigint'=>'0.23','bignum'=>'0.23','bigrat'=>'0.23','blib'=>'1.04','charnames'=>'1.06','constant'=>'1.17','diagnostics'=>'1.16','encoding'=>'2.6_01','fields'=>'2.12','filetest'=>'1.02','lib'=>'0.61','open'=>'1.06','ops'=>'1.02','overload'=>'1.06','re'=>'0.0601','sigtrap'=>'1.04','threads'=>'1.71','threads::shared'=>'1.27','utf8'=>'1.07','warnings'=>'1.05_01',},removed=>{}},5.009=>{delta_from=>5.008002,changed=>{'B'=>'1.03','B::C'=>'1.03','B::Concise'=>'0.57','B::Deparse'=>'0.65','DB_File'=>'1.806','Devel::PPPort'=>'2.008','English'=>'1.02','Fatal'=>'1.04','OS2::DLL'=>'1.02','Opcode'=>'1.06','Time::HiRes'=>'1.51','Unicode::Collate'=>'0.28','Unicode::Normalize'=>'0.23','XSLoader'=>'0.03','assertions'=>'0.01','assertions::activate'=>'0.01','overload'=>'1.02','version'=>'0.29',},removed=>{}},5.009001=>{delta_from=>5.008004,changed=>{'B'=>'1.05','B::Assembler'=>'0.06','B::C'=>'1.04','B::Concise'=>'0.59','B::Debug'=>'1.02','B::Deparse'=>'0.65','DB_File'=>'1.808_01','Devel::PPPort'=>'2.011_01','Digest'=>'1.05','DynaLoader'=>'1.04','English'=>'1.02','Exporter::Heavy'=>'5.567','ExtUtils::Command'=>'1.07','ExtUtils::Liblist::Kid'=>'1.3','ExtUtils::MM_Any'=>'0.0901','ExtUtils::MM_Cygwin'=>'1.07','ExtUtils::MM_NW5'=>'2.07_01','ExtUtils::MM_Unix'=>'1.45_01','ExtUtils::MM_VMS'=>'5.71_01','ExtUtils::MM_Win32'=>'1.10_01','ExtUtils::MM_Win95'=>'0.03','ExtUtils::MakeMaker'=>'6.21_02','ExtUtils::Manifest'=>'1.43','Fatal'=>'1.04','Getopt::Long'=>'2.3401','IO::Handle'=>'1.23','IO::Pipe'=>'1.122','IPC::Open3'=>'1.0105','MIME::Base64'=>'3.00_01','MIME::QuotedPrint'=>'3.00','Memoize'=>'1.01_01','ODBM_File'=>'1.04','Opcode'=>'1.06','POSIX'=>'1.07','Storable'=>'2.11','Time::HiRes'=>'1.56','Time::Local'=>'1.07_94','UNIVERSAL'=>'1.02','Unicode'=>'4.0.0','Unicode::UCD'=>'0.21','XSLoader'=>'0.03','assertions'=>'0.01','assertions::activate'=>'0.01','base'=>'2.04','if'=>'0.0401','open'=>'1.02','overload'=>'1.02','threads'=>'1.02','utf8'=>'1.02','version'=>'0.36',},removed=>{}},5.009002=>{delta_from=>5.008007,changed=>{'B'=>'1.07','B::Concise'=>'0.64','B::Deparse'=>'0.69','B::Disassembler'=>'1.03','B::Terse'=>'1.02','CGI'=>'3.07','Config::Extensions'=>'0.01','Devel::DProf'=>'20030813.00','DynaLoader'=>'1.07','Encode'=>'2.09','Encode::Alias'=>'2.02','English'=>'1.03','Exporter'=>'5.59','Exporter::Heavy'=>'5.59','ExtUtils::Command'=>'1.07','ExtUtils::Command::MM'=>'0.03_01','ExtUtils::Embed'=>'1.26','ExtUtils::Liblist::Kid'=>'1.3','ExtUtils::MM_Any'=>'0.10','ExtUtils::MM_Cygwin'=>'1.07','ExtUtils::MM_MacOS'=>'1.08','ExtUtils::MM_NW5'=>'2.07','ExtUtils::MM_Unix'=>'1.46_01','ExtUtils::MM_VMS'=>'5.71','ExtUtils::MM_Win32'=>'1.10','ExtUtils::MM_Win95'=>'0.03','ExtUtils::MakeMaker'=>'6.25','ExtUtils::Manifest'=>'1.44','Fatal'=>'1.04','File::Path'=>'1.06','FileCache'=>'1.04_01','Getopt::Long'=>'2.3401','IO::File'=>'1.10','IO::Socket::INET'=>'1.27','Math::BigFloat'=>'1.49','Math::BigInt'=>'1.75','Math::BigInt::Calc'=>'0.45','Math::BigRat'=>'0.14','Memoize'=>'1.01_01','Module::CoreList'=>'1.99','NEXT'=>'0.60_01','Opcode'=>'1.06','Pod::Html'=>'1.0502','Scalar::Util'=>'1.14_1','Storable'=>'2.14','Symbol'=>'1.05','Test::Harness'=>'2.46','Test::Harness::Straps'=>'0.20_01','Text::Balanced'=>'1.95_01','Text::Wrap'=>'2001.09292','UNIVERSAL'=>'1.02','Unicode'=>'4.0.1','Unicode::Normalize'=>'0.30','Unicode::UCD'=>'0.22','Win32'=>'0.23','XS::APItest'=>'0.05','XSLoader'=>'0.03','assertions'=>'0.01','assertions::activate'=>'0.01','base'=>'2.06','bigint'=>'0.06','bignum'=>'0.16','bigrat'=>'0.07','bytes'=>'1.01','encoding::warnings'=>'0.05','if'=>'0.0401','re'=>'0.05','threads::shared'=>'0.92','utf8'=>'1.04','version'=>'0.42','warnings'=>'1.04',},removed=>{'Test::Harness::Point'=>1,}},5.009003=>{delta_from=>5.008008,changed=>{'Archive::Tar'=>'1.26_01','Archive::Tar::Constant'=>'0.02','Archive::Tar::File'=>'0.02','AutoSplit'=>'1.04_01','B'=>'1.10','B::Bblock'=>'1.02','B::Bytecode'=>'1.01','B::C'=>'1.04','B::CC'=>'1.00','B::Concise'=>'0.67','B::Debug'=>'1.02','B::Deparse'=>'0.73','B::Lint'=>'1.04','B::Terse'=>'1.03','CGI'=>'3.15_01','CPAN'=>'1.83_58','CPAN::Debug'=>'4.44','CPAN::FirstTime'=>'4.50','CPAN::HandleConfig'=>'4.31','CPAN::Nox'=>'2.31','CPAN::Tarzip'=>'3.36','CPAN::Version'=>'2.55','Carp'=>'1.05','Carp::Heavy'=>'1.05','Compress::Zlib'=>'2.000_07','Compress::Zlib::Common'=>'2.000_07','Compress::Zlib::Compress::Gzip::Constants'=>'2.000_07','Compress::Zlib::Compress::Zip::Constants'=>'1.00','Compress::Zlib::CompressPlugin::Deflate'=>'2.000_05','Compress::Zlib::CompressPlugin::Identity'=>'2.000_05','Compress::Zlib::File::GlobMapper'=>'0.000_02','Compress::Zlib::FileConstants'=>'2.000_07','Compress::Zlib::IO::Compress::Base'=>'2.000_05','Compress::Zlib::IO::Compress::Deflate'=>'2.000_07','Compress::Zlib::IO::Compress::Gzip'=>'2.000_07','Compress::Zlib::IO::Compress::RawDeflate'=>'2.000_07','Compress::Zlib::IO::Compress::Zip'=>'2.000_04','Compress::Zlib::IO::Uncompress::AnyInflate'=>'2.000_07','Compress::Zlib::IO::Uncompress::AnyUncompress'=>'2.000_05','Compress::Zlib::IO::Uncompress::Base'=>'2.000_05','Compress::Zlib::IO::Uncompress::Gunzip'=>'2.000_07','Compress::Zlib::IO::Uncompress::Inflate'=>'2.000_07','Compress::Zlib::IO::Uncompress::RawInflate'=>'2.000_07','Compress::Zlib::IO::Uncompress::Unzip'=>'2.000_05','Compress::Zlib::ParseParameters'=>'2.000_07','Compress::Zlib::UncompressPlugin::Identity'=>'2.000_05','Compress::Zlib::UncompressPlugin::Inflate'=>'2.000_05','Config::Extensions'=>'0.01','Cwd'=>'3.15','Devel::PPPort'=>'3.08','Digest::SHA'=>'5.32','DirHandle'=>'1.01','DynaLoader'=>'1.07','Encode'=>'2.14','Encode::CN::HZ'=>'2.02','Encode::MIME::Header'=>'2.02','English'=>'1.04','Exporter'=>'5.59','Exporter::Heavy'=>'5.59','ExtUtils::CBuilder'=>'0.15','ExtUtils::CBuilder::Base'=>'0.12','ExtUtils::CBuilder::Platform::Unix'=>'0.12','ExtUtils::CBuilder::Platform::VMS'=>'0.12','ExtUtils::CBuilder::Platform::Windows'=>'0.12','ExtUtils::CBuilder::Platform::aix'=>'0.12','ExtUtils::CBuilder::Platform::cygwin'=>'0.12','ExtUtils::CBuilder::Platform::darwin'=>'0.12','ExtUtils::CBuilder::Platform::dec_osf'=>'0.01','ExtUtils::CBuilder::Platform::os2'=>'0.13','ExtUtils::Command::MM'=>'0.05_01','ExtUtils::Constant'=>'0.2','ExtUtils::Constant::Base'=>'0.02','ExtUtils::Constant::ProxySubs'=>'0.01','ExtUtils::Constant::XS'=>'0.02','ExtUtils::MM_Any'=>'0.13_01','ExtUtils::MM_Unix'=>'1.50_01','ExtUtils::MakeMaker'=>'6.30_01','ExtUtils::ParseXS'=>'2.15_02','Fatal'=>'1.04','File::Compare'=>'1.1005','File::Spec'=>'3.15','File::Temp'=>'0.16_01','IO::File'=>'1.13_01','IO::Handle'=>'1.26','IO::Socket'=>'1.29_01','IO::Socket::INET'=>'1.29_02','IO::Socket::UNIX'=>'1.22_01','IO::Zlib'=>'1.04_02','Locale::Maketext'=>'1.10_01','Math::BigInt::FastCalc'=>'0.10','Memoize'=>'1.01_01','Module::CoreList'=>'2.02','Moped::Msg'=>'0.01','NEXT'=>'0.60_01','Net::Cmd'=>'2.26_01','Net::Domain'=>'2.19_01','Net::Ping'=>'2.31_04','Opcode'=>'1.08','POSIX'=>'1.10','Pod::Escapes'=>'1.04','Pod::Man'=>'2.04','Pod::Perldoc'=>'3.14_01','Pod::Simple'=>'3.04','Pod::Simple::BlackBox'=>undef,'Pod::Simple::Checker'=>'2.02','Pod::Simple::Debug'=>undef,'Pod::Simple::DumpAsText'=>'2.02','Pod::Simple::DumpAsXML'=>'2.02','Pod::Simple::HTML'=>'3.03','Pod::Simple::HTMLBatch'=>'3.02','Pod::Simple::HTMLLegacy'=>'5.01','Pod::Simple::LinkSection'=>undef,'Pod::Simple::Methody'=>'2.02','Pod::Simple::Progress'=>'1.01','Pod::Simple::PullParser'=>'2.02','Pod::Simple::PullParserEndToken'=>undef,'Pod::Simple::PullParserStartToken'=>undef,'Pod::Simple::PullParserTextToken'=>undef,'Pod::Simple::PullParserToken'=>'2.02','Pod::Simple::RTF'=>'2.02','Pod::Simple::Search'=>'3.04','Pod::Simple::SimpleTree'=>'2.02','Pod::Simple::Text'=>'2.02','Pod::Simple::TextContent'=>'2.02','Pod::Simple::TiedOutFH'=>undef,'Pod::Simple::Transcode'=>undef,'Pod::Simple::TranscodeDumb'=>'2.02','Pod::Simple::TranscodeSmart'=>undef,'Pod::Simple::XMLOutStream'=>'2.02','Pod::Text'=>'3.01','Pod::Text::Color'=>'2.01','Pod::Text::Overstrike'=>'2','Pod::Text::Termcap'=>'2.01','Pod::Usage'=>'1.33_01','SelfLoader'=>'1.0905','Storable'=>'2.15_02','Test::Builder::Module'=>'0.03','Text::Balanced'=>'1.95_01','Tie::File'=>'0.97_01','UNIVERSAL'=>'1.03','XS::APItest'=>'0.09','assertions'=>'0.02','assertions::activate'=>'0.02','assertions::compat'=>undef,'constant'=>'1.07','encoding::warnings'=>'0.05','feature'=>'1.00','re'=>'0.06','sort'=>'2.00','version'=>'0.53',},removed=>{}},5.009004=>{delta_from=>5.009003,changed=>{'Archive::Tar'=>'1.30_01','AutoLoader'=>'5.61','B'=>'1.11','B::Bytecode'=>'1.02','B::C'=>'1.05','B::Concise'=>'0.69','B::Deparse'=>'0.76','B::Lint'=>'1.08','Benchmark'=>'1.08','CGI'=>'3.20','CGI::Cookie'=>'1.27','CGI::Fast'=>'1.07','CPAN'=>'1.87_55','CPAN::Debug'=>'5.400561','CPAN::FirstTime'=>'5.400742','CPAN::HandleConfig'=>'5.400740','CPAN::Nox'=>'5.400561','CPAN::Tarzip'=>'5.400714','CPAN::Version'=>'5.400561','Compress::Raw::Zlib'=>'2.000_13','Compress::Zlib'=>'2.000_13','Cwd'=>'3.19','Devel::PPPort'=>'3.10','Digest'=>'1.15','Digest::SHA'=>'5.43','Encode'=>'2.18_01','Encode::Alias'=>'2.06','Encode::Byte'=>'2.02','Encode::CJKConstants'=>'2.02','Encode::CN'=>'2.02','Encode::CN::HZ'=>'2.04','Encode::Config'=>'2.03','Encode::EBCDIC'=>'2.02','Encode::Encoder'=>'2.01','Encode::Encoding'=>'2.04','Encode::Guess'=>'2.02','Encode::JP'=>'2.03','Encode::JP::H2Z'=>'2.02','Encode::JP::JIS7'=>'2.02','Encode::KR'=>'2.02','Encode::KR::2022_KR'=>'2.02','Encode::MIME::Header'=>'2.04','Encode::MIME::Header::ISO_2022_JP'=>'1.03','Encode::Symbol'=>'2.02','Encode::TW'=>'2.02','Encode::Unicode'=>'2.03','Encode::Unicode::UTF7'=>'2.04','ExtUtils::CBuilder'=>'0.18','ExtUtils::CBuilder::Platform::Windows'=>'0.12_01','ExtUtils::Constant::Base'=>'0.03','ExtUtils::Constant::ProxySubs'=>'0.03','ExtUtils::Install'=>'1.41','ExtUtils::Installed'=>'1.41','ExtUtils::MM_Any'=>'0.13_02','ExtUtils::MM_NW5'=>'2.08_01','ExtUtils::MM_Unix'=>'1.5003','ExtUtils::MM_VMS'=>'5.73_03','ExtUtils::MM_Win32'=>'1.12_02','ExtUtils::MM_Win95'=>'0.04_01','ExtUtils::MakeMaker'=>'6.30_02','ExtUtils::Manifest'=>'1.46_01','ExtUtils::Mkbootstrap'=>'1.15_01','ExtUtils::Mksymlists'=>'1.19_01','ExtUtils::Packlist'=>'1.41','File::Basename'=>'2.75','File::Find'=>'1.11','File::GlobMapper'=>'0.000_02','File::Spec'=>'3.19','FileCache'=>'1.07','Getopt::Long'=>'2.3501','Hash::Util'=>'0.07','Hash::Util::FieldHash'=>'0.01','IO'=>'1.23_01','IO::Compress::Adapter::Deflate'=>'2.000_13','IO::Compress::Adapter::Identity'=>'2.000_13','IO::Compress::Base'=>'2.000_13','IO::Compress::Base::Common'=>'2.000_13','IO::Compress::Deflate'=>'2.000_13','IO::Compress::Gzip'=>'2.000_13','IO::Compress::Gzip::Constants'=>'2.000_13','IO::Compress::RawDeflate'=>'2.000_13','IO::Compress::Zip'=>'2.000_13','IO::Compress::Zip::Constants'=>'2.000_13','IO::Compress::Zlib::Constants'=>'2.000_13','IO::Compress::Zlib::Extra'=>'2.000_13','IO::Dir'=>'1.06','IO::File'=>'1.14','IO::Handle'=>'1.27','IO::Socket'=>'1.30_01','IO::Socket::INET'=>'1.31','IO::Socket::UNIX'=>'1.23','IO::Uncompress::Adapter::Identity'=>'2.000_13','IO::Uncompress::Adapter::Inflate'=>'2.000_13','IO::Uncompress::AnyInflate'=>'2.000_13','IO::Uncompress::AnyUncompress'=>'2.000_13','IO::Uncompress::Base'=>'2.000_13','IO::Uncompress::Gunzip'=>'2.000_13','IO::Uncompress::Inflate'=>'2.000_13','IO::Uncompress::RawInflate'=>'2.000_13','IO::Uncompress::Unzip'=>'2.000_13','MIME::Base64'=>'3.07_01','Math::Complex'=>'1.36','Math::Trig'=>'1.04','Module::Build'=>'0.2805','Module::Build::Base'=>undef,'Module::Build::Compat'=>'0.03','Module::Build::ConfigData'=>undef,'Module::Build::Cookbook'=>undef,'Module::Build::ModuleInfo'=>undef,'Module::Build::Notes'=>undef,'Module::Build::PPMMaker'=>undef,'Module::Build::Platform::Amiga'=>undef,'Module::Build::Platform::Default'=>undef,'Module::Build::Platform::EBCDIC'=>undef,'Module::Build::Platform::MPEiX'=>undef,'Module::Build::Platform::MacOS'=>undef,'Module::Build::Platform::RiscOS'=>undef,'Module::Build::Platform::Unix'=>undef,'Module::Build::Platform::VMS'=>undef,'Module::Build::Platform::VOS'=>undef,'Module::Build::Platform::Windows'=>undef,'Module::Build::Platform::aix'=>undef,'Module::Build::Platform::cygwin'=>undef,'Module::Build::Platform::darwin'=>undef,'Module::Build::Platform::os2'=>undef,'Module::Build::PodParser'=>undef,'Module::Build::Version'=>'0','Module::Build::YAML'=>'0.50','Module::CoreList'=>'2.08','Module::Load'=>'0.10','Module::Loaded'=>'0.01','Package::Constants'=>'0.01','Pod::Html'=>'1.07','Pod::Man'=>'2.09','Pod::Text'=>'3.07','Pod::Text::Color'=>'2.03','Pod::Text::Termcap'=>'2.03','SDBM_File'=>'1.06','Shell'=>'0.7','Sys::Syslog'=>'0.17','Term::ANSIColor'=>'1.11','Test::Builder'=>'0.33','Test::Builder::Tester'=>'1.04','Test::Harness'=>'2.62','Test::Harness::Util'=>'0.01','Test::More'=>'0.64','Test::Simple'=>'0.64','Text::Balanced'=>'1.98_01','Text::ParseWords'=>'3.25','Text::Tabs'=>'2007.071101','Text::Wrap'=>'2006.0711','Tie::RefHash'=>'1.34_01','Time::HiRes'=>'1.87','Time::Local'=>'1.13','Time::gmtime'=>'1.03','UNIVERSAL'=>'1.04','Unicode::Normalize'=>'1.01','Win32API::File'=>'0.1001','Win32API::File::ExtUtils::Myconst2perl'=>'1','assertions'=>'0.03','assertions::compat'=>'0.02','autouse'=>'1.06','diagnostics'=>'1.16','encoding'=>'2.04','encoding::warnings'=>'0.10','feature'=>'1.01','re'=>'0.0601','threads'=>'1.38','threads::shared'=>'0.94_01','version'=>'0.67',},removed=>{'Compress::Zlib::Common'=>1,'Compress::Zlib::Compress::Gzip::Constants'=>1,'Compress::Zlib::Compress::Zip::Constants'=>1,'Compress::Zlib::CompressPlugin::Deflate'=>1,'Compress::Zlib::CompressPlugin::Identity'=>1,'Compress::Zlib::File::GlobMapper'=>1,'Compress::Zlib::FileConstants'=>1,'Compress::Zlib::IO::Compress::Base'=>1,'Compress::Zlib::IO::Compress::Deflate'=>1,'Compress::Zlib::IO::Compress::Gzip'=>1,'Compress::Zlib::IO::Compress::RawDeflate'=>1,'Compress::Zlib::IO::Compress::Zip'=>1,'Compress::Zlib::IO::Uncompress::AnyInflate'=>1,'Compress::Zlib::IO::Uncompress::AnyUncompress'=>1,'Compress::Zlib::IO::Uncompress::Base'=>1,'Compress::Zlib::IO::Uncompress::Gunzip'=>1,'Compress::Zlib::IO::Uncompress::Inflate'=>1,'Compress::Zlib::IO::Uncompress::RawInflate'=>1,'Compress::Zlib::IO::Uncompress::Unzip'=>1,'Compress::Zlib::ParseParameters'=>1,'Compress::Zlib::UncompressPlugin::Identity'=>1,'Compress::Zlib::UncompressPlugin::Inflate'=>1,}},5.009005=>{delta_from=>5.009004,changed=>{'Archive::Extract'=>'0.22_01','Archive::Tar'=>'1.32','Attribute::Handlers'=>'0.78_06','AutoLoader'=>'5.63','AutoSplit'=>'1.05','B'=>'1.16','B::Concise'=>'0.72','B::Debug'=>'1.05','B::Deparse'=>'0.82','B::Lint'=>'1.09','B::Terse'=>'1.05','Benchmark'=>'1.1','CGI'=>'3.29','CGI::Cookie'=>'1.28','CGI::Util'=>'1.5_01','CPAN'=>'1.9102','CPAN::Debug'=>'5.400955','CPAN::FirstTime'=>'5.401669','CPAN::HandleConfig'=>'5.401744','CPAN::Kwalify'=>'5.401418','CPAN::Nox'=>'5.400844','CPAN::Queue'=>'5.401704','CPAN::Tarzip'=>'5.401717','CPAN::Version'=>'5.401387','CPANPLUS'=>'0.81_01','CPANPLUS::Backend'=>undef,'CPANPLUS::Backend::RV'=>undef,'CPANPLUS::Config'=>undef,'CPANPLUS::Configure'=>undef,'CPANPLUS::Configure::Setup'=>undef,'CPANPLUS::Dist'=>undef,'CPANPLUS::Dist::Base'=>'0.01','CPANPLUS::Dist::Build'=>'0.06_01','CPANPLUS::Dist::Build::Constants'=>'0.01','CPANPLUS::Dist::MM'=>undef,'CPANPLUS::Dist::Sample'=>undef,'CPANPLUS::Error'=>undef,'CPANPLUS::Internals'=>'0.81_01','CPANPLUS::Internals::Constants'=>'0.01','CPANPLUS::Internals::Constants::Report'=>'0.01','CPANPLUS::Internals::Extract'=>undef,'CPANPLUS::Internals::Fetch'=>undef,'CPANPLUS::Internals::Report'=>undef,'CPANPLUS::Internals::Search'=>undef,'CPANPLUS::Internals::Source'=>undef,'CPANPLUS::Internals::Utils'=>undef,'CPANPLUS::Internals::Utils::Autoflush'=>undef,'CPANPLUS::Module'=>undef,'CPANPLUS::Module::Author'=>undef,'CPANPLUS::Module::Author::Fake'=>undef,'CPANPLUS::Module::Checksums'=>undef,'CPANPLUS::Module::Fake'=>undef,'CPANPLUS::Module::Signature'=>undef,'CPANPLUS::Selfupdate'=>undef,'CPANPLUS::Shell'=>undef,'CPANPLUS::Shell::Classic'=>'0.0562','CPANPLUS::Shell::Default'=>'0.81_01','CPANPLUS::Shell::Default::Plugins::Remote'=>undef,'CPANPLUS::Shell::Default::Plugins::Source'=>undef,'CPANPLUS::inc'=>undef,'Carp'=>'1.07','Carp::Heavy'=>'1.07','Compress::Raw::Zlib'=>'2.005','Compress::Zlib'=>'2.005','Cwd'=>'3.25','DBM_Filter'=>'0.02','DB_File'=>'1.815','Data::Dumper'=>'2.121_13','Devel::InnerPackage'=>'0.3','Devel::PPPort'=>'3.11_01','Digest::MD5'=>'2.36_01','Digest::SHA'=>'5.44','DynaLoader'=>'1.08','Encode'=>'2.23','Encode::Alias'=>'2.07','Encode::Byte'=>'2.03','Encode::Config'=>'2.04','Encode::Encoding'=>'2.05','Encode::GSM0338'=>'2.00','Encode::JP::JIS7'=>'2.03','Encode::MIME::Header'=>'2.05','Encode::MIME::Name'=>'1.01','Encode::Unicode'=>'2.05','Errno'=>'1.10','Exporter'=>'5.60','Exporter::Heavy'=>'5.60','ExtUtils::CBuilder'=>'0.19','ExtUtils::CBuilder::Platform::Windows'=>'0.13','ExtUtils::Command'=>'1.13','ExtUtils::Command::MM'=>'0.07','ExtUtils::Constant::Base'=>'0.04','ExtUtils::Install'=>'1.41_01','ExtUtils::Liblist'=>'1.03','ExtUtils::Liblist::Kid'=>'1.33','ExtUtils::MM'=>'0.07','ExtUtils::MM_AIX'=>'0.05','ExtUtils::MM_Any'=>'0.15','ExtUtils::MM_BeOS'=>'1.07','ExtUtils::MM_Cygwin'=>'1.1','ExtUtils::MM_DOS'=>'0.04','ExtUtils::MM_MacOS'=>'1.1','ExtUtils::MM_NW5'=>'2.1','ExtUtils::MM_OS2'=>'1.07','ExtUtils::MM_QNX'=>'0.04','ExtUtils::MM_UWIN'=>'0.04','ExtUtils::MM_Unix'=>'1.54_01','ExtUtils::MM_VMS'=>'5.76','ExtUtils::MM_VOS'=>'0.04','ExtUtils::MM_Win32'=>'1.15','ExtUtils::MM_Win95'=>'0.06','ExtUtils::MY'=>'0.03','ExtUtils::MakeMaker'=>'6.36','ExtUtils::MakeMaker::Config'=>'0.04','ExtUtils::MakeMaker::bytes'=>'0.03','ExtUtils::MakeMaker::vmsish'=>'0.03','ExtUtils::Manifest'=>'1.51_01','ExtUtils::Mkbootstrap'=>'1.17','ExtUtils::Mksymlists'=>'1.21','ExtUtils::ParseXS'=>'2.18','ExtUtils::XSSymSet'=>'1.1','ExtUtils::testlib'=>'1.17','Fatal'=>'1.05','Fcntl'=>'1.06','File::Basename'=>'2.76','File::Copy'=>'2.10','File::Fetch'=>'0.10','File::Glob'=>'1.06','File::Path'=>'2.01','File::Spec'=>'3.25','File::Spec::Cygwin'=>'1.1_01','File::Spec::VMS'=>'1.4_01','File::Temp'=>'0.18','Filter::Util::Call'=>'1.0602','FindBin'=>'1.49','Getopt::Long'=>'2.36','Hash::Util::FieldHash'=>'1.01','IO::Compress::Adapter::Deflate'=>'2.005','IO::Compress::Adapter::Identity'=>'2.005','IO::Compress::Base'=>'2.005','IO::Compress::Base::Common'=>'2.005','IO::Compress::Deflate'=>'2.005','IO::Compress::Gzip'=>'2.005','IO::Compress::Gzip::Constants'=>'2.005','IO::Compress::RawDeflate'=>'2.005','IO::Compress::Zip'=>'2.005','IO::Compress::Zip::Constants'=>'2.005','IO::Compress::Zlib::Constants'=>'2.005','IO::Compress::Zlib::Extra'=>'2.005','IO::Uncompress::Adapter::Identity'=>'2.005','IO::Uncompress::Adapter::Inflate'=>'2.005','IO::Uncompress::AnyInflate'=>'2.005','IO::Uncompress::AnyUncompress'=>'2.005','IO::Uncompress::Base'=>'2.005','IO::Uncompress::Gunzip'=>'2.005','IO::Uncompress::Inflate'=>'2.005','IO::Uncompress::RawInflate'=>'2.005','IO::Uncompress::Unzip'=>'2.005','IO::Zlib'=>'1.05_01','IPC::Cmd'=>'0.36_01','List::Util'=>'1.19','Locale::Maketext::Simple'=>'0.18','Log::Message'=>'0.01','Log::Message::Config'=>'0.01','Log::Message::Handlers'=>undef,'Log::Message::Item'=>undef,'Log::Message::Simple'=>'0.0201','Math::BigFloat'=>'1.58','Math::BigInt'=>'1.87','Math::BigInt::Calc'=>'0.51','Math::BigInt::FastCalc'=>'0.15_01','Math::BigRat'=>'0.19','Math::Complex'=>'1.37','Memoize'=>'1.01_02','Module::Build'=>'0.2808','Module::Build::Config'=>undef,'Module::Build::Version'=>'0.7203','Module::CoreList'=>'2.12','Module::Load::Conditional'=>'0.16','Module::Pluggable'=>'3.6','Module::Pluggable::Object'=>'3.6','NDBM_File'=>'1.07','Net::Cmd'=>'2.28','Net::Config'=>'1.11','Net::Domain'=>'2.20','Net::FTP'=>'2.77','Net::FTP::A'=>'1.18','Net::NNTP'=>'2.24','Net::POP3'=>'2.29','Net::SMTP'=>'2.31','ODBM_File'=>'1.07','OS2::DLL'=>'1.03','Object::Accessor'=>'0.32','Opcode'=>'1.09','POSIX'=>'1.13','Params::Check'=>'0.26','PerlIO::encoding'=>'0.10','PerlIO::scalar'=>'0.05','PerlIO::via'=>'0.04','Pod::Html'=>'1.08','Pod::Man'=>'2.12','Pod::ParseUtils'=>'1.35','Pod::Parser'=>'1.35','Pod::Select'=>'1.35','Pod::Simple'=>'3.05','Pod::Text'=>'3.08','Pod::Usage'=>'1.35','Scalar::Util'=>'1.19','SelfLoader'=>'1.11','Shell'=>'0.72_01','Socket'=>'1.79','Storable'=>'2.16','Switch'=>'2.13','Sys::Syslog'=>'0.18_01','Term::ANSIColor'=>'1.12','Term::UI'=>'0.14_01','Term::UI::History'=>undef,'Test::Builder'=>'0.70','Test::Builder::Module'=>'0.68','Test::Builder::Tester'=>'1.07','Test::Harness'=>'2.64','Test::Harness::Results'=>'0.01','Test::More'=>'0.70','Test::Simple'=>'0.70','Text::Balanced'=>'2.0.0','Text::Soundex'=>'3.02','Text::Tabs'=>'2007.1117','Text::Wrap'=>'2006.1117','Thread'=>'3.02','Tie::File'=>'0.97_02','Tie::Hash::NamedCapture'=>'0.06','Tie::Memoize'=>'1.1','Tie::RefHash'=>'1.37','Time::HiRes'=>'1.9707','Time::Local'=>'1.17','Time::Piece'=>'1.11_02','Time::Seconds'=>undef,'Unicode'=>'5.0.0','Unicode::Normalize'=>'1.02','Unicode::UCD'=>'0.25','VMS::DCLsym'=>'1.03','Win32'=>'0.30','Win32API::File'=>'0.1001_01','Win32CORE'=>'0.02','XS::APItest'=>'0.12','XSLoader'=>'0.08','attributes'=>'0.08','base'=>'2.12','bigint'=>'0.22','bignum'=>'0.22','bigrat'=>'0.22','bytes'=>'1.03','charnames'=>'1.06','constant'=>'1.10','diagnostics'=>'1.17','encoding'=>'2.06','encoding::warnings'=>'0.11','feature'=>'1.10','fields'=>'2.12','less'=>'0.02','mro'=>'1.00','overload'=>'1.06','re'=>'0.08','sigtrap'=>'1.04','sort'=>'2.01','strict'=>'1.04','threads'=>'1.63','threads::shared'=>'1.12','utf8'=>'1.07','version'=>'0.7203','warnings'=>'1.06',},removed=>{'B::Asmdata'=>1,'B::Assembler'=>1,'B::Bblock'=>1,'B::Bytecode'=>1,'B::C'=>1,'B::CC'=>1,'B::Disassembler'=>1,'B::Stackobj'=>1,'B::Stash'=>1,'ByteLoader'=>1,'Thread::Signal'=>1,'Thread::Specific'=>1,'assertions'=>1,'assertions::activate'=>1,'assertions::compat'=>1,}},5.01=>{delta_from=>5.009005,changed=>{'Archive::Extract'=>'0.24','Archive::Tar'=>'1.38','Attribute::Handlers'=>'0.79','B'=>'1.17','B::Concise'=>'0.74','B::Deparse'=>'0.83','CPAN'=>'1.9205','CPAN::API::HOWTO'=>undef,'CPAN::Debug'=>'5.402212','CPAN::DeferedCode'=>'5.50','CPAN::FirstTime'=>'5.402229','CPAN::HandleConfig'=>'5.402212','CPAN::Nox'=>'5.402411','CPAN::Queue'=>'5.402212','CPAN::Tarzip'=>'5.402213','CPAN::Version'=>'5.5','CPANPLUS'=>'0.84','CPANPLUS::Dist::Build'=>'0.06_02','CPANPLUS::Internals'=>'0.84','CPANPLUS::Shell::Default'=>'0.84','CPANPLUS::Shell::Default::Plugins::CustomSource'=>undef,'Carp'=>'1.08','Carp::Heavy'=>'1.08','Compress::Raw::Zlib'=>'2.008','Compress::Zlib'=>'2.008','Cwd'=>'3.2501','DB_File'=>'1.816_1','Data::Dumper'=>'2.121_14','Devel::PPPort'=>'3.13','Digest::SHA'=>'5.45','Exporter'=>'5.62','Exporter::Heavy'=>'5.62','ExtUtils::CBuilder'=>'0.21','ExtUtils::CBuilder::Base'=>'0.21','ExtUtils::CBuilder::Platform::Unix'=>'0.21','ExtUtils::CBuilder::Platform::VMS'=>'0.22','ExtUtils::CBuilder::Platform::Windows'=>'0.21','ExtUtils::CBuilder::Platform::aix'=>'0.21','ExtUtils::CBuilder::Platform::cygwin'=>'0.21','ExtUtils::CBuilder::Platform::darwin'=>'0.21','ExtUtils::CBuilder::Platform::dec_osf'=>'0.21','ExtUtils::CBuilder::Platform::os2'=>'0.21','ExtUtils::Command::MM'=>'6.42','ExtUtils::Constant::ProxySubs'=>'0.05','ExtUtils::Embed'=>'1.27','ExtUtils::Install'=>'1.44','ExtUtils::Installed'=>'1.43','ExtUtils::Liblist'=>'6.42','ExtUtils::Liblist::Kid'=>'6.42','ExtUtils::MM'=>'6.42','ExtUtils::MM_AIX'=>'6.42','ExtUtils::MM_Any'=>'6.42','ExtUtils::MM_BeOS'=>'6.42','ExtUtils::MM_Cygwin'=>'6.42','ExtUtils::MM_DOS'=>'6.42','ExtUtils::MM_MacOS'=>'6.42','ExtUtils::MM_NW5'=>'6.42','ExtUtils::MM_OS2'=>'6.42','ExtUtils::MM_QNX'=>'6.42','ExtUtils::MM_UWIN'=>'6.42','ExtUtils::MM_Unix'=>'6.42','ExtUtils::MM_VMS'=>'6.42','ExtUtils::MM_VOS'=>'6.42','ExtUtils::MM_Win32'=>'6.42','ExtUtils::MM_Win95'=>'6.42','ExtUtils::MY'=>'6.42','ExtUtils::MakeMaker'=>'6.42','ExtUtils::MakeMaker::Config'=>'6.42','ExtUtils::MakeMaker::bytes'=>'6.42','ExtUtils::MakeMaker::vmsish'=>'6.42','ExtUtils::Mkbootstrap'=>'6.42','ExtUtils::Mksymlists'=>'6.42','ExtUtils::Packlist'=>'1.43','ExtUtils::ParseXS'=>'2.18_02','ExtUtils::testlib'=>'6.42','File::Copy'=>'2.11','File::Fetch'=>'0.14','File::Find'=>'1.12','File::Path'=>'2.04','File::Spec'=>'3.2501','File::Spec::Cygwin'=>'3.2501','File::Spec::Epoc'=>'3.2501','File::Spec::Functions'=>'3.2501','File::Spec::Mac'=>'3.2501','File::Spec::OS2'=>'3.2501','File::Spec::Unix'=>'3.2501','File::Spec::VMS'=>'3.2501','File::Spec::Win32'=>'3.2501','Filter::Util::Call'=>'1.07','Getopt::Long'=>'2.37','Hash::Util::FieldHash'=>'1.03','IO::Compress::Adapter::Deflate'=>'2.008','IO::Compress::Adapter::Identity'=>'2.008','IO::Compress::Base'=>'2.008','IO::Compress::Base::Common'=>'2.008','IO::Compress::Deflate'=>'2.008','IO::Compress::Gzip'=>'2.008','IO::Compress::Gzip::Constants'=>'2.008','IO::Compress::RawDeflate'=>'2.008','IO::Compress::Zip'=>'2.008','IO::Compress::Zip::Constants'=>'2.008','IO::Compress::Zlib::Constants'=>'2.008','IO::Compress::Zlib::Extra'=>'2.008','IO::Uncompress::Adapter::Identity'=>'2.008','IO::Uncompress::Adapter::Inflate'=>'2.008','IO::Uncompress::AnyInflate'=>'2.008','IO::Uncompress::AnyUncompress'=>'2.008','IO::Uncompress::Base'=>'2.008','IO::Uncompress::Gunzip'=>'2.008','IO::Uncompress::Inflate'=>'2.008','IO::Uncompress::RawInflate'=>'2.008','IO::Uncompress::Unzip'=>'2.008','IO::Zlib'=>'1.07','IPC::Cmd'=>'0.40_1','IPC::SysV'=>'1.05','Locale::Maketext'=>'1.12','Log::Message::Simple'=>'0.04','Math::BigFloat'=>'1.59','Math::BigInt'=>'1.88','Math::BigInt::Calc'=>'0.52','Math::BigInt::FastCalc'=>'0.16','Math::BigRat'=>'0.21','Module::Build'=>'0.2808_01','Module::Build::Base'=>'0.2808_01','Module::Build::Compat'=>'0.2808_01','Module::Build::Config'=>'0.2808_01','Module::Build::Dumper'=>undef,'Module::Build::ModuleInfo'=>'0.2808_01','Module::Build::Notes'=>'0.2808_01','Module::Build::PPMMaker'=>'0.2808_01','Module::Build::Platform::Amiga'=>'0.2808_01','Module::Build::Platform::Default'=>'0.2808_01','Module::Build::Platform::EBCDIC'=>'0.2808_01','Module::Build::Platform::MPEiX'=>'0.2808_01','Module::Build::Platform::MacOS'=>'0.2808_01','Module::Build::Platform::RiscOS'=>'0.2808_01','Module::Build::Platform::Unix'=>'0.2808_01','Module::Build::Platform::VMS'=>'0.2808_01','Module::Build::Platform::VOS'=>'0.2808_01','Module::Build::Platform::Windows'=>'0.2808_01','Module::Build::Platform::aix'=>'0.2808_01','Module::Build::Platform::cygwin'=>'0.2808_01','Module::Build::Platform::darwin'=>'0.2808_01','Module::Build::Platform::os2'=>'0.2808_01','Module::Build::PodParser'=>'0.2808_01','Module::CoreList'=>'2.13','Module::Load'=>'0.12','Module::Load::Conditional'=>'0.22','Net::Cmd'=>'2.29','Net::Ping'=>'2.33','Opcode'=>'1.11','Pod::Checker'=>'1.43_01','Pod::Man'=>'2.16','Pod::Perldoc'=>'3.14_02','Socket'=>'1.80','Storable'=>'2.18','Sys::Syslog'=>'0.22','Sys::Syslog::win32::Win32'=>undef,'Term::Cap'=>'1.12','Term::ReadLine'=>'1.03','Term::UI'=>'0.18','Test::Builder'=>'0.72','Test::Builder::Module'=>'0.72','Test::Builder::Tester'=>'1.09','Test::Harness::Straps'=>'0.26_01','Test::More'=>'0.72','Test::Simple'=>'0.72','Text::ParseWords'=>'3.26','Text::Soundex'=>'3.03','Tie::StdHandle'=>undef,'Time::HiRes'=>'1.9711','Time::Local'=>'1.18','Time::Piece'=>'1.12','VMS::Filespec'=>'1.12','Win32'=>'0.34','base'=>'2.13','constant'=>'1.13','feature'=>'1.11','fields'=>'2.13','filetest'=>'1.02','open'=>'1.06','threads'=>'1.67','threads::shared'=>'1.14','version'=>'0.74',},removed=>{}},5.010001=>{delta_from=>5.01,changed=>{'App::Prove'=>'3.17','App::Prove::State'=>'3.17','App::Prove::State::Result'=>'3.17','App::Prove::State::Result::Test'=>'3.17','Archive::Extract'=>'0.34','Archive::Tar'=>'1.52','Attribute::Handlers'=>'0.85','AutoLoader'=>'5.68','AutoSplit'=>'1.06','B'=>'1.22','B::Concise'=>'0.76','B::Debug'=>'1.11','B::Deparse'=>'0.89','B::Lint'=>'1.11','B::Lint::Debug'=>undef,'B::Xref'=>'1.02','Benchmark'=>'1.11','CGI'=>'3.43','CGI::Carp'=>'1.30_01','CGI::Cookie'=>'1.29','CPAN'=>'1.9402','CPAN::Author'=>'5.5','CPAN::Bundle'=>'5.5','CPAN::CacheMgr'=>'5.5','CPAN::Complete'=>'5.5','CPAN::Debug'=>'5.5','CPAN::DeferredCode'=>'5.50','CPAN::Distribution'=>'1.93','CPAN::Distroprefs'=>'6','CPAN::Distrostatus'=>'5.5','CPAN::Exception::RecursiveDependency'=>'5.5','CPAN::Exception::blocked_urllist'=>'1.0','CPAN::Exception::yaml_not_installed'=>'5.5','CPAN::FTP'=>'5.5001','CPAN::FTP::netrc'=>'1.00','CPAN::FirstTime'=>'5.53','CPAN::HandleConfig'=>'5.5','CPAN::Index'=>'1.93','CPAN::InfoObj'=>'5.5','CPAN::Kwalify'=>'5.50','CPAN::LWP::UserAgent'=>'1.00','CPAN::Module'=>'5.5','CPAN::Nox'=>'5.50','CPAN::Prompt'=>'5.5','CPAN::Queue'=>'5.5','CPAN::Shell'=>'5.5','CPAN::Tarzip'=>'5.501','CPAN::URL'=>'5.5','CPANPLUS'=>'0.88','CPANPLUS::Dist::Autobundle'=>undef,'CPANPLUS::Dist::Base'=>undef,'CPANPLUS::Dist::Build'=>'0.36','CPANPLUS::Dist::Build::Constants'=>'0.36','CPANPLUS::Internals'=>'0.88','CPANPLUS::Internals::Constants'=>undef,'CPANPLUS::Internals::Constants::Report'=>undef,'CPANPLUS::Internals::Source::Memory'=>undef,'CPANPLUS::Internals::Source::SQLite'=>undef,'CPANPLUS::Internals::Source::SQLite::Tie'=>undef,'CPANPLUS::Shell::Default'=>'0.88','Carp'=>'1.11','Carp::Heavy'=>'1.11','Compress::Raw::Bzip2'=>'2.020','Compress::Raw::Zlib'=>'2.020','Compress::Zlib'=>'2.020','Cwd'=>'3.30','DB'=>'1.02','DBM_Filter::compress'=>'0.02','DBM_Filter::encode'=>'0.02','DBM_Filter::int32'=>'0.02','DBM_Filter::null'=>'0.02','DBM_Filter::utf8'=>'0.02','DB_File'=>'1.820','Data::Dumper'=>'2.124','Devel::DProf'=>'20080331.00','Devel::PPPort'=>'3.19','Devel::Peek'=>'1.04','Digest'=>'1.16','Digest::MD5'=>'2.39','Digest::SHA'=>'5.47','Digest::base'=>'1.16','Digest::file'=>'1.16','DirHandle'=>'1.03','Dumpvalue'=>'1.13','DynaLoader'=>'1.10','Encode'=>'2.35','Encode::Alias'=>'2.12','Encode::CN::HZ'=>'2.05','Encode::Config'=>'2.05','Encode::GSM0338'=>'2.01','Encode::Guess'=>'2.03','Encode::JP::JIS7'=>'2.04','Encode::MIME::Header'=>'2.11','Encode::Unicode'=>'2.06','Errno'=>'1.11','Exporter'=>'5.63','Exporter::Heavy'=>'5.63','ExtUtils::CBuilder'=>'0.2602','ExtUtils::CBuilder::Base'=>'0.2602','ExtUtils::CBuilder::Platform::Unix'=>'0.2602','ExtUtils::CBuilder::Platform::VMS'=>'0.2602','ExtUtils::CBuilder::Platform::Windows'=>'0.2602','ExtUtils::CBuilder::Platform::aix'=>'0.2602','ExtUtils::CBuilder::Platform::cygwin'=>'0.2602','ExtUtils::CBuilder::Platform::darwin'=>'0.2602','ExtUtils::CBuilder::Platform::dec_osf'=>'0.2602','ExtUtils::CBuilder::Platform::os2'=>'0.2602','ExtUtils::Command'=>'1.16','ExtUtils::Command::MM'=>'6.55_02','ExtUtils::Constant'=>'0.22','ExtUtils::Constant::ProxySubs'=>'0.06','ExtUtils::Constant::Utils'=>'0.02','ExtUtils::Constant::XS'=>'0.03','ExtUtils::Embed'=>'1.28','ExtUtils::Install'=>'1.54','ExtUtils::Installed'=>'1.999_001','ExtUtils::Liblist'=>'6.55_02','ExtUtils::Liblist::Kid'=>'6.5502','ExtUtils::MM'=>'6.55_02','ExtUtils::MM_AIX'=>'6.55_02','ExtUtils::MM_Any'=>'6.55_02','ExtUtils::MM_BeOS'=>'6.55_02','ExtUtils::MM_Cygwin'=>'6.55_02','ExtUtils::MM_DOS'=>'6.5502','ExtUtils::MM_Darwin'=>'6.55_02','ExtUtils::MM_MacOS'=>'6.5502','ExtUtils::MM_NW5'=>'6.55_02','ExtUtils::MM_OS2'=>'6.55_02','ExtUtils::MM_QNX'=>'6.55_02','ExtUtils::MM_UWIN'=>'6.5502','ExtUtils::MM_Unix'=>'6.55_02','ExtUtils::MM_VMS'=>'6.55_02','ExtUtils::MM_VOS'=>'6.55_02','ExtUtils::MM_Win32'=>'6.55_02','ExtUtils::MM_Win95'=>'6.55_02','ExtUtils::MY'=>'6.5502','ExtUtils::MakeMaker'=>'6.55_02','ExtUtils::MakeMaker::Config'=>'6.55_02','ExtUtils::Manifest'=>'1.56','ExtUtils::Mkbootstrap'=>'6.55_02','ExtUtils::Mksymlists'=>'6.55_02','ExtUtils::ParseXS'=>'2.2002','ExtUtils::testlib'=>'6.5502','Fatal'=>'2.06_01','File::Basename'=>'2.77','File::CheckTree'=>'4.4','File::Compare'=>'1.1006','File::Copy'=>'2.14','File::DosGlob'=>'1.01','File::Fetch'=>'0.20','File::Find'=>'1.14','File::GlobMapper'=>'1.000','File::Path'=>'2.07_03','File::Spec'=>'3.30','File::Spec::Cygwin'=>'3.30','File::Spec::Epoc'=>'3.30','File::Spec::Functions'=>'3.30','File::Spec::Mac'=>'3.30','File::Spec::OS2'=>'3.30','File::Spec::Unix'=>'3.30','File::Spec::VMS'=>'3.30','File::Spec::Win32'=>'3.30','File::Temp'=>'0.22','File::stat'=>'1.01','FileCache'=>'1.08','FileHandle'=>'2.02','Filter::Simple'=>'0.84','Filter::Util::Call'=>'1.08','FindBin'=>'1.50','GDBM_File'=>'1.09','Getopt::Long'=>'2.38','Getopt::Std'=>'1.06','Hash::Util::FieldHash'=>'1.04','I18N::Collate'=>'1.01','IO'=>'1.25','IO::Compress::Adapter::Bzip2'=>'2.020','IO::Compress::Adapter::Deflate'=>'2.020','IO::Compress::Adapter::Identity'=>'2.020','IO::Compress::Base'=>'2.020','IO::Compress::Base::Common'=>'2.020','IO::Compress::Bzip2'=>'2.020','IO::Compress::Deflate'=>'2.020','IO::Compress::Gzip'=>'2.020','IO::Compress::Gzip::Constants'=>'2.020','IO::Compress::RawDeflate'=>'2.020','IO::Compress::Zip'=>'2.020','IO::Compress::Zip::Constants'=>'2.020','IO::Compress::Zlib::Constants'=>'2.020','IO::Compress::Zlib::Extra'=>'2.020','IO::Dir'=>'1.07','IO::Handle'=>'1.28','IO::Socket'=>'1.31','IO::Uncompress::Adapter::Bunzip2'=>'2.020','IO::Uncompress::Adapter::Identity'=>'2.020','IO::Uncompress::Adapter::Inflate'=>'2.020','IO::Uncompress::AnyInflate'=>'2.020','IO::Uncompress::AnyUncompress'=>'2.020','IO::Uncompress::Base'=>'2.020','IO::Uncompress::Bunzip2'=>'2.020','IO::Uncompress::Gunzip'=>'2.020','IO::Uncompress::Inflate'=>'2.020','IO::Uncompress::RawInflate'=>'2.020','IO::Uncompress::Unzip'=>'2.020','IO::Zlib'=>'1.09','IPC::Cmd'=>'0.46','IPC::Msg'=>'2.01','IPC::Open2'=>'1.03','IPC::Open3'=>'1.04','IPC::Semaphore'=>'2.01','IPC::SharedMem'=>'2.01','IPC::SysV'=>'2.01','List::Util'=>'1.21','List::Util::PP'=>'1.21','List::Util::XS'=>'1.21','Locale::Maketext'=>'1.13','Locale::Maketext::Guts'=>'1.13','Locale::Maketext::GutsLoader'=>'1.13','Log::Message'=>'0.02','MIME::Base64'=>'3.08','MIME::QuotedPrint'=>'3.08','Math::BigFloat'=>'1.60','Math::BigInt'=>'1.89','Math::BigInt::FastCalc'=>'0.19','Math::BigRat'=>'0.22','Math::Complex'=>'1.56','Math::Trig'=>'1.2','Memoize'=>'1.01_03','Module::Build'=>'0.340201','Module::Build::Base'=>'0.340201','Module::Build::Compat'=>'0.340201','Module::Build::Config'=>'0.340201','Module::Build::Cookbook'=>'0.340201','Module::Build::Dumper'=>'0.340201','Module::Build::ModuleInfo'=>'0.340201','Module::Build::Notes'=>'0.340201','Module::Build::PPMMaker'=>'0.340201','Module::Build::Platform::Amiga'=>'0.340201','Module::Build::Platform::Default'=>'0.340201','Module::Build::Platform::EBCDIC'=>'0.340201','Module::Build::Platform::MPEiX'=>'0.340201','Module::Build::Platform::MacOS'=>'0.340201','Module::Build::Platform::RiscOS'=>'0.340201','Module::Build::Platform::Unix'=>'0.340201','Module::Build::Platform::VMS'=>'0.340201','Module::Build::Platform::VOS'=>'0.340201','Module::Build::Platform::Windows'=>'0.340201','Module::Build::Platform::aix'=>'0.340201','Module::Build::Platform::cygwin'=>'0.340201','Module::Build::Platform::darwin'=>'0.340201','Module::Build::Platform::os2'=>'0.340201','Module::Build::PodParser'=>'0.340201','Module::Build::Version'=>'0.77','Module::CoreList'=>'2.18','Module::Load'=>'0.16','Module::Load::Conditional'=>'0.30','Module::Loaded'=>'0.02','Module::Pluggable'=>'3.9','Module::Pluggable::Object'=>'3.9','NDBM_File'=>'1.08','NEXT'=>'0.64','Net::Ping'=>'2.36','O'=>'1.01','OS2::Process'=>'1.03','OS2::REXX'=>'1.04','Object::Accessor'=>'0.34','POSIX'=>'1.17','Package::Constants'=>'0.02','Parse::CPAN::Meta'=>'1.39','PerlIO'=>'1.06','PerlIO::encoding'=>'0.11','PerlIO::scalar'=>'0.07','PerlIO::via'=>'0.07','Pod::Checker'=>'1.45','Pod::Find'=>'1.35','Pod::Html'=>'1.09','Pod::InputObjects'=>'1.31','Pod::Man'=>'2.22','Pod::ParseLink'=>'1.09','Pod::ParseUtils'=>'1.36','Pod::Parser'=>'1.37','Pod::Perldoc'=>'3.14_04','Pod::PlainText'=>'2.04','Pod::Select'=>'1.36','Pod::Simple'=>'3.07','Pod::Simple::XHTML'=>'3.04','Pod::Text'=>'3.13','Pod::Text::Color'=>'2.05','Pod::Text::Overstrike'=>'2.03','Pod::Text::Termcap'=>'2.05','Pod::Usage'=>'1.36','Safe'=>'2.18','Scalar::Util'=>'1.21','Scalar::Util::PP'=>'1.21','SelectSaver'=>'1.02','SelfLoader'=>'1.17','Socket'=>'1.82','Storable'=>'2.20','Switch'=>'2.14','Symbol'=>'1.07','Sys::Syslog'=>'0.27','TAP::Base'=>'3.17','TAP::Formatter::Base'=>'3.17','TAP::Formatter::Color'=>'3.17','TAP::Formatter::Console'=>'3.17','TAP::Formatter::Console::ParallelSession'=>'3.17','TAP::Formatter::Console::Session'=>'3.17','TAP::Formatter::File'=>'3.17','TAP::Formatter::File::Session'=>'3.17','TAP::Formatter::Session'=>'3.17','TAP::Harness'=>'3.17','TAP::Object'=>'3.17','TAP::Parser'=>'3.17','TAP::Parser::Aggregator'=>'3.17','TAP::Parser::Grammar'=>'3.17','TAP::Parser::Iterator'=>'3.17','TAP::Parser::Iterator::Array'=>'3.17','TAP::Parser::Iterator::Process'=>'3.17','TAP::Parser::Iterator::Stream'=>'3.17','TAP::Parser::IteratorFactory'=>'3.17','TAP::Parser::Multiplexer'=>'3.17','TAP::Parser::Result'=>'3.17','TAP::Parser::Result::Bailout'=>'3.17','TAP::Parser::Result::Comment'=>'3.17','TAP::Parser::Result::Plan'=>'3.17','TAP::Parser::Result::Pragma'=>'3.17','TAP::Parser::Result::Test'=>'3.17','TAP::Parser::Result::Unknown'=>'3.17','TAP::Parser::Result::Version'=>'3.17','TAP::Parser::Result::YAML'=>'3.17','TAP::Parser::ResultFactory'=>'3.17','TAP::Parser::Scheduler'=>'3.17','TAP::Parser::Scheduler::Job'=>'3.17','TAP::Parser::Scheduler::Spinner'=>'3.17','TAP::Parser::Source'=>'3.17','TAP::Parser::Source::Perl'=>'3.17','TAP::Parser::Utils'=>'3.17','TAP::Parser::YAMLish::Reader'=>'3.17','TAP::Parser::YAMLish::Writer'=>'3.17','Term::ANSIColor'=>'2.00','Term::ReadLine'=>'1.04','Term::UI'=>'0.20','Test'=>'1.25_02','Test::Builder'=>'0.92','Test::Builder::Module'=>'0.92','Test::Builder::Tester'=>'1.18','Test::Builder::Tester::Color'=>'1.18','Test::Harness'=>'3.17','Test::More'=>'0.92','Test::Simple'=>'0.92','Text::ParseWords'=>'3.27','Text::Tabs'=>'2009.0305','Text::Wrap'=>'2009.0305','Thread::Queue'=>'2.11','Thread::Semaphore'=>'2.09','Tie::Handle'=>'4.2','Tie::Hash'=>'1.03','Tie::RefHash'=>'1.38','Tie::Scalar'=>'1.01','Tie::StdHandle'=>'4.2','Time::HiRes'=>'1.9719','Time::Local'=>'1.1901','Time::Piece'=>'1.15','UNIVERSAL'=>'1.05','Unicode'=>'5.1.0','Unicode::Normalize'=>'1.03','Unicode::UCD'=>'0.27','VMS::Stdio'=>'2.4','Win32'=>'0.39','Win32API::File'=>'0.1101','XS::APItest'=>'0.15','XS::Typemap'=>'0.03','XSLoader'=>'0.10','attributes'=>'0.09','attrs'=>'1.03','autodie'=>'2.06_01','autodie::exception'=>'2.06_01','autodie::exception::system'=>'2.06_01','autodie::hints'=>'2.06_01','base'=>'2.14','bigint'=>'0.23','bignum'=>'0.23','bigrat'=>'0.23','blib'=>'1.04','charnames'=>'1.07','constant'=>'1.17','encoding'=>'2.6_01','feature'=>'1.13','fields'=>'2.14','lib'=>'0.62','mro'=>'1.01','open'=>'1.07','ops'=>'1.02','overload'=>'1.07','overload::numbers'=>undef,'overloading'=>'0.01','parent'=>'0.221','re'=>'0.09','threads'=>'1.72','threads::shared'=>'1.29','version'=>'0.77',},removed=>{'CPAN::API::HOWTO'=>1,'CPAN::DeferedCode'=>1,'CPANPLUS::inc'=>1,'ExtUtils::MakeMaker::bytes'=>1,'ExtUtils::MakeMaker::vmsish'=>1,'Test::Harness::Assert'=>1,'Test::Harness::Iterator'=>1,'Test::Harness::Point'=>1,'Test::Harness::Results'=>1,'Test::Harness::Straps'=>1,'Test::Harness::Util'=>1,}},5.011=>{delta_from=>5.010001,changed=>{'Archive::Tar'=>'1.54','Attribute::Handlers'=>'0.87','AutoLoader'=>'5.70','B::Deparse'=>'0.91','B::Lint'=>'1.11_01','B::Lint::Debug'=>'0.01','CGI'=>'3.45','CGI::Apache'=>'1.01','CGI::Carp'=>'3.45','CGI::Pretty'=>'3.44','CGI::Switch'=>'1.01','CGI::Util'=>'3.45','CPAN'=>'1.94_51','CPAN::Distribution'=>'1.94','CPAN::FTP'=>'5.5002','CPAN::Index'=>'1.94','CPAN::LWP::UserAgent'=>'1.94','CPANPLUS::Dist::Build'=>'0.40','CPANPLUS::Dist::Build::Constants'=>'0.40','Carp'=>'1.12','Carp::Heavy'=>'1.12','Class::ISA'=>'0.36','Compress::Raw::Bzip2'=>'2.021','Compress::Raw::Zlib'=>'2.021','Compress::Zlib'=>'2.021','Cwd'=>'3.3002','Data::Dumper'=>'2.125','Encode'=>'2.37','Exporter'=>'5.64','Exporter::Heavy'=>'5.64','ExtUtils::ParseXS'=>'2.200403','File::Basename'=>'2.78','File::Copy'=>'2.16','File::stat'=>'1.02','IO'=>'1.25_01','IO::Compress::Adapter::Bzip2'=>'2.021','IO::Compress::Adapter::Deflate'=>'2.021','IO::Compress::Adapter::Identity'=>'2.021','IO::Compress::Base'=>'2.021','IO::Compress::Base::Common'=>'2.021','IO::Compress::Bzip2'=>'2.021','IO::Compress::Deflate'=>'2.021','IO::Compress::Gzip'=>'2.021','IO::Compress::Gzip::Constants'=>'2.021','IO::Compress::RawDeflate'=>'2.021','IO::Compress::Zip'=>'2.021','IO::Compress::Zip::Constants'=>'2.021','IO::Compress::Zlib::Constants'=>'2.021','IO::Compress::Zlib::Extra'=>'2.021','IO::Uncompress::Adapter::Bunzip2'=>'2.021','IO::Uncompress::Adapter::Identity'=>'2.021','IO::Uncompress::Adapter::Inflate'=>'2.021','IO::Uncompress::AnyInflate'=>'2.021','IO::Uncompress::AnyUncompress'=>'2.021','IO::Uncompress::Base'=>'2.021','IO::Uncompress::Bunzip2'=>'2.021','IO::Uncompress::Gunzip'=>'2.021','IO::Uncompress::Inflate'=>'2.021','IO::Uncompress::RawInflate'=>'2.021','IO::Uncompress::Unzip'=>'2.021','IO::Zlib'=>'1.10','IPC::Cmd'=>'0.50','IPC::Open3'=>'1.05','Locale::Maketext::Simple'=>'0.21','Log::Message::Simple'=>'0.06','Math::BigInt'=>'1.89_01','Math::BigRat'=>'0.24','Module::Build'=>'0.35','Module::Build::Base'=>'0.35','Module::Build::Compat'=>'0.35','Module::Build::Config'=>'0.35','Module::Build::Cookbook'=>'0.35','Module::Build::Dumper'=>'0.35','Module::Build::ModuleInfo'=>'0.35','Module::Build::Notes'=>'0.35','Module::Build::PPMMaker'=>'0.35','Module::Build::Platform::Amiga'=>'0.35','Module::Build::Platform::Default'=>'0.35','Module::Build::Platform::EBCDIC'=>'0.35','Module::Build::Platform::MPEiX'=>'0.35','Module::Build::Platform::MacOS'=>'0.35','Module::Build::Platform::RiscOS'=>'0.35','Module::Build::Platform::Unix'=>'0.35','Module::Build::Platform::VMS'=>'0.35','Module::Build::Platform::VOS'=>'0.35','Module::Build::Platform::Windows'=>'0.35','Module::Build::Platform::aix'=>'0.35','Module::Build::Platform::cygwin'=>'0.35','Module::Build::Platform::darwin'=>'0.35','Module::Build::Platform::os2'=>'0.35','Module::Build::PodParser'=>'0.35','Module::CoreList'=>'2.19','Module::Loaded'=>'0.06','Opcode'=>'1.13','PerlIO::via'=>'0.08','Pod::Perldoc'=>'3.15_01','Pod::Plainer'=>'1.01','Safe'=>'2.19','Socket'=>'1.84','Switch'=>'2.14_01','Term::ANSIColor'=>'2.02','Term::ReadLine'=>'1.05','Text::Balanced'=>'2.02','Text::Soundex'=>'3.03_01','Time::Local'=>'1.1901_01','Unicode::Collate'=>'0.52_01','attributes'=>'0.12','constant'=>'1.19','deprecate'=>'0.01','overload'=>'1.08','parent'=>'0.223','re'=>'0.10','threads'=>'1.74','threads::shared'=>'1.31','warnings'=>'1.07',},removed=>{'attrs'=>1,}},5.011001=>{delta_from=>5.011,changed=>{'B'=>'1.23','B::Concise'=>'0.77','B::Deparse'=>'0.92','CGI'=>'3.48','CGI::Pretty'=>'3.46','CGI::Util'=>'3.48','CPANPLUS'=>'0.89_03','CPANPLUS::Internals'=>'0.89_03','CPANPLUS::Shell::Default'=>'0.89_03','Carp'=>'1.13','Carp::Heavy'=>'1.13','ExtUtils::CBuilder'=>'0.260301','ExtUtils::CBuilder::Base'=>'0.260301','ExtUtils::CBuilder::Platform::Unix'=>'0.260301','ExtUtils::CBuilder::Platform::VMS'=>'0.260301','ExtUtils::CBuilder::Platform::Windows'=>'0.260301','ExtUtils::CBuilder::Platform::aix'=>'0.260301','ExtUtils::CBuilder::Platform::cygwin'=>'0.260301','ExtUtils::CBuilder::Platform::darwin'=>'0.260301','ExtUtils::CBuilder::Platform::dec_osf'=>'0.260301','ExtUtils::CBuilder::Platform::os2'=>'0.260301','ExtUtils::Install'=>'1.55','ExtUtils::Manifest'=>'1.57','ExtUtils::Packlist'=>'1.44','ExtUtils::ParseXS'=>'2.21','File::Glob'=>'1.07','File::Path'=>'2.08','IO'=>'1.25_02','Module::CoreList'=>'2.21','OS2::DLL'=>'1.04','OS2::Process'=>'1.04','Object::Accessor'=>'0.36','Opcode'=>'1.15','POSIX'=>'1.18','Parse::CPAN::Meta'=>'1.40','PerlIO::via'=>'0.09','Pod::Simple'=>'3.08','Socket'=>'1.85','Storable'=>'2.22','Switch'=>'2.15','Test::Builder'=>'0.94','Test::Builder::Module'=>'0.94','Test::More'=>'0.94','Test::Simple'=>'0.94','XS::APItest'=>'0.16','mro'=>'1.02','overload'=>'1.09','threads::shared'=>'1.32',},removed=>{}},5.011002=>{delta_from=>5.011001,changed=>{'B::Concise'=>'0.78','B::Deparse'=>'0.93','CPANPLUS'=>'0.89_09','CPANPLUS::Dist::Build'=>'0.44','CPANPLUS::Dist::Build::Constants'=>'0.44','CPANPLUS::Internals'=>'0.89_09','CPANPLUS::Shell::Default'=>'0.89_09','Carp'=>'1.14','Carp::Heavy'=>'1.14','Compress::Zlib'=>'2.022','DBM_Filter'=>'0.03','Encode'=>'2.38','Encode::Byte'=>'2.04','Encode::CN'=>'2.03','Encode::JP'=>'2.04','Encode::KR'=>'2.03','Encode::TW'=>'2.03','Encode::Unicode'=>'2.07','Env'=>'1.01','Exporter'=>'5.64_01','Exporter::Heavy'=>'5.64_01','ExtUtils::CBuilder'=>'0.27','ExtUtils::CBuilder::Base'=>'0.27','ExtUtils::CBuilder::Platform::Unix'=>'0.27','ExtUtils::CBuilder::Platform::VMS'=>'0.27','ExtUtils::CBuilder::Platform::Windows'=>'0.27','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.27','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.27','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.27','ExtUtils::CBuilder::Platform::aix'=>'0.27','ExtUtils::CBuilder::Platform::cygwin'=>'0.27','ExtUtils::CBuilder::Platform::darwin'=>'0.27','ExtUtils::CBuilder::Platform::dec_osf'=>'0.27','ExtUtils::CBuilder::Platform::os2'=>'0.27','File::Fetch'=>'0.22','I18N::LangTags::Detect'=>'1.04','I18N::Langinfo'=>'0.03','IO::Compress::Adapter::Bzip2'=>'2.022','IO::Compress::Adapter::Deflate'=>'2.022','IO::Compress::Adapter::Identity'=>'2.022','IO::Compress::Base'=>'2.022','IO::Compress::Base::Common'=>'2.022','IO::Compress::Bzip2'=>'2.022','IO::Compress::Deflate'=>'2.022','IO::Compress::Gzip'=>'2.022','IO::Compress::Gzip::Constants'=>'2.022','IO::Compress::RawDeflate'=>'2.022','IO::Compress::Zip'=>'2.022','IO::Compress::Zip::Constants'=>'2.022','IO::Compress::Zlib::Constants'=>'2.022','IO::Compress::Zlib::Extra'=>'2.022','IO::Uncompress::Adapter::Bunzip2'=>'2.022','IO::Uncompress::Adapter::Identity'=>'2.022','IO::Uncompress::Adapter::Inflate'=>'2.022','IO::Uncompress::AnyInflate'=>'2.022','IO::Uncompress::AnyUncompress'=>'2.022','IO::Uncompress::Base'=>'2.022','IO::Uncompress::Bunzip2'=>'2.022','IO::Uncompress::Gunzip'=>'2.022','IO::Uncompress::Inflate'=>'2.022','IO::Uncompress::RawInflate'=>'2.022','IO::Uncompress::Unzip'=>'2.022','IPC::Cmd'=>'0.54','List::Util'=>'1.22','List::Util::PP'=>'1.22','List::Util::XS'=>'1.22','Locale::Maketext'=>'1.14','Module::Build'=>'0.35_09','Module::Build::Base'=>'0.35_09','Module::Build::Compat'=>'0.35_09','Module::Build::Config'=>'0.35_09','Module::Build::Cookbook'=>'0.35_09','Module::Build::Dumper'=>'0.35_09','Module::Build::ModuleInfo'=>'0.35_09','Module::Build::Notes'=>'0.35_09','Module::Build::PPMMaker'=>'0.35_09','Module::Build::Platform::Amiga'=>'0.35_09','Module::Build::Platform::Default'=>'0.35_09','Module::Build::Platform::EBCDIC'=>'0.35_09','Module::Build::Platform::MPEiX'=>'0.35_09','Module::Build::Platform::MacOS'=>'0.35_09','Module::Build::Platform::RiscOS'=>'0.35_09','Module::Build::Platform::Unix'=>'0.35_09','Module::Build::Platform::VMS'=>'0.35_09','Module::Build::Platform::VOS'=>'0.35_09','Module::Build::Platform::Windows'=>'0.35_09','Module::Build::Platform::aix'=>'0.35_09','Module::Build::Platform::cygwin'=>'0.35_09','Module::Build::Platform::darwin'=>'0.35_09','Module::Build::Platform::os2'=>'0.35_09','Module::Build::PodParser'=>'0.35_09','Module::Build::YAML'=>'1.40','Module::CoreList'=>'2.23','Module::Load::Conditional'=>'0.34','Pod::Simple'=>'3.10','Pod::Simple::XHTML'=>'3.10','Scalar::Util'=>'1.22','Scalar::Util::PP'=>'1.22','Switch'=>'2.16','XS::APItest'=>'0.17','XS::APItest::KeywordRPN'=>'0.003','base'=>'2.15','diagnostics'=>'1.18','fields'=>'2.15','inc::latest'=>'0.35_09','legacy'=>'1.00','overload'=>'1.10',},removed=>{}},5.011003=>{delta_from=>5.011002,changed=>{'App::Cpan'=>'1.570001','Archive::Extract'=>'0.36','CPAN'=>'1.94_5301','CPAN::FTP'=>'5.5004','CPAN::FirstTime'=>'5.530001','CPAN::Mirrors'=>'1.770001','CPANPLUS'=>'0.90','CPANPLUS::Internals'=>'0.90','CPANPLUS::Shell::Default'=>'0.90','Cwd'=>'3.31','Encode'=>'2.39','ExtUtils::Command::MM'=>'6.56','ExtUtils::Liblist'=>'6.56','ExtUtils::Liblist::Kid'=>'6.56','ExtUtils::MM'=>'6.56','ExtUtils::MM_AIX'=>'6.56','ExtUtils::MM_Any'=>'6.56','ExtUtils::MM_BeOS'=>'6.56','ExtUtils::MM_Cygwin'=>'6.56','ExtUtils::MM_DOS'=>'6.56','ExtUtils::MM_Darwin'=>'6.56','ExtUtils::MM_MacOS'=>'6.56','ExtUtils::MM_NW5'=>'6.56','ExtUtils::MM_OS2'=>'6.56','ExtUtils::MM_QNX'=>'6.56','ExtUtils::MM_UWIN'=>'6.56','ExtUtils::MM_Unix'=>'6.56','ExtUtils::MM_VMS'=>'6.56','ExtUtils::MM_VOS'=>'6.56','ExtUtils::MM_Win32'=>'6.56','ExtUtils::MM_Win95'=>'6.56','ExtUtils::MY'=>'6.56','ExtUtils::MakeMaker'=>'6.56','ExtUtils::MakeMaker::Config'=>'6.56','ExtUtils::Mkbootstrap'=>'6.56','ExtUtils::Mksymlists'=>'6.56','ExtUtils::testlib'=>'6.56','File::Find'=>'1.15','File::Path'=>'2.08_01','File::Spec'=>'3.31','Module::Build'=>'0.36','Module::Build::Base'=>'0.36','Module::Build::Compat'=>'0.36','Module::Build::Config'=>'0.36','Module::Build::Cookbook'=>'0.36','Module::Build::Dumper'=>'0.36','Module::Build::ModuleInfo'=>'0.36','Module::Build::Notes'=>'0.36','Module::Build::PPMMaker'=>'0.36','Module::Build::Platform::Amiga'=>'0.36','Module::Build::Platform::Default'=>'0.36','Module::Build::Platform::EBCDIC'=>'0.36','Module::Build::Platform::MPEiX'=>'0.36','Module::Build::Platform::MacOS'=>'0.36','Module::Build::Platform::RiscOS'=>'0.36','Module::Build::Platform::Unix'=>'0.36','Module::Build::Platform::VMS'=>'0.36','Module::Build::Platform::VOS'=>'0.36','Module::Build::Platform::Windows'=>'0.36','Module::Build::Platform::aix'=>'0.36','Module::Build::Platform::cygwin'=>'0.36','Module::Build::Platform::darwin'=>'0.36','Module::Build::Platform::os2'=>'0.36','Module::Build::PodParser'=>'0.36','Module::CoreList'=>'2.24','POSIX'=>'1.19','Pod::Simple'=>'3.13','Pod::Simple::BlackBox'=>'3.13','Pod::Simple::Checker'=>'3.13','Pod::Simple::Debug'=>'3.13','Pod::Simple::DumpAsText'=>'3.13','Pod::Simple::DumpAsXML'=>'3.13','Pod::Simple::HTML'=>'3.13','Pod::Simple::HTMLBatch'=>'3.13','Pod::Simple::LinkSection'=>'3.13','Pod::Simple::Methody'=>'3.13','Pod::Simple::Progress'=>'3.13','Pod::Simple::PullParser'=>'3.13','Pod::Simple::PullParserEndToken'=>'3.13','Pod::Simple::PullParserStartToken'=>'3.13','Pod::Simple::PullParserTextToken'=>'3.13','Pod::Simple::PullParserToken'=>'3.13','Pod::Simple::RTF'=>'3.13','Pod::Simple::Search'=>'3.13','Pod::Simple::SimpleTree'=>'3.13','Pod::Simple::Text'=>'3.13','Pod::Simple::TextContent'=>'3.13','Pod::Simple::TiedOutFH'=>'3.13','Pod::Simple::Transcode'=>'3.13','Pod::Simple::TranscodeDumb'=>'3.13','Pod::Simple::TranscodeSmart'=>'3.13','Pod::Simple::XHTML'=>'3.13','Pod::Simple::XMLOutStream'=>'3.13','Safe'=>'2.20','Unicode'=>'5.2.0','constant'=>'1.20','diagnostics'=>'1.19','feature'=>'1.14','inc::latest'=>'0.36','threads'=>'1.75','warnings'=>'1.08',},removed=>{'legacy'=>1,}},5.011004=>{delta_from=>5.011003,changed=>{'App::Cpan'=>'1.5701','Archive::Extract'=>'0.38','B::Deparse'=>'0.94','CPAN'=>'1.94_54','CPAN::FirstTime'=>'5.53','CPAN::Mirrors'=>'1.77','Carp'=>'1.15','Carp::Heavy'=>'1.15','Compress::Raw::Bzip2'=>'2.024','Compress::Raw::Zlib'=>'2.024','Compress::Zlib'=>'2.024','File::Copy'=>'2.17','File::Fetch'=>'0.24','GDBM_File'=>'1.10','IO::Compress::Adapter::Bzip2'=>'2.024','IO::Compress::Adapter::Deflate'=>'2.024','IO::Compress::Adapter::Identity'=>'2.024','IO::Compress::Base'=>'2.024','IO::Compress::Base::Common'=>'2.024','IO::Compress::Bzip2'=>'2.024','IO::Compress::Deflate'=>'2.024','IO::Compress::Gzip'=>'2.024','IO::Compress::Gzip::Constants'=>'2.024','IO::Compress::RawDeflate'=>'2.024','IO::Compress::Zip'=>'2.024','IO::Compress::Zip::Constants'=>'2.024','IO::Compress::Zlib::Constants'=>'2.024','IO::Compress::Zlib::Extra'=>'2.024','IO::Uncompress::Adapter::Bunzip2'=>'2.024','IO::Uncompress::Adapter::Identity'=>'2.024','IO::Uncompress::Adapter::Inflate'=>'2.024','IO::Uncompress::AnyInflate'=>'2.024','IO::Uncompress::AnyUncompress'=>'2.024','IO::Uncompress::Base'=>'2.024','IO::Uncompress::Bunzip2'=>'2.024','IO::Uncompress::Gunzip'=>'2.024','IO::Uncompress::Inflate'=>'2.024','IO::Uncompress::RawInflate'=>'2.024','IO::Uncompress::Unzip'=>'2.024','Module::Build'=>'0.3603','Module::Build::Base'=>'0.3603','Module::Build::Compat'=>'0.3603','Module::Build::Config'=>'0.3603','Module::Build::Cookbook'=>'0.3603','Module::Build::Dumper'=>'0.3603','Module::Build::ModuleInfo'=>'0.3603','Module::Build::Notes'=>'0.3603','Module::Build::PPMMaker'=>'0.3603','Module::Build::Platform::Amiga'=>'0.3603','Module::Build::Platform::Default'=>'0.3603','Module::Build::Platform::EBCDIC'=>'0.3603','Module::Build::Platform::MPEiX'=>'0.3603','Module::Build::Platform::MacOS'=>'0.3603','Module::Build::Platform::RiscOS'=>'0.3603','Module::Build::Platform::Unix'=>'0.3603','Module::Build::Platform::VMS'=>'0.3603','Module::Build::Platform::VOS'=>'0.3603','Module::Build::Platform::Windows'=>'0.3603','Module::Build::Platform::aix'=>'0.3603','Module::Build::Platform::cygwin'=>'0.3603','Module::Build::Platform::darwin'=>'0.3603','Module::Build::Platform::os2'=>'0.3603','Module::Build::PodParser'=>'0.3603','Module::CoreList'=>'2.25','PerlIO::encoding'=>'0.12','Safe'=>'2.21','UNIVERSAL'=>'1.06','feature'=>'1.15','inc::latest'=>'0.3603','less'=>'0.03','re'=>'0.11','version'=>'0.81','warnings'=>'1.09',},removed=>{}},5.011005=>{delta_from=>5.011004,changed=>{'B::Debug'=>'1.12','CPAN'=>'1.94_56','CPAN::Debug'=>'5.5001','CPAN::Distribution'=>'1.9456','CPAN::FirstTime'=>'5.5301','CPAN::HandleConfig'=>'5.5001','CPAN::Shell'=>'5.5001','CPAN::Tarzip'=>'5.5011','CPANPLUS::Dist::Build'=>'0.46','CPANPLUS::Dist::Build::Constants'=>'0.46','Module::CoreList'=>'2.26','Pod::Man'=>'2.23','Pod::ParseLink'=>'1.10','Pod::Perldoc'=>'3.15_02','Pod::Plainer'=>'1.02','Pod::Text'=>'3.14','Pod::Text::Color'=>'2.06','Pod::Text::Overstrike'=>'2.04','Pod::Text::Termcap'=>'2.06','Safe'=>'2.22','Socket'=>'1.86','version'=>'0.82',},removed=>{}},5.012=>{delta_from=>5.011005,changed=>{'B::Deparse'=>'0.96','CPAN::Distribution'=>'1.9456_01','Module::CoreList'=>'2.29','Safe'=>'2.25','Socket'=>'1.87','Tie::Scalar'=>'1.02','Time::Piece'=>'1.15_01','bytes'=>'1.04','feature'=>'1.16','utf8'=>'1.08',},removed=>{}},5.012001=>{delta_from=>5.012,changed=>{'B::Deparse'=>'0.97','CGI'=>'3.49','CGI::Fast'=>'1.08','Carp'=>'1.16','Carp::Heavy'=>'1.16','File::Copy'=>'2.18','Module::CoreList'=>'2.32','Pod::Functions'=>'1.04','Pod::Simple'=>'3.14','Pod::Simple::BlackBox'=>'3.14','Pod::Simple::Checker'=>'3.14','Pod::Simple::Debug'=>'3.14','Pod::Simple::DumpAsText'=>'3.14','Pod::Simple::DumpAsXML'=>'3.14','Pod::Simple::HTML'=>'3.14','Pod::Simple::HTMLBatch'=>'3.14','Pod::Simple::LinkSection'=>'3.14','Pod::Simple::Methody'=>'3.14','Pod::Simple::Progress'=>'3.14','Pod::Simple::PullParser'=>'3.14','Pod::Simple::PullParserEndToken'=>'3.14','Pod::Simple::PullParserStartToken'=>'3.14','Pod::Simple::PullParserTextToken'=>'3.14','Pod::Simple::PullParserToken'=>'3.14','Pod::Simple::RTF'=>'3.14','Pod::Simple::Search'=>'3.14','Pod::Simple::SimpleTree'=>'3.14','Pod::Simple::Text'=>'3.14','Pod::Simple::TextContent'=>'3.14','Pod::Simple::TiedOutFH'=>'3.14','Pod::Simple::Transcode'=>'3.14','Pod::Simple::TranscodeDumb'=>'3.14','Pod::Simple::TranscodeSmart'=>'3.14','Pod::Simple::XHTML'=>'3.14','Pod::Simple::XMLOutStream'=>'3.14','Safe'=>'2.27',},removed=>{}},5.012002=>{delta_from=>5.012001,changed=>{'Carp'=>'1.17','Carp::Heavy'=>'1.17','File::Spec'=>'3.31_01','Module::CoreList'=>'2.38','Module::Load::Conditional'=>'0.38','PerlIO::scalar'=>'0.08',},removed=>{}},5.012003=>{delta_from=>5.012002,changed=>{'B::Deparse'=>'0.9701','Module::Build::Platform::cygwin'=>'0.360301','Module::CoreList'=>'2.43','Socket'=>'1.87_01',},removed=>{}},5.012004=>{delta_from=>5.012003,changed=>{'Module::CoreList'=>'2.50',},removed=>{}},5.012005=>{delta_from=>5.012004,changed=>{'B::Concise'=>'0.78_01','Encode'=>'2.39_01','File::Glob'=>'1.07_01','Module::CoreList'=>'2.50_02','Unicode::UCD'=>'0.29','charnames'=>'1.07_01',},removed=>{}},5.013=>{delta_from=>5.012,changed=>{'CGI'=>'3.49','CGI::Fast'=>'1.08','Data::Dumper'=>'2.126','ExtUtils::MM_Unix'=>'6.5601','ExtUtils::MakeMaker'=>'6.5601','File::Copy'=>'2.18','IPC::Open3'=>'1.06','MIME::Base64'=>'3.09','MIME::QuotedPrint'=>'3.09','Module::CoreList'=>'2.31','Pod::Functions'=>'1.04','XS::APItest'=>'0.18','XS::APItest::KeywordRPN'=>'0.004','feature'=>'1.17','threads'=>'1.77_01','threads::shared'=>'1.33',},removed=>{}},5.013001=>{delta_from=>5.012001,changed=>{'Data::Dumper'=>'2.126','Dumpvalue'=>'1.14','Errno'=>'1.12','ExtUtils::MM_Unix'=>'6.5601','ExtUtils::MakeMaker'=>'6.5601','ExtUtils::ParseXS'=>'2.2205','File::Find'=>'1.16','IPC::Cmd'=>'0.58','IPC::Open3'=>'1.06','List::Util'=>'1.23','List::Util::PP'=>'1.23','List::Util::XS'=>'1.23','Locale::Codes'=>'3.12','Locale::Codes::Country'=>'3.12','Locale::Codes::Currency'=>'3.12','Locale::Codes::Language'=>'3.12','Locale::Codes::Script'=>'3.12','Locale::Constants'=>'3.12','Locale::Country'=>'3.12','Locale::Currency'=>'3.12','Locale::Language'=>'3.12','Locale::Script'=>'3.12','MIME::Base64'=>'3.09','MIME::QuotedPrint'=>'3.09','Module::Build::Platform::cygwin'=>'0.360301','Module::CoreList'=>'2.34','Module::Load::Conditional'=>'0.38','PerlIO::scalar'=>'0.08','Scalar::Util'=>'1.23','Scalar::Util::PP'=>'1.23','Socket'=>'1.88','Term::ReadLine'=>'1.06','Unicode::UCD'=>'0.28','XS::APItest'=>'0.19','XS::APItest::KeywordRPN'=>'0.004','charnames'=>'1.08','feature'=>'1.17','threads'=>'1.77_01','threads::shared'=>'1.33',},removed=>{'Class::ISA'=>1,'Pod::Plainer'=>1,'Switch'=>1,}},5.013002=>{delta_from=>5.013001,changed=>{'B::Concise'=>'0.79','B::Deparse'=>'0.98','CPAN'=>'1.94_57','CPAN::Distribution'=>'1.9600','Exporter'=>'5.64_02','Exporter::Heavy'=>'5.64_02','File::Copy'=>'2.19','Hash::Util'=>'0.08','IO::Socket'=>'1.32','Locale::Codes'=>'3.13','Locale::Codes::Country'=>'3.13','Locale::Codes::Currency'=>'3.13','Locale::Codes::Language'=>'3.13','Locale::Codes::Script'=>'3.13','Locale::Constants'=>'3.13','Locale::Country'=>'3.13','Locale::Currency'=>'3.13','Locale::Language'=>'3.13','Locale::Script'=>'3.13','Search::Dict'=>'1.03','Socket'=>'1.89','Thread::Semaphore'=>'2.11','UNIVERSAL'=>'1.07','VMS::DCLsym'=>'1.04','mro'=>'1.03','threads'=>'1.77_02','threads::shared'=>'1.33_01',},removed=>{}},5.013003=>{delta_from=>5.013002,changed=>{'App::Prove'=>'3.21','App::Prove::State'=>'3.21','App::Prove::State::Result'=>'3.21','App::Prove::State::Result::Test'=>'3.21','Archive::Extract'=>'0.42','Archive::Tar'=>'1.64','Archive::Tar::Constant'=>'1.64','Archive::Tar::File'=>'1.64','Attribute::Handlers'=>'0.88','CPANPLUS'=>'0.9007','CPANPLUS::Internals'=>'0.9007','CPANPLUS::Shell::Default'=>'0.9007','Compress::Raw::Bzip2'=>'2.027','Compress::Raw::Zlib'=>'2.027_01','Compress::Zlib'=>'2.027','DB'=>'1.03','Digest::MD5'=>'2.40','Digest::SHA'=>'5.48','Exporter'=>'5.64_03','Exporter::Heavy'=>'5.64_03','ExtUtils::CBuilder'=>'0.2703','ExtUtils::CBuilder::Base'=>'0.2703_01','ExtUtils::CBuilder::Platform::Unix'=>'0.2703','ExtUtils::CBuilder::Platform::VMS'=>'0.2703','ExtUtils::CBuilder::Platform::Windows'=>'0.2703','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.2703','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.2703','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.2703','ExtUtils::CBuilder::Platform::aix'=>'0.2703','ExtUtils::CBuilder::Platform::cygwin'=>'0.2703','ExtUtils::CBuilder::Platform::darwin'=>'0.2703','ExtUtils::CBuilder::Platform::dec_osf'=>'0.2703','ExtUtils::CBuilder::Platform::os2'=>'0.2703','ExtUtils::Manifest'=>'1.58','ExtUtils::ParseXS'=>'2.2206','Fatal'=>'2.10','File::Basename'=>'2.79','File::Copy'=>'2.20','File::DosGlob'=>'1.02','File::Find'=>'1.17','File::Glob'=>'1.08','File::stat'=>'1.03','I18N::LangTags'=>'0.35_01','I18N::LangTags::List'=>'0.35_01','IO::Compress::Adapter::Bzip2'=>'2.027','IO::Compress::Adapter::Deflate'=>'2.027','IO::Compress::Adapter::Identity'=>'2.027','IO::Compress::Base'=>'2.027','IO::Compress::Base::Common'=>'2.027','IO::Compress::Bzip2'=>'2.027','IO::Compress::Deflate'=>'2.027','IO::Compress::Gzip'=>'2.027','IO::Compress::Gzip::Constants'=>'2.027','IO::Compress::RawDeflate'=>'2.027','IO::Compress::Zip'=>'2.027','IO::Compress::Zip::Constants'=>'2.027','IO::Compress::Zlib::Constants'=>'2.027','IO::Compress::Zlib::Extra'=>'2.027','IO::Uncompress::Adapter::Bunzip2'=>'2.027','IO::Uncompress::Adapter::Identity'=>'2.027','IO::Uncompress::Adapter::Inflate'=>'2.027','IO::Uncompress::AnyInflate'=>'2.027','IO::Uncompress::AnyUncompress'=>'2.027','IO::Uncompress::Base'=>'2.027','IO::Uncompress::Bunzip2'=>'2.027','IO::Uncompress::Gunzip'=>'2.027','IO::Uncompress::Inflate'=>'2.027','IO::Uncompress::RawInflate'=>'2.027','IO::Uncompress::Unzip'=>'2.027','IPC::Cmd'=>'0.60','IPC::Msg'=>'2.03','IPC::Semaphore'=>'2.03','IPC::SharedMem'=>'2.03','IPC::SysV'=>'2.03','Locale::Maketext'=>'1.15','Locale::Maketext::Guts'=>undef,'Locale::Maketext::GutsLoader'=>undef,'Module::Build'=>'0.3607','Module::Build::Base'=>'0.3607','Module::Build::Compat'=>'0.3607','Module::Build::Config'=>'0.3607','Module::Build::Cookbook'=>'0.3607','Module::Build::Dumper'=>'0.3607','Module::Build::ModuleInfo'=>'0.3607','Module::Build::Notes'=>'0.3607','Module::Build::PPMMaker'=>'0.3607','Module::Build::Platform::Amiga'=>'0.3607','Module::Build::Platform::Default'=>'0.3607','Module::Build::Platform::EBCDIC'=>'0.3607','Module::Build::Platform::MPEiX'=>'0.3607','Module::Build::Platform::MacOS'=>'0.3607','Module::Build::Platform::RiscOS'=>'0.3607','Module::Build::Platform::Unix'=>'0.3607','Module::Build::Platform::VMS'=>'0.3607','Module::Build::Platform::VOS'=>'0.3607','Module::Build::Platform::Windows'=>'0.3607','Module::Build::Platform::aix'=>'0.3607','Module::Build::Platform::cygwin'=>'0.3607','Module::Build::Platform::darwin'=>'0.3607','Module::Build::Platform::os2'=>'0.3607','Module::Build::PodParser'=>'0.3607','Module::CoreList'=>'2.36','Module::Load'=>'0.18','TAP::Base'=>'3.21','TAP::Formatter::Base'=>'3.21','TAP::Formatter::Color'=>'3.21','TAP::Formatter::Console'=>'3.21','TAP::Formatter::Console::ParallelSession'=>'3.21','TAP::Formatter::Console::Session'=>'3.21','TAP::Formatter::File'=>'3.21','TAP::Formatter::File::Session'=>'3.21','TAP::Formatter::Session'=>'3.21','TAP::Harness'=>'3.21','TAP::Object'=>'3.21','TAP::Parser'=>'3.21','TAP::Parser::Aggregator'=>'3.21','TAP::Parser::Grammar'=>'3.21','TAP::Parser::Iterator'=>'3.21','TAP::Parser::Iterator::Array'=>'3.21','TAP::Parser::Iterator::Process'=>'3.21','TAP::Parser::Iterator::Stream'=>'3.21','TAP::Parser::IteratorFactory'=>'3.21','TAP::Parser::Multiplexer'=>'3.21','TAP::Parser::Result'=>'3.21','TAP::Parser::Result::Bailout'=>'3.21','TAP::Parser::Result::Comment'=>'3.21','TAP::Parser::Result::Plan'=>'3.21','TAP::Parser::Result::Pragma'=>'3.21','TAP::Parser::Result::Test'=>'3.21','TAP::Parser::Result::Unknown'=>'3.21','TAP::Parser::Result::Version'=>'3.21','TAP::Parser::Result::YAML'=>'3.21','TAP::Parser::ResultFactory'=>'3.21','TAP::Parser::Scheduler'=>'3.21','TAP::Parser::Scheduler::Job'=>'3.21','TAP::Parser::Scheduler::Spinner'=>'3.21','TAP::Parser::Source'=>'3.21','TAP::Parser::SourceHandler'=>'3.21','TAP::Parser::SourceHandler::Executable'=>'3.21','TAP::Parser::SourceHandler::File'=>'3.21','TAP::Parser::SourceHandler::Handle'=>'3.21','TAP::Parser::SourceHandler::Perl'=>'3.21','TAP::Parser::SourceHandler::RawTAP'=>'3.21','TAP::Parser::SourceHandler::pgTAP'=>'3.21','TAP::Parser::Utils'=>'3.21','TAP::Parser::YAMLish::Reader'=>'3.21','TAP::Parser::YAMLish::Writer'=>'3.21','Term::ANSIColor'=>'3.00','Term::ReadLine'=>'1.07','Test::Harness'=>'3.21','Tie::Array'=>'1.04','Time::HiRes'=>'1.9721','Time::Piece'=>'1.20_01','Unicode::Collate'=>'0.53','Unicode::Normalize'=>'1.06','Unicode::UCD'=>'0.29','autodie'=>'2.10','autodie::exception'=>'2.10','autodie::exception::system'=>'2.10','autodie::hints'=>'2.10','blib'=>'1.05','charnames'=>'1.11','diagnostics'=>'1.20','inc::latest'=>'0.3607','lib'=>'0.63','re'=>'0.12','threads'=>'1.77_03','threads::shared'=>'1.33_02','vars'=>'1.02','warnings'=>'1.10',},removed=>{'TAP::Parser::Source::Perl'=>1,}},5.013004=>{delta_from=>5.013003,changed=>{'App::Prove'=>'3.22','App::Prove::State'=>'3.22','App::Prove::State::Result'=>'3.22','App::Prove::State::Result::Test'=>'3.22','Archive::Tar'=>'1.68','Archive::Tar::Constant'=>'1.68','Archive::Tar::File'=>'1.68','B::Lint'=>'1.12','B::Lint::Debug'=>'1.12','Carp'=>'1.18','Carp::Heavy'=>'1.18','Compress::Raw::Bzip2'=>'2.030','Compress::Raw::Zlib'=>'2.030','Compress::Zlib'=>'2.030','ExtUtils::ParseXS'=>'2.2207','File::Spec'=>'3.31_01','I18N::Langinfo'=>'0.04','IO::Compress::Adapter::Bzip2'=>'2.030','IO::Compress::Adapter::Deflate'=>'2.030','IO::Compress::Adapter::Identity'=>'2.030','IO::Compress::Base'=>'2.030','IO::Compress::Base::Common'=>'2.030','IO::Compress::Bzip2'=>'2.030','IO::Compress::Deflate'=>'2.030','IO::Compress::Gzip'=>'2.030','IO::Compress::Gzip::Constants'=>'2.030','IO::Compress::RawDeflate'=>'2.030','IO::Compress::Zip'=>'2.030','IO::Compress::Zip::Constants'=>'2.030','IO::Compress::Zlib::Constants'=>'2.030','IO::Compress::Zlib::Extra'=>'2.030','IO::Uncompress::Adapter::Bunzip2'=>'2.030','IO::Uncompress::Adapter::Identity'=>'2.030','IO::Uncompress::Adapter::Inflate'=>'2.030','IO::Uncompress::AnyInflate'=>'2.030','IO::Uncompress::AnyUncompress'=>'2.030','IO::Uncompress::Base'=>'2.030','IO::Uncompress::Bunzip2'=>'2.030','IO::Uncompress::Gunzip'=>'2.030','IO::Uncompress::Inflate'=>'2.030','IO::Uncompress::RawInflate'=>'2.030','IO::Uncompress::Unzip'=>'2.030','Module::CoreList'=>'2.37','TAP::Base'=>'3.22','TAP::Formatter::Base'=>'3.22','TAP::Formatter::Color'=>'3.22','TAP::Formatter::Console'=>'3.22','TAP::Formatter::Console::ParallelSession'=>'3.22','TAP::Formatter::Console::Session'=>'3.22','TAP::Formatter::File'=>'3.22','TAP::Formatter::File::Session'=>'3.22','TAP::Formatter::Session'=>'3.22','TAP::Harness'=>'3.22','TAP::Object'=>'3.22','TAP::Parser'=>'3.22','TAP::Parser::Aggregator'=>'3.22','TAP::Parser::Grammar'=>'3.22','TAP::Parser::Iterator'=>'3.22','TAP::Parser::Iterator::Array'=>'3.22','TAP::Parser::Iterator::Process'=>'3.22','TAP::Parser::Iterator::Stream'=>'3.22','TAP::Parser::IteratorFactory'=>'3.22','TAP::Parser::Multiplexer'=>'3.22','TAP::Parser::Result'=>'3.22','TAP::Parser::Result::Bailout'=>'3.22','TAP::Parser::Result::Comment'=>'3.22','TAP::Parser::Result::Plan'=>'3.22','TAP::Parser::Result::Pragma'=>'3.22','TAP::Parser::Result::Test'=>'3.22','TAP::Parser::Result::Unknown'=>'3.22','TAP::Parser::Result::Version'=>'3.22','TAP::Parser::Result::YAML'=>'3.22','TAP::Parser::ResultFactory'=>'3.22','TAP::Parser::Scheduler'=>'3.22','TAP::Parser::Scheduler::Job'=>'3.22','TAP::Parser::Scheduler::Spinner'=>'3.22','TAP::Parser::Source'=>'3.22','TAP::Parser::SourceHandler'=>'3.22','TAP::Parser::SourceHandler::Executable'=>'3.22','TAP::Parser::SourceHandler::File'=>'3.22','TAP::Parser::SourceHandler::Handle'=>'3.22','TAP::Parser::SourceHandler::Perl'=>'3.22','TAP::Parser::SourceHandler::RawTAP'=>'3.22','TAP::Parser::Utils'=>'3.22','TAP::Parser::YAMLish::Reader'=>'3.22','TAP::Parser::YAMLish::Writer'=>'3.22','Test::Builder'=>'0.96','Test::Builder::Module'=>'0.96','Test::Builder::Tester'=>'1.20','Test::Builder::Tester::Color'=>'1.20','Test::Harness'=>'3.22','Test::More'=>'0.96','Test::Simple'=>'0.96','Unicode::Collate'=>'0.56','Unicode::Collate::Locale'=>'0.56','XS::APItest'=>'0.20','charnames'=>'1.15','feature'=>'1.18',},removed=>{'TAP::Parser::SourceHandler::pgTAP'=>1,}},5.013005=>{delta_from=>5.013004,changed=>{'B::Debug'=>'1.16','CPANPLUS::Dist::Build'=>'0.48','CPANPLUS::Dist::Build::Constants'=>'0.48','Data::Dumper'=>'2.128','Encode'=>'2.40','Encode::Guess'=>'2.04','Encode::MIME::Header'=>'2.12','Encode::Unicode::UTF7'=>'2.05','Errno'=>'1.13','ExtUtils::Command::MM'=>'6.57_05','ExtUtils::Liblist'=>'6.57_05','ExtUtils::Liblist::Kid'=>'6.5705','ExtUtils::MM'=>'6.57_05','ExtUtils::MM_AIX'=>'6.57_05','ExtUtils::MM_Any'=>'6.57_05','ExtUtils::MM_BeOS'=>'6.57_05','ExtUtils::MM_Cygwin'=>'6.57_05','ExtUtils::MM_DOS'=>'6.5705','ExtUtils::MM_Darwin'=>'6.57_05','ExtUtils::MM_MacOS'=>'6.5705','ExtUtils::MM_NW5'=>'6.57_05','ExtUtils::MM_OS2'=>'6.57_05','ExtUtils::MM_QNX'=>'6.57_05','ExtUtils::MM_UWIN'=>'6.5705','ExtUtils::MM_Unix'=>'6.57_05','ExtUtils::MM_VMS'=>'6.57_05','ExtUtils::MM_VOS'=>'6.57_05','ExtUtils::MM_Win32'=>'6.57_05','ExtUtils::MM_Win95'=>'6.57_05','ExtUtils::MY'=>'6.5705','ExtUtils::MakeMaker'=>'6.57_05','ExtUtils::MakeMaker::Config'=>'6.57_05','ExtUtils::MakeMaker::YAML'=>'1.44','ExtUtils::Mkbootstrap'=>'6.57_05','ExtUtils::Mksymlists'=>'6.57_05','ExtUtils::testlib'=>'6.5705','Filter::Simple'=>'0.85','Hash::Util'=>'0.09','Math::BigFloat'=>'1.62','Math::BigInt'=>'1.95','Math::BigInt::Calc'=>'0.54','Math::BigInt::CalcEmu'=>'0.06','Math::BigInt::FastCalc'=>'0.22','Math::BigRat'=>'0.26','Module::CoreList'=>'2.39','POSIX'=>'1.20','PerlIO::scalar'=>'0.09','Safe'=>'2.28','Test::Builder'=>'0.97_01','Test::Builder::Module'=>'0.97_01','Test::Builder::Tester'=>'1.21_01','Test::Builder::Tester::Color'=>'1.21_01','Test::More'=>'0.97_01','Test::Simple'=>'0.97_01','Tie::Hash'=>'1.04','Unicode::Collate'=>'0.59','Unicode::Collate::Locale'=>'0.59','XS::APItest'=>'0.21','XS::APItest::KeywordRPN'=>'0.005','XSLoader'=>'0.11','bigint'=>'0.25','bignum'=>'0.25','bigrat'=>'0.25','blib'=>'1.06','open'=>'1.08','threads::shared'=>'1.33_03','warnings'=>'1.11','warnings::register'=>'1.02',},removed=>{}},5.013006=>{delta_from=>5.013005,changed=>{'Archive::Extract'=>'0.44','B'=>'1.24','B::Deparse'=>'0.99','CPAN'=>'1.94_61','CPAN::FTP'=>'5.5005','CPAN::Queue'=>'5.5001','CPAN::Version'=>'5.5001','Carp'=>'1.19','Carp::Heavy'=>'1.19','Compress::Raw::Bzip2'=>'2.031','Cwd'=>'3.34','Data::Dumper'=>'2.129','Devel::Peek'=>'1.05','Digest::MD5'=>'2.51','ExtUtils::Constant::Base'=>'0.05','ExtUtils::Constant::ProxySubs'=>'0.07','ExtUtils::Embed'=>'1.29','ExtUtils::XSSymSet'=>'1.2','Fcntl'=>'1.09','File::DosGlob'=>'1.03','File::Find'=>'1.18','File::Glob'=>'1.09','File::Spec'=>'3.33','File::Spec::Cygwin'=>'3.33','File::Spec::Epoc'=>'3.33','File::Spec::Functions'=>'3.33','File::Spec::Mac'=>'3.33','File::Spec::OS2'=>'3.33','File::Spec::Unix'=>'3.33','File::Spec::VMS'=>'3.33','File::Spec::Win32'=>'3.33','GDBM_File'=>'1.11','Hash::Util::FieldHash'=>'1.05','I18N::Langinfo'=>'0.06','IPC::Cmd'=>'0.64','IPC::Open3'=>'1.07','Locale::Codes'=>'3.14','Locale::Codes::Country'=>'3.14','Locale::Codes::Currency'=>'3.14','Locale::Codes::Language'=>'3.14','Locale::Codes::Script'=>'3.14','Locale::Constants'=>'3.14','Locale::Country'=>'3.14','Locale::Currency'=>'3.14','Locale::Language'=>'3.14','Locale::Maketext'=>'1.16','Locale::Script'=>'3.14','Math::BigFloat'=>'1.63','Math::BigInt'=>'1.97','Math::BigInt::Calc'=>'0.55','Math::BigInt::CalcEmu'=>'0.07','Module::CoreList'=>'2.40','NDBM_File'=>'1.09','NEXT'=>'0.65','ODBM_File'=>'1.08','Opcode'=>'1.16','POSIX'=>'1.21','PerlIO::encoding'=>'0.13','PerlIO::scalar'=>'0.10','PerlIO::via'=>'0.10','Pod::Man'=>'2.25','Pod::Text'=>'3.15','SDBM_File'=>'1.07','Socket'=>'1.90','Sys::Hostname'=>'1.13','Tie::Hash::NamedCapture'=>'0.07','Unicode::Collate'=>'0.63','Unicode::Collate::Locale'=>'0.63','Unicode::Normalize'=>'1.07','XS::APItest'=>'0.23','XSLoader'=>'0.13','attributes'=>'0.13','charnames'=>'1.16','if'=>'0.06','mro'=>'1.04','overload'=>'1.11','re'=>'0.13','sigtrap'=>'1.05','threads'=>'1.81_01','threads::shared'=>'1.34',},removed=>{'XS::APItest::KeywordRPN'=>1,}},5.013007=>{delta_from=>5.013006,changed=>{'Archive::Extract'=>'0.46','Archive::Tar'=>'1.72','Archive::Tar::Constant'=>'1.72','Archive::Tar::File'=>'1.72','AutoLoader'=>'5.71','B'=>'1.26','B::Concise'=>'0.81','B::Deparse'=>'1.01','CGI'=>'3.50','CPAN'=>'1.94_62','CPANPLUS'=>'0.9010','CPANPLUS::Dist::Build'=>'0.50','CPANPLUS::Dist::Build::Constants'=>'0.50','CPANPLUS::Internals'=>'0.9010','CPANPLUS::Shell::Default'=>'0.9010','Data::Dumper'=>'2.130_01','DynaLoader'=>'1.11','ExtUtils::Constant'=>'0.23','ExtUtils::Constant::ProxySubs'=>'0.08','Fcntl'=>'1.10','File::Fetch'=>'0.28','File::Glob'=>'1.10','File::stat'=>'1.04','GDBM_File'=>'1.12','Hash::Util'=>'0.10','Hash::Util::FieldHash'=>'1.06','I18N::Langinfo'=>'0.07','Locale::Maketext'=>'1.17','Locale::Maketext::Guts'=>'1.17','Locale::Maketext::GutsLoader'=>'1.17','MIME::Base64'=>'3.10','MIME::QuotedPrint'=>'3.10','Math::BigFloat'=>'1.99_01','Math::BigInt'=>'1.99_01','Math::BigInt::Calc'=>'1.99_01','Math::BigInt::CalcEmu'=>'1.99_01','Math::BigInt::FastCalc'=>'0.24_01','Math::BigRat'=>'0.26_01','Module::CoreList'=>'2.41','NDBM_File'=>'1.10','ODBM_File'=>'1.09','Opcode'=>'1.17','POSIX'=>'1.22','Pod::Simple'=>'3.15','Pod::Simple::BlackBox'=>'3.15','Pod::Simple::Checker'=>'3.15','Pod::Simple::Debug'=>'3.15','Pod::Simple::DumpAsText'=>'3.15','Pod::Simple::DumpAsXML'=>'3.15','Pod::Simple::HTML'=>'3.15','Pod::Simple::HTMLBatch'=>'3.15','Pod::Simple::LinkSection'=>'3.15','Pod::Simple::Methody'=>'3.15','Pod::Simple::Progress'=>'3.15','Pod::Simple::PullParser'=>'3.15','Pod::Simple::PullParserEndToken'=>'3.15','Pod::Simple::PullParserStartToken'=>'3.15','Pod::Simple::PullParserTextToken'=>'3.15','Pod::Simple::PullParserToken'=>'3.15','Pod::Simple::RTF'=>'3.15','Pod::Simple::Search'=>'3.15','Pod::Simple::SimpleTree'=>'3.15','Pod::Simple::Text'=>'3.15','Pod::Simple::TextContent'=>'3.15','Pod::Simple::TiedOutFH'=>'3.15','Pod::Simple::Transcode'=>'3.15','Pod::Simple::TranscodeDumb'=>'3.15','Pod::Simple::TranscodeSmart'=>'3.15','Pod::Simple::XHTML'=>'3.15','Pod::Simple::XMLOutStream'=>'3.15','SDBM_File'=>'1.08','Safe'=>'2.29','SelfLoader'=>'1.18','Socket'=>'1.91','Storable'=>'2.24','Sys::Hostname'=>'1.14','Unicode'=>'6.0.0','Unicode::Collate'=>'0.67','Unicode::Collate::CJK::Big5'=>'0.65','Unicode::Collate::CJK::GB2312'=>'0.65','Unicode::Collate::CJK::JISX0208'=>'0.64','Unicode::Collate::CJK::Korean'=>'0.66','Unicode::Collate::CJK::Pinyin'=>'0.65','Unicode::Collate::CJK::Stroke'=>'0.65','Unicode::Collate::Locale'=>'0.67','XS::APItest'=>'0.26','XS::Typemap'=>'0.04','charnames'=>'1.17','mro'=>'1.05','parent'=>'0.224','re'=>'0.14','threads'=>'1.81_02',},removed=>{}},5.013008=>{delta_from=>5.013007,changed=>{'Archive::Tar'=>'1.74','Archive::Tar::Constant'=>'1.74','Archive::Tar::File'=>'1.74','B'=>'1.27','B::Concise'=>'0.82','B::Deparse'=>'1.02','Carp::Heavy'=>'1.17','Cwd'=>'3.35','Data::Dumper'=>'2.130_02','Devel::Peek'=>'1.06','Devel::SelfStubber'=>'1.05','Digest::SHA'=>'5.50','Dumpvalue'=>'1.15','DynaLoader'=>'1.12','Env'=>'1.02','Exporter::Heavy'=>'5.64_01','ExtUtils::CBuilder'=>'0.280201','ExtUtils::CBuilder::Base'=>'0.280201','ExtUtils::CBuilder::Platform::Unix'=>'0.280201','ExtUtils::CBuilder::Platform::VMS'=>'0.280201','ExtUtils::CBuilder::Platform::Windows'=>'0.280201','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280201','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280201','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280201','ExtUtils::CBuilder::Platform::aix'=>'0.280201','ExtUtils::CBuilder::Platform::cygwin'=>'0.280201','ExtUtils::CBuilder::Platform::darwin'=>'0.280201','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280201','ExtUtils::CBuilder::Platform::os2'=>'0.280201','ExtUtils::Constant::Utils'=>'0.03','ExtUtils::Embed'=>'1.30','ExtUtils::ParseXS'=>'2.2208','Fatal'=>'2.1001','Fcntl'=>'1.11','File::CheckTree'=>'4.41','File::Glob'=>'1.11','GDBM_File'=>'1.13','Hash::Util::FieldHash'=>'1.07','I18N::Collate'=>'1.02','IO'=>'1.25_03','IPC::Cmd'=>'0.66','IPC::Open3'=>'1.08','Locale::Codes'=>'3.15','Locale::Codes::Country'=>'3.15','Locale::Codes::Currency'=>'3.15','Locale::Codes::Language'=>'3.15','Locale::Codes::Script'=>'3.15','Locale::Constants'=>'3.15','Locale::Country'=>'3.15','Locale::Currency'=>'3.15','Locale::Language'=>'3.15','Locale::Script'=>'3.15','MIME::Base64'=>'3.13','MIME::QuotedPrint'=>'3.13','Math::BigFloat'=>'1.99_02','Math::BigInt'=>'1.99_02','Math::BigInt::Calc'=>'1.99_02','Math::BigInt::CalcEmu'=>'1.99_02','Memoize'=>'1.02','Memoize::AnyDBM_File'=>'1.02','Memoize::Expire'=>'1.02','Memoize::ExpireFile'=>'1.02','Memoize::ExpireTest'=>'1.02','Memoize::NDBM_File'=>'1.02','Memoize::SDBM_File'=>'1.02','Memoize::Storable'=>'1.02','Module::CoreList'=>'2.43','NDBM_File'=>'1.11','Net::Ping'=>'2.37','ODBM_File'=>'1.10','Opcode'=>'1.18','POSIX'=>'1.23','PerlIO::encoding'=>'0.14','PerlIO::scalar'=>'0.11','PerlIO::via'=>'0.11','SDBM_File'=>'1.09','Socket'=>'1.92','Storable'=>'2.25','Time::HiRes'=>'1.9721_01','Unicode::Collate'=>'0.6801','Unicode::Collate::Locale'=>'0.68','Unicode::Normalize'=>'1.08','Unicode::UCD'=>'0.30','Win32'=>'0.41','XS::APItest'=>'0.27','autodie'=>'2.1001','autodie::exception'=>'2.1001','autodie::exception::system'=>'2.1001','autodie::hints'=>'2.1001','feature'=>'1.19','if'=>'0.0601','mro'=>'1.06','overload'=>'1.12','re'=>'0.15','threads'=>'1.81_03','threads::shared'=>'1.35','version'=>'0.86',},removed=>{}},5.013009=>{delta_from=>5.013008,changed=>{'Archive::Extract'=>'0.48','Archive::Tar'=>'1.76','Archive::Tar::Constant'=>'1.76','Archive::Tar::File'=>'1.76','B::Concise'=>'0.83','B::Deparse'=>'1.03','B::Lint'=>'1.13','Benchmark'=>'1.12','CGI'=>'3.51','CGI::Carp'=>'3.51','CGI::Cookie'=>'1.30','CGI::Push'=>'1.05','CGI::Util'=>'3.51','CPAN'=>'1.94_63','CPAN::HTTP::Client'=>'1.94','CPAN::HTTP::Credentials'=>'1.94','CPAN::Meta::YAML'=>'0.003','CPANPLUS'=>'0.9011','CPANPLUS::Dist::Build'=>'0.52','CPANPLUS::Dist::Build::Constants'=>'0.52','CPANPLUS::Internals'=>'0.9011','CPANPLUS::Shell::Default'=>'0.9011','Carp::Heavy'=>'1.19','Compress::Raw::Bzip2'=>'2.033','Compress::Raw::Zlib'=>'2.033','Compress::Zlib'=>'2.033','Cwd'=>'3.36','DBM_Filter'=>'0.04','DB_File'=>'1.821','Devel::Peek'=>'1.07','DirHandle'=>'1.04','Dumpvalue'=>'1.16','Encode'=>'2.42','Encode::Alias'=>'2.13','Encode::MIME::Header'=>'2.13','Exporter::Heavy'=>'5.64_03','ExtUtils::Install'=>'1.56','ExtUtils::ParseXS'=>'2.2209','File::Basename'=>'2.80','File::Copy'=>'2.21','File::DosGlob'=>'1.04','File::Fetch'=>'0.32','File::Find'=>'1.19','File::Spec::Mac'=>'3.34','File::Spec::VMS'=>'3.34','File::stat'=>'1.05','HTTP::Tiny'=>'0.009','Hash::Util::FieldHash'=>'1.08','IO::Compress::Adapter::Bzip2'=>'2.033','IO::Compress::Adapter::Deflate'=>'2.033','IO::Compress::Adapter::Identity'=>'2.033','IO::Compress::Base'=>'2.033','IO::Compress::Base::Common'=>'2.033','IO::Compress::Bzip2'=>'2.033','IO::Compress::Deflate'=>'2.033','IO::Compress::Gzip'=>'2.033','IO::Compress::Gzip::Constants'=>'2.033','IO::Compress::RawDeflate'=>'2.033','IO::Compress::Zip'=>'2.033','IO::Compress::Zip::Constants'=>'2.033','IO::Compress::Zlib::Constants'=>'2.033','IO::Compress::Zlib::Extra'=>'2.033','IO::Handle'=>'1.29','IO::Uncompress::Adapter::Bunzip2'=>'2.033','IO::Uncompress::Adapter::Identity'=>'2.033','IO::Uncompress::Adapter::Inflate'=>'2.033','IO::Uncompress::AnyInflate'=>'2.033','IO::Uncompress::AnyUncompress'=>'2.033','IO::Uncompress::Base'=>'2.033','IO::Uncompress::Bunzip2'=>'2.033','IO::Uncompress::Gunzip'=>'2.033','IO::Uncompress::Inflate'=>'2.033','IO::Uncompress::RawInflate'=>'2.033','IO::Uncompress::Unzip'=>'2.033','IPC::Cmd'=>'0.68','IPC::Open3'=>'1.09','JSON::PP'=>'2.27103','JSON::PP::Boolean'=>undef,'Locale::Maketext'=>'1.18','Log::Message'=>'0.04','Log::Message::Config'=>'0.04','Log::Message::Handlers'=>'0.04','Log::Message::Item'=>'0.04','Log::Message::Simple'=>'0.08','Math::BigFloat'=>'1.99_03','Math::BigInt'=>'1.99_03','Math::BigInt::Calc'=>'1.99_03','Math::BigInt::FastCalc'=>'0.24_02','Math::BigRat'=>'0.26_02','Module::CoreList'=>'2.42_01','Module::Load::Conditional'=>'0.40','Module::Metadata'=>'1.000003','Net::Ping'=>'2.38','OS2::Process'=>'1.05','Object::Accessor'=>'0.38','POSIX'=>'1.24','Params::Check'=>'0.28','Perl::OSType'=>'1.002','Pod::LaTeX'=>'0.59','Pod::Perldoc'=>'3.15_03','Socket'=>'1.93','Storable'=>'2.26','Sys::Hostname'=>'1.15','Term::UI'=>'0.24','Thread::Queue'=>'2.12','Thread::Semaphore'=>'2.12','Time::Local'=>'1.2000','UNIVERSAL'=>'1.08','Unicode::Normalize'=>'1.10','Win32'=>'0.44','bigint'=>'0.26','bignum'=>'0.26','bigrat'=>'0.26','charnames'=>'1.18','diagnostics'=>'1.21','re'=>'0.16','threads'=>'1.83','threads::shared'=>'1.36','version'=>'0.88',},removed=>{}},5.01301=>{delta_from=>5.013009,changed=>{'Attribute::Handlers'=>'0.89','B'=>'1.28','B::Showlex'=>'1.03','CGI'=>'3.52','CPAN'=>'1.94_65','CPAN::Distribution'=>'1.9601','CPAN::FTP::netrc'=>'1.01','CPAN::FirstTime'=>'5.5303','CPAN::HandleConfig'=>'5.5003','CPAN::Meta'=>'2.110440','CPAN::Meta::Converter'=>'2.110440','CPAN::Meta::Feature'=>'2.110440','CPAN::Meta::History'=>'2.110440','CPAN::Meta::Prereqs'=>'2.110440','CPAN::Meta::Spec'=>'2.110440','CPAN::Meta::Validator'=>'2.110440','CPAN::Shell'=>'5.5002','CPANPLUS'=>'0.9101','CPANPLUS::Internals'=>'0.9101','CPANPLUS::Shell::Default'=>'0.9101','Carp'=>'1.20','Carp::Heavy'=>'1.20','Cwd'=>'3.37','Devel::DProf'=>'20110217.00','DynaLoader'=>'1.13','ExtUtils::CBuilder'=>'0.280202','ExtUtils::CBuilder::Base'=>'0.280202','ExtUtils::CBuilder::Platform::Unix'=>'0.280202','ExtUtils::CBuilder::Platform::VMS'=>'0.280202','ExtUtils::CBuilder::Platform::Windows'=>'0.280202','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280202','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280202','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280202','ExtUtils::CBuilder::Platform::aix'=>'0.280202','ExtUtils::CBuilder::Platform::cygwin'=>'0.280202','ExtUtils::CBuilder::Platform::darwin'=>'0.280202','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280202','ExtUtils::CBuilder::Platform::os2'=>'0.280202','File::Copy'=>'2.22','Filter::Simple'=>'0.86','HTTP::Tiny'=>'0.010','I18N::LangTags::Detect'=>'1.05','IO::Select'=>'1.18','IPC::Cmd'=>'0.70','Locale::Maketext'=>'1.19','Math::BigFloat'=>'1.992','Math::BigInt'=>'1.992','Math::BigInt::Calc'=>'1.992','Math::BigInt::CalcEmu'=>'1.992','Module::Build'=>'0.37_05','Module::Build::Base'=>'0.37_05','Module::Build::Compat'=>'0.37_05','Module::Build::Config'=>'0.37_05','Module::Build::Cookbook'=>'0.37_05','Module::Build::Dumper'=>'0.37_05','Module::Build::ModuleInfo'=>'0.37_05','Module::Build::Notes'=>'0.37_05','Module::Build::PPMMaker'=>'0.37_05','Module::Build::Platform::Amiga'=>'0.37_05','Module::Build::Platform::Default'=>'0.37_05','Module::Build::Platform::EBCDIC'=>'0.37_05','Module::Build::Platform::MPEiX'=>'0.37_05','Module::Build::Platform::MacOS'=>'0.37_05','Module::Build::Platform::RiscOS'=>'0.37_05','Module::Build::Platform::Unix'=>'0.37_05','Module::Build::Platform::VMS'=>'0.37_05','Module::Build::Platform::VOS'=>'0.37_05','Module::Build::Platform::Windows'=>'0.37_05','Module::Build::Platform::aix'=>'0.37_05','Module::Build::Platform::cygwin'=>'0.37_05','Module::Build::Platform::darwin'=>'0.37_05','Module::Build::Platform::os2'=>'0.37_05','Module::Build::PodParser'=>'0.37_05','Module::Build::Version'=>'0.87','Module::Build::YAML'=>'1.41','Module::CoreList'=>'2.45','Module::Load::Conditional'=>'0.44','Module::Metadata'=>'1.000004','OS2::Process'=>'1.06','Parse::CPAN::Meta'=>'1.4401','Pod::Html'=>'1.1','Socket'=>'1.94','Term::UI'=>'0.26','Unicode::Collate'=>'0.72','Unicode::Collate::Locale'=>'0.71','Unicode::UCD'=>'0.31','VMS::DCLsym'=>'1.05','Version::Requirements'=>'0.101020','bigrat'=>'0.27','deprecate'=>'0.02','diagnostics'=>'1.22','inc::latest'=>'0.37_05','overload'=>'1.13','re'=>'0.17','utf8'=>'1.09','warnings'=>'1.12',},removed=>{}},5.013011=>{delta_from=>5.01301,changed=>{'App::Prove'=>'3.23','App::Prove::State'=>'3.23','App::Prove::State::Result'=>'3.23','App::Prove::State::Result::Test'=>'3.23','B'=>'1.29','CPAN'=>'1.9600','CPAN::Author'=>'5.5001','CPAN::CacheMgr'=>'5.5001','CPAN::Distribution'=>'1.9602','CPAN::Exception::blocked_urllist'=>'1.001','CPAN::HTTP::Client'=>'1.9600','CPAN::HTTP::Credentials'=>'1.9600','CPAN::Index'=>'1.9600','CPAN::LWP::UserAgent'=>'1.9600','CPAN::Mirrors'=>'1.9600','CPAN::Module'=>'5.5001','CPANPLUS'=>'0.9103','CPANPLUS::Dist::Build'=>'0.54','CPANPLUS::Dist::Build::Constants'=>'0.54','CPANPLUS::Internals'=>'0.9103','CPANPLUS::Shell::Default'=>'0.9103','Cwd'=>'3.36','Devel::DProf'=>'20110228.00','Digest::SHA'=>'5.61','ExtUtils::Command'=>'1.17','File::Basename'=>'2.81','File::Copy'=>'2.21','File::Glob'=>'1.12','GDBM_File'=>'1.14','HTTP::Tiny'=>'0.011','Hash::Util'=>'0.11','Hash::Util::FieldHash'=>'1.09','I18N::Langinfo'=>'0.08','IO'=>'1.25_04','IO::Dir'=>'1.08','IO::File'=>'1.15','IO::Handle'=>'1.30','IO::Pipe'=>'1.14','IO::Poll'=>'0.08','IO::Select'=>'1.20','JSON::PP'=>'2.27105','Locale::Codes'=>'3.16','Locale::Codes::Country'=>'3.16','Locale::Codes::Currency'=>'3.16','Locale::Codes::Language'=>'3.16','Locale::Codes::Script'=>'3.16','Locale::Constants'=>'3.16','Locale::Country'=>'3.16','Locale::Currency'=>'3.16','Locale::Language'=>'3.16','Locale::Script'=>'3.16','Math::BigFloat'=>'1.993','Math::BigInt'=>'1.994','Math::BigInt::Calc'=>'1.993','Math::BigInt::CalcEmu'=>'1.993','Math::BigInt::FastCalc'=>'0.28','Module::Build'=>'0.3800','Module::Build::Base'=>'0.3800','Module::Build::Compat'=>'0.3800','Module::Build::Config'=>'0.3800','Module::Build::Cookbook'=>'0.3800','Module::Build::Dumper'=>'0.3800','Module::Build::ModuleInfo'=>'0.3800','Module::Build::Notes'=>'0.3800','Module::Build::PPMMaker'=>'0.3800','Module::Build::Platform::Amiga'=>'0.3800','Module::Build::Platform::Default'=>'0.3800','Module::Build::Platform::EBCDIC'=>'0.3800','Module::Build::Platform::MPEiX'=>'0.3800','Module::Build::Platform::MacOS'=>'0.3800','Module::Build::Platform::RiscOS'=>'0.3800','Module::Build::Platform::Unix'=>'0.3800','Module::Build::Platform::VMS'=>'0.3800','Module::Build::Platform::VOS'=>'0.3800','Module::Build::Platform::Windows'=>'0.3800','Module::Build::Platform::aix'=>'0.3800','Module::Build::Platform::cygwin'=>'0.3800','Module::Build::Platform::darwin'=>'0.3800','Module::Build::Platform::os2'=>'0.3800','Module::Build::PodParser'=>'0.3800','Module::CoreList'=>'2.46','NDBM_File'=>'1.12','Pod::Simple'=>'3.16','Pod::Simple::BlackBox'=>'3.16','Pod::Simple::Checker'=>'3.16','Pod::Simple::Debug'=>'3.16','Pod::Simple::DumpAsText'=>'3.16','Pod::Simple::DumpAsXML'=>'3.16','Pod::Simple::HTML'=>'3.16','Pod::Simple::HTMLBatch'=>'3.16','Pod::Simple::LinkSection'=>'3.16','Pod::Simple::Methody'=>'3.16','Pod::Simple::Progress'=>'3.16','Pod::Simple::PullParser'=>'3.16','Pod::Simple::PullParserEndToken'=>'3.16','Pod::Simple::PullParserStartToken'=>'3.16','Pod::Simple::PullParserTextToken'=>'3.16','Pod::Simple::PullParserToken'=>'3.16','Pod::Simple::RTF'=>'3.16','Pod::Simple::Search'=>'3.16','Pod::Simple::SimpleTree'=>'3.16','Pod::Simple::Text'=>'3.16','Pod::Simple::TextContent'=>'3.16','Pod::Simple::TiedOutFH'=>'3.16','Pod::Simple::Transcode'=>'3.16','Pod::Simple::TranscodeDumb'=>'3.16','Pod::Simple::TranscodeSmart'=>'3.16','Pod::Simple::XHTML'=>'3.16','Pod::Simple::XMLOutStream'=>'3.16','Storable'=>'2.27','Sys::Hostname'=>'1.16','TAP::Base'=>'3.23','TAP::Formatter::Base'=>'3.23','TAP::Formatter::Color'=>'3.23','TAP::Formatter::Console'=>'3.23','TAP::Formatter::Console::ParallelSession'=>'3.23','TAP::Formatter::Console::Session'=>'3.23','TAP::Formatter::File'=>'3.23','TAP::Formatter::File::Session'=>'3.23','TAP::Formatter::Session'=>'3.23','TAP::Harness'=>'3.23','TAP::Object'=>'3.23','TAP::Parser'=>'3.23','TAP::Parser::Aggregator'=>'3.23','TAP::Parser::Grammar'=>'3.23','TAP::Parser::Iterator'=>'3.23','TAP::Parser::Iterator::Array'=>'3.23','TAP::Parser::Iterator::Process'=>'3.23','TAP::Parser::Iterator::Stream'=>'3.23','TAP::Parser::IteratorFactory'=>'3.23','TAP::Parser::Multiplexer'=>'3.23','TAP::Parser::Result'=>'3.23','TAP::Parser::Result::Bailout'=>'3.23','TAP::Parser::Result::Comment'=>'3.23','TAP::Parser::Result::Plan'=>'3.23','TAP::Parser::Result::Pragma'=>'3.23','TAP::Parser::Result::Test'=>'3.23','TAP::Parser::Result::Unknown'=>'3.23','TAP::Parser::Result::Version'=>'3.23','TAP::Parser::Result::YAML'=>'3.23','TAP::Parser::ResultFactory'=>'3.23','TAP::Parser::Scheduler'=>'3.23','TAP::Parser::Scheduler::Job'=>'3.23','TAP::Parser::Scheduler::Spinner'=>'3.23','TAP::Parser::Source'=>'3.23','TAP::Parser::SourceHandler'=>'3.23','TAP::Parser::SourceHandler::Executable'=>'3.23','TAP::Parser::SourceHandler::File'=>'3.23','TAP::Parser::SourceHandler::Handle'=>'3.23','TAP::Parser::SourceHandler::Perl'=>'3.23','TAP::Parser::SourceHandler::RawTAP'=>'3.23','TAP::Parser::Utils'=>'3.23','TAP::Parser::YAMLish::Reader'=>'3.23','TAP::Parser::YAMLish::Writer'=>'3.23','Test::Builder'=>'0.98','Test::Builder::Module'=>'0.98','Test::Builder::Tester'=>'1.22','Test::Builder::Tester::Color'=>'1.22','Test::Harness'=>'3.23','Test::More'=>'0.98','Test::Simple'=>'0.98','Tie::Hash::NamedCapture'=>'0.08','Tie::RefHash'=>'1.39','Unicode::Collate'=>'0.73','Unicode::Collate::Locale'=>'0.73','Unicode::UCD'=>'0.32','XS::Typemap'=>'0.05','attributes'=>'0.14','base'=>'2.16','inc::latest'=>'0.3800','mro'=>'1.07','parent'=>'0.225',},removed=>{}},5.014=>{delta_from=>5.013011,changed=>{'ExtUtils::CBuilder'=>'0.280203','ExtUtils::CBuilder::Base'=>'0.280203','ExtUtils::CBuilder::Platform::Unix'=>'0.280203','ExtUtils::CBuilder::Platform::VMS'=>'0.280203','ExtUtils::CBuilder::Platform::Windows'=>'0.280203','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280203','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280203','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280203','ExtUtils::CBuilder::Platform::aix'=>'0.280203','ExtUtils::CBuilder::Platform::cygwin'=>'0.280203','ExtUtils::CBuilder::Platform::darwin'=>'0.280203','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280203','ExtUtils::CBuilder::Platform::os2'=>'0.280203','ExtUtils::ParseXS'=>'2.2210','File::Basename'=>'2.82','HTTP::Tiny'=>'0.012','IO::Handle'=>'1.31','Module::CoreList'=>'2.49','PerlIO'=>'1.07','Pod::Html'=>'1.11','XS::APItest'=>'0.28','bigint'=>'0.27','bignum'=>'0.27','bigrat'=>'0.28','constant'=>'1.21','feature'=>'1.20','re'=>'0.18','threads::shared'=>'1.37',},removed=>{}},5.014001=>{delta_from=>5.014,changed=>{'B::Deparse'=>'1.04','Module::CoreList'=>'2.49_01','Pod::Perldoc'=>'3.15_04',},removed=>{}},5.014002=>{delta_from=>5.014001,changed=>{'CPAN'=>'1.9600_01','CPAN::Distribution'=>'1.9602_01','Devel::DProf::dprof::V'=>undef,'Encode'=>'2.42_01','File::Glob'=>'1.13','Module::CoreList'=>'2.49_02','PerlIO::scalar'=>'0.11_01','Time::Piece::Seconds'=>undef,},removed=>{}},5.014003=>{delta_from=>5.014002,changed=>{'Digest'=>'1.16_01','IPC::Open3'=>'1.09_01','Module::CoreList'=>'2.49_04',},removed=>{}},5.014004=>{delta_from=>5.014003,changed=>{'Encode'=>'2.42_02','IPC::Open3'=>'1.0901','Module::CoreList'=>'2.49_06',},removed=>{}},5.015=>{delta_from=>5.014001,changed=>{'Archive::Extract'=>'0.52','Attribute::Handlers'=>'0.91','B'=>'1.30','B::Concise'=>'0.84','B::Deparse'=>'1.05','Benchmark'=>'1.13','CGI'=>'3.54','CGI::Util'=>'3.53','CPAN::Meta'=>'2.110930','CPAN::Meta::Converter'=>'2.110930','CPAN::Meta::Feature'=>'2.110930','CPAN::Meta::History'=>'2.110930','CPAN::Meta::Prereqs'=>'2.110930','CPAN::Meta::Spec'=>'2.110930','CPAN::Meta::Validator'=>'2.110930','CPANPLUS'=>'0.9105','CPANPLUS::Dist::Build'=>'0.56','CPANPLUS::Dist::Build::Constants'=>'0.56','CPANPLUS::Internals'=>'0.9105','CPANPLUS::Shell::Default'=>'0.9105','Compress::Raw::Bzip2'=>'2.035','Compress::Raw::Zlib'=>'2.035','Compress::Zlib'=>'2.035','DB_File'=>'1.822','Data::Dumper'=>'2.131','Devel::Peek'=>'1.08','Digest::SHA'=>'5.62','Encode'=>'2.43','Encode::Alias'=>'2.14','ExtUtils::CBuilder'=>'0.280204','ExtUtils::CBuilder::Base'=>'0.280204','Fatal'=>'2.10','File::Spec::Win32'=>'3.34','Filter::Simple'=>'0.87','Filter::Util::Call'=>'1.39','FindBin'=>'1.51','Hash::Util::FieldHash'=>'1.10','I18N::LangTags'=>'0.36','IO::Compress::Adapter::Bzip2'=>'2.035','IO::Compress::Adapter::Deflate'=>'2.035','IO::Compress::Adapter::Identity'=>'2.035','IO::Compress::Base'=>'2.035','IO::Compress::Base::Common'=>'2.035','IO::Compress::Bzip2'=>'2.035','IO::Compress::Deflate'=>'2.035','IO::Compress::Gzip'=>'2.035','IO::Compress::Gzip::Constants'=>'2.035','IO::Compress::RawDeflate'=>'2.035','IO::Compress::Zip'=>'2.035','IO::Compress::Zip::Constants'=>'2.035','IO::Compress::Zlib::Constants'=>'2.035','IO::Compress::Zlib::Extra'=>'2.035','IO::Uncompress::Adapter::Bunzip2'=>'2.035','IO::Uncompress::Adapter::Identity'=>'2.035','IO::Uncompress::Adapter::Inflate'=>'2.035','IO::Uncompress::AnyInflate'=>'2.035','IO::Uncompress::AnyUncompress'=>'2.035','IO::Uncompress::Base'=>'2.035','IO::Uncompress::Bunzip2'=>'2.035','IO::Uncompress::Gunzip'=>'2.035','IO::Uncompress::Inflate'=>'2.035','IO::Uncompress::RawInflate'=>'2.035','IO::Uncompress::Unzip'=>'2.035','IPC::Open2'=>'1.04','IPC::Open3'=>'1.11','JSON::PP'=>'2.27200','Math::BigFloat'=>'1.994','Math::BigInt'=>'1.995','Math::Complex'=>'1.57','Math::Trig'=>'1.21','Module::CoreList'=>'2.51','ODBM_File'=>'1.11','Object::Accessor'=>'0.42','Opcode'=>'1.19','PerlIO::encoding'=>'0.15','PerlIO::scalar'=>'0.12','Pod::Perldoc'=>'3.15_05','Storable'=>'2.28','Sys::Syslog'=>'0.29','Time::HiRes'=>'1.9722','Unicode::Collate'=>'0.76','Unicode::Collate::CJK::Pinyin'=>'0.76','Unicode::Collate::CJK::Stroke'=>'0.76','Unicode::Collate::Locale'=>'0.76','Unicode::Normalize'=>'1.12','XS::APItest'=>'0.29','XSLoader'=>'0.15','autodie'=>'2.10','autodie::exception'=>'2.10','autodie::exception::system'=>'2.10','autodie::hints'=>'2.10','base'=>'2.17','charnames'=>'1.22','constant'=>'1.22','feature'=>'1.21','mro'=>'1.08','overload'=>'1.14','threads::shared'=>'1.38','vmsish'=>'1.03',},removed=>{'Devel::DProf'=>1,'Shell'=>1,}},5.015001=>{delta_from=>5.015,changed=>{'B::Deparse'=>'1.06','CGI'=>'3.55','CPAN::Meta'=>'2.110930001','CPAN::Meta::Converter'=>'2.110930001','CPANPLUS'=>'0.9108','CPANPLUS::Internals'=>'0.9108','CPANPLUS::Shell::Default'=>'0.9108','Carp'=>'1.21','Carp::Heavy'=>'1.21','Compress::Raw::Bzip2'=>'2.037','Compress::Raw::Zlib'=>'2.037','Compress::Zlib'=>'2.037','Cwd'=>'3.37','Env'=>'1.03','ExtUtils::Command::MM'=>'6.58','ExtUtils::Liblist'=>'6.58','ExtUtils::Liblist::Kid'=>'6.58','ExtUtils::MM'=>'6.58','ExtUtils::MM_AIX'=>'6.58','ExtUtils::MM_Any'=>'6.58','ExtUtils::MM_BeOS'=>'6.58','ExtUtils::MM_Cygwin'=>'6.58','ExtUtils::MM_DOS'=>'6.58','ExtUtils::MM_Darwin'=>'6.58','ExtUtils::MM_MacOS'=>'6.58','ExtUtils::MM_NW5'=>'6.58','ExtUtils::MM_OS2'=>'6.58','ExtUtils::MM_QNX'=>'6.58','ExtUtils::MM_UWIN'=>'6.58','ExtUtils::MM_Unix'=>'6.58','ExtUtils::MM_VMS'=>'6.58','ExtUtils::MM_VOS'=>'6.58','ExtUtils::MM_Win32'=>'6.58','ExtUtils::MM_Win95'=>'6.58','ExtUtils::MY'=>'6.58','ExtUtils::MakeMaker'=>'6.58','ExtUtils::MakeMaker::Config'=>'6.58','ExtUtils::Mkbootstrap'=>'6.58','ExtUtils::Mksymlists'=>'6.58','ExtUtils::ParseXS'=>'3.00_01','ExtUtils::ParseXS::Constants'=>undef,'ExtUtils::ParseXS::CountLines'=>undef,'ExtUtils::ParseXS::Utilities'=>undef,'ExtUtils::Typemaps'=>'1.00','ExtUtils::Typemaps::InputMap'=>undef,'ExtUtils::Typemaps::OutputMap'=>undef,'ExtUtils::Typemaps::Type'=>'0.05','ExtUtils::testlib'=>'6.58','File::Basename'=>'2.83','File::Find'=>'1.20','HTTP::Tiny'=>'0.013','I18N::Langinfo'=>'0.08_02','IO::Compress::Adapter::Bzip2'=>'2.037','IO::Compress::Adapter::Deflate'=>'2.037','IO::Compress::Adapter::Identity'=>'2.037','IO::Compress::Base'=>'2.037','IO::Compress::Base::Common'=>'2.037','IO::Compress::Bzip2'=>'2.037','IO::Compress::Deflate'=>'2.037','IO::Compress::Gzip'=>'2.037','IO::Compress::Gzip::Constants'=>'2.037','IO::Compress::RawDeflate'=>'2.037','IO::Compress::Zip'=>'2.037','IO::Compress::Zip::Constants'=>'2.037','IO::Compress::Zlib::Constants'=>'2.037','IO::Compress::Zlib::Extra'=>'2.037','IO::Uncompress::Adapter::Bunzip2'=>'2.037','IO::Uncompress::Adapter::Identity'=>'2.037','IO::Uncompress::Adapter::Inflate'=>'2.037','IO::Uncompress::AnyInflate'=>'2.037','IO::Uncompress::AnyUncompress'=>'2.037','IO::Uncompress::Base'=>'2.037','IO::Uncompress::Bunzip2'=>'2.037','IO::Uncompress::Gunzip'=>'2.037','IO::Uncompress::Inflate'=>'2.037','IO::Uncompress::RawInflate'=>'2.037','IO::Uncompress::Unzip'=>'2.037','IPC::Cmd'=>'0.72','Locale::Codes'=>'3.17','Locale::Codes::Constants'=>'3.17','Locale::Codes::Country'=>'3.17','Locale::Codes::Country_Codes'=>'3.17','Locale::Codes::Currency'=>'3.17','Locale::Codes::Currency_Codes'=>'3.17','Locale::Codes::LangExt'=>'3.17','Locale::Codes::LangExt_Codes'=>'3.17','Locale::Codes::LangVar'=>'3.17','Locale::Codes::LangVar_Codes'=>'3.17','Locale::Codes::Language'=>'3.17','Locale::Codes::Language_Codes'=>'3.17','Locale::Codes::Script'=>'3.17','Locale::Codes::Script_Codes'=>'3.17','Locale::Country'=>'3.17','Locale::Currency'=>'3.17','Locale::Language'=>'3.17','Locale::Script'=>'3.17','Math::BigFloat::Trace'=>'0.28','Math::BigInt::FastCalc'=>'0.29','Math::BigInt::Trace'=>'0.28','Math::BigRat'=>'0.2602','Math::Complex'=>'1.58','Math::Trig'=>'1.22','Module::CoreList'=>'2.54','OS2::Process'=>'1.07','Pod::Perldoc'=>'3.15_06','Pod::Simple'=>'3.18','Pod::Simple::BlackBox'=>'3.18','Pod::Simple::Checker'=>'3.18','Pod::Simple::Debug'=>'3.18','Pod::Simple::DumpAsText'=>'3.18','Pod::Simple::DumpAsXML'=>'3.18','Pod::Simple::HTML'=>'3.18','Pod::Simple::HTMLBatch'=>'3.18','Pod::Simple::LinkSection'=>'3.18','Pod::Simple::Methody'=>'3.18','Pod::Simple::Progress'=>'3.18','Pod::Simple::PullParser'=>'3.18','Pod::Simple::PullParserEndToken'=>'3.18','Pod::Simple::PullParserStartToken'=>'3.18','Pod::Simple::PullParserTextToken'=>'3.18','Pod::Simple::PullParserToken'=>'3.18','Pod::Simple::RTF'=>'3.18','Pod::Simple::Search'=>'3.18','Pod::Simple::SimpleTree'=>'3.18','Pod::Simple::Text'=>'3.18','Pod::Simple::TextContent'=>'3.18','Pod::Simple::TiedOutFH'=>'3.18','Pod::Simple::Transcode'=>'3.18','Pod::Simple::TranscodeDumb'=>'3.18','Pod::Simple::TranscodeSmart'=>'3.18','Pod::Simple::XHTML'=>'3.18','Pod::Simple::XMLOutStream'=>'3.18','Storable'=>'2.31','Sys::Syslog::Win32'=>undef,'Time::HiRes'=>'1.9724','Unicode::Collate'=>'0.77','Unicode::UCD'=>'0.33','Win32API::File'=>'0.1200','XS::APItest'=>'0.30','attributes'=>'0.15','bigint'=>'0.28','bignum'=>'0.28','charnames'=>'1.23','diagnostics'=>'1.23','feature'=>'1.22','overload'=>'1.15','perlfaq'=>'5.015000','threads'=>'1.84','version'=>'0.93',},removed=>{'ExtUtils::MakeMaker::YAML'=>1,'Locale::Constants'=>1,'Sys::Syslog::win32::Win32'=>1,}},5.015002=>{delta_from=>5.015001,changed=>{'Attribute::Handlers'=>'0.92','B'=>'1.31','B::Concise'=>'0.85','B::Deparse'=>'1.07','B::Terse'=>'1.06','B::Xref'=>'1.03','CPAN'=>'1.9800','CPAN::Exception::yaml_process_error'=>'5.5','CPAN::Meta'=>'2.112150','CPAN::Meta::Converter'=>'2.112150','CPAN::Meta::Feature'=>'2.112150','CPAN::Meta::History'=>'2.112150','CPAN::Meta::Prereqs'=>'2.112150','CPAN::Meta::Spec'=>'2.112150','CPAN::Meta::Validator'=>'2.112150','CPANPLUS'=>'0.9109','CPANPLUS::Internals'=>'0.9109','CPANPLUS::Shell::Default'=>'0.9109','DB_File'=>'1.824','Data::Dumper'=>'2.132','Encode'=>'2.44','Encode::Alias'=>'2.15','Encode::Encoder'=>'2.02','Encode::Guess'=>'2.05','ExtUtils::Command::MM'=>'6.59','ExtUtils::Install'=>'1.57','ExtUtils::Installed'=>'1.999002','ExtUtils::Liblist'=>'6.59','ExtUtils::Liblist::Kid'=>'6.59','ExtUtils::MM'=>'6.59','ExtUtils::MM_AIX'=>'6.59','ExtUtils::MM_Any'=>'6.59','ExtUtils::MM_BeOS'=>'6.59','ExtUtils::MM_Cygwin'=>'6.59','ExtUtils::MM_DOS'=>'6.59','ExtUtils::MM_Darwin'=>'6.59','ExtUtils::MM_MacOS'=>'6.59','ExtUtils::MM_NW5'=>'6.59','ExtUtils::MM_OS2'=>'6.59','ExtUtils::MM_QNX'=>'6.59','ExtUtils::MM_UWIN'=>'6.59','ExtUtils::MM_Unix'=>'6.59','ExtUtils::MM_VMS'=>'6.59','ExtUtils::MM_VOS'=>'6.59','ExtUtils::MM_Win32'=>'6.59','ExtUtils::MM_Win95'=>'6.59','ExtUtils::MY'=>'6.59','ExtUtils::MakeMaker'=>'6.59','ExtUtils::MakeMaker::Config'=>'6.59','ExtUtils::Manifest'=>'1.60','ExtUtils::Mkbootstrap'=>'6.59','ExtUtils::Mksymlists'=>'6.59','ExtUtils::ParseXS'=>'3.03_01','ExtUtils::Typemaps'=>'1.01','ExtUtils::testlib'=>'6.59','File::Spec'=>'3.34','File::Spec::Mac'=>'3.35','File::Spec::Unix'=>'3.34','File::Spec::VMS'=>'3.35','File::Spec::Win32'=>'3.35','I18N::LangTags'=>'0.37','IO'=>'1.25_05','IO::Handle'=>'1.32','IO::Socket'=>'1.33','IO::Socket::INET'=>'1.32','IPC::Open3'=>'1.12','Math::BigFloat'=>'1.995','Math::BigFloat::Trace'=>'0.29','Math::BigInt'=>'1.996','Math::BigInt::Trace'=>'0.29','Module::Build'=>'0.39_01','Module::Build::Base'=>'0.39_01','Module::Build::Compat'=>'0.39_01','Module::Build::Config'=>'0.39_01','Module::Build::Cookbook'=>'0.39_01','Module::Build::Dumper'=>'0.39_01','Module::Build::ModuleInfo'=>'0.39_01','Module::Build::Notes'=>'0.39_01','Module::Build::PPMMaker'=>'0.39_01','Module::Build::Platform::Amiga'=>'0.39_01','Module::Build::Platform::Default'=>'0.39_01','Module::Build::Platform::EBCDIC'=>'0.39_01','Module::Build::Platform::MPEiX'=>'0.39_01','Module::Build::Platform::MacOS'=>'0.39_01','Module::Build::Platform::RiscOS'=>'0.39_01','Module::Build::Platform::Unix'=>'0.39_01','Module::Build::Platform::VMS'=>'0.39_01','Module::Build::Platform::VOS'=>'0.39_01','Module::Build::Platform::Windows'=>'0.39_01','Module::Build::Platform::aix'=>'0.39_01','Module::Build::Platform::cygwin'=>'0.39_01','Module::Build::Platform::darwin'=>'0.39_01','Module::Build::Platform::os2'=>'0.39_01','Module::Build::PodParser'=>'0.39_01','Module::CoreList'=>'2.55','Module::Load'=>'0.20','Module::Metadata'=>'1.000005_01','Opcode'=>'1.20','Params::Check'=>'0.32','PerlIO::via'=>'0.12','Term::ANSIColor'=>'3.01','Unicode::Collate'=>'0.78','Unicode::Normalize'=>'1.13','Unicode::UCD'=>'0.34','bigint'=>'0.29','bignum'=>'0.29','bigrat'=>'0.29','diagnostics'=>'1.24','fields'=>'2.16','inc::latest'=>'0.39_01',},removed=>{}},5.015003=>{delta_from=>5.015002,changed=>{'AnyDBM_File'=>'1.01','Archive::Extract'=>'0.56','Archive::Tar'=>'1.78','Archive::Tar::Constant'=>'1.78','Archive::Tar::File'=>'1.78','Attribute::Handlers'=>'0.93','B'=>'1.32','B::Concise'=>'0.86','B::Deparse'=>'1.08','CPAN::Meta'=>'2.112621','CPAN::Meta::Converter'=>'2.112621','CPAN::Meta::Feature'=>'2.112621','CPAN::Meta::History'=>'2.112621','CPAN::Meta::Prereqs'=>'2.112621','CPAN::Meta::Spec'=>'2.112621','CPAN::Meta::Validator'=>'2.112621','CPAN::Meta::YAML'=>'0.004','CPANPLUS'=>'0.9111','CPANPLUS::Dist::Build'=>'0.58','CPANPLUS::Dist::Build::Constants'=>'0.58','CPANPLUS::Internals'=>'0.9111','CPANPLUS::Shell::Default'=>'0.9111','Carp'=>'1.23','Carp::Heavy'=>'1.23','Data::Dumper'=>'2.134','Devel::PPPort'=>'3.20','Errno'=>'1.14','Exporter'=>'5.65','Exporter::Heavy'=>'5.65','ExtUtils::ParseXS'=>'3.04_04','ExtUtils::ParseXS::Constants'=>'3.04_04','ExtUtils::ParseXS::CountLines'=>'3.04_04','ExtUtils::ParseXS::Utilities'=>'3.04_04','ExtUtils::Typemaps'=>'1.02','File::Glob'=>'1.13','Filter::Simple'=>'0.88','IO'=>'1.25_06','IO::Handle'=>'1.33','Locale::Codes'=>'3.18','Locale::Codes::Constants'=>'3.18','Locale::Codes::Country'=>'3.18','Locale::Codes::Country_Codes'=>'3.18','Locale::Codes::Currency'=>'3.18','Locale::Codes::Currency_Codes'=>'3.18','Locale::Codes::LangExt'=>'3.18','Locale::Codes::LangExt_Codes'=>'3.18','Locale::Codes::LangVar'=>'3.18','Locale::Codes::LangVar_Codes'=>'3.18','Locale::Codes::Language'=>'3.18','Locale::Codes::Language_Codes'=>'3.18','Locale::Codes::Script'=>'3.18','Locale::Codes::Script_Codes'=>'3.18','Locale::Country'=>'3.18','Locale::Currency'=>'3.18','Locale::Language'=>'3.18','Locale::Script'=>'3.18','Math::BigFloat'=>'1.997','Math::BigInt'=>'1.997','Math::BigInt::Calc'=>'1.997','Math::BigInt::CalcEmu'=>'1.997','Math::BigInt::FastCalc'=>'0.30','Math::BigRat'=>'0.2603','Module::CoreList'=>'2.56','Module::Load::Conditional'=>'0.46','Module::Metadata'=>'1.000007','ODBM_File'=>'1.12','POSIX'=>'1.26','Pod::Perldoc'=>'3.15_07','Pod::Simple'=>'3.19','Pod::Simple::BlackBox'=>'3.19','Pod::Simple::Checker'=>'3.19','Pod::Simple::Debug'=>'3.19','Pod::Simple::DumpAsText'=>'3.19','Pod::Simple::DumpAsXML'=>'3.19','Pod::Simple::HTML'=>'3.19','Pod::Simple::HTMLBatch'=>'3.19','Pod::Simple::LinkSection'=>'3.19','Pod::Simple::Methody'=>'3.19','Pod::Simple::Progress'=>'3.19','Pod::Simple::PullParser'=>'3.19','Pod::Simple::PullParserEndToken'=>'3.19','Pod::Simple::PullParserStartToken'=>'3.19','Pod::Simple::PullParserTextToken'=>'3.19','Pod::Simple::PullParserToken'=>'3.19','Pod::Simple::RTF'=>'3.19','Pod::Simple::Search'=>'3.19','Pod::Simple::SimpleTree'=>'3.19','Pod::Simple::Text'=>'3.19','Pod::Simple::TextContent'=>'3.19','Pod::Simple::TiedOutFH'=>'3.19','Pod::Simple::Transcode'=>'3.19','Pod::Simple::TranscodeDumb'=>'3.19','Pod::Simple::TranscodeSmart'=>'3.19','Pod::Simple::XHTML'=>'3.19','Pod::Simple::XMLOutStream'=>'3.19','Search::Dict'=>'1.04','Socket'=>'1.94_01','Storable'=>'2.32','Text::Abbrev'=>'1.02','Tie::Array'=>'1.05','UNIVERSAL'=>'1.09','Unicode::UCD'=>'0.35','XS::APItest'=>'0.31','XSLoader'=>'0.16','attributes'=>'0.16','diagnostics'=>'1.25','open'=>'1.09','perlfaq'=>'5.0150034','threads'=>'1.85','threads::shared'=>'1.40',},removed=>{}},5.015004=>{delta_from=>5.015003,changed=>{'Archive::Tar'=>'1.80','Archive::Tar::Constant'=>'1.80','Archive::Tar::File'=>'1.80','Digest'=>'1.17','DynaLoader'=>'1.14','ExtUtils::Command::MM'=>'6.61_01','ExtUtils::Liblist'=>'6.61_01','ExtUtils::Liblist::Kid'=>'6.61_01','ExtUtils::MM'=>'6.61_01','ExtUtils::MM_AIX'=>'6.61_01','ExtUtils::MM_Any'=>'6.61_01','ExtUtils::MM_BeOS'=>'6.61_01','ExtUtils::MM_Cygwin'=>'6.61_01','ExtUtils::MM_DOS'=>'6.61_01','ExtUtils::MM_Darwin'=>'6.61_01','ExtUtils::MM_MacOS'=>'6.61_01','ExtUtils::MM_NW5'=>'6.61_01','ExtUtils::MM_OS2'=>'6.61_01','ExtUtils::MM_QNX'=>'6.61_01','ExtUtils::MM_UWIN'=>'6.61_01','ExtUtils::MM_Unix'=>'6.61_01','ExtUtils::MM_VMS'=>'6.61_01','ExtUtils::MM_VOS'=>'6.61_01','ExtUtils::MM_Win32'=>'6.61_01','ExtUtils::MM_Win95'=>'6.61_01','ExtUtils::MY'=>'6.61_01','ExtUtils::MakeMaker'=>'6.61_01','ExtUtils::MakeMaker::Config'=>'6.61_01','ExtUtils::Mkbootstrap'=>'6.61_01','ExtUtils::Mksymlists'=>'6.61_01','ExtUtils::ParseXS'=>'3.05','ExtUtils::ParseXS::Constants'=>'3.05','ExtUtils::ParseXS::CountLines'=>'3.05','ExtUtils::ParseXS::Utilities'=>'3.05','ExtUtils::testlib'=>'6.61_01','File::DosGlob'=>'1.05','Module::CoreList'=>'2.57','Module::Load'=>'0.22','Unicode::Collate'=>'0.80','Unicode::Collate::Locale'=>'0.80','Unicode::UCD'=>'0.36','XS::APItest'=>'0.32','XS::Typemap'=>'0.07','attributes'=>'0.17','base'=>'2.18','constant'=>'1.23','mro'=>'1.09','open'=>'1.10','perlfaq'=>'5.0150035',},removed=>{}},5.015005=>{delta_from=>5.015004,changed=>{'Archive::Extract'=>'0.58','B::Concise'=>'0.87','B::Deparse'=>'1.09','CGI'=>'3.58','CGI::Fast'=>'1.09','CPANPLUS'=>'0.9112','CPANPLUS::Dist::Build'=>'0.60','CPANPLUS::Dist::Build::Constants'=>'0.60','CPANPLUS::Internals'=>'0.9112','CPANPLUS::Shell::Default'=>'0.9112','Compress::Raw::Bzip2'=>'2.042','Compress::Raw::Zlib'=>'2.042','Compress::Zlib'=>'2.042','Digest::SHA'=>'5.63','Errno'=>'1.15','ExtUtils::Command::MM'=>'6.63_02','ExtUtils::Liblist'=>'6.63_02','ExtUtils::Liblist::Kid'=>'6.63_02','ExtUtils::MM'=>'6.63_02','ExtUtils::MM_AIX'=>'6.63_02','ExtUtils::MM_Any'=>'6.63_02','ExtUtils::MM_BeOS'=>'6.63_02','ExtUtils::MM_Cygwin'=>'6.63_02','ExtUtils::MM_DOS'=>'6.63_02','ExtUtils::MM_Darwin'=>'6.63_02','ExtUtils::MM_MacOS'=>'6.63_02','ExtUtils::MM_NW5'=>'6.63_02','ExtUtils::MM_OS2'=>'6.63_02','ExtUtils::MM_QNX'=>'6.63_02','ExtUtils::MM_UWIN'=>'6.63_02','ExtUtils::MM_Unix'=>'6.63_02','ExtUtils::MM_VMS'=>'6.63_02','ExtUtils::MM_VOS'=>'6.63_02','ExtUtils::MM_Win32'=>'6.63_02','ExtUtils::MM_Win95'=>'6.63_02','ExtUtils::MY'=>'6.63_02','ExtUtils::MakeMaker'=>'6.63_02','ExtUtils::MakeMaker::Config'=>'6.63_02','ExtUtils::Mkbootstrap'=>'6.63_02','ExtUtils::Mksymlists'=>'6.63_02','ExtUtils::testlib'=>'6.63_02','File::DosGlob'=>'1.06','File::Glob'=>'1.14','HTTP::Tiny'=>'0.016','IO::Compress::Adapter::Bzip2'=>'2.042','IO::Compress::Adapter::Deflate'=>'2.042','IO::Compress::Adapter::Identity'=>'2.042','IO::Compress::Base'=>'2.042','IO::Compress::Base::Common'=>'2.042','IO::Compress::Bzip2'=>'2.042','IO::Compress::Deflate'=>'2.042','IO::Compress::Gzip'=>'2.042','IO::Compress::Gzip::Constants'=>'2.042','IO::Compress::RawDeflate'=>'2.042','IO::Compress::Zip'=>'2.042','IO::Compress::Zip::Constants'=>'2.042','IO::Compress::Zlib::Constants'=>'2.042','IO::Compress::Zlib::Extra'=>'2.042','IO::Uncompress::Adapter::Bunzip2'=>'2.042','IO::Uncompress::Adapter::Identity'=>'2.042','IO::Uncompress::Adapter::Inflate'=>'2.042','IO::Uncompress::AnyInflate'=>'2.042','IO::Uncompress::AnyUncompress'=>'2.042','IO::Uncompress::Base'=>'2.042','IO::Uncompress::Bunzip2'=>'2.042','IO::Uncompress::Gunzip'=>'2.042','IO::Uncompress::Inflate'=>'2.042','IO::Uncompress::RawInflate'=>'2.042','IO::Uncompress::Unzip'=>'2.042','Locale::Maketext'=>'1.20','Locale::Maketext::Guts'=>'1.20','Locale::Maketext::GutsLoader'=>'1.20','Module::CoreList'=>'2.58','Opcode'=>'1.21','Socket'=>'1.94_02','Storable'=>'2.33','UNIVERSAL'=>'1.10','Unicode::Collate'=>'0.85','Unicode::Collate::CJK::Pinyin'=>'0.85','Unicode::Collate::CJK::Stroke'=>'0.85','Unicode::Collate::Locale'=>'0.85','Unicode::UCD'=>'0.37','XS::APItest'=>'0.33','arybase'=>'0.01','charnames'=>'1.24','feature'=>'1.23','perlfaq'=>'5.0150036','strict'=>'1.05','unicore::Name'=>undef,},removed=>{}},5.015006=>{delta_from=>5.015005,changed=>{'Archive::Tar'=>'1.82','Archive::Tar::Constant'=>'1.82','Archive::Tar::File'=>'1.82','AutoLoader'=>'5.72','B::Concise'=>'0.88','B::Debug'=>'1.17','B::Deparse'=>'1.10','CPAN::Meta::YAML'=>'0.005','CPANPLUS'=>'0.9113','CPANPLUS::Internals'=>'0.9113','CPANPLUS::Shell::Default'=>'0.9113','Carp'=>'1.24','Compress::Raw::Bzip2'=>'2.045','Compress::Raw::Zlib'=>'2.045','Compress::Zlib'=>'2.045','Cwd'=>'3.38','DB'=>'1.04','Data::Dumper'=>'2.135_01','Digest::SHA'=>'5.70','Dumpvalue'=>'1.17','Exporter'=>'5.66','Exporter::Heavy'=>'5.66','ExtUtils::CBuilder'=>'0.280205','ExtUtils::CBuilder::Platform::os2'=>'0.280204','ExtUtils::Packlist'=>'1.45','ExtUtils::ParseXS'=>'3.08','ExtUtils::ParseXS::Constants'=>'3.08','ExtUtils::ParseXS::CountLines'=>'3.08','ExtUtils::ParseXS::Utilities'=>'3.08','File::Basename'=>'2.84','File::Glob'=>'1.15','File::Spec::Unix'=>'3.35','Getopt::Std'=>'1.07','I18N::LangTags'=>'0.38','IO::Compress::Adapter::Bzip2'=>'2.045','IO::Compress::Adapter::Deflate'=>'2.045','IO::Compress::Adapter::Identity'=>'2.045','IO::Compress::Base'=>'2.046','IO::Compress::Base::Common'=>'2.045','IO::Compress::Bzip2'=>'2.045','IO::Compress::Deflate'=>'2.045','IO::Compress::Gzip'=>'2.045','IO::Compress::Gzip::Constants'=>'2.045','IO::Compress::RawDeflate'=>'2.045','IO::Compress::Zip'=>'2.046','IO::Compress::Zip::Constants'=>'2.045','IO::Compress::Zlib::Constants'=>'2.045','IO::Compress::Zlib::Extra'=>'2.045','IO::Dir'=>'1.09','IO::File'=>'1.16','IO::Uncompress::Adapter::Bunzip2'=>'2.045','IO::Uncompress::Adapter::Identity'=>'2.045','IO::Uncompress::Adapter::Inflate'=>'2.045','IO::Uncompress::AnyInflate'=>'2.045','IO::Uncompress::AnyUncompress'=>'2.045','IO::Uncompress::Base'=>'2.046','IO::Uncompress::Bunzip2'=>'2.045','IO::Uncompress::Gunzip'=>'2.045','IO::Uncompress::Inflate'=>'2.045','IO::Uncompress::RawInflate'=>'2.045','IO::Uncompress::Unzip'=>'2.046','Locale::Codes'=>'3.20','Locale::Codes::Constants'=>'3.20','Locale::Codes::Country'=>'3.20','Locale::Codes::Country_Codes'=>'3.20','Locale::Codes::Country_Retired'=>'3.20','Locale::Codes::Currency'=>'3.20','Locale::Codes::Currency_Codes'=>'3.20','Locale::Codes::Currency_Retired'=>'3.20','Locale::Codes::LangExt'=>'3.20','Locale::Codes::LangExt_Codes'=>'3.20','Locale::Codes::LangExt_Retired'=>'3.20','Locale::Codes::LangFam'=>'3.20','Locale::Codes::LangFam_Codes'=>'3.20','Locale::Codes::LangFam_Retired'=>'3.20','Locale::Codes::LangVar'=>'3.20','Locale::Codes::LangVar_Codes'=>'3.20','Locale::Codes::LangVar_Retired'=>'3.20','Locale::Codes::Language'=>'3.20','Locale::Codes::Language_Codes'=>'3.20','Locale::Codes::Language_Retired'=>'3.20','Locale::Codes::Script'=>'3.20','Locale::Codes::Script_Codes'=>'3.20','Locale::Codes::Script_Retired'=>'3.20','Locale::Country'=>'3.20','Locale::Currency'=>'3.20','Locale::Language'=>'3.20','Locale::Maketext'=>'1.21','Locale::Script'=>'3.20','Module::CoreList'=>'2.59','Module::Loaded'=>'0.08','Opcode'=>'1.22','POSIX'=>'1.27','Pod::Html'=>'1.12','Pod::LaTeX'=>'0.60','Pod::Perldoc'=>'3.15_08','Safe'=>'2.30','SelfLoader'=>'1.20','Socket'=>'1.97','Storable'=>'2.34','UNIVERSAL'=>'1.11','Unicode::Collate'=>'0.87','Unicode::Collate::Locale'=>'0.87','XS::APItest'=>'0.34','arybase'=>'0.02','charnames'=>'1.27','diagnostics'=>'1.26','feature'=>'1.24','if'=>'0.0602','overload'=>'1.16','sigtrap'=>'1.06','strict'=>'1.06','threads'=>'1.86','version'=>'0.96',},removed=>{}},5.015007=>{delta_from=>5.015006,changed=>{'B'=>'1.33','B::Deparse'=>'1.11','CGI'=>'3.59','CPAN::Meta'=>'2.113640','CPAN::Meta::Converter'=>'2.113640','CPAN::Meta::Feature'=>'2.113640','CPAN::Meta::History'=>'2.113640','CPAN::Meta::Prereqs'=>'2.113640','CPAN::Meta::Requirements'=>'2.113640','CPAN::Meta::Spec'=>'2.113640','CPAN::Meta::Validator'=>'2.113640','CPANPLUS'=>'0.9116','CPANPLUS::Internals'=>'0.9116','CPANPLUS::Shell::Default'=>'0.9116','Cwd'=>'3.39_01','Data::Dumper'=>'2.135_03','Devel::InnerPackage'=>'0.4','ExtUtils::CBuilder::Base'=>'0.280205','ExtUtils::CBuilder::Platform::Unix'=>'0.280205','ExtUtils::CBuilder::Platform::VMS'=>'0.280205','ExtUtils::CBuilder::Platform::Windows'=>'0.280205','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280205','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280205','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280205','ExtUtils::CBuilder::Platform::aix'=>'0.280205','ExtUtils::CBuilder::Platform::cygwin'=>'0.280205','ExtUtils::CBuilder::Platform::darwin'=>'0.280205','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280205','ExtUtils::CBuilder::Platform::os2'=>'0.280205','ExtUtils::Manifest'=>'1.61','ExtUtils::Packlist'=>'1.46','ExtUtils::ParseXS'=>'3.12','ExtUtils::ParseXS::Constants'=>'3.12','ExtUtils::ParseXS::CountLines'=>'3.12','ExtUtils::ParseXS::Utilities'=>'3.12','ExtUtils::Typemaps'=>'1.03','ExtUtils::Typemaps::Cmd'=>undef,'ExtUtils::Typemaps::Type'=>'0.06','File::Glob'=>'1.16','File::Spec'=>'3.39_01','File::Spec::Cygwin'=>'3.39_01','File::Spec::Epoc'=>'3.39_01','File::Spec::Functions'=>'3.39_01','File::Spec::Mac'=>'3.39_01','File::Spec::OS2'=>'3.39_01','File::Spec::Unix'=>'3.39_01','File::Spec::VMS'=>'3.39_01','File::Spec::Win32'=>'3.39_01','IO::Dir'=>'1.10','IO::Pipe'=>'1.15','IO::Poll'=>'0.09','IO::Select'=>'1.21','IO::Socket'=>'1.34','IO::Socket::INET'=>'1.33','IO::Socket::UNIX'=>'1.24','Locale::Maketext'=>'1.22','Math::BigInt'=>'1.998','Module::CoreList'=>'2.60','Module::Pluggable'=>'4.0','POSIX'=>'1.28','PerlIO::scalar'=>'0.13','Pod::Html'=>'1.13','Pod::Perldoc'=>'3.15_15','Pod::Perldoc::BaseTo'=>'3.15_15','Pod::Perldoc::GetOptsOO'=>'3.15_15','Pod::Perldoc::ToANSI'=>'3.15_15','Pod::Perldoc::ToChecker'=>'3.15_15','Pod::Perldoc::ToMan'=>'3.15_15','Pod::Perldoc::ToNroff'=>'3.15_15','Pod::Perldoc::ToPod'=>'3.15_15','Pod::Perldoc::ToRtf'=>'3.15_15','Pod::Perldoc::ToTerm'=>'3.15_15','Pod::Perldoc::ToText'=>'3.15_15','Pod::Perldoc::ToTk'=>'3.15_15','Pod::Perldoc::ToXml'=>'3.15_15','Term::UI'=>'0.30','Tie::File'=>'0.98','Unicode::UCD'=>'0.39','Version::Requirements'=>'0.101021','XS::APItest'=>'0.35','_charnames'=>'1.28','arybase'=>'0.03','autouse'=>'1.07','charnames'=>'1.28','diagnostics'=>'1.27','feature'=>'1.25','overload'=>'1.17','overloading'=>'0.02','perlfaq'=>'5.0150038',},removed=>{}},5.015008=>{delta_from=>5.015007,changed=>{'B'=>'1.34','B::Deparse'=>'1.12','CPAN::Meta'=>'2.120351','CPAN::Meta::Converter'=>'2.120351','CPAN::Meta::Feature'=>'2.120351','CPAN::Meta::History'=>'2.120351','CPAN::Meta::Prereqs'=>'2.120351','CPAN::Meta::Requirements'=>'2.120351','CPAN::Meta::Spec'=>'2.120351','CPAN::Meta::Validator'=>'2.120351','CPAN::Meta::YAML'=>'0.007','CPANPLUS'=>'0.9118','CPANPLUS::Dist::Build'=>'0.62','CPANPLUS::Dist::Build::Constants'=>'0.62','CPANPLUS::Internals'=>'0.9118','CPANPLUS::Shell::Default'=>'0.9118','Carp'=>'1.25','Carp::Heavy'=>'1.25','Compress::Raw::Bzip2'=>'2.048','Compress::Raw::Zlib'=>'2.048','Compress::Zlib'=>'2.048','Cwd'=>'3.39_02','DB_File'=>'1.826','Data::Dumper'=>'2.135_05','English'=>'1.05','ExtUtils::Install'=>'1.58','ExtUtils::ParseXS'=>'3.16','ExtUtils::ParseXS::Constants'=>'3.16','ExtUtils::ParseXS::CountLines'=>'3.16','ExtUtils::ParseXS::Utilities'=>'3.16','ExtUtils::Typemaps'=>'3.16','ExtUtils::Typemaps::Cmd'=>'3.16','ExtUtils::Typemaps::InputMap'=>'3.16','ExtUtils::Typemaps::OutputMap'=>'3.16','ExtUtils::Typemaps::Type'=>'3.16','File::Copy'=>'2.23','File::Glob'=>'1.17','File::Spec'=>'3.39_02','File::Spec::Cygwin'=>'3.39_02','File::Spec::Epoc'=>'3.39_02','File::Spec::Functions'=>'3.39_02','File::Spec::Mac'=>'3.39_02','File::Spec::OS2'=>'3.39_02','File::Spec::Unix'=>'3.39_02','File::Spec::VMS'=>'3.39_02','File::Spec::Win32'=>'3.39_02','Filter::Util::Call'=>'1.40','IO::Compress::Adapter::Bzip2'=>'2.048','IO::Compress::Adapter::Deflate'=>'2.048','IO::Compress::Adapter::Identity'=>'2.048','IO::Compress::Base'=>'2.048','IO::Compress::Base::Common'=>'2.048','IO::Compress::Bzip2'=>'2.048','IO::Compress::Deflate'=>'2.048','IO::Compress::Gzip'=>'2.048','IO::Compress::Gzip::Constants'=>'2.048','IO::Compress::RawDeflate'=>'2.048','IO::Compress::Zip'=>'2.048','IO::Compress::Zip::Constants'=>'2.048','IO::Compress::Zlib::Constants'=>'2.048','IO::Compress::Zlib::Extra'=>'2.048','IO::Uncompress::Adapter::Bunzip2'=>'2.048','IO::Uncompress::Adapter::Identity'=>'2.048','IO::Uncompress::Adapter::Inflate'=>'2.048','IO::Uncompress::AnyInflate'=>'2.048','IO::Uncompress::AnyUncompress'=>'2.048','IO::Uncompress::Base'=>'2.048','IO::Uncompress::Bunzip2'=>'2.048','IO::Uncompress::Gunzip'=>'2.048','IO::Uncompress::Inflate'=>'2.048','IO::Uncompress::RawInflate'=>'2.048','IO::Uncompress::Unzip'=>'2.048','IPC::Cmd'=>'0.76','Math::Complex'=>'1.59','Math::Trig'=>'1.23','Module::Metadata'=>'1.000009','Opcode'=>'1.23','POSIX'=>'1.30','Parse::CPAN::Meta'=>'1.4402','PerlIO::mmap'=>'0.010','Pod::Checker'=>'1.51','Pod::Find'=>'1.51','Pod::Functions'=>'1.05','Pod::Html'=>'1.14','Pod::InputObjects'=>'1.51','Pod::ParseUtils'=>'1.51','Pod::Parser'=>'1.51','Pod::PlainText'=>'2.05','Pod::Select'=>'1.51','Pod::Usage'=>'1.51','Safe'=>'2.31','Socket'=>'1.98','Term::Cap'=>'1.13','Term::ReadLine'=>'1.08','Time::HiRes'=>'1.9725','Unicode'=>'6.1.0','Unicode::UCD'=>'0.41','Version::Requirements'=>'0.101022','XS::APItest'=>'0.36','XS::Typemap'=>'0.08','_charnames'=>'1.29','arybase'=>'0.04','charnames'=>'1.29','diagnostics'=>'1.28','feature'=>'1.26','locale'=>'1.01','overload'=>'1.18','perlfaq'=>'5.0150039','re'=>'0.19','subs'=>'1.01','warnings'=>'1.13',},removed=>{}},5.015009=>{delta_from=>5.015008,changed=>{'B::Deparse'=>'1.13','B::Lint'=>'1.14','B::Lint::Debug'=>'1.14','CPAN::Meta'=>'2.120630','CPAN::Meta::Converter'=>'2.120630','CPAN::Meta::Feature'=>'2.120630','CPAN::Meta::History'=>'2.120630','CPAN::Meta::Prereqs'=>'2.120630','CPAN::Meta::Requirements'=>'2.120630','CPAN::Meta::Spec'=>'2.120630','CPAN::Meta::Validator'=>'2.120630','CPANPLUS'=>'0.9121','CPANPLUS::Internals'=>'0.9121','CPANPLUS::Shell::Default'=>'0.9121','Data::Dumper'=>'2.135_06','Digest::SHA'=>'5.71','ExtUtils::CBuilder'=>'0.280206','ExtUtils::CBuilder::Base'=>'0.280206','ExtUtils::CBuilder::Platform::Unix'=>'0.280206','ExtUtils::CBuilder::Platform::VMS'=>'0.280206','ExtUtils::CBuilder::Platform::Windows'=>'0.280206','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280206','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280206','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280206','ExtUtils::CBuilder::Platform::aix'=>'0.280206','ExtUtils::CBuilder::Platform::cygwin'=>'0.280206','ExtUtils::CBuilder::Platform::darwin'=>'0.280206','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280206','ExtUtils::CBuilder::Platform::os2'=>'0.280206','HTTP::Tiny'=>'0.017','Locale::Codes'=>'3.21','Locale::Codes::Constants'=>'3.21','Locale::Codes::Country'=>'3.21','Locale::Codes::Country_Codes'=>'3.21','Locale::Codes::Country_Retired'=>'3.21','Locale::Codes::Currency'=>'3.21','Locale::Codes::Currency_Codes'=>'3.21','Locale::Codes::Currency_Retired'=>'3.21','Locale::Codes::LangExt'=>'3.21','Locale::Codes::LangExt_Codes'=>'3.21','Locale::Codes::LangExt_Retired'=>'3.21','Locale::Codes::LangFam'=>'3.21','Locale::Codes::LangFam_Codes'=>'3.21','Locale::Codes::LangFam_Retired'=>'3.21','Locale::Codes::LangVar'=>'3.21','Locale::Codes::LangVar_Codes'=>'3.21','Locale::Codes::LangVar_Retired'=>'3.21','Locale::Codes::Language'=>'3.21','Locale::Codes::Language_Codes'=>'3.21','Locale::Codes::Language_Retired'=>'3.21','Locale::Codes::Script'=>'3.21','Locale::Codes::Script_Codes'=>'3.21','Locale::Codes::Script_Retired'=>'3.21','Locale::Country'=>'3.21','Locale::Currency'=>'3.21','Locale::Language'=>'3.21','Locale::Script'=>'3.21','Module::CoreList'=>'2.65','Pod::Html'=>'1.1501','Pod::Perldoc'=>'3.17','Pod::Perldoc::BaseTo'=>'3.17','Pod::Perldoc::GetOptsOO'=>'3.17','Pod::Perldoc::ToANSI'=>'3.17','Pod::Perldoc::ToChecker'=>'3.17','Pod::Perldoc::ToMan'=>'3.17','Pod::Perldoc::ToNroff'=>'3.17','Pod::Perldoc::ToPod'=>'3.17','Pod::Perldoc::ToRtf'=>'3.17','Pod::Perldoc::ToTerm'=>'3.17','Pod::Perldoc::ToText'=>'3.17','Pod::Perldoc::ToTk'=>'3.17','Pod::Perldoc::ToXml'=>'3.17','Pod::Simple'=>'3.20','Pod::Simple::BlackBox'=>'3.20','Pod::Simple::Checker'=>'3.20','Pod::Simple::Debug'=>'3.20','Pod::Simple::DumpAsText'=>'3.20','Pod::Simple::DumpAsXML'=>'3.20','Pod::Simple::HTML'=>'3.20','Pod::Simple::HTMLBatch'=>'3.20','Pod::Simple::LinkSection'=>'3.20','Pod::Simple::Methody'=>'3.20','Pod::Simple::Progress'=>'3.20','Pod::Simple::PullParser'=>'3.20','Pod::Simple::PullParserEndToken'=>'3.20','Pod::Simple::PullParserStartToken'=>'3.20','Pod::Simple::PullParserTextToken'=>'3.20','Pod::Simple::PullParserToken'=>'3.20','Pod::Simple::RTF'=>'3.20','Pod::Simple::Search'=>'3.20','Pod::Simple::SimpleTree'=>'3.20','Pod::Simple::Text'=>'3.20','Pod::Simple::TextContent'=>'3.20','Pod::Simple::TiedOutFH'=>'3.20','Pod::Simple::Transcode'=>'3.20','Pod::Simple::TranscodeDumb'=>'3.20','Pod::Simple::TranscodeSmart'=>'3.20','Pod::Simple::XHTML'=>'3.20','Pod::Simple::XMLOutStream'=>'3.20','Socket'=>'2.000','Term::ReadLine'=>'1.09','Unicode::Collate'=>'0.89','Unicode::Collate::CJK::Korean'=>'0.88','Unicode::Collate::Locale'=>'0.89','Unicode::Normalize'=>'1.14','Unicode::UCD'=>'0.42','XS::APItest'=>'0.37','arybase'=>'0.05','attributes'=>'0.18','charnames'=>'1.30','feature'=>'1.27',},removed=>{}},5.016=>{delta_from=>5.015009,changed=>{'B::Concise'=>'0.89','B::Deparse'=>'1.14','Carp'=>'1.26','Carp::Heavy'=>'1.26','IO::Socket'=>'1.35','Module::CoreList'=>'2.66','PerlIO::scalar'=>'0.14','Pod::Html'=>'1.1502','Safe'=>'2.31_01','Socket'=>'2.001','Unicode::UCD'=>'0.43','XS::APItest'=>'0.38','_charnames'=>'1.31','attributes'=>'0.19','strict'=>'1.07','version'=>'0.99',},removed=>{}},5.016001=>{delta_from=>5.016,changed=>{'B'=>'1.35','B::Deparse'=>'1.14_01','List::Util'=>'1.25','List::Util::PP'=>'1.25','List::Util::XS'=>'1.25','Module::CoreList'=>'2.70','PerlIO::scalar'=>'0.14_01','Scalar::Util'=>'1.25','Scalar::Util::PP'=>'1.25','re'=>'0.19_01',},removed=>{}},5.016002=>{delta_from=>5.016001,changed=>{'Module::CoreList'=>'2.76',},removed=>{}},5.016003=>{delta_from=>5.016002,changed=>{'Encode'=>'2.44_01','Module::CoreList'=>'2.76_02','XS::APItest'=>'0.39',},removed=>{}},5.017=>{delta_from=>5.016,changed=>{'B'=>'1.35','B::Concise'=>'0.90','ExtUtils::ParseXS'=>'3.17','ExtUtils::ParseXS::Utilities'=>'3.17','File::DosGlob'=>'1.07','File::Find'=>'1.21','File::stat'=>'1.06','Hash::Util'=>'0.12','IO::Socket'=>'1.34','Module::CoreList'=>'2.67','Pod::Functions'=>'1.06','Storable'=>'2.35','XS::APItest'=>'0.39','diagnostics'=>'1.29','feature'=>'1.28','overload'=>'1.19','utf8'=>'1.10',},removed=>{'Version::Requirements'=>1,}},5.017001=>{delta_from=>5.017,changed=>{'App::Prove'=>'3.25','App::Prove::State'=>'3.25','App::Prove::State::Result'=>'3.25','App::Prove::State::Result::Test'=>'3.25','Archive::Extract'=>'0.60','Archive::Tar'=>'1.88','Archive::Tar::Constant'=>'1.88','Archive::Tar::File'=>'1.88','B'=>'1.36','B::Deparse'=>'1.15','CPAN::Meta'=>'2.120921','CPAN::Meta::Converter'=>'2.120921','CPAN::Meta::Feature'=>'2.120921','CPAN::Meta::History'=>'2.120921','CPAN::Meta::Prereqs'=>'2.120921','CPAN::Meta::Requirements'=>'2.122','CPAN::Meta::Spec'=>'2.120921','CPAN::Meta::Validator'=>'2.120921','CPAN::Meta::YAML'=>'0.008','CPANPLUS'=>'0.9130','CPANPLUS::Config::HomeEnv'=>'0.04','CPANPLUS::Internals'=>'0.9130','CPANPLUS::Shell::Default'=>'0.9130','Class::Struct'=>'0.64','Compress::Raw::Bzip2'=>'2.052','Compress::Raw::Zlib'=>'2.054','Compress::Zlib'=>'2.052','Digest::MD5'=>'2.52','DynaLoader'=>'1.15','ExtUtils::CBuilder'=>'0.280208','ExtUtils::CBuilder::Base'=>'0.280208','ExtUtils::CBuilder::Platform::Unix'=>'0.280208','ExtUtils::CBuilder::Platform::VMS'=>'0.280208','ExtUtils::CBuilder::Platform::Windows'=>'0.280208','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280208','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280208','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280208','ExtUtils::CBuilder::Platform::aix'=>'0.280208','ExtUtils::CBuilder::Platform::cygwin'=>'0.280208','ExtUtils::CBuilder::Platform::darwin'=>'0.280208','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280208','ExtUtils::CBuilder::Platform::os2'=>'0.280208','Fatal'=>'2.11','File::DosGlob'=>'1.08','File::Fetch'=>'0.34','File::Spec::Unix'=>'3.39_03','Filter::Util::Call'=>'1.45','HTTP::Tiny'=>'0.022','IO'=>'1.25_07','IO::Compress::Adapter::Bzip2'=>'2.052','IO::Compress::Adapter::Deflate'=>'2.052','IO::Compress::Adapter::Identity'=>'2.052','IO::Compress::Base'=>'2.052','IO::Compress::Base::Common'=>'2.052','IO::Compress::Bzip2'=>'2.052','IO::Compress::Deflate'=>'2.052','IO::Compress::Gzip'=>'2.052','IO::Compress::Gzip::Constants'=>'2.052','IO::Compress::RawDeflate'=>'2.052','IO::Compress::Zip'=>'2.052','IO::Compress::Zip::Constants'=>'2.052','IO::Compress::Zlib::Constants'=>'2.052','IO::Compress::Zlib::Extra'=>'2.052','IO::Uncompress::Adapter::Bunzip2'=>'2.052','IO::Uncompress::Adapter::Identity'=>'2.052','IO::Uncompress::Adapter::Inflate'=>'2.052','IO::Uncompress::AnyInflate'=>'2.052','IO::Uncompress::AnyUncompress'=>'2.052','IO::Uncompress::Base'=>'2.052','IO::Uncompress::Bunzip2'=>'2.052','IO::Uncompress::Gunzip'=>'2.052','IO::Uncompress::Inflate'=>'2.052','IO::Uncompress::RawInflate'=>'2.052','IO::Uncompress::Unzip'=>'2.052','IPC::Cmd'=>'0.78','List::Util'=>'1.25','List::Util::XS'=>'1.25','Locale::Codes'=>'3.22','Locale::Codes::Constants'=>'3.22','Locale::Codes::Country'=>'3.22','Locale::Codes::Country_Codes'=>'3.22','Locale::Codes::Country_Retired'=>'3.22','Locale::Codes::Currency'=>'3.22','Locale::Codes::Currency_Codes'=>'3.22','Locale::Codes::Currency_Retired'=>'3.22','Locale::Codes::LangExt'=>'3.22','Locale::Codes::LangExt_Codes'=>'3.22','Locale::Codes::LangExt_Retired'=>'3.22','Locale::Codes::LangFam'=>'3.22','Locale::Codes::LangFam_Codes'=>'3.22','Locale::Codes::LangFam_Retired'=>'3.22','Locale::Codes::LangVar'=>'3.22','Locale::Codes::LangVar_Codes'=>'3.22','Locale::Codes::LangVar_Retired'=>'3.22','Locale::Codes::Language'=>'3.22','Locale::Codes::Language_Codes'=>'3.22','Locale::Codes::Language_Retired'=>'3.22','Locale::Codes::Script'=>'3.22','Locale::Codes::Script_Codes'=>'3.22','Locale::Codes::Script_Retired'=>'3.22','Locale::Country'=>'3.22','Locale::Currency'=>'3.22','Locale::Language'=>'3.22','Locale::Script'=>'3.22','Memoize'=>'1.03','Memoize::AnyDBM_File'=>'1.03','Memoize::Expire'=>'1.03','Memoize::ExpireFile'=>'1.03','Memoize::ExpireTest'=>'1.03','Memoize::NDBM_File'=>'1.03','Memoize::SDBM_File'=>'1.03','Memoize::Storable'=>'1.03','Module::Build'=>'0.40','Module::Build::Base'=>'0.40','Module::Build::Compat'=>'0.40','Module::Build::Config'=>'0.40','Module::Build::Cookbook'=>'0.40','Module::Build::Dumper'=>'0.40','Module::Build::ModuleInfo'=>'0.40','Module::Build::Notes'=>'0.40','Module::Build::PPMMaker'=>'0.40','Module::Build::Platform::Amiga'=>'0.40','Module::Build::Platform::Default'=>'0.40','Module::Build::Platform::EBCDIC'=>'0.40','Module::Build::Platform::MPEiX'=>'0.40','Module::Build::Platform::MacOS'=>'0.40','Module::Build::Platform::RiscOS'=>'0.40','Module::Build::Platform::Unix'=>'0.40','Module::Build::Platform::VMS'=>'0.40','Module::Build::Platform::VOS'=>'0.40','Module::Build::Platform::Windows'=>'0.40','Module::Build::Platform::aix'=>'0.40','Module::Build::Platform::cygwin'=>'0.40','Module::Build::Platform::darwin'=>'0.40','Module::Build::Platform::os2'=>'0.40','Module::Build::PodParser'=>'0.40','Module::CoreList'=>'2.68','Module::Load::Conditional'=>'0.50','Object::Accessor'=>'0.44','POSIX'=>'1.31','Params::Check'=>'0.36','Parse::CPAN::Meta'=>'1.4404','PerlIO::mmap'=>'0.011','PerlIO::via::QuotedPrint'=>'0.07','Pod::Html'=>'1.16','Pod::Man'=>'2.26','Pod::Text'=>'3.16','Safe'=>'2.33_01','Scalar::Util'=>'1.25','Search::Dict'=>'1.07','Storable'=>'2.36','TAP::Base'=>'3.25','TAP::Formatter::Base'=>'3.25','TAP::Formatter::Color'=>'3.25','TAP::Formatter::Console'=>'3.25','TAP::Formatter::Console::ParallelSession'=>'3.25','TAP::Formatter::Console::Session'=>'3.25','TAP::Formatter::File'=>'3.25','TAP::Formatter::File::Session'=>'3.25','TAP::Formatter::Session'=>'3.25','TAP::Harness'=>'3.25','TAP::Object'=>'3.25','TAP::Parser'=>'3.25','TAP::Parser::Aggregator'=>'3.25','TAP::Parser::Grammar'=>'3.25','TAP::Parser::Iterator'=>'3.25','TAP::Parser::Iterator::Array'=>'3.25','TAP::Parser::Iterator::Process'=>'3.25','TAP::Parser::Iterator::Stream'=>'3.25','TAP::Parser::IteratorFactory'=>'3.25','TAP::Parser::Multiplexer'=>'3.25','TAP::Parser::Result'=>'3.25','TAP::Parser::Result::Bailout'=>'3.25','TAP::Parser::Result::Comment'=>'3.25','TAP::Parser::Result::Plan'=>'3.25','TAP::Parser::Result::Pragma'=>'3.25','TAP::Parser::Result::Test'=>'3.25','TAP::Parser::Result::Unknown'=>'3.25','TAP::Parser::Result::Version'=>'3.25','TAP::Parser::Result::YAML'=>'3.25','TAP::Parser::ResultFactory'=>'3.25','TAP::Parser::Scheduler'=>'3.25','TAP::Parser::Scheduler::Job'=>'3.25','TAP::Parser::Scheduler::Spinner'=>'3.25','TAP::Parser::Source'=>'3.25','TAP::Parser::SourceHandler'=>'3.25','TAP::Parser::SourceHandler::Executable'=>'3.25','TAP::Parser::SourceHandler::File'=>'3.25','TAP::Parser::SourceHandler::Handle'=>'3.25','TAP::Parser::SourceHandler::Perl'=>'3.25','TAP::Parser::SourceHandler::RawTAP'=>'3.25','TAP::Parser::Utils'=>'3.25','TAP::Parser::YAMLish::Reader'=>'3.25','TAP::Parser::YAMLish::Writer'=>'3.25','Term::ANSIColor'=>'3.02','Test::Harness'=>'3.25','Unicode'=>'6.2.0','Unicode::UCD'=>'0.44','XS::APItest'=>'0.40','_charnames'=>'1.32','attributes'=>'0.2','autodie'=>'2.11','autodie::exception'=>'2.11','autodie::exception::system'=>'2.11','autodie::hints'=>'2.11','bigint'=>'0.30','charnames'=>'1.32','feature'=>'1.29','inc::latest'=>'0.40','perlfaq'=>'5.0150040','re'=>'0.20',},removed=>{'List::Util::PP'=>1,'Scalar::Util::PP'=>1,}},5.017002=>{delta_from=>5.017001,changed=>{'App::Prove'=>'3.25_01','App::Prove::State'=>'3.25_01','App::Prove::State::Result'=>'3.25_01','App::Prove::State::Result::Test'=>'3.25_01','B::Concise'=>'0.91','Compress::Raw::Bzip2'=>'2.05201','Compress::Raw::Zlib'=>'2.05401','Exporter'=>'5.67','Exporter::Heavy'=>'5.67','Fatal'=>'2.12','File::Fetch'=>'0.36','File::stat'=>'1.07','IO'=>'1.25_08','IO::Socket'=>'1.35','Module::CoreList'=>'2.69','PerlIO::scalar'=>'0.15','Socket'=>'2.002','Storable'=>'2.37','TAP::Base'=>'3.25_01','TAP::Formatter::Base'=>'3.25_01','TAP::Formatter::Color'=>'3.25_01','TAP::Formatter::Console'=>'3.25_01','TAP::Formatter::Console::ParallelSession'=>'3.25_01','TAP::Formatter::Console::Session'=>'3.25_01','TAP::Formatter::File'=>'3.25_01','TAP::Formatter::File::Session'=>'3.25_01','TAP::Formatter::Session'=>'3.25_01','TAP::Harness'=>'3.25_01','TAP::Object'=>'3.25_01','TAP::Parser'=>'3.25_01','TAP::Parser::Aggregator'=>'3.25_01','TAP::Parser::Grammar'=>'3.25_01','TAP::Parser::Iterator'=>'3.25_01','TAP::Parser::Iterator::Array'=>'3.25_01','TAP::Parser::Iterator::Process'=>'3.25_01','TAP::Parser::Iterator::Stream'=>'3.25_01','TAP::Parser::IteratorFactory'=>'3.25_01','TAP::Parser::Multiplexer'=>'3.25_01','TAP::Parser::Result'=>'3.25_01','TAP::Parser::Result::Bailout'=>'3.25_01','TAP::Parser::Result::Comment'=>'3.25_01','TAP::Parser::Result::Plan'=>'3.25_01','TAP::Parser::Result::Pragma'=>'3.25_01','TAP::Parser::Result::Test'=>'3.25_01','TAP::Parser::Result::Unknown'=>'3.25_01','TAP::Parser::Result::Version'=>'3.25_01','TAP::Parser::Result::YAML'=>'3.25_01','TAP::Parser::ResultFactory'=>'3.25_01','TAP::Parser::Scheduler'=>'3.25_01','TAP::Parser::Scheduler::Job'=>'3.25_01','TAP::Parser::Scheduler::Spinner'=>'3.25_01','TAP::Parser::Source'=>'3.25_01','TAP::Parser::SourceHandler'=>'3.25_01','TAP::Parser::SourceHandler::Executable'=>'3.25_01','TAP::Parser::SourceHandler::File'=>'3.25_01','TAP::Parser::SourceHandler::Handle'=>'3.25_01','TAP::Parser::SourceHandler::Perl'=>'3.25_01','TAP::Parser::SourceHandler::RawTAP'=>'3.25_01','TAP::Parser::Utils'=>'3.25_01','TAP::Parser::YAMLish::Reader'=>'3.25_01','TAP::Parser::YAMLish::Writer'=>'3.25_01','Test::Harness'=>'3.25_01','Tie::StdHandle'=>'4.3','XS::APItest'=>'0.41','autodie'=>'2.12','autodie::exception'=>'2.12','autodie::exception::system'=>'2.12','autodie::hints'=>'2.12','diagnostics'=>'1.30','overload'=>'1.20','re'=>'0.21','vars'=>'1.03',},removed=>{}},5.017003=>{delta_from=>5.017002,changed=>{'B'=>'1.37','B::Concise'=>'0.92','B::Debug'=>'1.18','B::Deparse'=>'1.16','CGI'=>'3.60','Compress::Raw::Bzip2'=>'2.055','Compress::Raw::Zlib'=>'2.056','Compress::Zlib'=>'2.055','Data::Dumper'=>'2.135_07','Devel::Peek'=>'1.09','Encode'=>'2.47','Encode::Alias'=>'2.16','Encode::GSM0338'=>'2.02','Encode::Unicode::UTF7'=>'2.06','IO::Compress::Adapter::Bzip2'=>'2.055','IO::Compress::Adapter::Deflate'=>'2.055','IO::Compress::Adapter::Identity'=>'2.055','IO::Compress::Base'=>'2.055','IO::Compress::Base::Common'=>'2.055','IO::Compress::Bzip2'=>'2.055','IO::Compress::Deflate'=>'2.055','IO::Compress::Gzip'=>'2.055','IO::Compress::Gzip::Constants'=>'2.055','IO::Compress::RawDeflate'=>'2.055','IO::Compress::Zip'=>'2.055','IO::Compress::Zip::Constants'=>'2.055','IO::Compress::Zlib::Constants'=>'2.055','IO::Compress::Zlib::Extra'=>'2.055','IO::Uncompress::Adapter::Bunzip2'=>'2.055','IO::Uncompress::Adapter::Identity'=>'2.055','IO::Uncompress::Adapter::Inflate'=>'2.055','IO::Uncompress::AnyInflate'=>'2.055','IO::Uncompress::AnyUncompress'=>'2.055','IO::Uncompress::Base'=>'2.055','IO::Uncompress::Bunzip2'=>'2.055','IO::Uncompress::Gunzip'=>'2.055','IO::Uncompress::Inflate'=>'2.055','IO::Uncompress::RawInflate'=>'2.055','IO::Uncompress::Unzip'=>'2.055','Module::Build'=>'0.4003','Module::Build::Base'=>'0.4003','Module::Build::Compat'=>'0.4003','Module::Build::Config'=>'0.4003','Module::Build::Cookbook'=>'0.4003','Module::Build::Dumper'=>'0.4003','Module::Build::ModuleInfo'=>'0.4003','Module::Build::Notes'=>'0.4003','Module::Build::PPMMaker'=>'0.4003','Module::Build::Platform::Amiga'=>'0.4003','Module::Build::Platform::Default'=>'0.4003','Module::Build::Platform::EBCDIC'=>'0.4003','Module::Build::Platform::MPEiX'=>'0.4003','Module::Build::Platform::MacOS'=>'0.4003','Module::Build::Platform::RiscOS'=>'0.4003','Module::Build::Platform::Unix'=>'0.4003','Module::Build::Platform::VMS'=>'0.4003','Module::Build::Platform::VOS'=>'0.4003','Module::Build::Platform::Windows'=>'0.4003','Module::Build::Platform::aix'=>'0.4003','Module::Build::Platform::cygwin'=>'0.4003','Module::Build::Platform::darwin'=>'0.4003','Module::Build::Platform::os2'=>'0.4003','Module::Build::PodParser'=>'0.4003','Module::CoreList'=>'2.71','Module::CoreList::TieHashDelta'=>'2.71','Module::Load::Conditional'=>'0.54','Module::Metadata'=>'1.000011','Module::Pluggable'=>'4.3','Module::Pluggable::Object'=>'4.3','Pod::Simple'=>'3.23','Pod::Simple::BlackBox'=>'3.23','Pod::Simple::Checker'=>'3.23','Pod::Simple::Debug'=>'3.23','Pod::Simple::DumpAsText'=>'3.23','Pod::Simple::DumpAsXML'=>'3.23','Pod::Simple::HTML'=>'3.23','Pod::Simple::HTMLBatch'=>'3.23','Pod::Simple::LinkSection'=>'3.23','Pod::Simple::Methody'=>'3.23','Pod::Simple::Progress'=>'3.23','Pod::Simple::PullParser'=>'3.23','Pod::Simple::PullParserEndToken'=>'3.23','Pod::Simple::PullParserStartToken'=>'3.23','Pod::Simple::PullParserTextToken'=>'3.23','Pod::Simple::PullParserToken'=>'3.23','Pod::Simple::RTF'=>'3.23','Pod::Simple::Search'=>'3.23','Pod::Simple::SimpleTree'=>'3.23','Pod::Simple::Text'=>'3.23','Pod::Simple::TextContent'=>'3.23','Pod::Simple::TiedOutFH'=>'3.23','Pod::Simple::Transcode'=>'3.23','Pod::Simple::TranscodeDumb'=>'3.23','Pod::Simple::TranscodeSmart'=>'3.23','Pod::Simple::XHTML'=>'3.23','Pod::Simple::XMLOutStream'=>'3.23','Socket'=>'2.004','Storable'=>'2.38','Sys::Syslog'=>'0.31','Term::ReadLine'=>'1.10','Text::Tabs'=>'2012.0818','Text::Wrap'=>'2012.0818','Time::Local'=>'1.2300','Unicode::UCD'=>'0.45','Win32'=>'0.45','Win32CORE'=>'0.03','XS::APItest'=>'0.42','inc::latest'=>'0.4003','perlfaq'=>'5.0150041','re'=>'0.22',},removed=>{}},5.017004=>{delta_from=>5.017003,changed=>{'Archive::Tar'=>'1.90','Archive::Tar::Constant'=>'1.90','Archive::Tar::File'=>'1.90','B'=>'1.38','B::Concise'=>'0.93','B::Deparse'=>'1.17','B::Xref'=>'1.04','CPANPLUS'=>'0.9131','CPANPLUS::Internals'=>'0.9131','CPANPLUS::Shell::Default'=>'0.9131','DB_File'=>'1.827','Devel::Peek'=>'1.10','DynaLoader'=>'1.16','Errno'=>'1.16','ExtUtils::ParseXS'=>'3.18','ExtUtils::ParseXS::Constants'=>'3.18','ExtUtils::ParseXS::CountLines'=>'3.18','ExtUtils::ParseXS::Utilities'=>'3.18','File::Copy'=>'2.24','File::Find'=>'1.22','IPC::Open3'=>'1.13','Locale::Codes'=>'3.23','Locale::Codes::Constants'=>'3.23','Locale::Codes::Country'=>'3.23','Locale::Codes::Country_Codes'=>'3.23','Locale::Codes::Country_Retired'=>'3.23','Locale::Codes::Currency'=>'3.23','Locale::Codes::Currency_Codes'=>'3.23','Locale::Codes::Currency_Retired'=>'3.23','Locale::Codes::LangExt'=>'3.23','Locale::Codes::LangExt_Codes'=>'3.23','Locale::Codes::LangExt_Retired'=>'3.23','Locale::Codes::LangFam'=>'3.23','Locale::Codes::LangFam_Codes'=>'3.23','Locale::Codes::LangFam_Retired'=>'3.23','Locale::Codes::LangVar'=>'3.23','Locale::Codes::LangVar_Codes'=>'3.23','Locale::Codes::LangVar_Retired'=>'3.23','Locale::Codes::Language'=>'3.23','Locale::Codes::Language_Codes'=>'3.23','Locale::Codes::Language_Retired'=>'3.23','Locale::Codes::Script'=>'3.23','Locale::Codes::Script_Codes'=>'3.23','Locale::Codes::Script_Retired'=>'3.23','Locale::Country'=>'3.23','Locale::Currency'=>'3.23','Locale::Language'=>'3.23','Locale::Script'=>'3.23','Math::BigFloat::Trace'=>'0.30','Math::BigInt::Trace'=>'0.30','Module::CoreList'=>'2.73','Module::CoreList::TieHashDelta'=>'2.73','Opcode'=>'1.24','Socket'=>'2.006','Storable'=>'2.39','Sys::Syslog'=>'0.32','Unicode::UCD'=>'0.46','XS::APItest'=>'0.43','bignum'=>'0.30','bigrat'=>'0.30','constant'=>'1.24','feature'=>'1.30','threads::shared'=>'1.41','version'=>'0.9901','warnings'=>'1.14',},removed=>{}},5.017005=>{delta_from=>5.017004,changed=>{'AutoLoader'=>'5.73','B'=>'1.39','B::Deparse'=>'1.18','CPANPLUS'=>'0.9133','CPANPLUS::Internals'=>'0.9133','CPANPLUS::Shell::Default'=>'0.9133','Carp'=>'1.27','Carp::Heavy'=>'1.27','Data::Dumper'=>'2.136','Digest::SHA'=>'5.72','ExtUtils::CBuilder'=>'0.280209','ExtUtils::CBuilder::Base'=>'0.280209','ExtUtils::CBuilder::Platform::Unix'=>'0.280209','ExtUtils::CBuilder::Platform::VMS'=>'0.280209','ExtUtils::CBuilder::Platform::Windows'=>'0.280209','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280209','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280209','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280209','ExtUtils::CBuilder::Platform::aix'=>'0.280209','ExtUtils::CBuilder::Platform::cygwin'=>'0.280209','ExtUtils::CBuilder::Platform::darwin'=>'0.280209','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280209','ExtUtils::CBuilder::Platform::os2'=>'0.280209','File::Copy'=>'2.25','File::Glob'=>'1.18','HTTP::Tiny'=>'0.024','Module::CoreList'=>'2.75','Module::CoreList::TieHashDelta'=>'2.75','PerlIO::encoding'=>'0.16','Unicode::Collate'=>'0.90','Unicode::Collate::Locale'=>'0.90','Unicode::Normalize'=>'1.15','Win32CORE'=>'0.04','XS::APItest'=>'0.44','attributes'=>'0.21','bigint'=>'0.31','bignum'=>'0.31','bigrat'=>'0.31','feature'=>'1.31','threads::shared'=>'1.42','warnings'=>'1.15',},removed=>{}},5.017006=>{delta_from=>5.017005,changed=>{'B'=>'1.40','B::Concise'=>'0.94','B::Deparse'=>'1.19','B::Xref'=>'1.05','CGI'=>'3.63','CGI::Util'=>'3.62','CPAN'=>'1.99_51','CPANPLUS::Dist::Build'=>'0.64','CPANPLUS::Dist::Build::Constants'=>'0.64','Carp'=>'1.28','Carp::Heavy'=>'1.28','Compress::Raw::Bzip2'=>'2.058','Compress::Raw::Zlib'=>'2.058','Compress::Zlib'=>'2.058','Data::Dumper'=>'2.137','Digest::SHA'=>'5.73','DynaLoader'=>'1.17','Env'=>'1.04','Errno'=>'1.17','ExtUtils::Manifest'=>'1.62','ExtUtils::Typemaps'=>'3.18','ExtUtils::Typemaps::Cmd'=>'3.18','ExtUtils::Typemaps::InputMap'=>'3.18','ExtUtils::Typemaps::OutputMap'=>'3.18','ExtUtils::Typemaps::Type'=>'3.18','Fatal'=>'2.13','File::Find'=>'1.23','Hash::Util'=>'0.13','IO::Compress::Adapter::Bzip2'=>'2.058','IO::Compress::Adapter::Deflate'=>'2.058','IO::Compress::Adapter::Identity'=>'2.058','IO::Compress::Base'=>'2.058','IO::Compress::Base::Common'=>'2.058','IO::Compress::Bzip2'=>'2.058','IO::Compress::Deflate'=>'2.058','IO::Compress::Gzip'=>'2.058','IO::Compress::Gzip::Constants'=>'2.058','IO::Compress::RawDeflate'=>'2.058','IO::Compress::Zip'=>'2.058','IO::Compress::Zip::Constants'=>'2.058','IO::Compress::Zlib::Constants'=>'2.058','IO::Compress::Zlib::Extra'=>'2.058','IO::Uncompress::Adapter::Bunzip2'=>'2.058','IO::Uncompress::Adapter::Identity'=>'2.058','IO::Uncompress::Adapter::Inflate'=>'2.058','IO::Uncompress::AnyInflate'=>'2.058','IO::Uncompress::AnyUncompress'=>'2.058','IO::Uncompress::Base'=>'2.058','IO::Uncompress::Bunzip2'=>'2.058','IO::Uncompress::Gunzip'=>'2.058','IO::Uncompress::Inflate'=>'2.058','IO::Uncompress::RawInflate'=>'2.058','IO::Uncompress::Unzip'=>'2.058','Module::CoreList'=>'2.78','Module::CoreList::TieHashDelta'=>'2.77','Module::Pluggable'=>'4.5','Module::Pluggable::Object'=>'4.5','Opcode'=>'1.25','Sys::Hostname'=>'1.17','Term::UI'=>'0.32','Thread::Queue'=>'3.01','Tie::Hash::NamedCapture'=>'0.09','Unicode::Collate'=>'0.93','Unicode::Collate::CJK::Korean'=>'0.93','Unicode::Collate::Locale'=>'0.93','Unicode::Normalize'=>'1.16','Unicode::UCD'=>'0.47','XS::APItest'=>'0.46','_charnames'=>'1.33','autodie'=>'2.13','autodie::exception'=>'2.13','autodie::exception::system'=>'2.13','autodie::hints'=>'2.13','charnames'=>'1.33','re'=>'0.23',},removed=>{}},5.017007=>{delta_from=>5.017006,changed=>{'B'=>'1.41','CPANPLUS::Dist::Build'=>'0.68','CPANPLUS::Dist::Build::Constants'=>'0.68','Compress::Raw::Bzip2'=>'2.059','Compress::Raw::Zlib'=>'2.059','Compress::Zlib'=>'2.059','Cwd'=>'3.39_03','Data::Dumper'=>'2.139','Devel::Peek'=>'1.11','Digest::SHA'=>'5.80','DynaLoader'=>'1.18','English'=>'1.06','Errno'=>'1.18','ExtUtils::Command::MM'=>'6.64','ExtUtils::Liblist'=>'6.64','ExtUtils::Liblist::Kid'=>'6.64','ExtUtils::MM'=>'6.64','ExtUtils::MM_AIX'=>'6.64','ExtUtils::MM_Any'=>'6.64','ExtUtils::MM_BeOS'=>'6.64','ExtUtils::MM_Cygwin'=>'6.64','ExtUtils::MM_DOS'=>'6.64','ExtUtils::MM_Darwin'=>'6.64','ExtUtils::MM_MacOS'=>'6.64','ExtUtils::MM_NW5'=>'6.64','ExtUtils::MM_OS2'=>'6.64','ExtUtils::MM_QNX'=>'6.64','ExtUtils::MM_UWIN'=>'6.64','ExtUtils::MM_Unix'=>'6.64','ExtUtils::MM_VMS'=>'6.64','ExtUtils::MM_VOS'=>'6.64','ExtUtils::MM_Win32'=>'6.64','ExtUtils::MM_Win95'=>'6.64','ExtUtils::MY'=>'6.64','ExtUtils::MakeMaker'=>'6.64','ExtUtils::MakeMaker::Config'=>'6.64','ExtUtils::Mkbootstrap'=>'6.64','ExtUtils::Mksymlists'=>'6.64','ExtUtils::testlib'=>'6.64','File::DosGlob'=>'1.09','File::Glob'=>'1.19','GDBM_File'=>'1.15','IO::Compress::Adapter::Bzip2'=>'2.059','IO::Compress::Adapter::Deflate'=>'2.059','IO::Compress::Adapter::Identity'=>'2.059','IO::Compress::Base'=>'2.059','IO::Compress::Base::Common'=>'2.059','IO::Compress::Bzip2'=>'2.059','IO::Compress::Deflate'=>'2.059','IO::Compress::Gzip'=>'2.059','IO::Compress::Gzip::Constants'=>'2.059','IO::Compress::RawDeflate'=>'2.059','IO::Compress::Zip'=>'2.059','IO::Compress::Zip::Constants'=>'2.059','IO::Compress::Zlib::Constants'=>'2.059','IO::Compress::Zlib::Extra'=>'2.059','IO::Uncompress::Adapter::Bunzip2'=>'2.059','IO::Uncompress::Adapter::Identity'=>'2.059','IO::Uncompress::Adapter::Inflate'=>'2.059','IO::Uncompress::AnyInflate'=>'2.059','IO::Uncompress::AnyUncompress'=>'2.059','IO::Uncompress::Base'=>'2.059','IO::Uncompress::Bunzip2'=>'2.059','IO::Uncompress::Gunzip'=>'2.059','IO::Uncompress::Inflate'=>'2.059','IO::Uncompress::RawInflate'=>'2.059','IO::Uncompress::Unzip'=>'2.059','List::Util'=>'1.26','List::Util::XS'=>'1.26','Locale::Codes'=>'3.24','Locale::Codes::Constants'=>'3.24','Locale::Codes::Country'=>'3.24','Locale::Codes::Country_Codes'=>'3.24','Locale::Codes::Country_Retired'=>'3.24','Locale::Codes::Currency'=>'3.24','Locale::Codes::Currency_Codes'=>'3.24','Locale::Codes::Currency_Retired'=>'3.24','Locale::Codes::LangExt'=>'3.24','Locale::Codes::LangExt_Codes'=>'3.24','Locale::Codes::LangExt_Retired'=>'3.24','Locale::Codes::LangFam'=>'3.24','Locale::Codes::LangFam_Codes'=>'3.24','Locale::Codes::LangFam_Retired'=>'3.24','Locale::Codes::LangVar'=>'3.24','Locale::Codes::LangVar_Codes'=>'3.24','Locale::Codes::LangVar_Retired'=>'3.24','Locale::Codes::Language'=>'3.24','Locale::Codes::Language_Codes'=>'3.24','Locale::Codes::Language_Retired'=>'3.24','Locale::Codes::Script'=>'3.24','Locale::Codes::Script_Codes'=>'3.24','Locale::Codes::Script_Retired'=>'3.24','Locale::Country'=>'3.24','Locale::Currency'=>'3.24','Locale::Language'=>'3.24','Locale::Maketext'=>'1.23','Locale::Script'=>'3.24','Module::CoreList'=>'2.79','Module::CoreList::TieHashDelta'=>'2.79','POSIX'=>'1.32','Scalar::Util'=>'1.26','Socket'=>'2.006_001','Storable'=>'2.40','Term::ReadLine'=>'1.11','Unicode::Collate'=>'0.96','Unicode::Collate::CJK::Stroke'=>'0.94','Unicode::Collate::CJK::Zhuyin'=>'0.94','Unicode::Collate::Locale'=>'0.96','XS::APItest'=>'0.48','XS::Typemap'=>'0.09','_charnames'=>'1.34','charnames'=>'1.34','feature'=>'1.32','mro'=>'1.10','sigtrap'=>'1.07','sort'=>'2.02',},removed=>{}},5.017008=>{delta_from=>5.017007,changed=>{'Archive::Extract'=>'0.62','B'=>'1.42','B::Concise'=>'0.95','Compress::Raw::Bzip2'=>'2.060','Compress::Raw::Zlib'=>'2.060','Compress::Zlib'=>'2.060','Cwd'=>'3.40','Data::Dumper'=>'2.141','Digest::SHA'=>'5.81','ExtUtils::Install'=>'1.59','File::Fetch'=>'0.38','File::Path'=>'2.09','File::Spec'=>'3.40','File::Spec::Cygwin'=>'3.40','File::Spec::Epoc'=>'3.40','File::Spec::Functions'=>'3.40','File::Spec::Mac'=>'3.40','File::Spec::OS2'=>'3.40','File::Spec::Unix'=>'3.40','File::Spec::VMS'=>'3.40','File::Spec::Win32'=>'3.40','HTTP::Tiny'=>'0.025','Hash::Util'=>'0.14','I18N::LangTags'=>'0.39','I18N::LangTags::List'=>'0.39','I18N::Langinfo'=>'0.09','IO'=>'1.26','IO::Compress::Adapter::Bzip2'=>'2.060','IO::Compress::Adapter::Deflate'=>'2.060','IO::Compress::Adapter::Identity'=>'2.060','IO::Compress::Base'=>'2.060','IO::Compress::Base::Common'=>'2.060','IO::Compress::Bzip2'=>'2.060','IO::Compress::Deflate'=>'2.060','IO::Compress::Gzip'=>'2.060','IO::Compress::Gzip::Constants'=>'2.060','IO::Compress::RawDeflate'=>'2.060','IO::Compress::Zip'=>'2.060','IO::Compress::Zip::Constants'=>'2.060','IO::Compress::Zlib::Constants'=>'2.060','IO::Compress::Zlib::Extra'=>'2.060','IO::Uncompress::Adapter::Bunzip2'=>'2.060','IO::Uncompress::Adapter::Identity'=>'2.060','IO::Uncompress::Adapter::Inflate'=>'2.060','IO::Uncompress::AnyInflate'=>'2.060','IO::Uncompress::AnyUncompress'=>'2.060','IO::Uncompress::Base'=>'2.060','IO::Uncompress::Bunzip2'=>'2.060','IO::Uncompress::Gunzip'=>'2.060','IO::Uncompress::Inflate'=>'2.060','IO::Uncompress::RawInflate'=>'2.060','IO::Uncompress::Unzip'=>'2.060','List::Util'=>'1.27','List::Util::XS'=>'1.27','Module::CoreList'=>'2.80','Module::CoreList::TieHashDelta'=>'2.80','Pod::Html'=>'1.17','Pod::LaTeX'=>'0.61','Pod::Man'=>'2.27','Pod::Text'=>'3.17','Pod::Text::Color'=>'2.07','Pod::Text::Overstrike'=>'2.05','Pod::Text::Termcap'=>'2.07','Safe'=>'2.34','Scalar::Util'=>'1.27','Socket'=>'2.009','Term::ANSIColor'=>'4.02','Test'=>'1.26','Unicode::Collate'=>'0.97','XS::APItest'=>'0.51','XS::Typemap'=>'0.10','_charnames'=>'1.35','charnames'=>'1.35','constant'=>'1.25','diagnostics'=>'1.31','threads::shared'=>'1.43','warnings'=>'1.16',},removed=>{}},5.017009=>{delta_from=>5.017008,changed=>{'App::Cpan'=>'1.60_02','App::Prove'=>'3.26','App::Prove::State'=>'3.26','App::Prove::State::Result'=>'3.26','App::Prove::State::Result::Test'=>'3.26','Archive::Extract'=>'0.68','Attribute::Handlers'=>'0.94','B::Lint'=>'1.17','B::Lint::Debug'=>'1.17','Benchmark'=>'1.14','CPAN'=>'2.00','CPAN::Distribution'=>'2.00','CPAN::FirstTime'=>'5.5304','CPAN::Nox'=>'5.5001','CPANPLUS'=>'0.9135','CPANPLUS::Backend'=>'0.9135','CPANPLUS::Backend::RV'=>'0.9135','CPANPLUS::Config'=>'0.9135','CPANPLUS::Config::HomeEnv'=>'0.9135','CPANPLUS::Configure'=>'0.9135','CPANPLUS::Configure::Setup'=>'0.9135','CPANPLUS::Dist'=>'0.9135','CPANPLUS::Dist::Autobundle'=>'0.9135','CPANPLUS::Dist::Base'=>'0.9135','CPANPLUS::Dist::Build'=>'0.70','CPANPLUS::Dist::Build::Constants'=>'0.70','CPANPLUS::Dist::MM'=>'0.9135','CPANPLUS::Dist::Sample'=>'0.9135','CPANPLUS::Error'=>'0.9135','CPANPLUS::Internals'=>'0.9135','CPANPLUS::Internals::Constants'=>'0.9135','CPANPLUS::Internals::Constants::Report'=>'0.9135','CPANPLUS::Internals::Extract'=>'0.9135','CPANPLUS::Internals::Fetch'=>'0.9135','CPANPLUS::Internals::Report'=>'0.9135','CPANPLUS::Internals::Search'=>'0.9135','CPANPLUS::Internals::Source'=>'0.9135','CPANPLUS::Internals::Source::Memory'=>'0.9135','CPANPLUS::Internals::Source::SQLite'=>'0.9135','CPANPLUS::Internals::Source::SQLite::Tie'=>'0.9135','CPANPLUS::Internals::Utils'=>'0.9135','CPANPLUS::Internals::Utils::Autoflush'=>'0.9135','CPANPLUS::Module'=>'0.9135','CPANPLUS::Module::Author'=>'0.9135','CPANPLUS::Module::Author::Fake'=>'0.9135','CPANPLUS::Module::Checksums'=>'0.9135','CPANPLUS::Module::Fake'=>'0.9135','CPANPLUS::Module::Signature'=>'0.9135','CPANPLUS::Selfupdate'=>'0.9135','CPANPLUS::Shell'=>'0.9135','CPANPLUS::Shell::Classic'=>'0.9135','CPANPLUS::Shell::Default'=>'0.9135','CPANPLUS::Shell::Default::Plugins::CustomSource'=>'0.9135','CPANPLUS::Shell::Default::Plugins::Remote'=>'0.9135','CPANPLUS::Shell::Default::Plugins::Source'=>'0.9135','Config'=>'5.017009','Config::Perl::V'=>'0.17','DBM_Filter'=>'0.05','Data::Dumper'=>'2.142','Digest::SHA'=>'5.82','Encode'=>'2.48','ExtUtils::Installed'=>'1.999003','ExtUtils::Manifest'=>'1.63','ExtUtils::ParseXS::Utilities'=>'3.19','ExtUtils::Typemaps'=>'3.19','File::CheckTree'=>'4.42','File::DosGlob'=>'1.10','File::Temp'=>'0.22_90','Filter::Simple'=>'0.89','IO'=>'1.27','Log::Message'=>'0.06','Log::Message::Config'=>'0.06','Log::Message::Handlers'=>'0.06','Log::Message::Item'=>'0.06','Log::Message::Simple'=>'0.10','Math::BigInt'=>'1.999','Module::CoreList'=>'2.82','Module::CoreList::TieHashDelta'=>'2.82','Module::Load'=>'0.24','Module::Pluggable'=>'4.6','Module::Pluggable::Object'=>'4.6','OS2::DLL'=>'1.05','OS2::ExtAttr'=>'0.03','OS2::Process'=>'1.08','Object::Accessor'=>'0.46','PerlIO::scalar'=>'0.16','Pod::Checker'=>'1.60','Pod::Find'=>'1.60','Pod::Html'=>'1.18','Pod::InputObjects'=>'1.60','Pod::ParseUtils'=>'1.60','Pod::Parser'=>'1.60','Pod::Perldoc'=>'3.19','Pod::Perldoc::BaseTo'=>'3.19','Pod::Perldoc::GetOptsOO'=>'3.19','Pod::Perldoc::ToANSI'=>'3.19','Pod::Perldoc::ToChecker'=>'3.19','Pod::Perldoc::ToMan'=>'3.19','Pod::Perldoc::ToNroff'=>'3.19','Pod::Perldoc::ToPod'=>'3.19','Pod::Perldoc::ToRtf'=>'3.19','Pod::Perldoc::ToTerm'=>'3.19','Pod::Perldoc::ToText'=>'3.19','Pod::Perldoc::ToTk'=>'3.19','Pod::Perldoc::ToXml'=>'3.19','Pod::PlainText'=>'2.06','Pod::Select'=>'1.60','Pod::Usage'=>'1.61','SelfLoader'=>'1.21','TAP::Base'=>'3.26','TAP::Formatter::Base'=>'3.26','TAP::Formatter::Color'=>'3.26','TAP::Formatter::Console'=>'3.26','TAP::Formatter::Console::ParallelSession'=>'3.26','TAP::Formatter::Console::Session'=>'3.26','TAP::Formatter::File'=>'3.26','TAP::Formatter::File::Session'=>'3.26','TAP::Formatter::Session'=>'3.26','TAP::Harness'=>'3.26','TAP::Object'=>'3.26','TAP::Parser'=>'3.26','TAP::Parser::Aggregator'=>'3.26','TAP::Parser::Grammar'=>'3.26','TAP::Parser::Iterator'=>'3.26','TAP::Parser::Iterator::Array'=>'3.26','TAP::Parser::Iterator::Process'=>'3.26','TAP::Parser::Iterator::Stream'=>'3.26','TAP::Parser::IteratorFactory'=>'3.26','TAP::Parser::Multiplexer'=>'3.26','TAP::Parser::Result'=>'3.26','TAP::Parser::Result::Bailout'=>'3.26','TAP::Parser::Result::Comment'=>'3.26','TAP::Parser::Result::Plan'=>'3.26','TAP::Parser::Result::Pragma'=>'3.26','TAP::Parser::Result::Test'=>'3.26','TAP::Parser::Result::Unknown'=>'3.26','TAP::Parser::Result::Version'=>'3.26','TAP::Parser::Result::YAML'=>'3.26','TAP::Parser::ResultFactory'=>'3.26','TAP::Parser::Scheduler'=>'3.26','TAP::Parser::Scheduler::Job'=>'3.26','TAP::Parser::Scheduler::Spinner'=>'3.26','TAP::Parser::Source'=>'3.26','TAP::Parser::SourceHandler'=>'3.26','TAP::Parser::SourceHandler::Executable'=>'3.26','TAP::Parser::SourceHandler::File'=>'3.26','TAP::Parser::SourceHandler::Handle'=>'3.26','TAP::Parser::SourceHandler::Perl'=>'3.26','TAP::Parser::SourceHandler::RawTAP'=>'3.26','TAP::Parser::Utils'=>'3.26','TAP::Parser::YAMLish::Reader'=>'3.26','TAP::Parser::YAMLish::Writer'=>'3.26','Term::UI'=>'0.34','Test::Harness'=>'3.26','Text::Soundex'=>'3.04','Thread::Queue'=>'3.02','Unicode::UCD'=>'0.50','Win32'=>'0.46','Win32API::File'=>'0.1201','_charnames'=>'1.36','arybase'=>'0.06','bigint'=>'0.32','bignum'=>'0.32','charnames'=>'1.36','filetest'=>'1.03','locale'=>'1.02','overload'=>'1.21','warnings'=>'1.17',},removed=>{}},5.017010=>{delta_from=>5.017009,changed=>{'Benchmark'=>'1.15','Config'=>'5.017009','Data::Dumper'=>'2.145','Digest::SHA'=>'5.84','Encode'=>'2.49','ExtUtils::Command::MM'=>'6.65_01','ExtUtils::Liblist'=>'6.65_01','ExtUtils::Liblist::Kid'=>'6.65_01','ExtUtils::MM'=>'6.65_01','ExtUtils::MM_AIX'=>'6.65_01','ExtUtils::MM_Any'=>'6.65_01','ExtUtils::MM_BeOS'=>'6.65_01','ExtUtils::MM_Cygwin'=>'6.65_01','ExtUtils::MM_DOS'=>'6.65_01','ExtUtils::MM_Darwin'=>'6.65_01','ExtUtils::MM_MacOS'=>'6.65_01','ExtUtils::MM_NW5'=>'6.65_01','ExtUtils::MM_OS2'=>'6.65_01','ExtUtils::MM_QNX'=>'6.65_01','ExtUtils::MM_UWIN'=>'6.65_01','ExtUtils::MM_Unix'=>'6.65_01','ExtUtils::MM_VMS'=>'6.65_01','ExtUtils::MM_VOS'=>'6.65_01','ExtUtils::MM_Win32'=>'6.65_01','ExtUtils::MM_Win95'=>'6.65_01','ExtUtils::MY'=>'6.65_01','ExtUtils::MakeMaker'=>'6.65_01','ExtUtils::MakeMaker::Config'=>'6.65_01','ExtUtils::Mkbootstrap'=>'6.65_01','ExtUtils::Mksymlists'=>'6.65_01','ExtUtils::testlib'=>'6.65_01','File::Copy'=>'2.26','File::Temp'=>'0.23','Getopt::Long'=>'2.39','Hash::Util'=>'0.15','I18N::Langinfo'=>'0.10','IPC::Cmd'=>'0.80','JSON::PP'=>'2.27202','Locale::Codes'=>'3.25','Locale::Codes::Constants'=>'3.25','Locale::Codes::Country'=>'3.25','Locale::Codes::Country_Codes'=>'3.25','Locale::Codes::Country_Retired'=>'3.25','Locale::Codes::Currency'=>'3.25','Locale::Codes::Currency_Codes'=>'3.25','Locale::Codes::Currency_Retired'=>'3.25','Locale::Codes::LangExt'=>'3.25','Locale::Codes::LangExt_Codes'=>'3.25','Locale::Codes::LangExt_Retired'=>'3.25','Locale::Codes::LangFam'=>'3.25','Locale::Codes::LangFam_Codes'=>'3.25','Locale::Codes::LangFam_Retired'=>'3.25','Locale::Codes::LangVar'=>'3.25','Locale::Codes::LangVar_Codes'=>'3.25','Locale::Codes::LangVar_Retired'=>'3.25','Locale::Codes::Language'=>'3.25','Locale::Codes::Language_Codes'=>'3.25','Locale::Codes::Language_Retired'=>'3.25','Locale::Codes::Script'=>'3.25','Locale::Codes::Script_Codes'=>'3.25','Locale::Codes::Script_Retired'=>'3.25','Locale::Country'=>'3.25','Locale::Currency'=>'3.25','Locale::Language'=>'3.25','Locale::Script'=>'3.25','Math::BigFloat'=>'1.998','Math::BigFloat::Trace'=>'0.32','Math::BigInt'=>'1.9991','Math::BigInt::CalcEmu'=>'1.998','Math::BigInt::Trace'=>'0.32','Math::BigRat'=>'0.2604','Module::CoreList'=>'2.84','Module::CoreList::TieHashDelta'=>'2.84','Module::Pluggable'=>'4.7','Net::Ping'=>'2.41','Perl::OSType'=>'1.003','Pod::Simple'=>'3.26','Pod::Simple::BlackBox'=>'3.26','Pod::Simple::Checker'=>'3.26','Pod::Simple::Debug'=>'3.26','Pod::Simple::DumpAsText'=>'3.26','Pod::Simple::DumpAsXML'=>'3.26','Pod::Simple::HTML'=>'3.26','Pod::Simple::HTMLBatch'=>'3.26','Pod::Simple::LinkSection'=>'3.26','Pod::Simple::Methody'=>'3.26','Pod::Simple::Progress'=>'3.26','Pod::Simple::PullParser'=>'3.26','Pod::Simple::PullParserEndToken'=>'3.26','Pod::Simple::PullParserStartToken'=>'3.26','Pod::Simple::PullParserTextToken'=>'3.26','Pod::Simple::PullParserToken'=>'3.26','Pod::Simple::RTF'=>'3.26','Pod::Simple::Search'=>'3.26','Pod::Simple::SimpleTree'=>'3.26','Pod::Simple::Text'=>'3.26','Pod::Simple::TextContent'=>'3.26','Pod::Simple::TiedOutFH'=>'3.26','Pod::Simple::Transcode'=>'3.26','Pod::Simple::TranscodeDumb'=>'3.26','Pod::Simple::TranscodeSmart'=>'3.26','Pod::Simple::XHTML'=>'3.26','Pod::Simple::XMLOutStream'=>'3.26','Safe'=>'2.35','Term::ReadLine'=>'1.12','Text::ParseWords'=>'3.28','Tie::File'=>'0.99','Unicode::UCD'=>'0.51','Win32'=>'0.47','bigint'=>'0.33','bignum'=>'0.33','bigrat'=>'0.33','constant'=>'1.27','perlfaq'=>'5.0150042','version'=>'0.9902',},removed=>{}},5.017011=>{delta_from=>5.017010,changed=>{'App::Cpan'=>'1.61','B::Deparse'=>'1.20','Config'=>'5.017009','Exporter'=>'5.68','Exporter::Heavy'=>'5.68','ExtUtils::CBuilder'=>'0.280210','ExtUtils::Command::MM'=>'6.66','ExtUtils::Liblist'=>'6.66','ExtUtils::Liblist::Kid'=>'6.66','ExtUtils::MM'=>'6.66','ExtUtils::MM_AIX'=>'6.66','ExtUtils::MM_Any'=>'6.66','ExtUtils::MM_BeOS'=>'6.66','ExtUtils::MM_Cygwin'=>'6.66','ExtUtils::MM_DOS'=>'6.66','ExtUtils::MM_Darwin'=>'6.66','ExtUtils::MM_MacOS'=>'6.66','ExtUtils::MM_NW5'=>'6.66','ExtUtils::MM_OS2'=>'6.66','ExtUtils::MM_QNX'=>'6.66','ExtUtils::MM_UWIN'=>'6.66','ExtUtils::MM_Unix'=>'6.66','ExtUtils::MM_VMS'=>'6.66','ExtUtils::MM_VOS'=>'6.66','ExtUtils::MM_Win32'=>'6.66','ExtUtils::MM_Win95'=>'6.66','ExtUtils::MY'=>'6.66','ExtUtils::MakeMaker'=>'6.66','ExtUtils::MakeMaker::Config'=>'6.66','ExtUtils::Mkbootstrap'=>'6.66','ExtUtils::Mksymlists'=>'6.66','ExtUtils::testlib'=>'6.66','File::Glob'=>'1.20','IO'=>'1.28','Module::CoreList'=>'2.87','Module::CoreList::TieHashDelta'=>'2.87','Storable'=>'2.41','bigint'=>'0.34','mro'=>'1.11','overload'=>'1.22','warnings'=>'1.18',},removed=>{}},5.018000=>{delta_from=>5.017011,changed=>{'Carp'=>'1.29','Carp::Heavy'=>'1.29','Config'=>'5.018000','Hash::Util'=>'0.16','IO::Handle'=>'1.34','IO::Socket'=>'1.36','Module::CoreList'=>'2.89','Module::CoreList::TieHashDelta'=>'2.89','Pod::Simple'=>'3.28','Pod::Simple::BlackBox'=>'3.28','Pod::Simple::Checker'=>'3.28','Pod::Simple::Debug'=>'3.28','Pod::Simple::DumpAsText'=>'3.28','Pod::Simple::DumpAsXML'=>'3.28','Pod::Simple::HTML'=>'3.28','Pod::Simple::HTMLBatch'=>'3.28','Pod::Simple::LinkSection'=>'3.28','Pod::Simple::Methody'=>'3.28','Pod::Simple::Progress'=>'3.28','Pod::Simple::PullParser'=>'3.28','Pod::Simple::PullParserEndToken'=>'3.28','Pod::Simple::PullParserStartToken'=>'3.28','Pod::Simple::PullParserTextToken'=>'3.28','Pod::Simple::PullParserToken'=>'3.28','Pod::Simple::RTF'=>'3.28','Pod::Simple::Search'=>'3.28','Pod::Simple::SimpleTree'=>'3.28','Pod::Simple::Text'=>'3.28','Pod::Simple::TextContent'=>'3.28','Pod::Simple::TiedOutFH'=>'3.28','Pod::Simple::Transcode'=>'3.28','Pod::Simple::TranscodeDumb'=>'3.28','Pod::Simple::TranscodeSmart'=>'3.28','Pod::Simple::XHTML'=>'3.28','Pod::Simple::XMLOutStream'=>'3.28',},removed=>{}},5.018001=>{delta_from=>5.018000,changed=>{'B'=>'1.42_01','Config'=>'5.018001','Digest::SHA'=>'5.84_01','Module::CoreList'=>'2.96','Module::CoreList::TieHashDelta'=>'2.96','Module::CoreList::Utils'=>'2.96',},removed=>{'VMS::Filespec'=>1,}},5.018002=>{delta_from=>5.018001,changed=>{'B'=>'1.42_02','B::Concise'=>'0.95_01','Config'=>'5.018002','File::Glob'=>'1.20_01','Module::CoreList'=>'3.03','Module::CoreList::TieHashDelta'=>'3.03','Module::CoreList::Utils'=>'3.03',},},5.018003=>{delta_from=>5.018002,changed=>{'Config'=>'5.018003','Digest::SHA'=>'5.84_02','Module::CoreList'=>'3.12','Module::CoreList::TieHashDelta'=>'3.12','Module::CoreList::Utils'=>'3.12',},},5.018004=>{delta_from=>5.018003,changed=>{'Config'=>'5.018004','Module::CoreList'=>'3.13','Module::CoreList::TieHashDelta'=>'3.13','Module::CoreList::Utils'=>'3.13',},},5.019000=>{delta_from=>5.018000,changed=>{'Config'=>'5.019000','Getopt::Std'=>'1.08','Module::CoreList'=>'2.91','Module::CoreList::TieHashDelta'=>'2.91','Storable'=>'2.42','feature'=>'1.33','utf8'=>'1.11',},removed=>{'Archive::Extract'=>1,'B::Lint'=>1,'B::Lint::Debug'=>1,'CPANPLUS'=>1,'CPANPLUS::Backend'=>1,'CPANPLUS::Backend::RV'=>1,'CPANPLUS::Config'=>1,'CPANPLUS::Config::HomeEnv'=>1,'CPANPLUS::Configure'=>1,'CPANPLUS::Configure::Setup'=>1,'CPANPLUS::Dist'=>1,'CPANPLUS::Dist::Autobundle'=>1,'CPANPLUS::Dist::Base'=>1,'CPANPLUS::Dist::Build'=>1,'CPANPLUS::Dist::Build::Constants'=>1,'CPANPLUS::Dist::MM'=>1,'CPANPLUS::Dist::Sample'=>1,'CPANPLUS::Error'=>1,'CPANPLUS::Internals'=>1,'CPANPLUS::Internals::Constants'=>1,'CPANPLUS::Internals::Constants::Report'=>1,'CPANPLUS::Internals::Extract'=>1,'CPANPLUS::Internals::Fetch'=>1,'CPANPLUS::Internals::Report'=>1,'CPANPLUS::Internals::Search'=>1,'CPANPLUS::Internals::Source'=>1,'CPANPLUS::Internals::Source::Memory'=>1,'CPANPLUS::Internals::Source::SQLite'=>1,'CPANPLUS::Internals::Source::SQLite::Tie'=>1,'CPANPLUS::Internals::Utils'=>1,'CPANPLUS::Internals::Utils::Autoflush'=>1,'CPANPLUS::Module'=>1,'CPANPLUS::Module::Author'=>1,'CPANPLUS::Module::Author::Fake'=>1,'CPANPLUS::Module::Checksums'=>1,'CPANPLUS::Module::Fake'=>1,'CPANPLUS::Module::Signature'=>1,'CPANPLUS::Selfupdate'=>1,'CPANPLUS::Shell'=>1,'CPANPLUS::Shell::Classic'=>1,'CPANPLUS::Shell::Default'=>1,'CPANPLUS::Shell::Default::Plugins::CustomSource'=>1,'CPANPLUS::Shell::Default::Plugins::Remote'=>1,'CPANPLUS::Shell::Default::Plugins::Source'=>1,'Devel::InnerPackage'=>1,'File::CheckTree'=>1,'Log::Message'=>1,'Log::Message::Config'=>1,'Log::Message::Handlers'=>1,'Log::Message::Item'=>1,'Log::Message::Simple'=>1,'Module::Pluggable'=>1,'Module::Pluggable::Object'=>1,'Object::Accessor'=>1,'Pod::LaTeX'=>1,'Term::UI'=>1,'Term::UI::History'=>1,'Text::Soundex'=>1,}},5.019001=>{delta_from=>5.019000,changed=>{'App::Prove'=>'3.28','App::Prove::State'=>'3.28','App::Prove::State::Result'=>'3.28','App::Prove::State::Result::Test'=>'3.28','Archive::Tar'=>'1.92','Archive::Tar::Constant'=>'1.92','Archive::Tar::File'=>'1.92','Attribute::Handlers'=>'0.95','B'=>'1.43','B::Concise'=>'0.96','B::Deparse'=>'1.21','B::Showlex'=>'1.04','Benchmark'=>'1.16','CPAN::Meta'=>'2.131560','CPAN::Meta::Converter'=>'2.131560','CPAN::Meta::Feature'=>'2.131560','CPAN::Meta::History'=>'2.131560','CPAN::Meta::Prereqs'=>'2.131560','CPAN::Meta::Spec'=>'2.131560','CPAN::Meta::Validator'=>'2.131560','Carp'=>'1.30','Carp::Heavy'=>'1.30','Compress::Raw::Bzip2'=>'2.061','Compress::Raw::Zlib'=>'2.061','Compress::Zlib'=>'2.061','Config'=>'5.019001','Config::Perl::V'=>'0.18','Cwd'=>'3.41','DB'=>'1.06','DB_File'=>'1.828','Data::Dumper'=>'2.146','Encode'=>'2.51','Encode::CN::HZ'=>'2.06','Encode::GSM0338'=>'2.03','Encode::Unicode::UTF7'=>'2.07','ExtUtils::CBuilder::Base'=>'0.280210','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280210','ExtUtils::Command::MM'=>'6.68','ExtUtils::Install'=>'1.60','ExtUtils::Liblist'=>'6.68','ExtUtils::Liblist::Kid'=>'6.68','ExtUtils::MM'=>'6.68','ExtUtils::MM_AIX'=>'6.68','ExtUtils::MM_Any'=>'6.68','ExtUtils::MM_BeOS'=>'6.68','ExtUtils::MM_Cygwin'=>'6.68','ExtUtils::MM_DOS'=>'6.68','ExtUtils::MM_Darwin'=>'6.68','ExtUtils::MM_MacOS'=>'6.68','ExtUtils::MM_NW5'=>'6.68','ExtUtils::MM_OS2'=>'6.68','ExtUtils::MM_QNX'=>'6.68','ExtUtils::MM_UWIN'=>'6.68','ExtUtils::MM_Unix'=>'6.68','ExtUtils::MM_VMS'=>'6.68','ExtUtils::MM_VOS'=>'6.68','ExtUtils::MM_Win32'=>'6.68','ExtUtils::MM_Win95'=>'6.68','ExtUtils::MY'=>'6.68','ExtUtils::MakeMaker'=>'6.68','ExtUtils::MakeMaker::Config'=>'6.68','ExtUtils::Mkbootstrap'=>'6.68','ExtUtils::Mksymlists'=>'6.68','ExtUtils::ParseXS'=>'3.19','ExtUtils::testlib'=>'6.68','Fatal'=>'2.19','File::Copy'=>'2.27','File::DosGlob'=>'1.11','File::Fetch'=>'0.42','File::Find'=>'1.24','File::Spec'=>'3.41','File::Spec::Cygwin'=>'3.41','File::Spec::Epoc'=>'3.41','File::Spec::Mac'=>'3.41','File::Spec::OS2'=>'3.41','File::Spec::Unix'=>'3.41','File::Spec::VMS'=>'3.41','File::Spec::Win32'=>'3.41','File::Temp'=>'0.2301','Filter::Simple'=>'0.90','Filter::Util::Call'=>'1.49','Getopt::Long'=>'2.4','HTTP::Tiny'=>'0.031','Hash::Util::FieldHash'=>'1.11','IO::Compress::Adapter::Bzip2'=>'2.061','IO::Compress::Adapter::Deflate'=>'2.061','IO::Compress::Adapter::Identity'=>'2.061','IO::Compress::Base'=>'2.061','IO::Compress::Base::Common'=>'2.061','IO::Compress::Bzip2'=>'2.061','IO::Compress::Deflate'=>'2.061','IO::Compress::Gzip'=>'2.061','IO::Compress::Gzip::Constants'=>'2.061','IO::Compress::RawDeflate'=>'2.061','IO::Compress::Zip'=>'2.061','IO::Compress::Zip::Constants'=>'2.061','IO::Compress::Zlib::Constants'=>'2.061','IO::Compress::Zlib::Extra'=>'2.061','IO::Handle'=>'1.35','IO::Uncompress::Adapter::Bunzip2'=>'2.061','IO::Uncompress::Adapter::Identity'=>'2.061','IO::Uncompress::Adapter::Inflate'=>'2.061','IO::Uncompress::AnyInflate'=>'2.061','IO::Uncompress::AnyUncompress'=>'2.061','IO::Uncompress::Base'=>'2.061','IO::Uncompress::Bunzip2'=>'2.061','IO::Uncompress::Gunzip'=>'2.061','IO::Uncompress::Inflate'=>'2.061','IO::Uncompress::RawInflate'=>'2.061','IO::Uncompress::Unzip'=>'2.061','IPC::Open3'=>'1.14','Locale::Codes'=>'3.26','Locale::Codes::Constants'=>'3.26','Locale::Codes::Country'=>'3.26','Locale::Codes::Country_Codes'=>'3.26','Locale::Codes::Country_Retired'=>'3.26','Locale::Codes::Currency'=>'3.26','Locale::Codes::Currency_Codes'=>'3.26','Locale::Codes::Currency_Retired'=>'3.26','Locale::Codes::LangExt'=>'3.26','Locale::Codes::LangExt_Codes'=>'3.26','Locale::Codes::LangExt_Retired'=>'3.26','Locale::Codes::LangFam'=>'3.26','Locale::Codes::LangFam_Codes'=>'3.26','Locale::Codes::LangFam_Retired'=>'3.26','Locale::Codes::LangVar'=>'3.26','Locale::Codes::LangVar_Codes'=>'3.26','Locale::Codes::LangVar_Retired'=>'3.26','Locale::Codes::Language'=>'3.26','Locale::Codes::Language_Codes'=>'3.26','Locale::Codes::Language_Retired'=>'3.26','Locale::Codes::Script'=>'3.26','Locale::Codes::Script_Codes'=>'3.26','Locale::Codes::Script_Retired'=>'3.26','Locale::Country'=>'3.26','Locale::Currency'=>'3.26','Locale::Language'=>'3.26','Locale::Maketext'=>'1.24','Locale::Script'=>'3.26','Math::BigFloat'=>'1.999','Math::BigInt'=>'1.9992','Math::BigInt::Calc'=>'1.998','Math::BigInt::CalcEmu'=>'1.9991','Math::BigRat'=>'0.2606','Module::Build'=>'0.4005','Module::Build::Base'=>'0.4005','Module::Build::Compat'=>'0.4005','Module::Build::Config'=>'0.4005','Module::Build::Cookbook'=>'0.4005','Module::Build::Dumper'=>'0.4005','Module::Build::ModuleInfo'=>'0.4005','Module::Build::Notes'=>'0.4005','Module::Build::PPMMaker'=>'0.4005','Module::Build::Platform::Amiga'=>'0.4005','Module::Build::Platform::Default'=>'0.4005','Module::Build::Platform::EBCDIC'=>'0.4005','Module::Build::Platform::MPEiX'=>'0.4005','Module::Build::Platform::MacOS'=>'0.4005','Module::Build::Platform::RiscOS'=>'0.4005','Module::Build::Platform::Unix'=>'0.4005','Module::Build::Platform::VMS'=>'0.4005','Module::Build::Platform::VOS'=>'0.4005','Module::Build::Platform::Windows'=>'0.4005','Module::Build::Platform::aix'=>'0.4005','Module::Build::Platform::cygwin'=>'0.4005','Module::Build::Platform::darwin'=>'0.4005','Module::Build::Platform::os2'=>'0.4005','Module::Build::PodParser'=>'0.4005','Module::CoreList'=>'2.92','Module::CoreList::TieHashDelta'=>'2.92','Module::CoreList::Utils'=>'2.92','Module::Metadata'=>'1.000014','Net::Ping'=>'2.42','OS2::Process'=>'1.09','POSIX'=>'1.33','Pod::Find'=>'1.61','Pod::Html'=>'1.19','Pod::InputObjects'=>'1.61','Pod::ParseUtils'=>'1.61','Pod::Parser'=>'1.61','Pod::Perldoc'=>'3.20','Pod::Perldoc::BaseTo'=>'3.20','Pod::Perldoc::GetOptsOO'=>'3.20','Pod::Perldoc::ToANSI'=>'3.20','Pod::Perldoc::ToChecker'=>'3.20','Pod::Perldoc::ToMan'=>'3.20','Pod::Perldoc::ToNroff'=>'3.20','Pod::Perldoc::ToPod'=>'3.20','Pod::Perldoc::ToRtf'=>'3.20','Pod::Perldoc::ToTerm'=>'3.20','Pod::Perldoc::ToText'=>'3.20','Pod::Perldoc::ToTk'=>'3.20','Pod::Perldoc::ToXml'=>'3.20','Pod::Select'=>'1.61','Pod::Usage'=>'1.63','Safe'=>'2.36','Storable'=>'2.43','Sys::Hostname'=>'1.18','Sys::Syslog'=>'0.33','TAP::Base'=>'3.28','TAP::Formatter::Base'=>'3.28','TAP::Formatter::Color'=>'3.28','TAP::Formatter::Console'=>'3.28','TAP::Formatter::Console::ParallelSession'=>'3.28','TAP::Formatter::Console::Session'=>'3.28','TAP::Formatter::File'=>'3.28','TAP::Formatter::File::Session'=>'3.28','TAP::Formatter::Session'=>'3.28','TAP::Harness'=>'3.28','TAP::Object'=>'3.28','TAP::Parser'=>'3.28','TAP::Parser::Aggregator'=>'3.28','TAP::Parser::Grammar'=>'3.28','TAP::Parser::Iterator'=>'3.28','TAP::Parser::Iterator::Array'=>'3.28','TAP::Parser::Iterator::Process'=>'3.28','TAP::Parser::Iterator::Stream'=>'3.28','TAP::Parser::IteratorFactory'=>'3.28','TAP::Parser::Multiplexer'=>'3.28','TAP::Parser::Result'=>'3.28','TAP::Parser::Result::Bailout'=>'3.28','TAP::Parser::Result::Comment'=>'3.28','TAP::Parser::Result::Plan'=>'3.28','TAP::Parser::Result::Pragma'=>'3.28','TAP::Parser::Result::Test'=>'3.28','TAP::Parser::Result::Unknown'=>'3.28','TAP::Parser::Result::Version'=>'3.28','TAP::Parser::Result::YAML'=>'3.28','TAP::Parser::ResultFactory'=>'3.28','TAP::Parser::Scheduler'=>'3.28','TAP::Parser::Scheduler::Job'=>'3.28','TAP::Parser::Scheduler::Spinner'=>'3.28','TAP::Parser::Source'=>'3.28','TAP::Parser::SourceHandler'=>'3.28','TAP::Parser::SourceHandler::Executable'=>'3.28','TAP::Parser::SourceHandler::File'=>'3.28','TAP::Parser::SourceHandler::Handle'=>'3.28','TAP::Parser::SourceHandler::Perl'=>'3.28','TAP::Parser::SourceHandler::RawTAP'=>'3.28','TAP::Parser::Utils'=>'3.28','TAP::Parser::YAMLish::Reader'=>'3.28','TAP::Parser::YAMLish::Writer'=>'3.28','Term::ReadLine'=>'1.13','Test::Harness'=>'3.28','Text::Tabs'=>'2013.0523','Text::Wrap'=>'2013.0523','Thread'=>'3.04','Tie::File'=>'1.00','Time::Piece'=>'1.2002','Unicode::Collate'=>'0.98','Unicode::UCD'=>'0.53','XS::APItest'=>'0.53','_charnames'=>'1.37','autodie'=>'2.19','autodie::exception'=>'2.19','autodie::exception::system'=>'2.19','autodie::hints'=>'2.19','autodie::skip'=>'2.19','bigint'=>'0.35','charnames'=>'1.38','encoding'=>'2.12','inc::latest'=>'0.4005','mro'=>'1.12','perlfaq'=>'5.0150043','re'=>'0.25','threads'=>'1.87','threads::shared'=>'1.44','utf8'=>'1.12',},removed=>{}},5.019002=>{delta_from=>5.019001,changed=>{'B'=>'1.44','B::Concise'=>'0.98','B::Deparse'=>'1.22','Benchmark'=>'1.17','Class::Struct'=>'0.65','Config'=>'5.019002','DB'=>'1.07','DBM_Filter'=>'0.06','DBM_Filter::compress'=>'0.03','DBM_Filter::encode'=>'0.03','DBM_Filter::int32'=>'0.03','DBM_Filter::null'=>'0.03','DBM_Filter::utf8'=>'0.03','DB_File'=>'1.829','Data::Dumper'=>'2.147','Devel::Peek'=>'1.12','Digest::MD5'=>'2.53','Digest::SHA'=>'5.85','English'=>'1.07','Errno'=>'1.19','ExtUtils::Embed'=>'1.31','ExtUtils::Miniperl'=>'1','ExtUtils::ParseXS'=>'3.21','ExtUtils::ParseXS::Constants'=>'3.21','ExtUtils::ParseXS::CountLines'=>'3.21','ExtUtils::ParseXS::Eval'=>'3.19','ExtUtils::ParseXS::Utilities'=>'3.21','ExtUtils::Typemaps'=>'3.21','ExtUtils::Typemaps::Cmd'=>'3.21','ExtUtils::Typemaps::InputMap'=>'3.21','ExtUtils::Typemaps::OutputMap'=>'3.21','ExtUtils::Typemaps::Type'=>'3.21','ExtUtils::XSSymSet'=>'1.3','Fatal'=>'2.20','File::Basename'=>'2.85','File::Spec::VMS'=>'3.43','File::Spec::Win32'=>'3.42','Getopt::Long'=>'2.41','Getopt::Std'=>'1.09','HTTP::Tiny'=>'0.034','Hash::Util::FieldHash'=>'1.12','I18N::Langinfo'=>'0.11','IO::Socket::INET'=>'1.34','IO::Socket::UNIX'=>'1.25','IPC::Cmd'=>'0.82','MIME::Base64'=>'3.14','Module::CoreList'=>'2.94','Module::CoreList::TieHashDelta'=>'2.94','Module::CoreList::Utils'=>'2.94','POSIX'=>'1.34','Params::Check'=>'0.38','Parse::CPAN::Meta'=>'1.4405','Pod::Functions'=>'1.07','Pod::Html'=>'1.2','Safe'=>'2.37','Socket'=>'2.010','Storable'=>'2.45','Text::ParseWords'=>'3.29','Tie::Array'=>'1.06','Tie::Hash'=>'1.05','Tie::Scalar'=>'1.03','Time::Piece'=>'1.21','Time::Seconds'=>'1.21','XS::APItest'=>'0.54','autodie'=>'2.20','autodie::exception'=>'2.20','autodie::exception::system'=>'2.20','autodie::hints'=>'2.20','autodie::skip'=>'2.20','base'=>'2.19','deprecate'=>'0.03','if'=>'0.0603','integer'=>'1.01','strict'=>'1.08','subs'=>'1.02','vmsish'=>'1.04',},removed=>{}},5.019003=>{delta_from=>5.019002,changed=>{'B'=>'1.45','CPAN::Meta'=>'2.132140','CPAN::Meta::Converter'=>'2.132140','CPAN::Meta::Feature'=>'2.132140','CPAN::Meta::History'=>'2.132140','CPAN::Meta::Prereqs'=>'2.132140','CPAN::Meta::Spec'=>'2.132140','CPAN::Meta::Validator'=>'2.132140','Carp'=>'1.31','Carp::Heavy'=>'1.31','Compress::Raw::Bzip2'=>'2.062','Compress::Raw::Zlib'=>'2.062','Compress::Zlib'=>'2.062','Config'=>'5.019003','Config::Perl::V'=>'0.19','Cwd'=>'3.44','Data::Dumper'=>'2.148','Devel::PPPort'=>'3.21','Devel::Peek'=>'1.13','DynaLoader'=>'1.19','Encode'=>'2.52','Encode::Alias'=>'2.17','Encode::Encoding'=>'2.06','Encode::GSM0338'=>'2.04','Encode::MIME::Header'=>'2.14','Encode::Unicode'=>'2.08','English'=>'1.08','Exporter'=>'5.69','Exporter::Heavy'=>'5.69','ExtUtils::Command::MM'=>'6.72','ExtUtils::Liblist'=>'6.72','ExtUtils::Liblist::Kid'=>'6.72','ExtUtils::MM'=>'6.72','ExtUtils::MM_AIX'=>'6.72','ExtUtils::MM_Any'=>'6.72','ExtUtils::MM_BeOS'=>'6.72','ExtUtils::MM_Cygwin'=>'6.72','ExtUtils::MM_DOS'=>'6.72','ExtUtils::MM_Darwin'=>'6.72','ExtUtils::MM_MacOS'=>'6.72','ExtUtils::MM_NW5'=>'6.72','ExtUtils::MM_OS2'=>'6.72','ExtUtils::MM_QNX'=>'6.72','ExtUtils::MM_UWIN'=>'6.72','ExtUtils::MM_Unix'=>'6.72','ExtUtils::MM_VMS'=>'6.72','ExtUtils::MM_VOS'=>'6.72','ExtUtils::MM_Win32'=>'6.72','ExtUtils::MM_Win95'=>'6.72','ExtUtils::MY'=>'6.72','ExtUtils::MakeMaker'=>'6.72','ExtUtils::MakeMaker::Config'=>'6.72','ExtUtils::Mkbootstrap'=>'6.72','ExtUtils::Mksymlists'=>'6.72','ExtUtils::ParseXS::Eval'=>'3.21','ExtUtils::testlib'=>'6.72','File::Spec'=>'3.44','File::Spec::Cygwin'=>'3.44','File::Spec::Epoc'=>'3.44','File::Spec::Functions'=>'3.44','File::Spec::Mac'=>'3.44','File::Spec::OS2'=>'3.44','File::Spec::Unix'=>'3.44','File::Spec::VMS'=>'3.44','File::Spec::Win32'=>'3.44','Getopt::Std'=>'1.10','IO::Compress::Adapter::Bzip2'=>'2.062','IO::Compress::Adapter::Deflate'=>'2.062','IO::Compress::Adapter::Identity'=>'2.062','IO::Compress::Base'=>'2.062','IO::Compress::Base::Common'=>'2.062','IO::Compress::Bzip2'=>'2.062','IO::Compress::Deflate'=>'2.062','IO::Compress::Gzip'=>'2.062','IO::Compress::Gzip::Constants'=>'2.062','IO::Compress::RawDeflate'=>'2.062','IO::Compress::Zip'=>'2.062','IO::Compress::Zip::Constants'=>'2.062','IO::Compress::Zlib::Constants'=>'2.062','IO::Compress::Zlib::Extra'=>'2.062','IO::Uncompress::Adapter::Bunzip2'=>'2.062','IO::Uncompress::Adapter::Identity'=>'2.062','IO::Uncompress::Adapter::Inflate'=>'2.062','IO::Uncompress::AnyInflate'=>'2.062','IO::Uncompress::AnyUncompress'=>'2.062','IO::Uncompress::Base'=>'2.062','IO::Uncompress::Bunzip2'=>'2.062','IO::Uncompress::Gunzip'=>'2.062','IO::Uncompress::Inflate'=>'2.062','IO::Uncompress::RawInflate'=>'2.062','IO::Uncompress::Unzip'=>'2.062','IPC::Cmd'=>'0.84','IPC::Msg'=>'2.04','IPC::Open3'=>'1.15','IPC::Semaphore'=>'2.04','IPC::SharedMem'=>'2.04','IPC::SysV'=>'2.04','List::Util'=>'1.31','List::Util::XS'=>'1.31','Math::BigFloat::Trace'=>'0.36','Math::BigInt::Trace'=>'0.36','Module::Build'=>'0.4007','Module::Build::Base'=>'0.4007','Module::Build::Compat'=>'0.4007','Module::Build::Config'=>'0.4007','Module::Build::Cookbook'=>'0.4007','Module::Build::Dumper'=>'0.4007','Module::Build::ModuleInfo'=>'0.4007','Module::Build::Notes'=>'0.4007','Module::Build::PPMMaker'=>'0.4007','Module::Build::Platform::Default'=>'0.4007','Module::Build::Platform::MacOS'=>'0.4007','Module::Build::Platform::Unix'=>'0.4007','Module::Build::Platform::VMS'=>'0.4007','Module::Build::Platform::VOS'=>'0.4007','Module::Build::Platform::Windows'=>'0.4007','Module::Build::Platform::aix'=>'0.4007','Module::Build::Platform::cygwin'=>'0.4007','Module::Build::Platform::darwin'=>'0.4007','Module::Build::Platform::os2'=>'0.4007','Module::Build::PodParser'=>'0.4007','Module::CoreList'=>'2.97','Module::CoreList::TieHashDelta'=>'2.97','Module::CoreList::Utils'=>'2.97','Net::Cmd'=>'2.30','Net::Config'=>'1.12','Net::Domain'=>'2.22','Net::FTP'=>'2.78','Net::FTP::dataconn'=>'0.12','Net::NNTP'=>'2.25','Net::Netrc'=>'2.14','Net::POP3'=>'2.30','Net::SMTP'=>'2.32','PerlIO'=>'1.08','Pod::Functions'=>'1.08','Scalar::Util'=>'1.31','Socket'=>'2.011','Storable'=>'2.46','Time::HiRes'=>'1.9726','Time::Piece'=>'1.22','Time::Seconds'=>'1.22','XS::APItest'=>'0.55','bigint'=>'0.36','bignum'=>'0.36','bigrat'=>'0.36','constant'=>'1.28','diagnostics'=>'1.32','inc::latest'=>'0.4007','mro'=>'1.13','parent'=>'0.226','utf8'=>'1.13','version'=>'0.9903',},removed=>{'Module::Build::Platform::Amiga'=>1,'Module::Build::Platform::EBCDIC'=>1,'Module::Build::Platform::MPEiX'=>1,'Module::Build::Platform::RiscOS'=>1,}},5.019004=>{delta_from=>5.019003,changed=>{'B'=>'1.46','B::Concise'=>'0.99','B::Deparse'=>'1.23','CPAN'=>'2.03','CPAN::Meta'=>'2.132620','CPAN::Meta::Converter'=>'2.132620','CPAN::Meta::Feature'=>'2.132620','CPAN::Meta::History'=>'2.132620','CPAN::Meta::Prereqs'=>'2.132620','CPAN::Meta::Requirements'=>'2.123','CPAN::Meta::Spec'=>'2.132620','CPAN::Meta::Validator'=>'2.132620','Carp'=>'1.32','Carp::Heavy'=>'1.32','Config'=>'5.019004','Data::Dumper'=>'2.149','Devel::Peek'=>'1.14','DynaLoader'=>'1.20','Encode'=>'2.55','Encode::Alias'=>'2.18','Encode::CN::HZ'=>'2.07','Encode::Encoder'=>'2.03','Encode::Encoding'=>'2.07','Encode::GSM0338'=>'2.05','Encode::Guess'=>'2.06','Encode::JP::JIS7'=>'2.05','Encode::KR::2022_KR'=>'2.03','Encode::MIME::Header'=>'2.15','Encode::MIME::Header::ISO_2022_JP'=>'1.04','Encode::Unicode'=>'2.09','Encode::Unicode::UTF7'=>'2.08','Errno'=>'1.20','Exporter'=>'5.70','Exporter::Heavy'=>'5.70','ExtUtils::CBuilder'=>'0.280212','ExtUtils::CBuilder::Base'=>'0.280212','ExtUtils::CBuilder::Platform::Unix'=>'0.280212','ExtUtils::CBuilder::Platform::VMS'=>'0.280212','ExtUtils::CBuilder::Platform::Windows'=>'0.280212','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280212','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280212','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280212','ExtUtils::CBuilder::Platform::aix'=>'0.280212','ExtUtils::CBuilder::Platform::cygwin'=>'0.280212','ExtUtils::CBuilder::Platform::darwin'=>'0.280212','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280212','ExtUtils::CBuilder::Platform::os2'=>'0.280212','ExtUtils::Command'=>'1.18','ExtUtils::Command::MM'=>'6.76','ExtUtils::Liblist'=>'6.76','ExtUtils::Liblist::Kid'=>'6.76','ExtUtils::MM'=>'6.76','ExtUtils::MM_AIX'=>'6.76','ExtUtils::MM_Any'=>'6.76','ExtUtils::MM_BeOS'=>'6.76','ExtUtils::MM_Cygwin'=>'6.76','ExtUtils::MM_DOS'=>'6.76','ExtUtils::MM_Darwin'=>'6.76','ExtUtils::MM_MacOS'=>'6.76','ExtUtils::MM_NW5'=>'6.76','ExtUtils::MM_OS2'=>'6.76','ExtUtils::MM_QNX'=>'6.76','ExtUtils::MM_UWIN'=>'6.76','ExtUtils::MM_Unix'=>'6.76','ExtUtils::MM_VMS'=>'6.76','ExtUtils::MM_VOS'=>'6.76','ExtUtils::MM_Win32'=>'6.76','ExtUtils::MM_Win95'=>'6.76','ExtUtils::MY'=>'6.76','ExtUtils::MakeMaker'=>'6.76','ExtUtils::MakeMaker::Config'=>'6.76','ExtUtils::Mkbootstrap'=>'6.76','ExtUtils::Mksymlists'=>'6.76','ExtUtils::ParseXS'=>'3.23','ExtUtils::ParseXS::Constants'=>'3.23','ExtUtils::ParseXS::CountLines'=>'3.23','ExtUtils::ParseXS::Eval'=>'3.23','ExtUtils::ParseXS::Utilities'=>'3.23','ExtUtils::Typemaps'=>'3.23','ExtUtils::Typemaps::Cmd'=>'3.23','ExtUtils::Typemaps::InputMap'=>'3.23','ExtUtils::Typemaps::OutputMap'=>'3.23','ExtUtils::Typemaps::Type'=>'3.23','ExtUtils::testlib'=>'6.76','Fatal'=>'2.21','File::Copy'=>'2.28','File::Find'=>'1.25','File::Glob'=>'1.21','FileCache'=>'1.09','HTTP::Tiny'=>'0.035','Hash::Util::FieldHash'=>'1.13','I18N::LangTags'=>'0.40','IO'=>'1.29','IO::Socket'=>'1.37','IPC::Open3'=>'1.16','JSON::PP'=>'2.27202_01','List::Util'=>'1.32','List::Util::XS'=>'1.32','Locale::Codes'=>'3.27','Locale::Codes::Constants'=>'3.27','Locale::Codes::Country'=>'3.27','Locale::Codes::Country_Codes'=>'3.27','Locale::Codes::Country_Retired'=>'3.27','Locale::Codes::Currency'=>'3.27','Locale::Codes::Currency_Codes'=>'3.27','Locale::Codes::Currency_Retired'=>'3.27','Locale::Codes::LangExt'=>'3.27','Locale::Codes::LangExt_Codes'=>'3.27','Locale::Codes::LangExt_Retired'=>'3.27','Locale::Codes::LangFam'=>'3.27','Locale::Codes::LangFam_Codes'=>'3.27','Locale::Codes::LangFam_Retired'=>'3.27','Locale::Codes::LangVar'=>'3.27','Locale::Codes::LangVar_Codes'=>'3.27','Locale::Codes::LangVar_Retired'=>'3.27','Locale::Codes::Language'=>'3.27','Locale::Codes::Language_Codes'=>'3.27','Locale::Codes::Language_Retired'=>'3.27','Locale::Codes::Script'=>'3.27','Locale::Codes::Script_Codes'=>'3.27','Locale::Codes::Script_Retired'=>'3.27','Locale::Country'=>'3.27','Locale::Currency'=>'3.27','Locale::Language'=>'3.27','Locale::Script'=>'3.27','Math::BigFloat'=>'1.9991','Math::BigInt'=>'1.9993','Math::BigInt::FastCalc'=>'0.31','Module::CoreList'=>'2.99','Module::CoreList::TieHashDelta'=>'2.99','Module::CoreList::Utils'=>'2.99','Module::Load::Conditional'=>'0.58','Module::Metadata'=>'1.000018','Opcode'=>'1.26','POSIX'=>'1.35','Parse::CPAN::Meta'=>'1.4407','Perl::OSType'=>'1.005','Pod::Html'=>'1.21','Scalar::Util'=>'1.32','Socket'=>'2.012','Storable'=>'2.47','Term::ReadLine'=>'1.14','Test::Builder'=>'0.98_06','Test::Builder::Module'=>'0.98_06','Test::More'=>'0.98_06','Test::Simple'=>'0.98_06','Time::Piece'=>'1.23','Time::Seconds'=>'1.23','Unicode::Collate'=>'0.99','Unicode::UCD'=>'0.54','XS::APItest'=>'0.56','XS::Typemap'=>'0.11','_charnames'=>'1.39','autodie'=>'2.21','autodie::exception'=>'2.21','autodie::exception::system'=>'2.21','autodie::hints'=>'2.21','autodie::skip'=>'2.21','charnames'=>'1.39','diagnostics'=>'1.33','mro'=>'1.14','parent'=>'0.228','perlfaq'=>'5.0150044','re'=>'0.26','version'=>'0.9904','warnings'=>'1.19',},removed=>{}},5.019005=>{delta_from=>5.019004,changed=>{'App::Prove'=>'3.29','App::Prove::State'=>'3.29','App::Prove::State::Result'=>'3.29','App::Prove::State::Result::Test'=>'3.29','CPAN::Meta'=>'2.132830','CPAN::Meta::Converter'=>'2.132830','CPAN::Meta::Feature'=>'2.132830','CPAN::Meta::History'=>'2.132830','CPAN::Meta::Prereqs'=>'2.132830','CPAN::Meta::Requirements'=>'2.125','CPAN::Meta::Spec'=>'2.132830','CPAN::Meta::Validator'=>'2.132830','CPAN::Meta::YAML'=>'0.010','Config'=>'5.019005','Cwd'=>'3.45','ExtUtils::Command::MM'=>'6.80','ExtUtils::Install'=>'1.61','ExtUtils::Liblist'=>'6.80','ExtUtils::Liblist::Kid'=>'6.80','ExtUtils::MM'=>'6.80','ExtUtils::MM_AIX'=>'6.80','ExtUtils::MM_Any'=>'6.80','ExtUtils::MM_BeOS'=>'6.80','ExtUtils::MM_Cygwin'=>'6.80','ExtUtils::MM_DOS'=>'6.80','ExtUtils::MM_Darwin'=>'6.80','ExtUtils::MM_MacOS'=>'6.80','ExtUtils::MM_NW5'=>'6.80','ExtUtils::MM_OS2'=>'6.80','ExtUtils::MM_QNX'=>'6.80','ExtUtils::MM_UWIN'=>'6.80','ExtUtils::MM_Unix'=>'6.80','ExtUtils::MM_VMS'=>'6.80','ExtUtils::MM_VOS'=>'6.80','ExtUtils::MM_Win32'=>'6.80','ExtUtils::MM_Win95'=>'6.80','ExtUtils::MY'=>'6.80','ExtUtils::MakeMaker'=>'6.80','ExtUtils::MakeMaker::Config'=>'6.80','ExtUtils::Mkbootstrap'=>'6.80','ExtUtils::Mksymlists'=>'6.80','ExtUtils::testlib'=>'6.80','Fatal'=>'2.22','File::Fetch'=>'0.44','File::Glob'=>'1.22','File::Spec'=>'3.45','File::Spec::Cygwin'=>'3.45','File::Spec::Epoc'=>'3.45','File::Spec::Functions'=>'3.45','File::Spec::Mac'=>'3.45','File::Spec::OS2'=>'3.45','File::Spec::Unix'=>'3.45','File::Spec::VMS'=>'3.45','File::Spec::Win32'=>'3.45','File::Temp'=>'0.2304','Getopt::Long'=>'2.42','HTTP::Tiny'=>'0.036','IPC::Cmd'=>'0.84_01','JSON::PP'=>'2.27203','List::Util'=>'1.35','List::Util::XS'=>'1.35','Module::CoreList'=>'3.00','Module::CoreList::TieHashDelta'=>'3.00','Module::CoreList::Utils'=>'3.00','Module::Metadata'=>'1.000019','Parse::CPAN::Meta'=>'1.4409','Perl::OSType'=>'1.006','PerlIO::scalar'=>'0.17','Pod::Man'=>'2.28','Pod::Text'=>'3.18','Pod::Text::Termcap'=>'2.08','Scalar::Util'=>'1.35','TAP::Base'=>'3.29','TAP::Formatter::Base'=>'3.29','TAP::Formatter::Color'=>'3.29','TAP::Formatter::Console'=>'3.29','TAP::Formatter::Console::ParallelSession'=>'3.29','TAP::Formatter::Console::Session'=>'3.29','TAP::Formatter::File'=>'3.29','TAP::Formatter::File::Session'=>'3.29','TAP::Formatter::Session'=>'3.29','TAP::Harness'=>'3.29','TAP::Harness::Env'=>'3.29','TAP::Object'=>'3.29','TAP::Parser'=>'3.29','TAP::Parser::Aggregator'=>'3.29','TAP::Parser::Grammar'=>'3.29','TAP::Parser::Iterator'=>'3.29','TAP::Parser::Iterator::Array'=>'3.29','TAP::Parser::Iterator::Process'=>'3.29','TAP::Parser::Iterator::Stream'=>'3.29','TAP::Parser::IteratorFactory'=>'3.29','TAP::Parser::Multiplexer'=>'3.29','TAP::Parser::Result'=>'3.29','TAP::Parser::Result::Bailout'=>'3.29','TAP::Parser::Result::Comment'=>'3.29','TAP::Parser::Result::Plan'=>'3.29','TAP::Parser::Result::Pragma'=>'3.29','TAP::Parser::Result::Test'=>'3.29','TAP::Parser::Result::Unknown'=>'3.29','TAP::Parser::Result::Version'=>'3.29','TAP::Parser::Result::YAML'=>'3.29','TAP::Parser::ResultFactory'=>'3.29','TAP::Parser::Scheduler'=>'3.29','TAP::Parser::Scheduler::Job'=>'3.29','TAP::Parser::Scheduler::Spinner'=>'3.29','TAP::Parser::Source'=>'3.29','TAP::Parser::SourceHandler'=>'3.29','TAP::Parser::SourceHandler::Executable'=>'3.29','TAP::Parser::SourceHandler::File'=>'3.29','TAP::Parser::SourceHandler::Handle'=>'3.29','TAP::Parser::SourceHandler::Perl'=>'3.29','TAP::Parser::SourceHandler::RawTAP'=>'3.29','TAP::Parser::YAMLish::Reader'=>'3.29','TAP::Parser::YAMLish::Writer'=>'3.29','Test::Builder'=>'0.99','Test::Builder::Module'=>'0.99','Test::Builder::Tester'=>'1.23_002','Test::Builder::Tester::Color'=>'1.23_002','Test::Harness'=>'3.29','Test::More'=>'0.99','Test::Simple'=>'0.99','Unicode'=>'6.3.0','Unicode::Normalize'=>'1.17','Unicode::UCD'=>'0.55','attributes'=>'0.22','autodie'=>'2.22','autodie::exception'=>'2.22','autodie::exception::system'=>'2.22','autodie::hints'=>'2.22','autodie::skip'=>'2.22','feature'=>'1.34','threads'=>'1.89','warnings'=>'1.20',},removed=>{'TAP::Parser::Utils'=>1,}},5.019006=>{delta_from=>5.019005,changed=>{'App::Prove'=>'3.30','App::Prove::State'=>'3.30','App::Prove::State::Result'=>'3.30','App::Prove::State::Result::Test'=>'3.30','Archive::Tar'=>'1.96','Archive::Tar::Constant'=>'1.96','Archive::Tar::File'=>'1.96','AutoLoader'=>'5.74','B'=>'1.47','B::Concise'=>'0.991','B::Debug'=>'1.19','B::Deparse'=>'1.24','Benchmark'=>'1.18','Compress::Raw::Bzip2'=>'2.063','Compress::Raw::Zlib'=>'2.063','Compress::Zlib'=>'2.063','Config'=>'5.019006','DB_File'=>'1.831','Devel::Peek'=>'1.15','DynaLoader'=>'1.21','Errno'=>'1.20_01','ExtUtils::Command::MM'=>'6.82','ExtUtils::Liblist'=>'6.82','ExtUtils::Liblist::Kid'=>'6.82','ExtUtils::MM'=>'6.82','ExtUtils::MM_AIX'=>'6.82','ExtUtils::MM_Any'=>'6.82','ExtUtils::MM_BeOS'=>'6.82','ExtUtils::MM_Cygwin'=>'6.82','ExtUtils::MM_DOS'=>'6.82','ExtUtils::MM_Darwin'=>'6.82','ExtUtils::MM_MacOS'=>'6.82','ExtUtils::MM_NW5'=>'6.82','ExtUtils::MM_OS2'=>'6.82','ExtUtils::MM_QNX'=>'6.82','ExtUtils::MM_UWIN'=>'6.82','ExtUtils::MM_Unix'=>'6.82','ExtUtils::MM_VMS'=>'6.82','ExtUtils::MM_VOS'=>'6.82','ExtUtils::MM_Win32'=>'6.82','ExtUtils::MM_Win95'=>'6.82','ExtUtils::MY'=>'6.82','ExtUtils::MakeMaker'=>'6.82','ExtUtils::MakeMaker::Config'=>'6.82','ExtUtils::Mkbootstrap'=>'6.82','ExtUtils::Mksymlists'=>'6.82','ExtUtils::testlib'=>'6.82','File::DosGlob'=>'1.12','File::Find'=>'1.26','File::Glob'=>'1.23','HTTP::Tiny'=>'0.038','IO'=>'1.30','IO::Compress::Adapter::Bzip2'=>'2.063','IO::Compress::Adapter::Deflate'=>'2.063','IO::Compress::Adapter::Identity'=>'2.063','IO::Compress::Base'=>'2.063','IO::Compress::Base::Common'=>'2.063','IO::Compress::Bzip2'=>'2.063','IO::Compress::Deflate'=>'2.063','IO::Compress::Gzip'=>'2.063','IO::Compress::Gzip::Constants'=>'2.063','IO::Compress::RawDeflate'=>'2.063','IO::Compress::Zip'=>'2.063','IO::Compress::Zip::Constants'=>'2.063','IO::Compress::Zlib::Constants'=>'2.063','IO::Compress::Zlib::Extra'=>'2.063','IO::Select'=>'1.22','IO::Uncompress::Adapter::Bunzip2'=>'2.063','IO::Uncompress::Adapter::Identity'=>'2.063','IO::Uncompress::Adapter::Inflate'=>'2.063','IO::Uncompress::AnyInflate'=>'2.063','IO::Uncompress::AnyUncompress'=>'2.063','IO::Uncompress::Base'=>'2.063','IO::Uncompress::Bunzip2'=>'2.063','IO::Uncompress::Gunzip'=>'2.063','IO::Uncompress::Inflate'=>'2.063','IO::Uncompress::RawInflate'=>'2.063','IO::Uncompress::Unzip'=>'2.063','IPC::Cmd'=>'0.90','Locale::Maketext'=>'1.25','Module::Build'=>'0.4202','Module::Build::Base'=>'0.4202','Module::Build::Compat'=>'0.4202','Module::Build::Config'=>'0.4202','Module::Build::Cookbook'=>'0.4202','Module::Build::Dumper'=>'0.4202','Module::Build::ModuleInfo'=>'0.4202','Module::Build::Notes'=>'0.4202','Module::Build::PPMMaker'=>'0.4202','Module::Build::Platform::Default'=>'0.4202','Module::Build::Platform::MacOS'=>'0.4202','Module::Build::Platform::Unix'=>'0.4202','Module::Build::Platform::VMS'=>'0.4202','Module::Build::Platform::VOS'=>'0.4202','Module::Build::Platform::Windows'=>'0.4202','Module::Build::Platform::aix'=>'0.4202','Module::Build::Platform::cygwin'=>'0.4202','Module::Build::Platform::darwin'=>'0.4202','Module::Build::Platform::os2'=>'0.4202','Module::Build::PodParser'=>'0.4202','Module::CoreList'=>'3.01','Module::CoreList::TieHashDelta'=>'3.01','Module::CoreList::Utils'=>'3.01','Opcode'=>'1.27','POSIX'=>'1.36','Package::Constants'=>'0.04','PerlIO::scalar'=>'0.18','PerlIO::via'=>'0.13','SDBM_File'=>'1.10','Socket'=>'2.013','TAP::Base'=>'3.30','TAP::Formatter::Base'=>'3.30','TAP::Formatter::Color'=>'3.30','TAP::Formatter::Console'=>'3.30','TAP::Formatter::Console::ParallelSession'=>'3.30','TAP::Formatter::Console::Session'=>'3.30','TAP::Formatter::File'=>'3.30','TAP::Formatter::File::Session'=>'3.30','TAP::Formatter::Session'=>'3.30','TAP::Harness'=>'3.30','TAP::Harness::Env'=>'3.30','TAP::Object'=>'3.30','TAP::Parser'=>'3.30','TAP::Parser::Aggregator'=>'3.30','TAP::Parser::Grammar'=>'3.30','TAP::Parser::Iterator'=>'3.30','TAP::Parser::Iterator::Array'=>'3.30','TAP::Parser::Iterator::Process'=>'3.30','TAP::Parser::Iterator::Stream'=>'3.30','TAP::Parser::IteratorFactory'=>'3.30','TAP::Parser::Multiplexer'=>'3.30','TAP::Parser::Result'=>'3.30','TAP::Parser::Result::Bailout'=>'3.30','TAP::Parser::Result::Comment'=>'3.30','TAP::Parser::Result::Plan'=>'3.30','TAP::Parser::Result::Pragma'=>'3.30','TAP::Parser::Result::Test'=>'3.30','TAP::Parser::Result::Unknown'=>'3.30','TAP::Parser::Result::Version'=>'3.30','TAP::Parser::Result::YAML'=>'3.30','TAP::Parser::ResultFactory'=>'3.30','TAP::Parser::Scheduler'=>'3.30','TAP::Parser::Scheduler::Job'=>'3.30','TAP::Parser::Scheduler::Spinner'=>'3.30','TAP::Parser::Source'=>'3.30','TAP::Parser::SourceHandler'=>'3.30','TAP::Parser::SourceHandler::Executable'=>'3.30','TAP::Parser::SourceHandler::File'=>'3.30','TAP::Parser::SourceHandler::Handle'=>'3.30','TAP::Parser::SourceHandler::Perl'=>'3.30','TAP::Parser::SourceHandler::RawTAP'=>'3.30','TAP::Parser::YAMLish::Reader'=>'3.30','TAP::Parser::YAMLish::Writer'=>'3.30','Term::Cap'=>'1.15','Test::Builder'=>'1.001002','Test::Builder::Module'=>'1.001002','Test::Harness'=>'3.30','Test::More'=>'1.001002','Test::Simple'=>'1.001002','Tie::StdHandle'=>'4.4','Unicode::Collate'=>'1.02','Unicode::Collate::CJK::Korean'=>'1.02','Unicode::Collate::Locale'=>'1.02','XS::APItest'=>'0.57','XS::Typemap'=>'0.12','arybase'=>'0.07','bignum'=>'0.37','constant'=>'1.29','fields'=>'2.17','inc::latest'=>'0.4202','threads'=>'1.90','threads::shared'=>'1.45',},removed=>{}},5.019007=>{delta_from=>5.019006,changed=>{'CGI'=>'3.64','CGI::Apache'=>'1.02','CGI::Carp'=>'3.64','CGI::Cookie'=>'1.31','CGI::Fast'=>'1.10','CGI::Pretty'=>'3.64','CGI::Push'=>'1.06','CGI::Switch'=>'1.02','CGI::Util'=>'3.64','CPAN::Meta'=>'2.133380','CPAN::Meta::Converter'=>'2.133380','CPAN::Meta::Feature'=>'2.133380','CPAN::Meta::History'=>'2.133380','CPAN::Meta::Prereqs'=>'2.133380','CPAN::Meta::Spec'=>'2.133380','CPAN::Meta::Validator'=>'2.133380','Config'=>'5.019007','Data::Dumper'=>'2.150','DynaLoader'=>'1.22','ExtUtils::Command::MM'=>'6.84','ExtUtils::Liblist'=>'6.84','ExtUtils::Liblist::Kid'=>'6.84','ExtUtils::MM'=>'6.84','ExtUtils::MM_AIX'=>'6.84','ExtUtils::MM_Any'=>'6.84','ExtUtils::MM_BeOS'=>'6.84','ExtUtils::MM_Cygwin'=>'6.84','ExtUtils::MM_DOS'=>'6.84','ExtUtils::MM_Darwin'=>'6.84','ExtUtils::MM_MacOS'=>'6.84','ExtUtils::MM_NW5'=>'6.84','ExtUtils::MM_OS2'=>'6.84','ExtUtils::MM_QNX'=>'6.84','ExtUtils::MM_UWIN'=>'6.84','ExtUtils::MM_Unix'=>'6.84','ExtUtils::MM_VMS'=>'6.84','ExtUtils::MM_VOS'=>'6.84','ExtUtils::MM_Win32'=>'6.84','ExtUtils::MM_Win95'=>'6.84','ExtUtils::MY'=>'6.84','ExtUtils::MakeMaker'=>'6.84','ExtUtils::MakeMaker::Config'=>'6.84','ExtUtils::Mkbootstrap'=>'6.84','ExtUtils::Mksymlists'=>'6.84','ExtUtils::testlib'=>'6.84','File::Fetch'=>'0.46','HTTP::Tiny'=>'0.039','Locale::Codes'=>'3.28','Locale::Codes::Constants'=>'3.28','Locale::Codes::Country'=>'3.28','Locale::Codes::Country_Codes'=>'3.28','Locale::Codes::Country_Retired'=>'3.28','Locale::Codes::Currency'=>'3.28','Locale::Codes::Currency_Codes'=>'3.28','Locale::Codes::Currency_Retired'=>'3.28','Locale::Codes::LangExt'=>'3.28','Locale::Codes::LangExt_Codes'=>'3.28','Locale::Codes::LangExt_Retired'=>'3.28','Locale::Codes::LangFam'=>'3.28','Locale::Codes::LangFam_Codes'=>'3.28','Locale::Codes::LangFam_Retired'=>'3.28','Locale::Codes::LangVar'=>'3.28','Locale::Codes::LangVar_Codes'=>'3.28','Locale::Codes::LangVar_Retired'=>'3.28','Locale::Codes::Language'=>'3.28','Locale::Codes::Language_Codes'=>'3.28','Locale::Codes::Language_Retired'=>'3.28','Locale::Codes::Script'=>'3.28','Locale::Codes::Script_Codes'=>'3.28','Locale::Codes::Script_Retired'=>'3.28','Locale::Country'=>'3.28','Locale::Currency'=>'3.28','Locale::Language'=>'3.28','Locale::Script'=>'3.28','Module::Build'=>'0.4203','Module::Build::Base'=>'0.4203','Module::Build::Compat'=>'0.4203','Module::Build::Config'=>'0.4203','Module::Build::Cookbook'=>'0.4203','Module::Build::Dumper'=>'0.4203','Module::Build::ModuleInfo'=>'0.4203','Module::Build::Notes'=>'0.4203','Module::Build::PPMMaker'=>'0.4203','Module::Build::Platform::Default'=>'0.4203','Module::Build::Platform::MacOS'=>'0.4203','Module::Build::Platform::Unix'=>'0.4203','Module::Build::Platform::VMS'=>'0.4203','Module::Build::Platform::VOS'=>'0.4203','Module::Build::Platform::Windows'=>'0.4203','Module::Build::Platform::aix'=>'0.4203','Module::Build::Platform::cygwin'=>'0.4203','Module::Build::Platform::darwin'=>'0.4203','Module::Build::Platform::os2'=>'0.4203','Module::Build::PodParser'=>'0.4203','Module::CoreList'=>'3.02','Module::CoreList::TieHashDelta'=>'3.02','Module::CoreList::Utils'=>'3.02','POSIX'=>'1.37','PerlIO::encoding'=>'0.17','PerlIO::via'=>'0.14','SDBM_File'=>'1.11','Storable'=>'2.48','Time::Piece'=>'1.24','Time::Seconds'=>'1.24','Unicode::Collate'=>'1.04','Win32'=>'0.48','XS::APItest'=>'0.58','base'=>'2.20','constant'=>'1.30','inc::latest'=>'0.4203','threads'=>'1.91',},removed=>{}},5.019008=>{delta_from=>5.019007,changed=>{'Config'=>'5.019008','DynaLoader'=>'1.24','Encode'=>'2.57','Errno'=>'1.20_02','ExtUtils::CBuilder'=>'0.280213','ExtUtils::CBuilder::Base'=>'0.280213','ExtUtils::CBuilder::Platform::Unix'=>'0.280213','ExtUtils::CBuilder::Platform::VMS'=>'0.280213','ExtUtils::CBuilder::Platform::Windows'=>'0.280213','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280213','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280213','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280213','ExtUtils::CBuilder::Platform::aix'=>'0.280213','ExtUtils::CBuilder::Platform::cygwin'=>'0.280213','ExtUtils::CBuilder::Platform::darwin'=>'0.280213','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280213','ExtUtils::CBuilder::Platform::os2'=>'0.280213','ExtUtils::Command::MM'=>'6.86','ExtUtils::Liblist'=>'6.86','ExtUtils::Liblist::Kid'=>'6.86','ExtUtils::MM'=>'6.86','ExtUtils::MM_AIX'=>'6.86','ExtUtils::MM_Any'=>'6.86','ExtUtils::MM_BeOS'=>'6.86','ExtUtils::MM_Cygwin'=>'6.86','ExtUtils::MM_DOS'=>'6.86','ExtUtils::MM_Darwin'=>'6.86','ExtUtils::MM_MacOS'=>'6.86','ExtUtils::MM_NW5'=>'6.86','ExtUtils::MM_OS2'=>'6.86','ExtUtils::MM_QNX'=>'6.86','ExtUtils::MM_UWIN'=>'6.86','ExtUtils::MM_Unix'=>'6.86','ExtUtils::MM_VMS'=>'6.86','ExtUtils::MM_VOS'=>'6.86','ExtUtils::MM_Win32'=>'6.86','ExtUtils::MM_Win95'=>'6.86','ExtUtils::MY'=>'6.86','ExtUtils::MakeMaker'=>'6.86','ExtUtils::MakeMaker::Config'=>'6.86','ExtUtils::Mkbootstrap'=>'6.86','ExtUtils::Mksymlists'=>'6.86','ExtUtils::testlib'=>'6.86','File::Copy'=>'2.29','Hash::Util::FieldHash'=>'1.14','IO::Socket::IP'=>'0.26','IO::Socket::UNIX'=>'1.26','List::Util'=>'1.36','List::Util::XS'=>'1.36','Module::Build'=>'0.4204','Module::Build::Base'=>'0.4204','Module::Build::Compat'=>'0.4204','Module::Build::Config'=>'0.4204','Module::Build::Cookbook'=>'0.4204','Module::Build::Dumper'=>'0.4204','Module::Build::ModuleInfo'=>'0.4204','Module::Build::Notes'=>'0.4204','Module::Build::PPMMaker'=>'0.4204','Module::Build::Platform::Default'=>'0.4204','Module::Build::Platform::MacOS'=>'0.4204','Module::Build::Platform::Unix'=>'0.4204','Module::Build::Platform::VMS'=>'0.4204','Module::Build::Platform::VOS'=>'0.4204','Module::Build::Platform::Windows'=>'0.4204','Module::Build::Platform::aix'=>'0.4204','Module::Build::Platform::cygwin'=>'0.4204','Module::Build::Platform::darwin'=>'0.4204','Module::Build::Platform::os2'=>'0.4204','Module::Build::PodParser'=>'0.4204','Module::CoreList'=>'3.04','Module::CoreList::TieHashDelta'=>'3.04','Module::CoreList::Utils'=>'3.04','Module::Load'=>'0.28','Module::Load::Conditional'=>'0.60','Net::Config'=>'1.13','Net::FTP::A'=>'1.19','POSIX'=>'1.38_01','Perl::OSType'=>'1.007','PerlIO::encoding'=>'0.18','Pod::Perldoc'=>'3.21','Pod::Perldoc::BaseTo'=>'3.21','Pod::Perldoc::GetOptsOO'=>'3.21','Pod::Perldoc::ToANSI'=>'3.21','Pod::Perldoc::ToChecker'=>'3.21','Pod::Perldoc::ToMan'=>'3.21','Pod::Perldoc::ToNroff'=>'3.21','Pod::Perldoc::ToPod'=>'3.21','Pod::Perldoc::ToRtf'=>'3.21','Pod::Perldoc::ToTerm'=>'3.21','Pod::Perldoc::ToText'=>'3.21','Pod::Perldoc::ToTk'=>'3.21','Pod::Perldoc::ToXml'=>'3.21','Scalar::Util'=>'1.36','Time::Piece'=>'1.27','Time::Seconds'=>'1.27','Unicode::UCD'=>'0.57','XS::APItest'=>'0.59','XSLoader'=>'0.17','base'=>'2.21','constant'=>'1.31','inc::latest'=>'0.4204','threads::shared'=>'1.46','version'=>'0.9907','version::regex'=>'0.9907','version::vpp'=>'0.9907','warnings'=>'1.21',},removed=>{}},5.019009=>{delta_from=>5.019008,changed=>{'B'=>'1.48','B::Concise'=>'0.992','B::Deparse'=>'1.25','CGI'=>'3.65','CPAN::Meta::YAML'=>'0.011','Compress::Raw::Bzip2'=>'2.064','Compress::Raw::Zlib'=>'2.065','Compress::Zlib'=>'2.064','Config'=>'5.019009','Config::Perl::V'=>'0.20','Cwd'=>'3.47','Devel::Peek'=>'1.16','Digest::SHA'=>'5.87','DynaLoader'=>'1.25','English'=>'1.09','ExtUtils::CBuilder'=>'0.280216','ExtUtils::CBuilder::Base'=>'0.280216','ExtUtils::CBuilder::Platform::Unix'=>'0.280216','ExtUtils::CBuilder::Platform::VMS'=>'0.280216','ExtUtils::CBuilder::Platform::Windows'=>'0.280216','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280216','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280216','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280216','ExtUtils::CBuilder::Platform::aix'=>'0.280216','ExtUtils::CBuilder::Platform::android'=>'0.280216','ExtUtils::CBuilder::Platform::cygwin'=>'0.280216','ExtUtils::CBuilder::Platform::darwin'=>'0.280216','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280216','ExtUtils::CBuilder::Platform::os2'=>'0.280216','ExtUtils::Command::MM'=>'6.88','ExtUtils::Embed'=>'1.32','ExtUtils::Install'=>'1.62','ExtUtils::Installed'=>'1.999004','ExtUtils::Liblist'=>'6.88','ExtUtils::Liblist::Kid'=>'6.88','ExtUtils::MM'=>'6.88','ExtUtils::MM_AIX'=>'6.88','ExtUtils::MM_Any'=>'6.88','ExtUtils::MM_BeOS'=>'6.88','ExtUtils::MM_Cygwin'=>'6.88','ExtUtils::MM_DOS'=>'6.88','ExtUtils::MM_Darwin'=>'6.88','ExtUtils::MM_MacOS'=>'6.88','ExtUtils::MM_NW5'=>'6.88','ExtUtils::MM_OS2'=>'6.88','ExtUtils::MM_QNX'=>'6.88','ExtUtils::MM_UWIN'=>'6.88','ExtUtils::MM_Unix'=>'6.88','ExtUtils::MM_VMS'=>'6.88','ExtUtils::MM_VOS'=>'6.88','ExtUtils::MM_Win32'=>'6.88','ExtUtils::MM_Win95'=>'6.88','ExtUtils::MY'=>'6.88','ExtUtils::MakeMaker'=>'6.88','ExtUtils::MakeMaker::Config'=>'6.88','ExtUtils::Mkbootstrap'=>'6.88','ExtUtils::Mksymlists'=>'6.88','ExtUtils::Packlist'=>'1.47','ExtUtils::testlib'=>'6.88','Fatal'=>'2.23','File::Fetch'=>'0.48','File::Spec'=>'3.47','File::Spec::Cygwin'=>'3.47','File::Spec::Epoc'=>'3.47','File::Spec::Functions'=>'3.47','File::Spec::Mac'=>'3.47','File::Spec::OS2'=>'3.47','File::Spec::Unix'=>'3.47','File::Spec::VMS'=>'3.47','File::Spec::Win32'=>'3.47','HTTP::Tiny'=>'0.042','IO::Compress::Adapter::Bzip2'=>'2.064','IO::Compress::Adapter::Deflate'=>'2.064','IO::Compress::Adapter::Identity'=>'2.064','IO::Compress::Base'=>'2.064','IO::Compress::Base::Common'=>'2.064','IO::Compress::Bzip2'=>'2.064','IO::Compress::Deflate'=>'2.064','IO::Compress::Gzip'=>'2.064','IO::Compress::Gzip::Constants'=>'2.064','IO::Compress::RawDeflate'=>'2.064','IO::Compress::Zip'=>'2.064','IO::Compress::Zip::Constants'=>'2.064','IO::Compress::Zlib::Constants'=>'2.064','IO::Compress::Zlib::Extra'=>'2.064','IO::Socket::INET'=>'1.35','IO::Socket::IP'=>'0.28','IO::Uncompress::Adapter::Bunzip2'=>'2.064','IO::Uncompress::Adapter::Identity'=>'2.064','IO::Uncompress::Adapter::Inflate'=>'2.064','IO::Uncompress::AnyInflate'=>'2.064','IO::Uncompress::AnyUncompress'=>'2.064','IO::Uncompress::Base'=>'2.064','IO::Uncompress::Bunzip2'=>'2.064','IO::Uncompress::Gunzip'=>'2.064','IO::Uncompress::Inflate'=>'2.064','IO::Uncompress::RawInflate'=>'2.064','IO::Uncompress::Unzip'=>'2.064','IPC::Cmd'=>'0.92','List::Util'=>'1.38','List::Util::XS'=>'1.38','Locale::Codes'=>'3.29','Locale::Codes::Constants'=>'3.29','Locale::Codes::Country'=>'3.29','Locale::Codes::Country_Codes'=>'3.29','Locale::Codes::Country_Retired'=>'3.29','Locale::Codes::Currency'=>'3.29','Locale::Codes::Currency_Codes'=>'3.29','Locale::Codes::Currency_Retired'=>'3.29','Locale::Codes::LangExt'=>'3.29','Locale::Codes::LangExt_Codes'=>'3.29','Locale::Codes::LangExt_Retired'=>'3.29','Locale::Codes::LangFam'=>'3.29','Locale::Codes::LangFam_Codes'=>'3.29','Locale::Codes::LangFam_Retired'=>'3.29','Locale::Codes::LangVar'=>'3.29','Locale::Codes::LangVar_Codes'=>'3.29','Locale::Codes::LangVar_Retired'=>'3.29','Locale::Codes::Language'=>'3.29','Locale::Codes::Language_Codes'=>'3.29','Locale::Codes::Language_Retired'=>'3.29','Locale::Codes::Script'=>'3.29','Locale::Codes::Script_Codes'=>'3.29','Locale::Codes::Script_Retired'=>'3.29','Locale::Country'=>'3.29','Locale::Currency'=>'3.29','Locale::Language'=>'3.29','Locale::Script'=>'3.29','Module::Build'=>'0.4205','Module::Build::Base'=>'0.4205','Module::Build::Compat'=>'0.4205','Module::Build::Config'=>'0.4205','Module::Build::Cookbook'=>'0.4205','Module::Build::Dumper'=>'0.4205','Module::Build::ModuleInfo'=>'0.4205','Module::Build::Notes'=>'0.4205','Module::Build::PPMMaker'=>'0.4205','Module::Build::Platform::Default'=>'0.4205','Module::Build::Platform::MacOS'=>'0.4205','Module::Build::Platform::Unix'=>'0.4205','Module::Build::Platform::VMS'=>'0.4205','Module::Build::Platform::VOS'=>'0.4205','Module::Build::Platform::Windows'=>'0.4205','Module::Build::Platform::aix'=>'0.4205','Module::Build::Platform::cygwin'=>'0.4205','Module::Build::Platform::darwin'=>'0.4205','Module::Build::Platform::os2'=>'0.4205','Module::Build::PodParser'=>'0.4205','Module::CoreList'=>'3.06','Module::CoreList::TieHashDelta'=>'3.06','Module::CoreList::Utils'=>'3.06','Module::Load'=>'0.30','Module::Load::Conditional'=>'0.62','Net::Domain'=>'2.23','Net::FTP'=>'2.79','Net::NNTP'=>'2.26','Net::POP3'=>'2.31','Net::Ping'=>'2.43','Net::SMTP'=>'2.33','POSIX'=>'1.38_02','Parse::CPAN::Meta'=>'1.4413','Pod::Escapes'=>'1.06','Pod::Find'=>'1.62','Pod::InputObjects'=>'1.62','Pod::ParseUtils'=>'1.62','Pod::Parser'=>'1.62','Pod::Select'=>'1.62','Scalar::Util'=>'1.38','autodie'=>'2.23','autodie::exception'=>'2.23','autodie::exception::system'=>'2.23','autodie::hints'=>'2.23','autodie::skip'=>'2.23','diagnostics'=>'1.34','feature'=>'1.35','inc::latest'=>'0.4205','locale'=>'1.03','mro'=>'1.15','threads'=>'1.92','version'=>'0.9908','version::regex'=>'0.9908','version::vpp'=>'0.9908','warnings'=>'1.22',},removed=>{}},5.01901=>{delta_from=>5.019009,changed=>{'App::Cpan'=>'1.62','Attribute::Handlers'=>'0.96','B::Deparse'=>'1.26','CPAN'=>'2.04','CPAN::Bundle'=>'5.5001','CPAN::Complete'=>'5.5001','CPAN::Distribution'=>'2.01','CPAN::Distroprefs'=>'6.0001','CPAN::FirstTime'=>'5.5305','CPAN::Meta'=>'2.140640','CPAN::Meta::Converter'=>'2.140640','CPAN::Meta::Feature'=>'2.140640','CPAN::Meta::History'=>'2.140640','CPAN::Meta::Prereqs'=>'2.140640','CPAN::Meta::Spec'=>'2.140640','CPAN::Meta::Validator'=>'2.140640','CPAN::Meta::YAML'=>'0.012','CPAN::Queue'=>'5.5002','CPAN::Shell'=>'5.5003','CPAN::Tarzip'=>'5.5012','CPAN::Version'=>'5.5003','Carp'=>'1.33','Carp::Heavy'=>'1.33','Config'=>'5.019010','Data::Dumper'=>'2.151','Devel::PPPort'=>'3.22','Digest::SHA'=>'5.88','ExtUtils::Command::MM'=>'6.92','ExtUtils::Install'=>'1.63','ExtUtils::Installed'=>'1.999005','ExtUtils::Liblist'=>'6.92','ExtUtils::Liblist::Kid'=>'6.92','ExtUtils::MM'=>'6.92','ExtUtils::MM_AIX'=>'6.92','ExtUtils::MM_Any'=>'6.92','ExtUtils::MM_BeOS'=>'6.92','ExtUtils::MM_Cygwin'=>'6.92','ExtUtils::MM_DOS'=>'6.92','ExtUtils::MM_Darwin'=>'6.92','ExtUtils::MM_MacOS'=>'6.92','ExtUtils::MM_NW5'=>'6.92','ExtUtils::MM_OS2'=>'6.92','ExtUtils::MM_QNX'=>'6.92','ExtUtils::MM_UWIN'=>'6.92','ExtUtils::MM_Unix'=>'6.92','ExtUtils::MM_VMS'=>'6.92','ExtUtils::MM_VOS'=>'6.92','ExtUtils::MM_Win32'=>'6.92','ExtUtils::MM_Win95'=>'6.92','ExtUtils::MY'=>'6.92','ExtUtils::MakeMaker'=>'6.92','ExtUtils::MakeMaker::Config'=>'6.92','ExtUtils::Mkbootstrap'=>'6.92','ExtUtils::Mksymlists'=>'6.92','ExtUtils::Packlist'=>'1.48','ExtUtils::ParseXS'=>'3.24','ExtUtils::ParseXS::Constants'=>'3.24','ExtUtils::ParseXS::CountLines'=>'3.24','ExtUtils::ParseXS::Eval'=>'3.24','ExtUtils::ParseXS::Utilities'=>'3.24','ExtUtils::Typemaps'=>'3.24','ExtUtils::Typemaps::Cmd'=>'3.24','ExtUtils::Typemaps::InputMap'=>'3.24','ExtUtils::Typemaps::OutputMap'=>'3.24','ExtUtils::Typemaps::Type'=>'3.24','ExtUtils::testlib'=>'6.92','File::Find'=>'1.27','Filter::Simple'=>'0.91','HTTP::Tiny'=>'0.043','Hash::Util::FieldHash'=>'1.15','IO'=>'1.31','IO::Socket::IP'=>'0.29','Locale::Codes'=>'3.30','Locale::Codes::Constants'=>'3.30','Locale::Codes::Country'=>'3.30','Locale::Codes::Country_Codes'=>'3.30','Locale::Codes::Country_Retired'=>'3.30','Locale::Codes::Currency'=>'3.30','Locale::Codes::Currency_Codes'=>'3.30','Locale::Codes::Currency_Retired'=>'3.30','Locale::Codes::LangExt'=>'3.30','Locale::Codes::LangExt_Codes'=>'3.30','Locale::Codes::LangExt_Retired'=>'3.30','Locale::Codes::LangFam'=>'3.30','Locale::Codes::LangFam_Codes'=>'3.30','Locale::Codes::LangFam_Retired'=>'3.30','Locale::Codes::LangVar'=>'3.30','Locale::Codes::LangVar_Codes'=>'3.30','Locale::Codes::LangVar_Retired'=>'3.30','Locale::Codes::Language'=>'3.30','Locale::Codes::Language_Codes'=>'3.30','Locale::Codes::Language_Retired'=>'3.30','Locale::Codes::Script'=>'3.30','Locale::Codes::Script_Codes'=>'3.30','Locale::Codes::Script_Retired'=>'3.30','Locale::Country'=>'3.30','Locale::Currency'=>'3.30','Locale::Language'=>'3.30','Locale::Script'=>'3.30','Module::CoreList'=>'3.09','Module::CoreList::TieHashDelta'=>'3.09','Module::CoreList::Utils'=>'3.09','Module::Load'=>'0.32','POSIX'=>'1.38_03','Parse::CPAN::Meta'=>'1.4414','Pod::Perldoc'=>'3.23','Pod::Perldoc::BaseTo'=>'3.23','Pod::Perldoc::GetOptsOO'=>'3.23','Pod::Perldoc::ToANSI'=>'3.23','Pod::Perldoc::ToChecker'=>'3.23','Pod::Perldoc::ToMan'=>'3.23','Pod::Perldoc::ToNroff'=>'3.23','Pod::Perldoc::ToPod'=>'3.23','Pod::Perldoc::ToRtf'=>'3.23','Pod::Perldoc::ToTerm'=>'3.23','Pod::Perldoc::ToText'=>'3.23','Pod::Perldoc::ToTk'=>'3.23','Pod::Perldoc::ToXml'=>'3.23','Thread::Queue'=>'3.05','XS::APItest'=>'0.60','XS::Typemap'=>'0.13','autouse'=>'1.08','base'=>'2.22','charnames'=>'1.40','feature'=>'1.36','mro'=>'1.16','threads'=>'1.93','warnings'=>'1.23','warnings::register'=>'1.03',},removed=>{}},5.019011=>{delta_from=>5.01901,changed=>{'CPAN'=>'2.05','CPAN::Distribution'=>'2.02','CPAN::FirstTime'=>'5.5306','CPAN::Shell'=>'5.5004','Carp'=>'1.3301','Carp::Heavy'=>'1.3301','Config'=>'5.019011','ExtUtils::Command::MM'=>'6.94','ExtUtils::Install'=>'1.67','ExtUtils::Liblist'=>'6.94','ExtUtils::Liblist::Kid'=>'6.94','ExtUtils::MM'=>'6.94','ExtUtils::MM_AIX'=>'6.94','ExtUtils::MM_Any'=>'6.94','ExtUtils::MM_BeOS'=>'6.94','ExtUtils::MM_Cygwin'=>'6.94','ExtUtils::MM_DOS'=>'6.94','ExtUtils::MM_Darwin'=>'6.94','ExtUtils::MM_MacOS'=>'6.94','ExtUtils::MM_NW5'=>'6.94','ExtUtils::MM_OS2'=>'6.94','ExtUtils::MM_QNX'=>'6.94','ExtUtils::MM_UWIN'=>'6.94','ExtUtils::MM_Unix'=>'6.94','ExtUtils::MM_VMS'=>'6.94','ExtUtils::MM_VOS'=>'6.94','ExtUtils::MM_Win32'=>'6.94','ExtUtils::MM_Win95'=>'6.94','ExtUtils::MY'=>'6.94','ExtUtils::MakeMaker'=>'6.94','ExtUtils::MakeMaker::Config'=>'6.94','ExtUtils::Mkbootstrap'=>'6.94','ExtUtils::Mksymlists'=>'6.94','ExtUtils::testlib'=>'6.94','Module::CoreList'=>'3.10','Module::CoreList::TieHashDelta'=>'3.10','Module::CoreList::Utils'=>'3.10','PerlIO'=>'1.09','Storable'=>'2.49','Win32'=>'0.49','experimental'=>'0.007',},removed=>{}},5.020000=>{delta_from=>5.019011,changed=>{'Config'=>'5.02','Devel::PPPort'=>'3.21','Encode'=>'2.60','Errno'=>'1.20_03','ExtUtils::Command::MM'=>'6.98','ExtUtils::Liblist'=>'6.98','ExtUtils::Liblist::Kid'=>'6.98','ExtUtils::MM'=>'6.98','ExtUtils::MM_AIX'=>'6.98','ExtUtils::MM_Any'=>'6.98','ExtUtils::MM_BeOS'=>'6.98','ExtUtils::MM_Cygwin'=>'6.98','ExtUtils::MM_DOS'=>'6.98','ExtUtils::MM_Darwin'=>'6.98','ExtUtils::MM_MacOS'=>'6.98','ExtUtils::MM_NW5'=>'6.98','ExtUtils::MM_OS2'=>'6.98','ExtUtils::MM_QNX'=>'6.98','ExtUtils::MM_UWIN'=>'6.98','ExtUtils::MM_Unix'=>'6.98','ExtUtils::MM_VMS'=>'6.98','ExtUtils::MM_VOS'=>'6.98','ExtUtils::MM_Win32'=>'6.98','ExtUtils::MM_Win95'=>'6.98','ExtUtils::MY'=>'6.98','ExtUtils::MakeMaker'=>'6.98','ExtUtils::MakeMaker::Config'=>'6.98','ExtUtils::Miniperl'=>'1.01','ExtUtils::Mkbootstrap'=>'6.98','ExtUtils::Mksymlists'=>'6.98','ExtUtils::testlib'=>'6.98','Pod::Functions::Functions'=>'1.08',},removed=>{}},5.021000=>{delta_from=>5.020000,changed=>{'Module::CoreList'=>'5.021001','Module::CoreList::TieHashDelta'=>'5.021001','Module::CoreList::Utils'=>'5.021001','feature'=>'1.37',},removed=>{'CGI'=>1,'CGI::Apache'=>1,'CGI::Carp'=>1,'CGI::Cookie'=>1,'CGI::Fast'=>1,'CGI::Pretty'=>1,'CGI::Push'=>1,'CGI::Switch'=>1,'CGI::Util'=>1,'Module::Build'=>1,'Module::Build::Base'=>1,'Module::Build::Compat'=>1,'Module::Build::Config'=>1,'Module::Build::ConfigData'=>1,'Module::Build::Cookbook'=>1,'Module::Build::Dumper'=>1,'Module::Build::ModuleInfo'=>1,'Module::Build::Notes'=>1,'Module::Build::PPMMaker'=>1,'Module::Build::Platform::Default'=>1,'Module::Build::Platform::MacOS'=>1,'Module::Build::Platform::Unix'=>1,'Module::Build::Platform::VMS'=>1,'Module::Build::Platform::VOS'=>1,'Module::Build::Platform::Windows'=>1,'Module::Build::Platform::aix'=>1,'Module::Build::Platform::cygwin'=>1,'Module::Build::Platform::darwin'=>1,'Module::Build::Platform::os2'=>1,'Module::Build::PodParser'=>1,'Module::Build::Version'=>1,'Module::Build::YAML'=>1,'Package::Constants'=>1,'inc::latest'=>1,}},5.021001=>{delta_from=>5.021000,changed=>{'App::Prove'=>'3.32','App::Prove::State'=>'3.32','App::Prove::State::Result'=>'3.32','App::Prove::State::Result::Test'=>'3.32','Archive::Tar'=>'2.00','Archive::Tar::Constant'=>'2.00','Archive::Tar::File'=>'2.00','B'=>'1.49','B::Deparse'=>'1.27','Benchmark'=>'1.19','CPAN::Meta'=>'2.141520','CPAN::Meta::Converter'=>'2.141520','CPAN::Meta::Feature'=>'2.141520','CPAN::Meta::History'=>'2.141520','CPAN::Meta::Prereqs'=>'2.141520','CPAN::Meta::Spec'=>'2.141520','CPAN::Meta::Validator'=>'2.141520','Carp'=>'1.34','Carp::Heavy'=>'1.34','Config'=>'5.021001','Cwd'=>'3.48','Data::Dumper'=>'2.152','Devel::PPPort'=>'3.24','Devel::Peek'=>'1.17','Digest::SHA'=>'5.92','DynaLoader'=>'1.26','Encode'=>'2.62','Errno'=>'1.20_04','Exporter'=>'5.71','Exporter::Heavy'=>'5.71','ExtUtils::Install'=>'1.68','ExtUtils::Miniperl'=>'1.02','ExtUtils::ParseXS'=>'3.25','ExtUtils::ParseXS::Constants'=>'3.25','ExtUtils::ParseXS::CountLines'=>'3.25','ExtUtils::ParseXS::Eval'=>'3.25','ExtUtils::ParseXS::Utilities'=>'3.25','ExtUtils::Typemaps'=>'3.25','ExtUtils::Typemaps::Cmd'=>'3.25','ExtUtils::Typemaps::InputMap'=>'3.25','ExtUtils::Typemaps::OutputMap'=>'3.25','ExtUtils::Typemaps::Type'=>'3.25','Fatal'=>'2.25','File::Spec'=>'3.48','File::Spec::Cygwin'=>'3.48','File::Spec::Epoc'=>'3.48','File::Spec::Functions'=>'3.48','File::Spec::Mac'=>'3.48','File::Spec::OS2'=>'3.48','File::Spec::Unix'=>'3.48','File::Spec::VMS'=>'3.48','File::Spec::Win32'=>'3.48','Hash::Util'=>'0.17','IO'=>'1.32','List::Util'=>'1.39','List::Util::XS'=>'1.39','Locale::Codes'=>'3.31','Locale::Codes::Constants'=>'3.31','Locale::Codes::Country'=>'3.31','Locale::Codes::Country_Codes'=>'3.31','Locale::Codes::Country_Retired'=>'3.31','Locale::Codes::Currency'=>'3.31','Locale::Codes::Currency_Codes'=>'3.31','Locale::Codes::Currency_Retired'=>'3.31','Locale::Codes::LangExt'=>'3.31','Locale::Codes::LangExt_Codes'=>'3.31','Locale::Codes::LangExt_Retired'=>'3.31','Locale::Codes::LangFam'=>'3.31','Locale::Codes::LangFam_Codes'=>'3.31','Locale::Codes::LangFam_Retired'=>'3.31','Locale::Codes::LangVar'=>'3.31','Locale::Codes::LangVar_Codes'=>'3.31','Locale::Codes::LangVar_Retired'=>'3.31','Locale::Codes::Language'=>'3.31','Locale::Codes::Language_Codes'=>'3.31','Locale::Codes::Language_Retired'=>'3.31','Locale::Codes::Script'=>'3.31','Locale::Codes::Script_Codes'=>'3.31','Locale::Codes::Script_Retired'=>'3.31','Locale::Country'=>'3.31','Locale::Currency'=>'3.31','Locale::Language'=>'3.31','Locale::Script'=>'3.31','Math::BigFloat'=>'1.9994','Math::BigInt'=>'1.9995','Math::BigInt::Calc'=>'1.9994','Math::BigInt::CalcEmu'=>'1.9994','Math::BigRat'=>'0.2608','Module::CoreList'=>'5.021001_01','Module::CoreList::TieHashDelta'=>'5.021001_01','Module::CoreList::Utils'=>'5.021001_01','Module::Metadata'=>'1.000024','NDBM_File'=>'1.13','Net::Config'=>'1.14','Net::SMTP'=>'2.34','Net::Time'=>'2.11','OS2::Process'=>'1.10','POSIX'=>'1.40','PerlIO::encoding'=>'0.19','PerlIO::mmap'=>'0.013','PerlIO::scalar'=>'0.19','PerlIO::via'=>'0.15','Pod::Html'=>'1.22','Scalar::Util'=>'1.39','SelfLoader'=>'1.22','Socket'=>'2.014','Storable'=>'2.51','TAP::Base'=>'3.32','TAP::Formatter::Base'=>'3.32','TAP::Formatter::Color'=>'3.32','TAP::Formatter::Console'=>'3.32','TAP::Formatter::Console::ParallelSession'=>'3.32','TAP::Formatter::Console::Session'=>'3.32','TAP::Formatter::File'=>'3.32','TAP::Formatter::File::Session'=>'3.32','TAP::Formatter::Session'=>'3.32','TAP::Harness'=>'3.32','TAP::Harness::Env'=>'3.32','TAP::Object'=>'3.32','TAP::Parser'=>'3.32','TAP::Parser::Aggregator'=>'3.32','TAP::Parser::Grammar'=>'3.32','TAP::Parser::Iterator'=>'3.32','TAP::Parser::Iterator::Array'=>'3.32','TAP::Parser::Iterator::Process'=>'3.32','TAP::Parser::Iterator::Stream'=>'3.32','TAP::Parser::IteratorFactory'=>'3.32','TAP::Parser::Multiplexer'=>'3.32','TAP::Parser::Result'=>'3.32','TAP::Parser::Result::Bailout'=>'3.32','TAP::Parser::Result::Comment'=>'3.32','TAP::Parser::Result::Plan'=>'3.32','TAP::Parser::Result::Pragma'=>'3.32','TAP::Parser::Result::Test'=>'3.32','TAP::Parser::Result::Unknown'=>'3.32','TAP::Parser::Result::Version'=>'3.32','TAP::Parser::Result::YAML'=>'3.32','TAP::Parser::ResultFactory'=>'3.32','TAP::Parser::Scheduler'=>'3.32','TAP::Parser::Scheduler::Job'=>'3.32','TAP::Parser::Scheduler::Spinner'=>'3.32','TAP::Parser::Source'=>'3.32','TAP::Parser::SourceHandler'=>'3.32','TAP::Parser::SourceHandler::Executable'=>'3.32','TAP::Parser::SourceHandler::File'=>'3.32','TAP::Parser::SourceHandler::Handle'=>'3.32','TAP::Parser::SourceHandler::Perl'=>'3.32','TAP::Parser::SourceHandler::RawTAP'=>'3.32','TAP::Parser::YAMLish::Reader'=>'3.32','TAP::Parser::YAMLish::Writer'=>'3.32','Term::ANSIColor'=>'4.03','Test::Builder'=>'1.001003','Test::Builder::Module'=>'1.001003','Test::Builder::Tester'=>'1.23_003','Test::Harness'=>'3.32','Test::More'=>'1.001003','Test::Simple'=>'1.001003','Tie::File'=>'1.01','Unicode'=>'7.0.0','Unicode::Collate'=>'1.07','Unicode::Normalize'=>'1.18','Unicode::UCD'=>'0.58','XS::APItest'=>'0.61','_charnames'=>'1.41','autodie'=>'2.25','autodie::Scope::Guard'=>'2.25','autodie::Scope::GuardStack'=>'2.25','autodie::ScopeUtil'=>'2.25','autodie::exception'=>'2.25','autodie::exception::system'=>'2.25','autodie::hints'=>'2.25','autodie::skip'=>'2.25','charnames'=>'1.41','locale'=>'1.04','threads'=>'1.94','utf8'=>'1.14','warnings'=>'1.24',},removed=>{}},5.021002=>{delta_from=>5.021001,changed=>{'B'=>'1.50','Config'=>'5.021002','Cwd'=>'3.49','Devel::Peek'=>'1.18','ExtUtils::Manifest'=>'1.64','File::Copy'=>'2.30','File::Spec'=>'3.49','File::Spec::Cygwin'=>'3.49','File::Spec::Epoc'=>'3.49','File::Spec::Functions'=>'3.49','File::Spec::Mac'=>'3.49','File::Spec::OS2'=>'3.49','File::Spec::Unix'=>'3.49','File::Spec::VMS'=>'3.49','File::Spec::Win32'=>'3.49','Filter::Simple'=>'0.92','Hash::Util'=>'0.18','IO'=>'1.33','IO::Socket::IP'=>'0.31','IPC::Open3'=>'1.17','Math::BigFloat'=>'1.9996','Math::BigInt'=>'1.9996','Math::BigInt::Calc'=>'1.9996','Math::BigInt::CalcEmu'=>'1.9996','Module::CoreList'=>'5.021002','Module::CoreList::TieHashDelta'=>'5.021002','Module::CoreList::Utils'=>'5.021002','POSIX'=>'1.41','Pod::Usage'=>'1.64','XS::APItest'=>'0.62','arybase'=>'0.08','experimental'=>'0.008','threads'=>'1.95','warnings'=>'1.26',},removed=>{}},5.021003=>{delta_from=>5.021002,changed=>{'B::Debug'=>'1.21','CPAN::Meta'=>'2.142060','CPAN::Meta::Converter'=>'2.142060','CPAN::Meta::Feature'=>'2.142060','CPAN::Meta::History'=>'2.142060','CPAN::Meta::Merge'=>'2.142060','CPAN::Meta::Prereqs'=>'2.142060','CPAN::Meta::Requirements'=>'2.126','CPAN::Meta::Spec'=>'2.142060','CPAN::Meta::Validator'=>'2.142060','Config'=>'5.021003','Config::Perl::V'=>'0.22','ExtUtils::CBuilder'=>'0.280217','ExtUtils::CBuilder::Base'=>'0.280217','ExtUtils::CBuilder::Platform::Unix'=>'0.280217','ExtUtils::CBuilder::Platform::VMS'=>'0.280217','ExtUtils::CBuilder::Platform::Windows'=>'0.280217','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280217','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280217','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280217','ExtUtils::CBuilder::Platform::aix'=>'0.280217','ExtUtils::CBuilder::Platform::android'=>'0.280217','ExtUtils::CBuilder::Platform::cygwin'=>'0.280217','ExtUtils::CBuilder::Platform::darwin'=>'0.280217','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280217','ExtUtils::CBuilder::Platform::os2'=>'0.280217','ExtUtils::Manifest'=>'1.65','HTTP::Tiny'=>'0.047','IPC::Open3'=>'1.18','Module::CoreList'=>'5.021003','Module::CoreList::TieHashDelta'=>'5.021003','Module::CoreList::Utils'=>'5.021003','Opcode'=>'1.28','POSIX'=>'1.42','Safe'=>'2.38','Socket'=>'2.015','Sys::Hostname'=>'1.19','UNIVERSAL'=>'1.12','XS::APItest'=>'0.63','perlfaq'=>'5.0150045',},removed=>{}},5.020001=>{delta_from=>5.020000,changed=>{'Config'=>'5.020001','Config::Perl::V'=>'0.22','Cwd'=>'3.48','Exporter'=>'5.71','Exporter::Heavy'=>'5.71','ExtUtils::CBuilder'=>'0.280217','ExtUtils::CBuilder::Base'=>'0.280217','ExtUtils::CBuilder::Platform::Unix'=>'0.280217','ExtUtils::CBuilder::Platform::VMS'=>'0.280217','ExtUtils::CBuilder::Platform::Windows'=>'0.280217','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280217','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280217','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280217','ExtUtils::CBuilder::Platform::aix'=>'0.280217','ExtUtils::CBuilder::Platform::android'=>'0.280217','ExtUtils::CBuilder::Platform::cygwin'=>'0.280217','ExtUtils::CBuilder::Platform::darwin'=>'0.280217','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280217','ExtUtils::CBuilder::Platform::os2'=>'0.280217','File::Copy'=>'2.30','File::Spec'=>'3.48','File::Spec::Cygwin'=>'3.48','File::Spec::Epoc'=>'3.48','File::Spec::Functions'=>'3.48','File::Spec::Mac'=>'3.48','File::Spec::OS2'=>'3.48','File::Spec::Unix'=>'3.48','File::Spec::VMS'=>'3.48','File::Spec::Win32'=>'3.48','Module::CoreList'=>'5.020001','Module::CoreList::TieHashDelta'=>'5.020001','Module::CoreList::Utils'=>'5.020001','PerlIO::via'=>'0.15','Unicode::UCD'=>'0.58','XS::APItest'=>'0.60_01','utf8'=>'1.13_01','version'=>'0.9909','version::regex'=>'0.9909','version::vpp'=>'0.9909',},removed=>{}},5.021004=>{delta_from=>5.021003,changed=>{'App::Prove'=>'3.33','App::Prove::State'=>'3.33','App::Prove::State::Result'=>'3.33','App::Prove::State::Result::Test'=>'3.33','Archive::Tar'=>'2.02','Archive::Tar::Constant'=>'2.02','Archive::Tar::File'=>'2.02','Attribute::Handlers'=>'0.97','B'=>'1.51','B::Concise'=>'0.993','B::Deparse'=>'1.28','B::Op_private'=>'5.021004','CPAN::Meta::Requirements'=>'2.128','Config'=>'5.021004','Cwd'=>'3.50','Data::Dumper'=>'2.154','ExtUtils::CBuilder'=>'0.280219','ExtUtils::CBuilder::Base'=>'0.280219','ExtUtils::CBuilder::Platform::Unix'=>'0.280219','ExtUtils::CBuilder::Platform::VMS'=>'0.280219','ExtUtils::CBuilder::Platform::Windows'=>'0.280219','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280219','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280219','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280219','ExtUtils::CBuilder::Platform::aix'=>'0.280219','ExtUtils::CBuilder::Platform::android'=>'0.280219','ExtUtils::CBuilder::Platform::cygwin'=>'0.280219','ExtUtils::CBuilder::Platform::darwin'=>'0.280219','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280219','ExtUtils::CBuilder::Platform::os2'=>'0.280219','ExtUtils::Install'=>'2.04','ExtUtils::Installed'=>'2.04','ExtUtils::Liblist::Kid'=>'6.98_01','ExtUtils::Manifest'=>'1.68','ExtUtils::Packlist'=>'2.04','File::Find'=>'1.28','File::Spec'=>'3.50','File::Spec::Cygwin'=>'3.50','File::Spec::Epoc'=>'3.50','File::Spec::Functions'=>'3.50','File::Spec::Mac'=>'3.50','File::Spec::OS2'=>'3.50','File::Spec::Unix'=>'3.50','File::Spec::VMS'=>'3.50','File::Spec::Win32'=>'3.50','Getopt::Std'=>'1.11','HTTP::Tiny'=>'0.049','IO'=>'1.34','IO::Socket::IP'=>'0.32','List::Util'=>'1.41','List::Util::XS'=>'1.41','Locale::Codes'=>'3.32','Locale::Codes::Constants'=>'3.32','Locale::Codes::Country'=>'3.32','Locale::Codes::Country_Codes'=>'3.32','Locale::Codes::Country_Retired'=>'3.32','Locale::Codes::Currency'=>'3.32','Locale::Codes::Currency_Codes'=>'3.32','Locale::Codes::Currency_Retired'=>'3.32','Locale::Codes::LangExt'=>'3.32','Locale::Codes::LangExt_Codes'=>'3.32','Locale::Codes::LangExt_Retired'=>'3.32','Locale::Codes::LangFam'=>'3.32','Locale::Codes::LangFam_Codes'=>'3.32','Locale::Codes::LangFam_Retired'=>'3.32','Locale::Codes::LangVar'=>'3.32','Locale::Codes::LangVar_Codes'=>'3.32','Locale::Codes::LangVar_Retired'=>'3.32','Locale::Codes::Language'=>'3.32','Locale::Codes::Language_Codes'=>'3.32','Locale::Codes::Language_Retired'=>'3.32','Locale::Codes::Script'=>'3.32','Locale::Codes::Script_Codes'=>'3.32','Locale::Codes::Script_Retired'=>'3.32','Locale::Country'=>'3.32','Locale::Currency'=>'3.32','Locale::Language'=>'3.32','Locale::Script'=>'3.32','Math::BigFloat'=>'1.9997','Math::BigInt'=>'1.9997','Math::BigInt::Calc'=>'1.9997','Math::BigInt::CalcEmu'=>'1.9997','Module::CoreList'=>'5.20140920','Module::CoreList::TieHashDelta'=>'5.20140920','Module::CoreList::Utils'=>'5.20140920','POSIX'=>'1.43','Pod::Perldoc'=>'3.24','Pod::Perldoc::BaseTo'=>'3.24','Pod::Perldoc::GetOptsOO'=>'3.24','Pod::Perldoc::ToANSI'=>'3.24','Pod::Perldoc::ToChecker'=>'3.24','Pod::Perldoc::ToMan'=>'3.24','Pod::Perldoc::ToNroff'=>'3.24','Pod::Perldoc::ToPod'=>'3.24','Pod::Perldoc::ToRtf'=>'3.24','Pod::Perldoc::ToTerm'=>'3.24','Pod::Perldoc::ToText'=>'3.24','Pod::Perldoc::ToTk'=>'3.24','Pod::Perldoc::ToXml'=>'3.24','Scalar::Util'=>'1.41','Sub::Util'=>'1.41','TAP::Base'=>'3.33','TAP::Formatter::Base'=>'3.33','TAP::Formatter::Color'=>'3.33','TAP::Formatter::Console'=>'3.33','TAP::Formatter::Console::ParallelSession'=>'3.33','TAP::Formatter::Console::Session'=>'3.33','TAP::Formatter::File'=>'3.33','TAP::Formatter::File::Session'=>'3.33','TAP::Formatter::Session'=>'3.33','TAP::Harness'=>'3.33','TAP::Harness::Env'=>'3.33','TAP::Object'=>'3.33','TAP::Parser'=>'3.33','TAP::Parser::Aggregator'=>'3.33','TAP::Parser::Grammar'=>'3.33','TAP::Parser::Iterator'=>'3.33','TAP::Parser::Iterator::Array'=>'3.33','TAP::Parser::Iterator::Process'=>'3.33','TAP::Parser::Iterator::Stream'=>'3.33','TAP::Parser::IteratorFactory'=>'3.33','TAP::Parser::Multiplexer'=>'3.33','TAP::Parser::Result'=>'3.33','TAP::Parser::Result::Bailout'=>'3.33','TAP::Parser::Result::Comment'=>'3.33','TAP::Parser::Result::Plan'=>'3.33','TAP::Parser::Result::Pragma'=>'3.33','TAP::Parser::Result::Test'=>'3.33','TAP::Parser::Result::Unknown'=>'3.33','TAP::Parser::Result::Version'=>'3.33','TAP::Parser::Result::YAML'=>'3.33','TAP::Parser::ResultFactory'=>'3.33','TAP::Parser::Scheduler'=>'3.33','TAP::Parser::Scheduler::Job'=>'3.33','TAP::Parser::Scheduler::Spinner'=>'3.33','TAP::Parser::Source'=>'3.33','TAP::Parser::SourceHandler'=>'3.33','TAP::Parser::SourceHandler::Executable'=>'3.33','TAP::Parser::SourceHandler::File'=>'3.33','TAP::Parser::SourceHandler::Handle'=>'3.33','TAP::Parser::SourceHandler::Perl'=>'3.33','TAP::Parser::SourceHandler::RawTAP'=>'3.33','TAP::Parser::YAMLish::Reader'=>'3.33','TAP::Parser::YAMLish::Writer'=>'3.33','Term::ReadLine'=>'1.15','Test::Builder'=>'1.001006','Test::Builder::Module'=>'1.001006','Test::Builder::Tester'=>'1.24','Test::Builder::Tester::Color'=>'1.24','Test::Harness'=>'3.33','Test::More'=>'1.001006','Test::Simple'=>'1.001006','Time::Piece'=>'1.29','Time::Seconds'=>'1.29','XS::APItest'=>'0.64','_charnames'=>'1.42','attributes'=>'0.23','bigint'=>'0.37','bignum'=>'0.38','bigrat'=>'0.37','constant'=>'1.32','experimental'=>'0.010','overload'=>'1.23','threads'=>'1.96','version'=>'0.9909','version::regex'=>'0.9909','version::vpp'=>'0.9909',},removed=>{}},5.021005=>{delta_from=>5.021004,changed=>{'B'=>'1.52','B::Concise'=>'0.994','B::Debug'=>'1.22','B::Deparse'=>'1.29','B::Op_private'=>'5.021005','CPAN::Meta'=>'2.142690','CPAN::Meta::Converter'=>'2.142690','CPAN::Meta::Feature'=>'2.142690','CPAN::Meta::History'=>'2.142690','CPAN::Meta::Merge'=>'2.142690','CPAN::Meta::Prereqs'=>'2.142690','CPAN::Meta::Spec'=>'2.142690','CPAN::Meta::Validator'=>'2.142690','Compress::Raw::Bzip2'=>'2.066','Compress::Raw::Zlib'=>'2.066','Compress::Zlib'=>'2.066','Config'=>'5.021005','Cwd'=>'3.51','DynaLoader'=>'1.27','Errno'=>'1.21','ExtUtils::CBuilder'=>'0.280220','ExtUtils::CBuilder::Base'=>'0.280220','ExtUtils::CBuilder::Platform::Unix'=>'0.280220','ExtUtils::CBuilder::Platform::VMS'=>'0.280220','ExtUtils::CBuilder::Platform::Windows'=>'0.280220','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280220','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280220','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280220','ExtUtils::CBuilder::Platform::aix'=>'0.280220','ExtUtils::CBuilder::Platform::android'=>'0.280220','ExtUtils::CBuilder::Platform::cygwin'=>'0.280220','ExtUtils::CBuilder::Platform::darwin'=>'0.280220','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280220','ExtUtils::CBuilder::Platform::os2'=>'0.280220','ExtUtils::Miniperl'=>'1.03','Fcntl'=>'1.13','File::Find'=>'1.29','File::Spec'=>'3.51','File::Spec::Cygwin'=>'3.51','File::Spec::Epoc'=>'3.51','File::Spec::Functions'=>'3.51','File::Spec::Mac'=>'3.51','File::Spec::OS2'=>'3.51','File::Spec::Unix'=>'3.51','File::Spec::VMS'=>'3.51','File::Spec::Win32'=>'3.51','HTTP::Tiny'=>'0.050','IO::Compress::Adapter::Bzip2'=>'2.066','IO::Compress::Adapter::Deflate'=>'2.066','IO::Compress::Adapter::Identity'=>'2.066','IO::Compress::Base'=>'2.066','IO::Compress::Base::Common'=>'2.066','IO::Compress::Bzip2'=>'2.066','IO::Compress::Deflate'=>'2.066','IO::Compress::Gzip'=>'2.066','IO::Compress::Gzip::Constants'=>'2.066','IO::Compress::RawDeflate'=>'2.066','IO::Compress::Zip'=>'2.066','IO::Compress::Zip::Constants'=>'2.066','IO::Compress::Zlib::Constants'=>'2.066','IO::Compress::Zlib::Extra'=>'2.066','IO::Uncompress::Adapter::Bunzip2'=>'2.066','IO::Uncompress::Adapter::Identity'=>'2.066','IO::Uncompress::Adapter::Inflate'=>'2.066','IO::Uncompress::AnyInflate'=>'2.066','IO::Uncompress::AnyUncompress'=>'2.066','IO::Uncompress::Base'=>'2.066','IO::Uncompress::Bunzip2'=>'2.066','IO::Uncompress::Gunzip'=>'2.066','IO::Uncompress::Inflate'=>'2.066','IO::Uncompress::RawInflate'=>'2.066','IO::Uncompress::Unzip'=>'2.066','JSON::PP'=>'2.27300','Module::CoreList'=>'5.20141020','Module::CoreList::TieHashDelta'=>'5.20141020','Module::CoreList::Utils'=>'5.20141020','Net::Cmd'=>'3.02','Net::Config'=>'3.02','Net::Domain'=>'3.02','Net::FTP'=>'3.02','Net::FTP::A'=>'3.02','Net::FTP::E'=>'3.02','Net::FTP::I'=>'3.02','Net::FTP::L'=>'3.02','Net::FTP::dataconn'=>'3.02','Net::NNTP'=>'3.02','Net::Netrc'=>'3.02','Net::POP3'=>'3.02','Net::SMTP'=>'3.02','Net::Time'=>'3.02','Opcode'=>'1.29','POSIX'=>'1.45','Socket'=>'2.016','Test::Builder'=>'1.001008','Test::Builder::Module'=>'1.001008','Test::More'=>'1.001008','Test::Simple'=>'1.001008','XS::APItest'=>'0.65','XSLoader'=>'0.18','attributes'=>'0.24','experimental'=>'0.012','feature'=>'1.38','perlfaq'=>'5.0150046','re'=>'0.27','threads::shared'=>'1.47','warnings'=>'1.28','warnings::register'=>'1.04',},removed=>{}},5.021006=>{delta_from=>5.021005,changed=>{'App::Prove'=>'3.34','App::Prove::State'=>'3.34','App::Prove::State::Result'=>'3.34','App::Prove::State::Result::Test'=>'3.34','B'=>'1.53','B::Concise'=>'0.995','B::Deparse'=>'1.30','B::Op_private'=>'5.021006','CPAN::Meta'=>'2.143240','CPAN::Meta::Converter'=>'2.143240','CPAN::Meta::Feature'=>'2.143240','CPAN::Meta::History'=>'2.143240','CPAN::Meta::Merge'=>'2.143240','CPAN::Meta::Prereqs'=>'2.143240','CPAN::Meta::Requirements'=>'2.130','CPAN::Meta::Spec'=>'2.143240','CPAN::Meta::Validator'=>'2.143240','Config'=>'5.021006','Devel::Peek'=>'1.19','Digest::SHA'=>'5.93','DynaLoader'=>'1.28','Encode'=>'2.64','Exporter'=>'5.72','Exporter::Heavy'=>'5.72','ExtUtils::Command::MM'=>'7.02','ExtUtils::Liblist'=>'7.02','ExtUtils::Liblist::Kid'=>'7.02','ExtUtils::MM'=>'7.02','ExtUtils::MM_AIX'=>'7.02','ExtUtils::MM_Any'=>'7.02','ExtUtils::MM_BeOS'=>'7.02','ExtUtils::MM_Cygwin'=>'7.02','ExtUtils::MM_DOS'=>'7.02','ExtUtils::MM_Darwin'=>'7.02','ExtUtils::MM_MacOS'=>'7.02','ExtUtils::MM_NW5'=>'7.02','ExtUtils::MM_OS2'=>'7.02','ExtUtils::MM_QNX'=>'7.02','ExtUtils::MM_UWIN'=>'7.02','ExtUtils::MM_Unix'=>'7.02','ExtUtils::MM_VMS'=>'7.02','ExtUtils::MM_VOS'=>'7.02','ExtUtils::MM_Win32'=>'7.02','ExtUtils::MM_Win95'=>'7.02','ExtUtils::MY'=>'7.02','ExtUtils::MakeMaker'=>'7.02','ExtUtils::MakeMaker::Config'=>'7.02','ExtUtils::MakeMaker::Locale'=>'7.02','ExtUtils::MakeMaker::version'=>'7.02','ExtUtils::MakeMaker::version::regex'=>'7.02','ExtUtils::MakeMaker::version::vpp'=>'7.02','ExtUtils::Manifest'=>'1.69','ExtUtils::Mkbootstrap'=>'7.02','ExtUtils::Mksymlists'=>'7.02','ExtUtils::ParseXS'=>'3.26','ExtUtils::ParseXS::Constants'=>'3.26','ExtUtils::ParseXS::CountLines'=>'3.26','ExtUtils::ParseXS::Eval'=>'3.26','ExtUtils::ParseXS::Utilities'=>'3.26','ExtUtils::testlib'=>'7.02','File::Spec::VMS'=>'3.52','HTTP::Tiny'=>'0.051','I18N::Langinfo'=>'0.12','IO::Socket'=>'1.38','Module::CoreList'=>'5.20141120','Module::CoreList::TieHashDelta'=>'5.20141120','Module::CoreList::Utils'=>'5.20141120','POSIX'=>'1.46','PerlIO::encoding'=>'0.20','PerlIO::scalar'=>'0.20','TAP::Base'=>'3.34','TAP::Formatter::Base'=>'3.34','TAP::Formatter::Color'=>'3.34','TAP::Formatter::Console'=>'3.34','TAP::Formatter::Console::ParallelSession'=>'3.34','TAP::Formatter::Console::Session'=>'3.34','TAP::Formatter::File'=>'3.34','TAP::Formatter::File::Session'=>'3.34','TAP::Formatter::Session'=>'3.34','TAP::Harness'=>'3.34','TAP::Harness::Env'=>'3.34','TAP::Object'=>'3.34','TAP::Parser'=>'3.34','TAP::Parser::Aggregator'=>'3.34','TAP::Parser::Grammar'=>'3.34','TAP::Parser::Iterator'=>'3.34','TAP::Parser::Iterator::Array'=>'3.34','TAP::Parser::Iterator::Process'=>'3.34','TAP::Parser::Iterator::Stream'=>'3.34','TAP::Parser::IteratorFactory'=>'3.34','TAP::Parser::Multiplexer'=>'3.34','TAP::Parser::Result'=>'3.34','TAP::Parser::Result::Bailout'=>'3.34','TAP::Parser::Result::Comment'=>'3.34','TAP::Parser::Result::Plan'=>'3.34','TAP::Parser::Result::Pragma'=>'3.34','TAP::Parser::Result::Test'=>'3.34','TAP::Parser::Result::Unknown'=>'3.34','TAP::Parser::Result::Version'=>'3.34','TAP::Parser::Result::YAML'=>'3.34','TAP::Parser::ResultFactory'=>'3.34','TAP::Parser::Scheduler'=>'3.34','TAP::Parser::Scheduler::Job'=>'3.34','TAP::Parser::Scheduler::Spinner'=>'3.34','TAP::Parser::Source'=>'3.34','TAP::Parser::SourceHandler'=>'3.34','TAP::Parser::SourceHandler::Executable'=>'3.34','TAP::Parser::SourceHandler::File'=>'3.34','TAP::Parser::SourceHandler::Handle'=>'3.34','TAP::Parser::SourceHandler::Perl'=>'3.34','TAP::Parser::SourceHandler::RawTAP'=>'3.34','TAP::Parser::YAMLish::Reader'=>'3.34','TAP::Parser::YAMLish::Writer'=>'3.34','Test::Builder'=>'1.301001_075','Test::Builder::Module'=>'1.301001_075','Test::Builder::Tester'=>'1.301001_075','Test::Builder::Tester::Color'=>'1.301001_075','Test::Harness'=>'3.34','Test::More'=>'1.301001_075','Test::More::DeepCheck'=>undef,'Test::More::DeepCheck::Strict'=>undef,'Test::More::DeepCheck::Tolerant'=>undef,'Test::More::Tools'=>undef,'Test::MostlyLike'=>undef,'Test::Simple'=>'1.301001_075','Test::Stream'=>'1.301001_075','Test::Stream::ArrayBase'=>undef,'Test::Stream::ArrayBase::Meta'=>undef,'Test::Stream::Carp'=>undef,'Test::Stream::Context'=>undef,'Test::Stream::Event'=>undef,'Test::Stream::Event::Bail'=>undef,'Test::Stream::Event::Child'=>undef,'Test::Stream::Event::Diag'=>undef,'Test::Stream::Event::Finish'=>undef,'Test::Stream::Event::Note'=>undef,'Test::Stream::Event::Ok'=>undef,'Test::Stream::Event::Plan'=>undef,'Test::Stream::Event::Subtest'=>undef,'Test::Stream::ExitMagic'=>undef,'Test::Stream::ExitMagic::Context'=>undef,'Test::Stream::Exporter'=>undef,'Test::Stream::Exporter::Meta'=>undef,'Test::Stream::IOSets'=>undef,'Test::Stream::Meta'=>undef,'Test::Stream::PackageUtil'=>undef,'Test::Stream::Tester'=>undef,'Test::Stream::Tester::Checks'=>undef,'Test::Stream::Tester::Checks::Event'=>undef,'Test::Stream::Tester::Events'=>undef,'Test::Stream::Tester::Events::Event'=>undef,'Test::Stream::Tester::Grab'=>undef,'Test::Stream::Threads'=>undef,'Test::Stream::Toolset'=>undef,'Test::Stream::Util'=>undef,'Test::Tester'=>'1.301001_075','Test::Tester::Capture'=>undef,'Test::use::ok'=>'1.301001_075','Unicode::UCD'=>'0.59','XS::APItest'=>'0.68','XSLoader'=>'0.19','experimental'=>'0.013','locale'=>'1.05','ok'=>'1.301001_075','overload'=>'1.24','re'=>'0.28','warnings'=>'1.29',},removed=>{}},5.021007=>{delta_from=>5.021006,changed=>{'Archive::Tar'=>'2.04','Archive::Tar::Constant'=>'2.04','Archive::Tar::File'=>'2.04','B'=>'1.54','B::Concise'=>'0.996','B::Deparse'=>'1.31','B::Op_private'=>'5.021007','B::Showlex'=>'1.05','Compress::Raw::Bzip2'=>'2.067','Compress::Raw::Zlib'=>'2.067','Compress::Zlib'=>'2.067','Config'=>'5.021007','Cwd'=>'3.54','DB_File'=>'1.834','Data::Dumper'=>'2.155','Devel::PPPort'=>'3.25','Devel::Peek'=>'1.20','DynaLoader'=>'1.29','Encode'=>'2.67','Errno'=>'1.22','ExtUtils::CBuilder'=>'0.280221','ExtUtils::CBuilder::Base'=>'0.280221','ExtUtils::CBuilder::Platform::Unix'=>'0.280221','ExtUtils::CBuilder::Platform::VMS'=>'0.280221','ExtUtils::CBuilder::Platform::Windows'=>'0.280221','ExtUtils::CBuilder::Platform::aix'=>'0.280221','ExtUtils::CBuilder::Platform::android'=>'0.280221','ExtUtils::CBuilder::Platform::cygwin'=>'0.280221','ExtUtils::CBuilder::Platform::darwin'=>'0.280221','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280221','ExtUtils::CBuilder::Platform::os2'=>'0.280221','ExtUtils::Command::MM'=>'7.04','ExtUtils::Liblist'=>'7.04','ExtUtils::Liblist::Kid'=>'7.04','ExtUtils::MM'=>'7.04','ExtUtils::MM_AIX'=>'7.04','ExtUtils::MM_Any'=>'7.04','ExtUtils::MM_BeOS'=>'7.04','ExtUtils::MM_Cygwin'=>'7.04','ExtUtils::MM_DOS'=>'7.04','ExtUtils::MM_Darwin'=>'7.04','ExtUtils::MM_MacOS'=>'7.04','ExtUtils::MM_NW5'=>'7.04','ExtUtils::MM_OS2'=>'7.04','ExtUtils::MM_QNX'=>'7.04','ExtUtils::MM_UWIN'=>'7.04','ExtUtils::MM_Unix'=>'7.04','ExtUtils::MM_VMS'=>'7.04','ExtUtils::MM_VOS'=>'7.04','ExtUtils::MM_Win32'=>'7.04','ExtUtils::MM_Win95'=>'7.04','ExtUtils::MY'=>'7.04','ExtUtils::MakeMaker'=>'7.04','ExtUtils::MakeMaker::Config'=>'7.04','ExtUtils::MakeMaker::Locale'=>'7.04','ExtUtils::MakeMaker::version'=>'7.04','ExtUtils::MakeMaker::version::regex'=>'7.04','ExtUtils::MakeMaker::version::vpp'=>'7.04','ExtUtils::Mkbootstrap'=>'7.04','ExtUtils::Mksymlists'=>'7.04','ExtUtils::ParseXS'=>'3.27','ExtUtils::ParseXS::Constants'=>'3.27','ExtUtils::ParseXS::CountLines'=>'3.27','ExtUtils::ParseXS::Eval'=>'3.27','ExtUtils::ParseXS::Utilities'=>'3.27','ExtUtils::testlib'=>'7.04','File::Spec'=>'3.53','File::Spec::Cygwin'=>'3.54','File::Spec::Epoc'=>'3.54','File::Spec::Functions'=>'3.54','File::Spec::Mac'=>'3.54','File::Spec::OS2'=>'3.54','File::Spec::Unix'=>'3.54','File::Spec::VMS'=>'3.54','File::Spec::Win32'=>'3.54','Filter::Util::Call'=>'1.51','HTTP::Tiny'=>'0.053','IO'=>'1.35','IO::Compress::Adapter::Bzip2'=>'2.067','IO::Compress::Adapter::Deflate'=>'2.067','IO::Compress::Adapter::Identity'=>'2.067','IO::Compress::Base'=>'2.067','IO::Compress::Base::Common'=>'2.067','IO::Compress::Bzip2'=>'2.067','IO::Compress::Deflate'=>'2.067','IO::Compress::Gzip'=>'2.067','IO::Compress::Gzip::Constants'=>'2.067','IO::Compress::RawDeflate'=>'2.067','IO::Compress::Zip'=>'2.067','IO::Compress::Zip::Constants'=>'2.067','IO::Compress::Zlib::Constants'=>'2.067','IO::Compress::Zlib::Extra'=>'2.067','IO::Socket::IP'=>'0.34','IO::Uncompress::Adapter::Bunzip2'=>'2.067','IO::Uncompress::Adapter::Identity'=>'2.067','IO::Uncompress::Adapter::Inflate'=>'2.067','IO::Uncompress::AnyInflate'=>'2.067','IO::Uncompress::AnyUncompress'=>'2.067','IO::Uncompress::Base'=>'2.067','IO::Uncompress::Bunzip2'=>'2.067','IO::Uncompress::Gunzip'=>'2.067','IO::Uncompress::Inflate'=>'2.067','IO::Uncompress::RawInflate'=>'2.067','IO::Uncompress::Unzip'=>'2.067','Locale::Codes'=>'3.33','Locale::Codes::Constants'=>'3.33','Locale::Codes::Country'=>'3.33','Locale::Codes::Country_Codes'=>'3.33','Locale::Codes::Country_Retired'=>'3.33','Locale::Codes::Currency'=>'3.33','Locale::Codes::Currency_Codes'=>'3.33','Locale::Codes::Currency_Retired'=>'3.33','Locale::Codes::LangExt'=>'3.33','Locale::Codes::LangExt_Codes'=>'3.33','Locale::Codes::LangExt_Retired'=>'3.33','Locale::Codes::LangFam'=>'3.33','Locale::Codes::LangFam_Codes'=>'3.33','Locale::Codes::LangFam_Retired'=>'3.33','Locale::Codes::LangVar'=>'3.33','Locale::Codes::LangVar_Codes'=>'3.33','Locale::Codes::LangVar_Retired'=>'3.33','Locale::Codes::Language'=>'3.33','Locale::Codes::Language_Codes'=>'3.33','Locale::Codes::Language_Retired'=>'3.33','Locale::Codes::Script'=>'3.33','Locale::Codes::Script_Codes'=>'3.33','Locale::Codes::Script_Retired'=>'3.33','Locale::Country'=>'3.33','Locale::Currency'=>'3.33','Locale::Language'=>'3.33','Locale::Maketext'=>'1.26','Locale::Script'=>'3.33','Module::CoreList'=>'5.20141220','Module::CoreList::TieHashDelta'=>'5.20141220','Module::CoreList::Utils'=>'5.20141220','NDBM_File'=>'1.14','Net::Cmd'=>'3.04','Net::Config'=>'3.04','Net::Domain'=>'3.04','Net::FTP'=>'3.04','Net::FTP::A'=>'3.04','Net::FTP::E'=>'3.04','Net::FTP::I'=>'3.04','Net::FTP::L'=>'3.04','Net::FTP::dataconn'=>'3.04','Net::NNTP'=>'3.04','Net::Netrc'=>'3.04','Net::POP3'=>'3.04','Net::SMTP'=>'3.04','Net::Time'=>'3.04','Opcode'=>'1.30','POSIX'=>'1.48','PerlIO::scalar'=>'0.21','Pod::Escapes'=>'1.07','SDBM_File'=>'1.12','Storable'=>'2.52','Sys::Hostname'=>'1.20','Test::Builder'=>'1.301001_090','Test::Builder::Module'=>'1.301001_090','Test::Builder::Tester'=>'1.301001_090','Test::Builder::Tester::Color'=>'1.301001_090','Test::CanFork'=>undef,'Test::CanThread'=>undef,'Test::More'=>'1.301001_090','Test::Simple'=>'1.301001_090','Test::Stream'=>'1.301001_090','Test::Stream::API'=>undef,'Test::Stream::ForceExit'=>undef,'Test::Stream::Subtest'=>undef,'Test::Tester'=>'1.301001_090','Test::use::ok'=>'1.301001_090','Unicode::Collate'=>'1.09','Unicode::Collate::CJK::Big5'=>'1.09','Unicode::Collate::CJK::GB2312'=>'1.09','Unicode::Collate::CJK::JISX0208'=>'1.09','Unicode::Collate::CJK::Korean'=>'1.09','Unicode::Collate::CJK::Pinyin'=>'1.09','Unicode::Collate::CJK::Stroke'=>'1.09','Unicode::Collate::CJK::Zhuyin'=>'1.09','Unicode::Collate::Locale'=>'1.09','XS::APItest'=>'0.69','XSLoader'=>'0.20','_charnames'=>'1.43','arybase'=>'0.09','charnames'=>'1.43','feature'=>'1.39','mro'=>'1.17','ok'=>'1.301001_090','strict'=>'1.09','threads'=>'1.96_001',},removed=>{}},5.021008=>{delta_from=>5.021007,changed=>{'App::Prove'=>'3.35','App::Prove::State'=>'3.35','App::Prove::State::Result'=>'3.35','App::Prove::State::Result::Test'=>'3.35','B'=>'1.55','B::Deparse'=>'1.32','B::Op_private'=>'5.021008','CPAN::Meta::Requirements'=>'2.131','Compress::Raw::Bzip2'=>'2.068','Compress::Raw::Zlib'=>'2.068','Compress::Zlib'=>'2.068','Config'=>'5.021008','DB_File'=>'1.835','Data::Dumper'=>'2.156','Devel::PPPort'=>'3.28','Devel::Peek'=>'1.21','Digest::MD5'=>'2.54','Digest::SHA'=>'5.95','DynaLoader'=>'1.30','ExtUtils::Command'=>'1.20','ExtUtils::Manifest'=>'1.70','Fatal'=>'2.26','File::Glob'=>'1.24','Filter::Util::Call'=>'1.54','Getopt::Long'=>'2.43','IO::Compress::Adapter::Bzip2'=>'2.068','IO::Compress::Adapter::Deflate'=>'2.068','IO::Compress::Adapter::Identity'=>'2.068','IO::Compress::Base'=>'2.068','IO::Compress::Base::Common'=>'2.068','IO::Compress::Bzip2'=>'2.068','IO::Compress::Deflate'=>'2.068','IO::Compress::Gzip'=>'2.068','IO::Compress::Gzip::Constants'=>'2.068','IO::Compress::RawDeflate'=>'2.068','IO::Compress::Zip'=>'2.068','IO::Compress::Zip::Constants'=>'2.068','IO::Compress::Zlib::Constants'=>'2.068','IO::Compress::Zlib::Extra'=>'2.068','IO::Socket::IP'=>'0.36','IO::Uncompress::Adapter::Bunzip2'=>'2.068','IO::Uncompress::Adapter::Identity'=>'2.068','IO::Uncompress::Adapter::Inflate'=>'2.068','IO::Uncompress::AnyInflate'=>'2.068','IO::Uncompress::AnyUncompress'=>'2.068','IO::Uncompress::Base'=>'2.068','IO::Uncompress::Bunzip2'=>'2.068','IO::Uncompress::Gunzip'=>'2.068','IO::Uncompress::Inflate'=>'2.068','IO::Uncompress::RawInflate'=>'2.068','IO::Uncompress::Unzip'=>'2.068','MIME::Base64'=>'3.15','Module::CoreList'=>'5.20150220','Module::CoreList::TieHashDelta'=>'5.20150220','Module::CoreList::Utils'=>'5.20150220','Module::Load::Conditional'=>'0.64','Module::Metadata'=>'1.000026','Net::Cmd'=>'3.05','Net::Config'=>'3.05','Net::Domain'=>'3.05','Net::FTP'=>'3.05','Net::FTP::A'=>'3.05','Net::FTP::E'=>'3.05','Net::FTP::I'=>'3.05','Net::FTP::L'=>'3.05','Net::FTP::dataconn'=>'3.05','Net::NNTP'=>'3.05','Net::Netrc'=>'3.05','Net::POP3'=>'3.05','Net::SMTP'=>'3.05','Net::Time'=>'3.05','Opcode'=>'1.31','POSIX'=>'1.49','PerlIO::encoding'=>'0.21','Pod::Simple'=>'3.29','Pod::Simple::BlackBox'=>'3.29','Pod::Simple::Checker'=>'3.29','Pod::Simple::Debug'=>'3.29','Pod::Simple::DumpAsText'=>'3.29','Pod::Simple::DumpAsXML'=>'3.29','Pod::Simple::HTML'=>'3.29','Pod::Simple::HTMLBatch'=>'3.29','Pod::Simple::LinkSection'=>'3.29','Pod::Simple::Methody'=>'3.29','Pod::Simple::Progress'=>'3.29','Pod::Simple::PullParser'=>'3.29','Pod::Simple::PullParserEndToken'=>'3.29','Pod::Simple::PullParserStartToken'=>'3.29','Pod::Simple::PullParserTextToken'=>'3.29','Pod::Simple::PullParserToken'=>'3.29','Pod::Simple::RTF'=>'3.29','Pod::Simple::Search'=>'3.29','Pod::Simple::SimpleTree'=>'3.29','Pod::Simple::Text'=>'3.29','Pod::Simple::TextContent'=>'3.29','Pod::Simple::TiedOutFH'=>'3.29','Pod::Simple::Transcode'=>'3.29','Pod::Simple::TranscodeDumb'=>'3.29','Pod::Simple::TranscodeSmart'=>'3.29','Pod::Simple::XHTML'=>'3.29','Pod::Simple::XMLOutStream'=>'3.29','SDBM_File'=>'1.13','Safe'=>'2.39','TAP::Base'=>'3.35','TAP::Formatter::Base'=>'3.35','TAP::Formatter::Color'=>'3.35','TAP::Formatter::Console'=>'3.35','TAP::Formatter::Console::ParallelSession'=>'3.35','TAP::Formatter::Console::Session'=>'3.35','TAP::Formatter::File'=>'3.35','TAP::Formatter::File::Session'=>'3.35','TAP::Formatter::Session'=>'3.35','TAP::Harness'=>'3.35','TAP::Harness::Env'=>'3.35','TAP::Object'=>'3.35','TAP::Parser'=>'3.35','TAP::Parser::Aggregator'=>'3.35','TAP::Parser::Grammar'=>'3.35','TAP::Parser::Iterator'=>'3.35','TAP::Parser::Iterator::Array'=>'3.35','TAP::Parser::Iterator::Process'=>'3.35','TAP::Parser::Iterator::Stream'=>'3.35','TAP::Parser::IteratorFactory'=>'3.35','TAP::Parser::Multiplexer'=>'3.35','TAP::Parser::Result'=>'3.35','TAP::Parser::Result::Bailout'=>'3.35','TAP::Parser::Result::Comment'=>'3.35','TAP::Parser::Result::Plan'=>'3.35','TAP::Parser::Result::Pragma'=>'3.35','TAP::Parser::Result::Test'=>'3.35','TAP::Parser::Result::Unknown'=>'3.35','TAP::Parser::Result::Version'=>'3.35','TAP::Parser::Result::YAML'=>'3.35','TAP::Parser::ResultFactory'=>'3.35','TAP::Parser::Scheduler'=>'3.35','TAP::Parser::Scheduler::Job'=>'3.35','TAP::Parser::Scheduler::Spinner'=>'3.35','TAP::Parser::Source'=>'3.35','TAP::Parser::SourceHandler'=>'3.35','TAP::Parser::SourceHandler::Executable'=>'3.35','TAP::Parser::SourceHandler::File'=>'3.35','TAP::Parser::SourceHandler::Handle'=>'3.35','TAP::Parser::SourceHandler::Perl'=>'3.35','TAP::Parser::SourceHandler::RawTAP'=>'3.35','TAP::Parser::YAMLish::Reader'=>'3.35','TAP::Parser::YAMLish::Writer'=>'3.35','Test::Builder'=>'1.301001_097','Test::Builder::Module'=>'1.301001_097','Test::Builder::Tester'=>'1.301001_097','Test::Builder::Tester::Color'=>'1.301001_097','Test::Harness'=>'3.35','Test::More'=>'1.301001_097','Test::Simple'=>'1.301001_097','Test::Stream'=>'1.301001_097','Test::Stream::Block'=>undef,'Test::Tester'=>'1.301001_097','Test::Tester::CaptureRunner'=>undef,'Test::Tester::Delegate'=>undef,'Test::use::ok'=>'1.301001_097','Unicode::Collate'=>'1.10','Unicode::Collate::CJK::Big5'=>'1.10','Unicode::Collate::CJK::GB2312'=>'1.10','Unicode::Collate::CJK::JISX0208'=>'1.10','Unicode::Collate::CJK::Korean'=>'1.10','Unicode::Collate::CJK::Pinyin'=>'1.10','Unicode::Collate::CJK::Stroke'=>'1.10','Unicode::Collate::CJK::Zhuyin'=>'1.10','Unicode::Collate::Locale'=>'1.10','VMS::DCLsym'=>'1.06','XS::APItest'=>'0.70','arybase'=>'0.10','attributes'=>'0.25','autodie'=>'2.26','autodie::Scope::Guard'=>'2.26','autodie::Scope::GuardStack'=>'2.26','autodie::ScopeUtil'=>'2.26','autodie::exception'=>'2.26','autodie::exception::system'=>'2.26','autodie::hints'=>'2.26','autodie::skip'=>'2.26','ok'=>'1.301001_097','re'=>'0.30','warnings'=>'1.30',},removed=>{}},5.020002=>{delta_from=>5.020001,changed=>{'CPAN::Author'=>'5.5002','CPAN::CacheMgr'=>'5.5002','CPAN::FTP'=>'5.5006','CPAN::HTTP::Client'=>'1.9601','CPAN::HandleConfig'=>'5.5005','CPAN::Index'=>'1.9601','CPAN::LWP::UserAgent'=>'1.9601','CPAN::Mirrors'=>'1.9601','Config'=>'5.020002','Cwd'=>'3.48_01','Data::Dumper'=>'2.151_01','Errno'=>'1.20_05','File::Spec'=>'3.48_01','File::Spec::Cygwin'=>'3.48_01','File::Spec::Epoc'=>'3.48_01','File::Spec::Functions'=>'3.48_01','File::Spec::Mac'=>'3.48_01','File::Spec::OS2'=>'3.48_01','File::Spec::Unix'=>'3.48_01','File::Spec::VMS'=>'3.48_01','File::Spec::Win32'=>'3.48_01','IO::Socket'=>'1.38','Module::CoreList'=>'5.20150214','Module::CoreList::TieHashDelta'=>'5.20150214','Module::CoreList::Utils'=>'5.20150214','PerlIO::scalar'=>'0.18_01','Pod::PlainText'=>'2.07','Storable'=>'2.49_01','VMS::DCLsym'=>'1.05_01','VMS::Stdio'=>'2.41','attributes'=>'0.23','feature'=>'1.36_01',},removed=>{}},5.021009=>{delta_from=>5.021008,changed=>{'B'=>'1.56','B::Debug'=>'1.23','B::Deparse'=>'1.33','B::Op_private'=>'5.021009','Benchmark'=>'1.20','CPAN::Author'=>'5.5002','CPAN::CacheMgr'=>'5.5002','CPAN::FTP'=>'5.5006','CPAN::HTTP::Client'=>'1.9601','CPAN::HandleConfig'=>'5.5005','CPAN::Index'=>'1.9601','CPAN::LWP::UserAgent'=>'1.9601','CPAN::Meta::Requirements'=>'2.132','CPAN::Mirrors'=>'1.9601','Carp'=>'1.35','Carp::Heavy'=>'1.35','Config'=>'5.021009','Config::Perl::V'=>'0.23','Data::Dumper'=>'2.157','Devel::Peek'=>'1.22','DynaLoader'=>'1.31','Encode'=>'2.70','Encode::MIME::Header'=>'2.16','Errno'=>'1.23','ExtUtils::Miniperl'=>'1.04','HTTP::Tiny'=>'0.054','Module::CoreList'=>'5.20150220','Module::CoreList::TieHashDelta'=>'5.20150220','Module::CoreList::Utils'=>'5.20150220','Opcode'=>'1.32','POSIX'=>'1.51','Perl::OSType'=>'1.008','PerlIO::scalar'=>'0.22','Pod::Find'=>'1.63','Pod::InputObjects'=>'1.63','Pod::ParseUtils'=>'1.63','Pod::Parser'=>'1.63','Pod::Perldoc'=>'3.25','Pod::Perldoc::BaseTo'=>'3.25','Pod::Perldoc::GetOptsOO'=>'3.25','Pod::Perldoc::ToANSI'=>'3.25','Pod::Perldoc::ToChecker'=>'3.25','Pod::Perldoc::ToMan'=>'3.25','Pod::Perldoc::ToNroff'=>'3.25','Pod::Perldoc::ToPod'=>'3.25','Pod::Perldoc::ToRtf'=>'3.25','Pod::Perldoc::ToTerm'=>'3.25','Pod::Perldoc::ToText'=>'3.25','Pod::Perldoc::ToTk'=>'3.25','Pod::Perldoc::ToXml'=>'3.25','Pod::PlainText'=>'2.07','Pod::Select'=>'1.63','Socket'=>'2.018','Storable'=>'2.53','Test::Builder'=>'1.301001_098','Test::Builder::Module'=>'1.301001_098','Test::Builder::Tester'=>'1.301001_098','Test::Builder::Tester::Color'=>'1.301001_098','Test::More'=>'1.301001_098','Test::Simple'=>'1.301001_098','Test::Stream'=>'1.301001_098','Test::Tester'=>'1.301001_098','Test::use::ok'=>'1.301001_098','Unicode::Collate'=>'1.11','Unicode::Collate::CJK::Big5'=>'1.11','Unicode::Collate::CJK::GB2312'=>'1.11','Unicode::Collate::CJK::JISX0208'=>'1.11','Unicode::Collate::CJK::Korean'=>'1.11','Unicode::Collate::CJK::Pinyin'=>'1.11','Unicode::Collate::CJK::Stroke'=>'1.11','Unicode::Collate::CJK::Zhuyin'=>'1.11','Unicode::Collate::Locale'=>'1.11','Unicode::UCD'=>'0.61','VMS::Stdio'=>'2.41','Win32'=>'0.51','Win32API::File'=>'0.1202','attributes'=>'0.26','bigint'=>'0.39','bignum'=>'0.39','bigrat'=>'0.39','constant'=>'1.33','encoding'=>'2.13','feature'=>'1.40','ok'=>'1.301001_098','overload'=>'1.25','perlfaq'=>'5.021009','re'=>'0.31','threads::shared'=>'1.48','warnings'=>'1.31',},removed=>{}},5.021010=>{delta_from=>5.021009,changed=>{'App::Cpan'=>'1.63','B'=>'1.57','B::Deparse'=>'1.34','B::Op_private'=>'5.021010','Benchmark'=>'1.2','CPAN'=>'2.10','CPAN::Distribution'=>'2.04','CPAN::FirstTime'=>'5.5307','CPAN::HTTP::Credentials'=>'1.9601','CPAN::HandleConfig'=>'5.5006','CPAN::Meta'=>'2.150001','CPAN::Meta::Converter'=>'2.150001','CPAN::Meta::Feature'=>'2.150001','CPAN::Meta::History'=>'2.150001','CPAN::Meta::Merge'=>'2.150001','CPAN::Meta::Prereqs'=>'2.150001','CPAN::Meta::Spec'=>'2.150001','CPAN::Meta::Validator'=>'2.150001','CPAN::Module'=>'5.5002','CPAN::Plugin'=>'0.95','CPAN::Plugin::Specfile'=>'0.01','CPAN::Shell'=>'5.5005','Carp'=>'1.36','Carp::Heavy'=>'1.36','Config'=>'5.02101','Cwd'=>'3.55','DB'=>'1.08','Data::Dumper'=>'2.158','Devel::PPPort'=>'3.31','DynaLoader'=>'1.32','Encode'=>'2.72','Encode::Alias'=>'2.19','File::Spec'=>'3.55','File::Spec::Cygwin'=>'3.55','File::Spec::Epoc'=>'3.55','File::Spec::Functions'=>'3.55','File::Spec::Mac'=>'3.55','File::Spec::OS2'=>'3.55','File::Spec::Unix'=>'3.55','File::Spec::VMS'=>'3.55','File::Spec::Win32'=>'3.55','Getopt::Long'=>'2.45','Locale::Codes'=>'3.34','Locale::Codes::Constants'=>'3.34','Locale::Codes::Country'=>'3.34','Locale::Codes::Country_Codes'=>'3.34','Locale::Codes::Country_Retired'=>'3.34','Locale::Codes::Currency'=>'3.34','Locale::Codes::Currency_Codes'=>'3.34','Locale::Codes::Currency_Retired'=>'3.34','Locale::Codes::LangExt'=>'3.34','Locale::Codes::LangExt_Codes'=>'3.34','Locale::Codes::LangExt_Retired'=>'3.34','Locale::Codes::LangFam'=>'3.34','Locale::Codes::LangFam_Codes'=>'3.34','Locale::Codes::LangFam_Retired'=>'3.34','Locale::Codes::LangVar'=>'3.34','Locale::Codes::LangVar_Codes'=>'3.34','Locale::Codes::LangVar_Retired'=>'3.34','Locale::Codes::Language'=>'3.34','Locale::Codes::Language_Codes'=>'3.34','Locale::Codes::Language_Retired'=>'3.34','Locale::Codes::Script'=>'3.34','Locale::Codes::Script_Codes'=>'3.34','Locale::Codes::Script_Retired'=>'3.34','Locale::Country'=>'3.34','Locale::Currency'=>'3.34','Locale::Language'=>'3.34','Locale::Script'=>'3.34','Module::CoreList'=>'5.20150320','Module::CoreList::TieHashDelta'=>'5.20150320','Module::CoreList::Utils'=>'5.20150320','POSIX'=>'1.52','Pod::Functions'=>'1.09','Pod::Functions::Functions'=>'1.09','Term::Complete'=>'1.403','Test::Builder'=>'1.001014','Test::Builder::IO::Scalar'=>'2.113','Test::Builder::Module'=>'1.001014','Test::Builder::Tester'=>'1.28','Test::Builder::Tester::Color'=>'1.290001','Test::More'=>'1.001014','Test::Simple'=>'1.001014','Test::Tester'=>'0.114','Test::use::ok'=>'0.16','Text::Balanced'=>'2.03','Text::ParseWords'=>'3.30','Unicode::Collate'=>'1.12','Unicode::Collate::CJK::Big5'=>'1.12','Unicode::Collate::CJK::GB2312'=>'1.12','Unicode::Collate::CJK::JISX0208'=>'1.12','Unicode::Collate::CJK::Korean'=>'1.12','Unicode::Collate::CJK::Pinyin'=>'1.12','Unicode::Collate::CJK::Stroke'=>'1.12','Unicode::Collate::CJK::Zhuyin'=>'1.12','Unicode::Collate::Locale'=>'1.12','XS::APItest'=>'0.71','encoding'=>'2.14','locale'=>'1.06','meta_notation'=>undef,'ok'=>'0.16','parent'=>'0.232','re'=>'0.32','sigtrap'=>'1.08','threads'=>'2.01','utf8'=>'1.15',},removed=>{'Test::CanFork'=>1,'Test::CanThread'=>1,'Test::More::DeepCheck'=>1,'Test::More::DeepCheck::Strict'=>1,'Test::More::DeepCheck::Tolerant'=>1,'Test::More::Tools'=>1,'Test::MostlyLike'=>1,'Test::Stream'=>1,'Test::Stream::API'=>1,'Test::Stream::ArrayBase'=>1,'Test::Stream::ArrayBase::Meta'=>1,'Test::Stream::Block'=>1,'Test::Stream::Carp'=>1,'Test::Stream::Context'=>1,'Test::Stream::Event'=>1,'Test::Stream::Event::Bail'=>1,'Test::Stream::Event::Child'=>1,'Test::Stream::Event::Diag'=>1,'Test::Stream::Event::Finish'=>1,'Test::Stream::Event::Note'=>1,'Test::Stream::Event::Ok'=>1,'Test::Stream::Event::Plan'=>1,'Test::Stream::Event::Subtest'=>1,'Test::Stream::ExitMagic'=>1,'Test::Stream::ExitMagic::Context'=>1,'Test::Stream::Exporter'=>1,'Test::Stream::Exporter::Meta'=>1,'Test::Stream::ForceExit'=>1,'Test::Stream::IOSets'=>1,'Test::Stream::Meta'=>1,'Test::Stream::PackageUtil'=>1,'Test::Stream::Subtest'=>1,'Test::Stream::Tester'=>1,'Test::Stream::Tester::Checks'=>1,'Test::Stream::Tester::Checks::Event'=>1,'Test::Stream::Tester::Events'=>1,'Test::Stream::Tester::Events::Event'=>1,'Test::Stream::Tester::Grab'=>1,'Test::Stream::Threads'=>1,'Test::Stream::Toolset'=>1,'Test::Stream::Util'=>1,}},5.021011=>{delta_from=>5.021010,changed=>{'B'=>'1.58','B::Deparse'=>'1.35','B::Op_private'=>'5.021011','CPAN'=>'2.11','Config'=>'5.021011','Config::Perl::V'=>'0.24','Cwd'=>'3.56','ExtUtils::Miniperl'=>'1.05','ExtUtils::ParseXS'=>'3.28','ExtUtils::ParseXS::Constants'=>'3.28','ExtUtils::ParseXS::CountLines'=>'3.28','ExtUtils::ParseXS::Eval'=>'3.28','ExtUtils::ParseXS::Utilities'=>'3.28','ExtUtils::Typemaps'=>'3.28','ExtUtils::Typemaps::Cmd'=>'3.28','ExtUtils::Typemaps::InputMap'=>'3.28','ExtUtils::Typemaps::OutputMap'=>'3.28','ExtUtils::Typemaps::Type'=>'3.28','File::Spec'=>'3.56','File::Spec::Cygwin'=>'3.56','File::Spec::Epoc'=>'3.56','File::Spec::Functions'=>'3.56','File::Spec::Mac'=>'3.56','File::Spec::OS2'=>'3.56','File::Spec::Unix'=>'3.56','File::Spec::VMS'=>'3.56','File::Spec::Win32'=>'3.56','IO::Socket::IP'=>'0.37','Module::CoreList'=>'5.20150420','Module::CoreList::TieHashDelta'=>'5.20150420','Module::CoreList::Utils'=>'5.20150420','PerlIO::mmap'=>'0.014','XS::APItest'=>'0.72','attributes'=>'0.27','if'=>'0.0604','utf8'=>'1.16','warnings'=>'1.32',},removed=>{}},5.022000=>{delta_from=>5.021011,changed=>{'B::Op_private'=>'5.022000','Config'=>'5.022','ExtUtils::Command::MM'=>'7.04_01','ExtUtils::Liblist'=>'7.04_01','ExtUtils::Liblist::Kid'=>'7.04_01','ExtUtils::MM'=>'7.04_01','ExtUtils::MM_AIX'=>'7.04_01','ExtUtils::MM_Any'=>'7.04_01','ExtUtils::MM_BeOS'=>'7.04_01','ExtUtils::MM_Cygwin'=>'7.04_01','ExtUtils::MM_DOS'=>'7.04_01','ExtUtils::MM_Darwin'=>'7.04_01','ExtUtils::MM_MacOS'=>'7.04_01','ExtUtils::MM_NW5'=>'7.04_01','ExtUtils::MM_OS2'=>'7.04_01','ExtUtils::MM_QNX'=>'7.04_01','ExtUtils::MM_UWIN'=>'7.04_01','ExtUtils::MM_Unix'=>'7.04_01','ExtUtils::MM_VMS'=>'7.04_01','ExtUtils::MM_VOS'=>'7.04_01','ExtUtils::MM_Win32'=>'7.04_01','ExtUtils::MM_Win95'=>'7.04_01','ExtUtils::MY'=>'7.04_01','ExtUtils::MakeMaker'=>'7.04_01','ExtUtils::MakeMaker::Config'=>'7.04_01','ExtUtils::MakeMaker::Locale'=>'7.04_01','ExtUtils::MakeMaker::version'=>'7.04_01','ExtUtils::MakeMaker::version::regex'=>'7.04_01','ExtUtils::MakeMaker::version::vpp'=>'7.04_01','ExtUtils::Mkbootstrap'=>'7.04_01','ExtUtils::Mksymlists'=>'7.04_01','ExtUtils::testlib'=>'7.04_01','Module::CoreList'=>'5.20150520','Module::CoreList::TieHashDelta'=>'5.20150520','Module::CoreList::Utils'=>'5.20150520','POSIX'=>'1.53','PerlIO::via::QuotedPrint'=>'0.08','overload'=>'1.26','utf8'=>'1.17',},removed=>{}},5.023000=>{delta_from=>5.022000,changed=>{'B::Op_private'=>'5.023000','CPAN::Meta'=>'2.150005','CPAN::Meta::Converter'=>'2.150005','CPAN::Meta::Feature'=>'2.150005','CPAN::Meta::History'=>'2.150005','CPAN::Meta::Merge'=>'2.150005','CPAN::Meta::Prereqs'=>'2.150005','CPAN::Meta::Requirements'=>'2.133','CPAN::Meta::Spec'=>'2.150005','CPAN::Meta::Validator'=>'2.150005','CPAN::Meta::YAML'=>'0.016','Config'=>'5.023','Encode'=>'2.73','ExtUtils::CBuilder'=>'0.280223','ExtUtils::CBuilder::Base'=>'0.280223','ExtUtils::CBuilder::Platform::Unix'=>'0.280223','ExtUtils::CBuilder::Platform::VMS'=>'0.280223','ExtUtils::CBuilder::Platform::Windows'=>'0.280223','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280223','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280223','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280223','ExtUtils::CBuilder::Platform::aix'=>'0.280223','ExtUtils::CBuilder::Platform::android'=>'0.280223','ExtUtils::CBuilder::Platform::cygwin'=>'0.280223','ExtUtils::CBuilder::Platform::darwin'=>'0.280223','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280223','ExtUtils::CBuilder::Platform::os2'=>'0.280223','Fatal'=>'2.27','Getopt::Long'=>'2.46','HTTP::Tiny'=>'0.056','List::Util'=>'1.42_01','List::Util::XS'=>'1.42_01','Locale::Codes'=>'3.35','Locale::Codes::Constants'=>'3.35','Locale::Codes::Country'=>'3.35','Locale::Codes::Country_Codes'=>'3.35','Locale::Codes::Country_Retired'=>'3.35','Locale::Codes::Currency'=>'3.35','Locale::Codes::Currency_Codes'=>'3.35','Locale::Codes::Currency_Retired'=>'3.35','Locale::Codes::LangExt'=>'3.35','Locale::Codes::LangExt_Codes'=>'3.35','Locale::Codes::LangExt_Retired'=>'3.35','Locale::Codes::LangFam'=>'3.35','Locale::Codes::LangFam_Codes'=>'3.35','Locale::Codes::LangFam_Retired'=>'3.35','Locale::Codes::LangVar'=>'3.35','Locale::Codes::LangVar_Codes'=>'3.35','Locale::Codes::LangVar_Retired'=>'3.35','Locale::Codes::Language'=>'3.35','Locale::Codes::Language_Codes'=>'3.35','Locale::Codes::Language_Retired'=>'3.35','Locale::Codes::Script'=>'3.35','Locale::Codes::Script_Codes'=>'3.35','Locale::Codes::Script_Retired'=>'3.35','Locale::Country'=>'3.35','Locale::Currency'=>'3.35','Locale::Language'=>'3.35','Locale::Script'=>'3.35','Math::BigFloat'=>'1.999701','Math::BigInt'=>'1.999701','Math::BigInt::Calc'=>'1.999701','Math::BigInt::CalcEmu'=>'1.999701','Math::BigRat'=>'0.260801','Module::CoreList'=>'5.20150620','Module::CoreList::TieHashDelta'=>'5.20150620','Module::CoreList::Utils'=>'5.20150620','Module::Metadata'=>'1.000027','Net::Cmd'=>'3.06','Net::Config'=>'3.06','Net::Domain'=>'3.06','Net::FTP'=>'3.06','Net::FTP::A'=>'3.06','Net::FTP::E'=>'3.06','Net::FTP::I'=>'3.06','Net::FTP::L'=>'3.06','Net::FTP::dataconn'=>'3.06','Net::NNTP'=>'3.06','Net::Netrc'=>'3.06','Net::POP3'=>'3.06','Net::SMTP'=>'3.06','Net::Time'=>'3.06','POSIX'=>'1.54','Parse::CPAN::Meta'=>'1.4417','Pod::Simple'=>'3.30','Pod::Simple::BlackBox'=>'3.30','Pod::Simple::Checker'=>'3.30','Pod::Simple::Debug'=>'3.30','Pod::Simple::DumpAsText'=>'3.30','Pod::Simple::DumpAsXML'=>'3.30','Pod::Simple::HTML'=>'3.30','Pod::Simple::HTMLBatch'=>'3.30','Pod::Simple::LinkSection'=>'3.30','Pod::Simple::Methody'=>'3.30','Pod::Simple::Progress'=>'3.30','Pod::Simple::PullParser'=>'3.30','Pod::Simple::PullParserEndToken'=>'3.30','Pod::Simple::PullParserStartToken'=>'3.30','Pod::Simple::PullParserTextToken'=>'3.30','Pod::Simple::PullParserToken'=>'3.30','Pod::Simple::RTF'=>'3.30','Pod::Simple::Search'=>'3.30','Pod::Simple::SimpleTree'=>'3.30','Pod::Simple::Text'=>'3.30','Pod::Simple::TextContent'=>'3.30','Pod::Simple::TiedOutFH'=>'3.30','Pod::Simple::Transcode'=>'3.30','Pod::Simple::TranscodeDumb'=>'3.30','Pod::Simple::TranscodeSmart'=>'3.30','Pod::Simple::XHTML'=>'3.30','Pod::Simple::XMLOutStream'=>'3.30','Pod::Usage'=>'1.67','Scalar::Util'=>'1.42_01','Socket'=>'2.019','Sub::Util'=>'1.42_01','Time::Piece'=>'1.30','Time::Seconds'=>'1.30','UNIVERSAL'=>'1.13','Unicode'=>'8.0.0','XS::APItest'=>'0.73','autodie'=>'2.27','autodie::Scope::Guard'=>'2.27','autodie::Scope::GuardStack'=>'2.27','autodie::Util'=>'2.27','autodie::exception'=>'2.27','autodie::exception::system'=>'2.27','autodie::hints'=>'2.27','autodie::skip'=>'2.27','encoding'=>'2.15','feature'=>'1.41','parent'=>'0.234','threads'=>'2.02',},removed=>{}},5.023001=>{delta_from=>5.023000,changed=>{'B::Op_private'=>'5.023001','Config'=>'5.023001','DynaLoader'=>'1.33','Encode'=>'2.75','Encode::MIME::Header'=>'2.17','Encode::Unicode'=>'2.13','Fatal'=>'2.29','File::Path'=>'2.11','Getopt::Long'=>'2.47','I18N::Langinfo'=>'0.13','IPC::Open3'=>'1.19','Module::CoreList'=>'5.20150720','Module::CoreList::TieHashDelta'=>'5.20150720','Module::CoreList::Utils'=>'5.20150720','Net::Cmd'=>'3.07','Net::Config'=>'3.07','Net::Domain'=>'3.07','Net::FTP'=>'3.07','Net::FTP::A'=>'3.07','Net::FTP::E'=>'3.07','Net::FTP::I'=>'3.07','Net::FTP::L'=>'3.07','Net::FTP::dataconn'=>'3.07','Net::NNTP'=>'3.07','Net::Netrc'=>'3.07','Net::POP3'=>'3.07','Net::SMTP'=>'3.07','Net::Time'=>'3.07','Opcode'=>'1.33','POSIX'=>'1.55','PerlIO::scalar'=>'0.23','Socket'=>'2.020','Storable'=>'2.54','Unicode::Collate'=>'1.14','Unicode::Collate::CJK::Big5'=>'1.14','Unicode::Collate::CJK::GB2312'=>'1.14','Unicode::Collate::CJK::JISX0208'=>'1.14','Unicode::Collate::CJK::Korean'=>'1.14','Unicode::Collate::CJK::Pinyin'=>'1.14','Unicode::Collate::CJK::Stroke'=>'1.14','Unicode::Collate::CJK::Zhuyin'=>'1.14','Unicode::Collate::Locale'=>'1.14','Unicode::Normalize'=>'1.19','XS::APItest'=>'0.74','XS::Typemap'=>'0.14','autodie'=>'2.29','autodie::Scope::Guard'=>'2.29','autodie::Scope::GuardStack'=>'2.29','autodie::Util'=>'2.29','autodie::exception'=>'2.29','autodie::exception::system'=>'2.29','autodie::hints'=>'2.29','autodie::skip'=>'2.29','encoding'=>'2.16','feature'=>'1.42','warnings'=>'1.33',},removed=>{'autodie::ScopeUtil'=>1,}},5.023002=>{delta_from=>5.023001,changed=>{'Attribute::Handlers'=>'0.99','B::Op_private'=>'5.023002','CPAN::Meta::YAML'=>'0.017','Config'=>'5.023002','Cwd'=>'3.57','Encode'=>'2.76','ExtUtils::ParseXS'=>'3.29','ExtUtils::ParseXS::Constants'=>'3.29','ExtUtils::ParseXS::CountLines'=>'3.29','ExtUtils::ParseXS::Eval'=>'3.29','ExtUtils::ParseXS::Utilities'=>'3.29','ExtUtils::Typemaps'=>'3.29','File::Find'=>'1.30','File::Spec'=>'3.57','File::Spec::Cygwin'=>'3.57','File::Spec::Epoc'=>'3.57','File::Spec::Functions'=>'3.57','File::Spec::Mac'=>'3.57','File::Spec::OS2'=>'3.57','File::Spec::Unix'=>'3.57','File::Spec::VMS'=>'3.57','File::Spec::Win32'=>'3.57','Filter::Util::Call'=>'1.55','Hash::Util'=>'0.19','Module::CoreList'=>'5.20150820','Module::CoreList::TieHashDelta'=>'5.20150820','Module::CoreList::Utils'=>'5.20150820','POSIX'=>'1.56','Term::Cap'=>'1.17','Unicode::UCD'=>'0.62','perlfaq'=>'5.021010',},removed=>{}},5.020003=>{delta_from=>5.020002,changed=>{'Config'=>'5.020003','Errno'=>'1.20_06','Module::CoreList'=>'5.20150912','Module::CoreList::TieHashDelta'=>'5.20150912','Module::CoreList::Utils'=>'5.20150912',},removed=>{}},5.023003=>{delta_from=>5.023002,changed=>{'Amiga::ARexx'=>'0.02','Amiga::Exec'=>'0.01','B'=>'1.59','B::Op_private'=>'5.023003','Carp'=>'1.37','Carp::Heavy'=>'1.37','Compress::Raw::Zlib'=>'2.068_01','Config'=>'5.023003','Cwd'=>'3.58','DynaLoader'=>'1.34','Encode'=>'2.77','Encode::Unicode'=>'2.14','English'=>'1.10','Errno'=>'1.24','ExtUtils::Command'=>'7.10','ExtUtils::Command::MM'=>'7.10','ExtUtils::Liblist'=>'7.10','ExtUtils::Liblist::Kid'=>'7.10','ExtUtils::MM'=>'7.10','ExtUtils::MM_AIX'=>'7.10','ExtUtils::MM_Any'=>'7.10','ExtUtils::MM_BeOS'=>'7.10','ExtUtils::MM_Cygwin'=>'7.10','ExtUtils::MM_DOS'=>'7.10','ExtUtils::MM_Darwin'=>'7.10','ExtUtils::MM_MacOS'=>'7.10','ExtUtils::MM_NW5'=>'7.10','ExtUtils::MM_OS2'=>'7.10','ExtUtils::MM_QNX'=>'7.10','ExtUtils::MM_UWIN'=>'7.10','ExtUtils::MM_Unix'=>'7.10','ExtUtils::MM_VMS'=>'7.10','ExtUtils::MM_VOS'=>'7.10','ExtUtils::MM_Win32'=>'7.10','ExtUtils::MM_Win95'=>'7.10','ExtUtils::MY'=>'7.10','ExtUtils::MakeMaker'=>'7.10','ExtUtils::MakeMaker::Config'=>'7.10','ExtUtils::MakeMaker::Locale'=>'7.10','ExtUtils::MakeMaker::version'=>'7.10','ExtUtils::MakeMaker::version::regex'=>'7.10','ExtUtils::MakeMaker::version::vpp'=>'7.10','ExtUtils::Mkbootstrap'=>'7.10','ExtUtils::Mksymlists'=>'7.10','ExtUtils::ParseXS'=>'3.30','ExtUtils::ParseXS::Constants'=>'3.30','ExtUtils::ParseXS::CountLines'=>'3.30','ExtUtils::ParseXS::Eval'=>'3.30','ExtUtils::ParseXS::Utilities'=>'3.30','ExtUtils::Typemaps'=>'3.30','ExtUtils::Typemaps::Cmd'=>'3.30','ExtUtils::Typemaps::InputMap'=>'3.30','ExtUtils::Typemaps::OutputMap'=>'3.30','ExtUtils::Typemaps::Type'=>'3.30','ExtUtils::testlib'=>'7.10','File::Find'=>'1.31','File::Glob'=>'1.25','File::Spec'=>'3.58','File::Spec::AmigaOS'=>'3.58','File::Spec::Cygwin'=>'3.58','File::Spec::Epoc'=>'3.58','File::Spec::Functions'=>'3.58','File::Spec::Mac'=>'3.58','File::Spec::OS2'=>'3.58','File::Spec::Unix'=>'3.58','File::Spec::VMS'=>'3.58','File::Spec::Win32'=>'3.58','Hash::Util::FieldHash'=>'1.17','Locale::Codes'=>'3.36','Locale::Codes::Constants'=>'3.36','Locale::Codes::Country'=>'3.36','Locale::Codes::Country_Codes'=>'3.36','Locale::Codes::Country_Retired'=>'3.36','Locale::Codes::Currency'=>'3.36','Locale::Codes::Currency_Codes'=>'3.36','Locale::Codes::Currency_Retired'=>'3.36','Locale::Codes::LangExt'=>'3.36','Locale::Codes::LangExt_Codes'=>'3.36','Locale::Codes::LangExt_Retired'=>'3.36','Locale::Codes::LangFam'=>'3.36','Locale::Codes::LangFam_Codes'=>'3.36','Locale::Codes::LangFam_Retired'=>'3.36','Locale::Codes::LangVar'=>'3.36','Locale::Codes::LangVar_Codes'=>'3.36','Locale::Codes::LangVar_Retired'=>'3.36','Locale::Codes::Language'=>'3.36','Locale::Codes::Language_Codes'=>'3.36','Locale::Codes::Language_Retired'=>'3.36','Locale::Codes::Script'=>'3.36','Locale::Codes::Script_Codes'=>'3.36','Locale::Codes::Script_Retired'=>'3.36','Locale::Country'=>'3.36','Locale::Currency'=>'3.36','Locale::Language'=>'3.36','Locale::Script'=>'3.36','Math::BigFloat::Trace'=>'0.40','Math::BigInt::Trace'=>'0.40','Module::CoreList'=>'5.20150920','Module::CoreList::TieHashDelta'=>'5.20150920','Module::CoreList::Utils'=>'5.20150920','OS2::DLL'=>'1.06','OS2::ExtAttr'=>'0.04','OS2::Process'=>'1.11','OS2::REXX'=>'1.05','POSIX'=>'1.57','Pod::Perldoc'=>'3.25_01','Socket'=>'2.020_01','Test'=>'1.27','Thread::Queue'=>'3.06','Time::HiRes'=>'1.9727_02','Unicode::UCD'=>'0.63','Win32'=>'0.52','XS::APItest'=>'0.75','bigint'=>'0.40','bignum'=>'0.40','bigrat'=>'0.40','encoding'=>'2.17','experimental'=>'0.014','if'=>'0.0605','locale'=>'1.07','mro'=>'1.18','threads'=>'2.03',},removed=>{}},5.023004=>{delta_from=>5.023003,changed=>{'B'=>'1.60','B::Op_private'=>'5.023004','Compress::Raw::Bzip2'=>'2.069','Compress::Raw::Zlib'=>'2.069','Compress::Zlib'=>'2.069','Config'=>'5.023004','Devel::PPPort'=>'3.32','DynaLoader'=>'1.35','Encode'=>'2.78','ExtUtils::CBuilder'=>'0.280224','ExtUtils::CBuilder::Base'=>'0.280224','ExtUtils::CBuilder::Platform::Unix'=>'0.280224','ExtUtils::CBuilder::Platform::VMS'=>'0.280224','ExtUtils::CBuilder::Platform::Windows'=>'0.280224','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280224','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280224','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280224','ExtUtils::CBuilder::Platform::aix'=>'0.280224','ExtUtils::CBuilder::Platform::android'=>'0.280224','ExtUtils::CBuilder::Platform::cygwin'=>'0.280224','ExtUtils::CBuilder::Platform::darwin'=>'0.280224','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280224','ExtUtils::CBuilder::Platform::os2'=>'0.280224','File::Path'=>'2.12','IO'=>'1.36','IO::Compress::Adapter::Bzip2'=>'2.069','IO::Compress::Adapter::Deflate'=>'2.069','IO::Compress::Adapter::Identity'=>'2.069','IO::Compress::Base'=>'2.069','IO::Compress::Base::Common'=>'2.069','IO::Compress::Bzip2'=>'2.069','IO::Compress::Deflate'=>'2.069','IO::Compress::Gzip'=>'2.069','IO::Compress::Gzip::Constants'=>'2.069','IO::Compress::RawDeflate'=>'2.069','IO::Compress::Zip'=>'2.069','IO::Compress::Zip::Constants'=>'2.069','IO::Compress::Zlib::Constants'=>'2.069','IO::Compress::Zlib::Extra'=>'2.069','IO::Poll'=>'0.10','IO::Uncompress::Adapter::Bunzip2'=>'2.069','IO::Uncompress::Adapter::Identity'=>'2.069','IO::Uncompress::Adapter::Inflate'=>'2.069','IO::Uncompress::AnyInflate'=>'2.069','IO::Uncompress::AnyUncompress'=>'2.069','IO::Uncompress::Base'=>'2.069','IO::Uncompress::Bunzip2'=>'2.069','IO::Uncompress::Gunzip'=>'2.069','IO::Uncompress::Inflate'=>'2.069','IO::Uncompress::RawInflate'=>'2.069','IO::Uncompress::Unzip'=>'2.069','Math::BigFloat'=>'1.999704','Math::BigFloat::Trace'=>'0.41','Math::BigInt'=>'1.999704','Math::BigInt::Calc'=>'1.999704','Math::BigInt::CalcEmu'=>'1.999704','Math::BigInt::FastCalc'=>'0.34','Math::BigInt::Trace'=>'0.41','Module::CoreList'=>'5.20151020','Module::CoreList::TieHashDelta'=>'5.20151020','Module::CoreList::Utils'=>'5.20151020','Module::Metadata'=>'1.000029','POSIX'=>'1.58','Perl::OSType'=>'1.009','PerlIO::encoding'=>'0.22','Socket'=>'2.020_02','Unicode::Normalize'=>'1.21','XS::APItest'=>'0.76','bigint'=>'0.41','bignum'=>'0.41','bigrat'=>'0.41','experimental'=>'0.016','if'=>'0.0606','warnings'=>'1.35',},removed=>{}},5.023005=>{delta_from=>5.023004,changed=>{'B'=>'1.61','B::Op_private'=>'5.023005','Carp'=>'1.38','Carp::Heavy'=>'1.38','Config'=>'5.023005','Config::Perl::V'=>'0.25','Cwd'=>'3.59','Devel::Peek'=>'1.23','Dumpvalue'=>'1.18','DynaLoader'=>'1.36','File::Find'=>'1.32','File::Spec'=>'3.59','File::Spec::AmigaOS'=>'3.59','File::Spec::Cygwin'=>'3.59','File::Spec::Epoc'=>'3.59','File::Spec::Functions'=>'3.59','File::Spec::Mac'=>'3.59','File::Spec::OS2'=>'3.59','File::Spec::Unix'=>'3.59','File::Spec::VMS'=>'3.59','File::Spec::Win32'=>'3.59','Getopt::Long'=>'2.48','Hash::Util::FieldHash'=>'1.18','IPC::Open3'=>'1.20','Math::BigFloat'=>'1.999710','Math::BigInt'=>'1.999710','Math::BigInt::Calc'=>'1.999710','Math::BigInt::CalcEmu'=>'1.999710','Math::BigInt::FastCalc'=>'0.37','Module::CoreList'=>'5.20151120','Module::CoreList::TieHashDelta'=>'5.20151120','Module::CoreList::Utils'=>'5.20151120','Module::Metadata'=>'1.000030','POSIX'=>'1.59','PerlIO::encoding'=>'0.23','PerlIO::mmap'=>'0.015','PerlIO::scalar'=>'0.24','PerlIO::via'=>'0.16','Pod::Simple'=>'3.32','Pod::Simple::BlackBox'=>'3.32','Pod::Simple::Checker'=>'3.32','Pod::Simple::Debug'=>'3.32','Pod::Simple::DumpAsText'=>'3.32','Pod::Simple::DumpAsXML'=>'3.32','Pod::Simple::HTML'=>'3.32','Pod::Simple::HTMLBatch'=>'3.32','Pod::Simple::LinkSection'=>'3.32','Pod::Simple::Methody'=>'3.32','Pod::Simple::Progress'=>'3.32','Pod::Simple::PullParser'=>'3.32','Pod::Simple::PullParserEndToken'=>'3.32','Pod::Simple::PullParserStartToken'=>'3.32','Pod::Simple::PullParserTextToken'=>'3.32','Pod::Simple::PullParserToken'=>'3.32','Pod::Simple::RTF'=>'3.32','Pod::Simple::Search'=>'3.32','Pod::Simple::SimpleTree'=>'3.32','Pod::Simple::Text'=>'3.32','Pod::Simple::TextContent'=>'3.32','Pod::Simple::TiedOutFH'=>'3.32','Pod::Simple::Transcode'=>'3.32','Pod::Simple::TranscodeDumb'=>'3.32','Pod::Simple::TranscodeSmart'=>'3.32','Pod::Simple::XHTML'=>'3.32','Pod::Simple::XMLOutStream'=>'3.32','Thread::Queue'=>'3.07','Tie::Scalar'=>'1.04','Time::HiRes'=>'1.9728','Time::Piece'=>'1.31','Time::Seconds'=>'1.31','Unicode::Normalize'=>'1.23','XSLoader'=>'0.21','arybase'=>'0.11','base'=>'2.22_01','fields'=>'2.22_01','threads'=>'2.04','threads::shared'=>'1.49',},removed=>{'ExtUtils::MakeMaker::version::vpp'=>1,'version::vpp'=>1,}},5.022001=>{delta_from=>5.022,changed=>{'B::Op_private'=>'5.022001','Config'=>'5.022001','Module::CoreList'=>'5.20151213','Module::CoreList::TieHashDelta'=>'5.20151213','Module::CoreList::Utils'=>'5.20151213','POSIX'=>'1.53_01','PerlIO::scalar'=>'0.23','Storable'=>'2.53_01','Win32'=>'0.52','warnings'=>'1.34',},removed=>{}},5.023006=>{delta_from=>5.023005,changed=>{'B::Deparse'=>'1.36','B::Op_private'=>'5.023006','Benchmark'=>'1.21','CPAN::Meta::Requirements'=>'2.140','CPAN::Meta::YAML'=>'0.018','Config'=>'5.023006','Cwd'=>'3.60','Data::Dumper'=>'2.159','DynaLoader'=>'1.37','File::Spec'=>'3.60','File::Spec::AmigaOS'=>'3.60','File::Spec::Cygwin'=>'3.60','File::Spec::Epoc'=>'3.60','File::Spec::Functions'=>'3.60','File::Spec::Mac'=>'3.60','File::Spec::OS2'=>'3.60','File::Spec::Unix'=>'3.60','File::Spec::VMS'=>'3.60','File::Spec::Win32'=>'3.60','Hash::Util::FieldHash'=>'1.19','Locale::Codes'=>'3.37','Locale::Codes::Constants'=>'3.37','Locale::Codes::Country'=>'3.37','Locale::Codes::Country_Codes'=>'3.37','Locale::Codes::Country_Retired'=>'3.37','Locale::Codes::Currency'=>'3.37','Locale::Codes::Currency_Codes'=>'3.37','Locale::Codes::Currency_Retired'=>'3.37','Locale::Codes::LangExt'=>'3.37','Locale::Codes::LangExt_Codes'=>'3.37','Locale::Codes::LangExt_Retired'=>'3.37','Locale::Codes::LangFam'=>'3.37','Locale::Codes::LangFam_Codes'=>'3.37','Locale::Codes::LangFam_Retired'=>'3.37','Locale::Codes::LangVar'=>'3.37','Locale::Codes::LangVar_Codes'=>'3.37','Locale::Codes::LangVar_Retired'=>'3.37','Locale::Codes::Language'=>'3.37','Locale::Codes::Language_Codes'=>'3.37','Locale::Codes::Language_Retired'=>'3.37','Locale::Codes::Script'=>'3.37','Locale::Codes::Script_Codes'=>'3.37','Locale::Codes::Script_Retired'=>'3.37','Locale::Country'=>'3.37','Locale::Currency'=>'3.37','Locale::Language'=>'3.37','Locale::Script'=>'3.37','Math::BigInt::FastCalc'=>'0.38','Module::CoreList'=>'5.20151220','Module::CoreList::TieHashDelta'=>'5.20151220','Module::CoreList::Utils'=>'5.20151220','Module::Metadata'=>'1.000031','Opcode'=>'1.34','PerlIO::mmap'=>'0.016','Pod::Perldoc'=>'3.25_02','SDBM_File'=>'1.14','Term::ANSIColor'=>'4.04','Test'=>'1.28','Unicode::Normalize'=>'1.24','XS::APItest'=>'0.77','base'=>'2.23','encoding::warnings'=>'0.12','fields'=>'2.23','locale'=>'1.08','strict'=>'1.10','threads'=>'2.05','threads::shared'=>'1.50','utf8'=>'1.18',},removed=>{}},5.023007=>{delta_from=>5.023006,changed=>{'App::Prove'=>'3.36','App::Prove::State'=>'3.36','App::Prove::State::Result'=>'3.36','App::Prove::State::Result::Test'=>'3.36','B'=>'1.62','B::Deparse'=>'1.37','B::Op_private'=>'5.023007','Benchmark'=>'1.22','Config'=>'5.023007','Cwd'=>'3.62','Data::Dumper'=>'2.160','ExtUtils::ParseXS'=>'3.31','ExtUtils::ParseXS::Constants'=>'3.31','ExtUtils::ParseXS::CountLines'=>'3.31','ExtUtils::ParseXS::Eval'=>'3.31','ExtUtils::ParseXS::Utilities'=>'3.31','ExtUtils::Typemaps'=>'3.31','ExtUtils::Typemaps::Cmd'=>'3.31','ExtUtils::Typemaps::InputMap'=>'3.31','ExtUtils::Typemaps::OutputMap'=>'3.31','ExtUtils::Typemaps::Type'=>'3.31','File::Find'=>'1.33','File::Spec'=>'3.62','File::Spec::AmigaOS'=>'3.62','File::Spec::Cygwin'=>'3.62','File::Spec::Epoc'=>'3.62','File::Spec::Functions'=>'3.62','File::Spec::Mac'=>'3.62','File::Spec::OS2'=>'3.62','File::Spec::Unix'=>'3.62','File::Spec::VMS'=>'3.62','File::Spec::Win32'=>'3.62','Math::BigFloat'=>'1.999715','Math::BigFloat::Trace'=>'0.42','Math::BigInt'=>'1.999715','Math::BigInt::Calc'=>'1.999715','Math::BigInt::CalcEmu'=>'1.999715','Math::BigInt::FastCalc'=>'0.40','Math::BigInt::Trace'=>'0.42','Math::BigRat'=>'0.260802','Module::CoreList'=>'5.20160120','Module::CoreList::TieHashDelta'=>'5.20160120','Module::CoreList::Utils'=>'5.20160120','Net::Cmd'=>'3.08','Net::Config'=>'3.08','Net::Domain'=>'3.08','Net::FTP'=>'3.08','Net::FTP::A'=>'3.08','Net::FTP::E'=>'3.08','Net::FTP::I'=>'3.08','Net::FTP::L'=>'3.08','Net::FTP::dataconn'=>'3.08','Net::NNTP'=>'3.08','Net::Netrc'=>'3.08','Net::POP3'=>'3.08','Net::SMTP'=>'3.08','Net::Time'=>'3.08','Pod::Man'=>'4.04','Pod::ParseLink'=>'4.04','Pod::Text'=>'4.04','Pod::Text::Color'=>'4.04','Pod::Text::Overstrike'=>'4.04','Pod::Text::Termcap'=>'4.04','Pod::Usage'=>'1.68','TAP::Base'=>'3.36','TAP::Formatter::Base'=>'3.36','TAP::Formatter::Color'=>'3.36','TAP::Formatter::Console'=>'3.36','TAP::Formatter::Console::ParallelSession'=>'3.36','TAP::Formatter::Console::Session'=>'3.36','TAP::Formatter::File'=>'3.36','TAP::Formatter::File::Session'=>'3.36','TAP::Formatter::Session'=>'3.36','TAP::Harness'=>'3.36','TAP::Harness::Env'=>'3.36','TAP::Object'=>'3.36','TAP::Parser'=>'3.36','TAP::Parser::Aggregator'=>'3.36','TAP::Parser::Grammar'=>'3.36','TAP::Parser::Iterator'=>'3.36','TAP::Parser::Iterator::Array'=>'3.36','TAP::Parser::Iterator::Process'=>'3.36','TAP::Parser::Iterator::Stream'=>'3.36','TAP::Parser::IteratorFactory'=>'3.36','TAP::Parser::Multiplexer'=>'3.36','TAP::Parser::Result'=>'3.36','TAP::Parser::Result::Bailout'=>'3.36','TAP::Parser::Result::Comment'=>'3.36','TAP::Parser::Result::Plan'=>'3.36','TAP::Parser::Result::Pragma'=>'3.36','TAP::Parser::Result::Test'=>'3.36','TAP::Parser::Result::Unknown'=>'3.36','TAP::Parser::Result::Version'=>'3.36','TAP::Parser::Result::YAML'=>'3.36','TAP::Parser::ResultFactory'=>'3.36','TAP::Parser::Scheduler'=>'3.36','TAP::Parser::Scheduler::Job'=>'3.36','TAP::Parser::Scheduler::Spinner'=>'3.36','TAP::Parser::Source'=>'3.36','TAP::Parser::SourceHandler'=>'3.36','TAP::Parser::SourceHandler::Executable'=>'3.36','TAP::Parser::SourceHandler::File'=>'3.36','TAP::Parser::SourceHandler::Handle'=>'3.36','TAP::Parser::SourceHandler::Perl'=>'3.36','TAP::Parser::SourceHandler::RawTAP'=>'3.36','TAP::Parser::YAMLish::Reader'=>'3.36','TAP::Parser::YAMLish::Writer'=>'3.36','Test::Harness'=>'3.36','Unicode::Normalize'=>'1.25','Unicode::UCD'=>'0.64','XS::APItest'=>'0.78','bigint'=>'0.42','bignum'=>'0.42','bigrat'=>'0.42','utf8'=>'1.19',},removed=>{}},5.023008=>{delta_from=>5.023007,changed=>{'B::Op_private'=>'5.023008','Config'=>'5.023008','Cwd'=>'3.63','DynaLoader'=>'1.38','Encode'=>'2.80','Encode::Alias'=>'2.20','Encode::MIME::Header'=>'2.19','Encode::Unicode'=>'2.15','ExtUtils::CBuilder'=>'0.280225','ExtUtils::CBuilder::Base'=>'0.280225','ExtUtils::CBuilder::Platform::Unix'=>'0.280225','ExtUtils::CBuilder::Platform::VMS'=>'0.280225','ExtUtils::CBuilder::Platform::Windows'=>'0.280225','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280225','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280225','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280225','ExtUtils::CBuilder::Platform::aix'=>'0.280225','ExtUtils::CBuilder::Platform::android'=>'0.280225','ExtUtils::CBuilder::Platform::cygwin'=>'0.280225','ExtUtils::CBuilder::Platform::darwin'=>'0.280225','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280225','ExtUtils::CBuilder::Platform::os2'=>'0.280225','ExtUtils::Command::MM'=>'7.10_01','ExtUtils::Liblist'=>'7.10_01','ExtUtils::Liblist::Kid'=>'7.10_01','ExtUtils::MM'=>'7.10_01','ExtUtils::MM_AIX'=>'7.10_01','ExtUtils::MM_Any'=>'7.10_01','ExtUtils::MM_BeOS'=>'7.10_01','ExtUtils::MM_Cygwin'=>'7.10_01','ExtUtils::MM_DOS'=>'7.10_01','ExtUtils::MM_Darwin'=>'7.10_01','ExtUtils::MM_MacOS'=>'7.10_01','ExtUtils::MM_NW5'=>'7.10_01','ExtUtils::MM_OS2'=>'7.10_01','ExtUtils::MM_QNX'=>'7.10_01','ExtUtils::MM_UWIN'=>'7.10_01','ExtUtils::MM_Unix'=>'7.10_01','ExtUtils::MM_VMS'=>'7.10_01','ExtUtils::MM_VOS'=>'7.10_01','ExtUtils::MM_Win32'=>'7.10_01','ExtUtils::MM_Win95'=>'7.10_01','ExtUtils::MY'=>'7.10_01','ExtUtils::MakeMaker'=>'7.10_01','ExtUtils::MakeMaker::Config'=>'7.10_01','ExtUtils::MakeMaker::version'=>'7.10_01','ExtUtils::MakeMaker::version::regex'=>'7.10_01','ExtUtils::Mkbootstrap'=>'7.10_01','ExtUtils::Mksymlists'=>'7.10_01','ExtUtils::testlib'=>'7.10_01','File::Spec'=>'3.63','File::Spec::AmigaOS'=>'3.63','File::Spec::Cygwin'=>'3.63','File::Spec::Epoc'=>'3.63','File::Spec::Functions'=>'3.63','File::Spec::Mac'=>'3.63','File::Spec::OS2'=>'3.63','File::Spec::Unix'=>'3.63','File::Spec::VMS'=>'3.63','File::Spec::Win32'=>'3.63','IPC::Msg'=>'2.05','IPC::Semaphore'=>'2.05','IPC::SharedMem'=>'2.05','IPC::SysV'=>'2.05','Module::CoreList'=>'5.20160121','Module::CoreList::TieHashDelta'=>'5.20160121','Module::CoreList::Utils'=>'5.20160121','ODBM_File'=>'1.13','POSIX'=>'1.63','PerlIO::encoding'=>'0.24','Pod::Man'=>'4.06','Pod::ParseLink'=>'4.06','Pod::Text'=>'4.06','Pod::Text::Color'=>'4.06','Pod::Text::Overstrike'=>'4.06','Pod::Text::Termcap'=>'4.06','Storable'=>'2.55','Time::HiRes'=>'1.9730','XS::APItest'=>'0.79',},removed=>{}},5.023009=>{delta_from=>5.023008,changed=>{'Amiga::ARexx'=>'0.04','Amiga::Exec'=>'0.02','B::Op_private'=>'5.023009','Carp'=>'1.40','Carp::Heavy'=>'1.40','Config'=>'5.023009','Errno'=>'1.25','ExtUtils::Embed'=>'1.33','File::Find'=>'1.34','File::Glob'=>'1.26','File::Spec::AmigaOS'=>';.64','IPC::Msg'=>'2.06_01','IPC::Semaphore'=>'2.06_01','IPC::SharedMem'=>'2.06_01','IPC::SysV'=>'2.06_01','List::Util'=>'1.42_02','List::Util::XS'=>'1.42_02','Module::CoreList'=>'5.20160320','Module::CoreList::TieHashDelta'=>'5.20160320','Module::CoreList::Utils'=>'5.20160320','POSIX'=>'1.64','Pod::Functions'=>'1.10','Pod::Functions::Functions'=>'1.10','Scalar::Util'=>'1.42_02','SelfLoader'=>'1.23','Socket'=>'2.020_03','Storable'=>'2.56','Sub::Util'=>'1.42_02','Thread::Queue'=>'3.08','Tie::File'=>'1.02','Time::HiRes'=>'1.9732','Win32API::File'=>'0.1203','Win32API::File::inc::ExtUtils::Myconst2perl'=>'1','XS::APItest'=>'0.80','autouse'=>'1.11','bytes'=>'1.05','strict'=>'1.11','threads'=>'2.06','version'=>'0.9916','version::regex'=>'0.9916','warnings'=>'1.36',},removed=>{'Win32API::File::ExtUtils::Myconst2perl'=>1,}},5.022002=>{delta_from=>5.022001,changed=>{'B::Op_private'=>'5.022002','Config'=>'5.022002','Cwd'=>'3.56_01','File::Spec'=>'3.56_01','File::Spec::Cygwin'=>'3.56_01','File::Spec::Epoc'=>'3.56_01','File::Spec::Functions'=>'3.56_01','File::Spec::Mac'=>'3.56_01','File::Spec::OS2'=>'3.56_01','File::Spec::Unix'=>'3.56_01','File::Spec::VMS'=>'3.56_01','File::Spec::Win32'=>'3.56_01','Module::CoreList'=>'5.20160429','Module::CoreList::TieHashDelta'=>'5.20160429','Module::CoreList::Utils'=>'5.20160429','XS::APItest'=>'0.72_01',},removed=>{}},5.024000=>{delta_from=>5.023009,changed=>{'B::Op_private'=>'5.024000','Config'=>'5.024','File::Copy'=>'2.31','File::Path'=>'2.12_01','File::Spec::AmigaOS'=>'3.64','IO::Handle'=>'1.36','Module::CoreList'=>'5.20160506','Module::CoreList::TieHashDelta'=>'5.20160506','Module::CoreList::Utils'=>'5.20160506','ODBM_File'=>'1.14','POSIX'=>'1.65','Pod::Man'=>'4.07','Pod::ParseLink'=>'4.07','Pod::Text'=>'4.07','Pod::Text::Color'=>'4.07','Pod::Text::Overstrike'=>'4.07','Pod::Text::Termcap'=>'4.07','Thread::Queue'=>'3.09','Time::HiRes'=>'1.9733','threads'=>'2.07','threads::shared'=>'1.51','locale'=>'1.09',},removed=>{}},5.025000=>{delta_from=>5.024,changed=>{'B::Op_private'=>'5.025000','Config'=>'5.025','Module::CoreList'=>'5.20160507','Module::CoreList::TieHashDelta'=>'5.20160507','Module::CoreList::Utils'=>'5.20160507','feature'=>'1.43',},removed=>{}},5.025001=>{delta_from=>5.025,changed=>{'Archive::Tar'=>'2.08','Archive::Tar::Constant'=>'2.08','Archive::Tar::File'=>'2.08','B::Op_private'=>'5.025001','Carp'=>'1.41','Carp::Heavy'=>'1.41','Config'=>'5.025001','Config::Perl::V'=>'0.26','DB_File'=>'1.838','Digest::MD5'=>'2.55','IPC::Cmd'=>'0.94','IPC::Msg'=>'2.07','IPC::Semaphore'=>'2.07','IPC::SharedMem'=>'2.07','IPC::SysV'=>'2.07','List::Util'=>'1.45_01','List::Util::XS'=>'1.45_01','Locale::Codes'=>'3.38','Locale::Codes::Constants'=>'3.38','Locale::Codes::Country'=>'3.38','Locale::Codes::Country_Codes'=>'3.38','Locale::Codes::Country_Retired'=>'3.38','Locale::Codes::Currency'=>'3.38','Locale::Codes::Currency_Codes'=>'3.38','Locale::Codes::Currency_Retired'=>'3.38','Locale::Codes::LangExt'=>'3.38','Locale::Codes::LangExt_Codes'=>'3.38','Locale::Codes::LangExt_Retired'=>'3.38','Locale::Codes::LangFam'=>'3.38','Locale::Codes::LangFam_Codes'=>'3.38','Locale::Codes::LangFam_Retired'=>'3.38','Locale::Codes::LangVar'=>'3.38','Locale::Codes::LangVar_Codes'=>'3.38','Locale::Codes::LangVar_Retired'=>'3.38','Locale::Codes::Language'=>'3.38','Locale::Codes::Language_Codes'=>'3.38','Locale::Codes::Language_Retired'=>'3.38','Locale::Codes::Script'=>'3.38','Locale::Codes::Script_Codes'=>'3.38','Locale::Codes::Script_Retired'=>'3.38','Locale::Country'=>'3.38','Locale::Currency'=>'3.38','Locale::Language'=>'3.38','Locale::Maketext'=>'1.27','Locale::Script'=>'3.38','Module::CoreList'=>'5.20160520','Module::CoreList::TieHashDelta'=>'5.20160520','Module::CoreList::Utils'=>'5.20160520','Module::Metadata'=>'1.000032','POSIX'=>'1.69','Scalar::Util'=>'1.45_01','Sub::Util'=>'1.45_01','Sys::Syslog'=>'0.34','Term::ANSIColor'=>'4.05','Test2'=>'1.302015','Test2::API'=>'1.302015','Test2::API::Breakage'=>'1.302015','Test2::API::Context'=>'1.302015','Test2::API::Instance'=>'1.302015','Test2::API::Stack'=>'1.302015','Test2::Event'=>'1.302015','Test2::Event::Bail'=>'1.302015','Test2::Event::Diag'=>'1.302015','Test2::Event::Exception'=>'1.302015','Test2::Event::Note'=>'1.302015','Test2::Event::Ok'=>'1.302015','Test2::Event::Plan'=>'1.302015','Test2::Event::Skip'=>'1.302015','Test2::Event::Subtest'=>'1.302015','Test2::Event::Waiting'=>'1.302015','Test2::Formatter'=>'1.302015','Test2::Formatter::TAP'=>'1.302015','Test2::Hub'=>'1.302015','Test2::Hub::Interceptor'=>'1.302015','Test2::Hub::Interceptor::Terminator'=>'1.302015','Test2::Hub::Subtest'=>'1.302015','Test2::IPC'=>'1.302015','Test2::IPC::Driver'=>'1.302015','Test2::IPC::Driver::Files'=>'1.302015','Test2::Util'=>'1.302015','Test2::Util::ExternalMeta'=>'1.302015','Test2::Util::HashBase'=>'1.302015','Test2::Util::Trace'=>'1.302015','Test::Builder'=>'1.302015','Test::Builder::Formatter'=>'1.302015','Test::Builder::Module'=>'1.302015','Test::Builder::Tester'=>'1.302015','Test::Builder::Tester::Color'=>'1.302015','Test::Builder::TodoDiag'=>'1.302015','Test::More'=>'1.302015','Test::Simple'=>'1.302015','Test::Tester'=>'1.302015','Test::Tester::Capture'=>'1.302015','Test::Tester::CaptureRunner'=>'1.302015','Test::Tester::Delegate'=>'1.302015','Test::use::ok'=>'1.302015','XS::APItest'=>'0.81','_charnames'=>'1.44','charnames'=>'1.44','ok'=>'1.302015','perlfaq'=>'5.021011','re'=>'0.33','threads'=>'2.08','threads::shared'=>'1.52',},removed=>{}},5.025002=>{delta_from=>5.025001,changed=>{'App::Cpan'=>'1.64','B::Op_private'=>'5.025002','CPAN'=>'2.14','CPAN::Distribution'=>'2.12','CPAN::FTP'=>'5.5007','CPAN::FirstTime'=>'5.5309','CPAN::HandleConfig'=>'5.5007','CPAN::Index'=>'2.12','CPAN::Mirrors'=>'2.12','CPAN::Plugin'=>'0.96','CPAN::Shell'=>'5.5006','Config'=>'5.025002','Cwd'=>'3.64','Devel::Peek'=>'1.24','DynaLoader'=>'1.39','ExtUtils::Command'=>'7.18','ExtUtils::Command::MM'=>'7.18','ExtUtils::Liblist'=>'7.18','ExtUtils::Liblist::Kid'=>'7.18','ExtUtils::MM'=>'7.18','ExtUtils::MM_AIX'=>'7.18','ExtUtils::MM_Any'=>'7.18','ExtUtils::MM_BeOS'=>'7.18','ExtUtils::MM_Cygwin'=>'7.18','ExtUtils::MM_DOS'=>'7.18','ExtUtils::MM_Darwin'=>'7.18','ExtUtils::MM_MacOS'=>'7.18','ExtUtils::MM_NW5'=>'7.18','ExtUtils::MM_OS2'=>'7.18','ExtUtils::MM_QNX'=>'7.18','ExtUtils::MM_UWIN'=>'7.18','ExtUtils::MM_Unix'=>'7.18','ExtUtils::MM_VMS'=>'7.18','ExtUtils::MM_VOS'=>'7.18','ExtUtils::MM_Win32'=>'7.18','ExtUtils::MM_Win95'=>'7.18','ExtUtils::MY'=>'7.18','ExtUtils::MakeMaker'=>'7.18','ExtUtils::MakeMaker::Config'=>'7.18','ExtUtils::MakeMaker::Locale'=>'7.18','ExtUtils::MakeMaker::version'=>'7.18','ExtUtils::MakeMaker::version::regex'=>'7.18','ExtUtils::Miniperl'=>'1.06','ExtUtils::Mkbootstrap'=>'7.18','ExtUtils::Mksymlists'=>'7.18','ExtUtils::ParseXS'=>'3.32','ExtUtils::ParseXS::Constants'=>'3.32','ExtUtils::ParseXS::CountLines'=>'3.32','ExtUtils::ParseXS::Eval'=>'3.32','ExtUtils::ParseXS::Utilities'=>'3.32','ExtUtils::Typemaps'=>'3.32','ExtUtils::Typemaps::Cmd'=>'3.32','ExtUtils::Typemaps::InputMap'=>'3.32','ExtUtils::Typemaps::OutputMap'=>'3.32','ExtUtils::Typemaps::Type'=>'3.32','ExtUtils::testlib'=>'7.18','File::Copy'=>'2.32','File::Glob'=>'1.27','File::Spec'=>'3.64','File::Spec::Cygwin'=>'3.64','File::Spec::Epoc'=>'3.64','File::Spec::Functions'=>'3.64','File::Spec::Mac'=>'3.64','File::Spec::OS2'=>'3.64','File::Spec::Unix'=>'3.64','File::Spec::VMS'=>'3.64','File::Spec::Win32'=>'3.64','FileHandle'=>'2.03','Getopt::Long'=>'2.49','HTTP::Tiny'=>'0.058','JSON::PP'=>'2.27400','Locale::Codes'=>'3.39','Locale::Codes::Constants'=>'3.39','Locale::Codes::Country'=>'3.39','Locale::Codes::Country_Codes'=>'3.39','Locale::Codes::Country_Retired'=>'3.39','Locale::Codes::Currency'=>'3.39','Locale::Codes::Currency_Codes'=>'3.39','Locale::Codes::Currency_Retired'=>'3.39','Locale::Codes::LangExt'=>'3.39','Locale::Codes::LangExt_Codes'=>'3.39','Locale::Codes::LangExt_Retired'=>'3.39','Locale::Codes::LangFam'=>'3.39','Locale::Codes::LangFam_Codes'=>'3.39','Locale::Codes::LangFam_Retired'=>'3.39','Locale::Codes::LangVar'=>'3.39','Locale::Codes::LangVar_Codes'=>'3.39','Locale::Codes::LangVar_Retired'=>'3.39','Locale::Codes::Language'=>'3.39','Locale::Codes::Language_Codes'=>'3.39','Locale::Codes::Language_Retired'=>'3.39','Locale::Codes::Script'=>'3.39','Locale::Codes::Script_Codes'=>'3.39','Locale::Codes::Script_Retired'=>'3.39','Locale::Country'=>'3.39','Locale::Currency'=>'3.39','Locale::Language'=>'3.39','Locale::Script'=>'3.39','Module::CoreList'=>'5.20160620','Module::CoreList::TieHashDelta'=>'5.20160620','Module::CoreList::Utils'=>'5.20160620','Opcode'=>'1.35','POSIX'=>'1.70','Pod::Checker'=>'1.73','Pod::Functions'=>'1.11','Pod::Functions::Functions'=>'1.11','Pod::Usage'=>'1.69','Test2'=>'1.302026','Test2::API'=>'1.302026','Test2::API::Breakage'=>'1.302026','Test2::API::Context'=>'1.302026','Test2::API::Instance'=>'1.302026','Test2::API::Stack'=>'1.302026','Test2::Event'=>'1.302026','Test2::Event::Bail'=>'1.302026','Test2::Event::Diag'=>'1.302026','Test2::Event::Exception'=>'1.302026','Test2::Event::Generic'=>'1.302026','Test2::Event::Note'=>'1.302026','Test2::Event::Ok'=>'1.302026','Test2::Event::Plan'=>'1.302026','Test2::Event::Skip'=>'1.302026','Test2::Event::Subtest'=>'1.302026','Test2::Event::Waiting'=>'1.302026','Test2::Formatter'=>'1.302026','Test2::Formatter::TAP'=>'1.302026','Test2::Hub'=>'1.302026','Test2::Hub::Interceptor'=>'1.302026','Test2::Hub::Interceptor::Terminator'=>'1.302026','Test2::Hub::Subtest'=>'1.302026','Test2::IPC'=>'1.302026','Test2::IPC::Driver'=>'1.302026','Test2::IPC::Driver::Files'=>'1.302026','Test2::Util'=>'1.302026','Test2::Util::ExternalMeta'=>'1.302026','Test2::Util::HashBase'=>'1.302026','Test2::Util::Trace'=>'1.302026','Test::Builder'=>'1.302026','Test::Builder::Formatter'=>'1.302026','Test::Builder::Module'=>'1.302026','Test::Builder::Tester'=>'1.302026','Test::Builder::Tester::Color'=>'1.302026','Test::Builder::TodoDiag'=>'1.302026','Test::More'=>'1.302026','Test::Simple'=>'1.302026','Test::Tester'=>'1.302026','Test::Tester::Capture'=>'1.302026','Test::Tester::CaptureRunner'=>'1.302026','Test::Tester::Delegate'=>'1.302026','Test::use::ok'=>'1.302026','Thread::Queue'=>'3.11','Time::HiRes'=>'1.9734','Unicode::UCD'=>'0.65','VMS::DCLsym'=>'1.07','XS::APItest'=>'0.82','diagnostics'=>'1.35','feature'=>'1.44','ok'=>'1.302026','threads'=>'2.09',},removed=>{}},5.025003=>{delta_from=>5.025002,changed=>{'B::Op_private'=>'5.025003','Config'=>'5.025003','Data::Dumper'=>'2.161','Devel::PPPort'=>'3.35','Encode'=>'2.84','Encode::MIME::Header'=>'2.23','Encode::MIME::Header::ISO_2022_JP'=>'1.07','ExtUtils::ParseXS'=>'3.33','ExtUtils::ParseXS::Constants'=>'3.33','ExtUtils::ParseXS::CountLines'=>'3.33','ExtUtils::ParseXS::Eval'=>'3.33','ExtUtils::ParseXS::Utilities'=>'3.33','ExtUtils::Typemaps'=>'3.33','ExtUtils::Typemaps::Cmd'=>'3.33','ExtUtils::Typemaps::InputMap'=>'3.33','ExtUtils::Typemaps::OutputMap'=>'3.33','ExtUtils::Typemaps::Type'=>'3.33','Hash::Util'=>'0.20','Math::BigFloat'=>'1.999726','Math::BigFloat::Trace'=>'0.43','Math::BigInt'=>'1.999726','Math::BigInt::Calc'=>'1.999726','Math::BigInt::CalcEmu'=>'1.999726','Math::BigInt::FastCalc'=>'0.42','Math::BigInt::Trace'=>'0.43','Math::BigRat'=>'0.260804','Module::CoreList'=>'5.20160720','Module::CoreList::TieHashDelta'=>'5.20160720','Module::CoreList::Utils'=>'5.20160720','Net::Cmd'=>'3.09','Net::Config'=>'3.09','Net::Domain'=>'3.09','Net::FTP'=>'3.09','Net::FTP::A'=>'3.09','Net::FTP::E'=>'3.09','Net::FTP::I'=>'3.09','Net::FTP::L'=>'3.09','Net::FTP::dataconn'=>'3.09','Net::NNTP'=>'3.09','Net::Netrc'=>'3.09','Net::POP3'=>'3.09','Net::SMTP'=>'3.09','Net::Time'=>'3.09','Parse::CPAN::Meta'=>'1.4422','Perl::OSType'=>'1.010','Test2'=>'1.302045','Test2::API'=>'1.302045','Test2::API::Breakage'=>'1.302045','Test2::API::Context'=>'1.302045','Test2::API::Instance'=>'1.302045','Test2::API::Stack'=>'1.302045','Test2::Event'=>'1.302045','Test2::Event::Bail'=>'1.302045','Test2::Event::Diag'=>'1.302045','Test2::Event::Exception'=>'1.302045','Test2::Event::Generic'=>'1.302045','Test2::Event::Info'=>'1.302045','Test2::Event::Note'=>'1.302045','Test2::Event::Ok'=>'1.302045','Test2::Event::Plan'=>'1.302045','Test2::Event::Skip'=>'1.302045','Test2::Event::Subtest'=>'1.302045','Test2::Event::Waiting'=>'1.302045','Test2::Formatter'=>'1.302045','Test2::Formatter::TAP'=>'1.302045','Test2::Hub'=>'1.302045','Test2::Hub::Interceptor'=>'1.302045','Test2::Hub::Interceptor::Terminator'=>'1.302045','Test2::Hub::Subtest'=>'1.302045','Test2::IPC'=>'1.302045','Test2::IPC::Driver'=>'1.302045','Test2::IPC::Driver::Files'=>'1.302045','Test2::Util'=>'1.302045','Test2::Util::ExternalMeta'=>'1.302045','Test2::Util::HashBase'=>'1.302045','Test2::Util::Trace'=>'1.302045','Test::Builder'=>'1.302045','Test::Builder::Formatter'=>'1.302045','Test::Builder::Module'=>'1.302045','Test::Builder::Tester'=>'1.302045','Test::Builder::Tester::Color'=>'1.302045','Test::Builder::TodoDiag'=>'1.302045','Test::More'=>'1.302045','Test::Simple'=>'1.302045','Test::Tester'=>'1.302045','Test::Tester::Capture'=>'1.302045','Test::Tester::CaptureRunner'=>'1.302045','Test::Tester::Delegate'=>'1.302045','Test::use::ok'=>'1.302045','Time::HiRes'=>'1.9739','Unicode'=>'9.0.0','Unicode::UCD'=>'0.66','XSLoader'=>'0.22','bigint'=>'0.43','bignum'=>'0.43','bigrat'=>'0.43','encoding'=>'2.17_01','encoding::warnings'=>'0.13','feature'=>'1.45','ok'=>'1.302045','version'=>'0.9917','version::regex'=>'0.9917','warnings'=>'1.37',},removed=>{}},5.025004=>{delta_from=>5.025003,changed=>{'App::Cpan'=>'1.64_01','App::Prove'=>'3.36_01','App::Prove::State'=>'3.36_01','App::Prove::State::Result'=>'3.36_01','App::Prove::State::Result::Test'=>'3.36_01','Archive::Tar'=>'2.10','Archive::Tar::Constant'=>'2.10','Archive::Tar::File'=>'2.10','B'=>'1.63','B::Concise'=>'0.998','B::Deparse'=>'1.38','B::Op_private'=>'5.025004','CPAN'=>'2.14_01','CPAN::Meta'=>'2.150010','CPAN::Meta::Converter'=>'2.150010','CPAN::Meta::Feature'=>'2.150010','CPAN::Meta::History'=>'2.150010','CPAN::Meta::Merge'=>'2.150010','CPAN::Meta::Prereqs'=>'2.150010','CPAN::Meta::Spec'=>'2.150010','CPAN::Meta::Validator'=>'2.150010','Carp'=>'1.42','Carp::Heavy'=>'1.42','Compress::Zlib'=>'2.069_01','Config'=>'5.025004','Config::Perl::V'=>'0.27','Cwd'=>'3.65','Digest'=>'1.17_01','Digest::SHA'=>'5.96','Encode'=>'2.86','Errno'=>'1.26','ExtUtils::Command'=>'7.24','ExtUtils::Command::MM'=>'7.24','ExtUtils::Liblist'=>'7.24','ExtUtils::Liblist::Kid'=>'7.24','ExtUtils::MM'=>'7.24','ExtUtils::MM_AIX'=>'7.24','ExtUtils::MM_Any'=>'7.24','ExtUtils::MM_BeOS'=>'7.24','ExtUtils::MM_Cygwin'=>'7.24','ExtUtils::MM_DOS'=>'7.24','ExtUtils::MM_Darwin'=>'7.24','ExtUtils::MM_MacOS'=>'7.24','ExtUtils::MM_NW5'=>'7.24','ExtUtils::MM_OS2'=>'7.24','ExtUtils::MM_QNX'=>'7.24','ExtUtils::MM_UWIN'=>'7.24','ExtUtils::MM_Unix'=>'7.24','ExtUtils::MM_VMS'=>'7.24','ExtUtils::MM_VOS'=>'7.24','ExtUtils::MM_Win32'=>'7.24','ExtUtils::MM_Win95'=>'7.24','ExtUtils::MY'=>'7.24','ExtUtils::MakeMaker'=>'7.24','ExtUtils::MakeMaker::Config'=>'7.24','ExtUtils::MakeMaker::Locale'=>'7.24','ExtUtils::MakeMaker::version'=>'7.24','ExtUtils::MakeMaker::version::regex'=>'7.24','ExtUtils::Mkbootstrap'=>'7.24','ExtUtils::Mksymlists'=>'7.24','ExtUtils::testlib'=>'7.24','File::Fetch'=>'0.52','File::Spec'=>'3.65','File::Spec::AmigaOS'=>'3.65','File::Spec::Cygwin'=>'3.65','File::Spec::Epoc'=>'3.65','File::Spec::Functions'=>'3.65','File::Spec::Mac'=>'3.65','File::Spec::OS2'=>'3.65','File::Spec::Unix'=>'3.65','File::Spec::VMS'=>'3.65','File::Spec::Win32'=>'3.65','HTTP::Tiny'=>'0.064','Hash::Util'=>'0.21','I18N::LangTags'=>'0.41','I18N::LangTags::Detect'=>'1.06','IO'=>'1.37','IO::Compress::Adapter::Bzip2'=>'2.069_01','IO::Compress::Adapter::Deflate'=>'2.069_01','IO::Compress::Adapter::Identity'=>'2.069_01','IO::Compress::Base'=>'2.069_01','IO::Compress::Base::Common'=>'2.069_01','IO::Compress::Bzip2'=>'2.069_01','IO::Compress::Deflate'=>'2.069_01','IO::Compress::Gzip'=>'2.069_01','IO::Compress::Gzip::Constants'=>'2.069_01','IO::Compress::RawDeflate'=>'2.069_01','IO::Compress::Zip'=>'2.069_01','IO::Compress::Zip::Constants'=>'2.069_01','IO::Compress::Zlib::Constants'=>'2.069_01','IO::Compress::Zlib::Extra'=>'2.069_01','IO::Socket::IP'=>'0.38','IO::Uncompress::Adapter::Bunzip2'=>'2.069_01','IO::Uncompress::Adapter::Identity'=>'2.069_01','IO::Uncompress::Adapter::Inflate'=>'2.069_01','IO::Uncompress::AnyInflate'=>'2.069_01','IO::Uncompress::AnyUncompress'=>'2.069_01','IO::Uncompress::Base'=>'2.069_01','IO::Uncompress::Bunzip2'=>'2.069_01','IO::Uncompress::Gunzip'=>'2.069_01','IO::Uncompress::Inflate'=>'2.069_01','IO::Uncompress::RawInflate'=>'2.069_01','IO::Uncompress::Unzip'=>'2.069_01','IPC::Cmd'=>'0.96','JSON::PP'=>'2.27400_01','Locale::Maketext'=>'1.28','Locale::Maketext::Simple'=>'0.21_01','Math::BigFloat::Trace'=>'0.43_01','Math::BigInt::Trace'=>'0.43_01','Memoize'=>'1.03_01','Module::CoreList'=>'5.20160820','Module::CoreList::TieHashDelta'=>'5.20160820','Module::CoreList::Utils'=>'5.20160820','Module::Load::Conditional'=>'0.68','Module::Metadata'=>'1.000033','NEXT'=>'0.67','Net::Cmd'=>'3.10','Net::Config'=>'3.10','Net::Domain'=>'3.10','Net::FTP'=>'3.10','Net::FTP::A'=>'3.10','Net::FTP::E'=>'3.10','Net::FTP::I'=>'3.10','Net::FTP::L'=>'3.10','Net::FTP::dataconn'=>'3.10','Net::NNTP'=>'3.10','Net::Netrc'=>'3.10','Net::POP3'=>'3.10','Net::Ping'=>'2.44','Net::SMTP'=>'3.10','Net::Time'=>'3.10','Opcode'=>'1.37','POSIX'=>'1.71','Parse::CPAN::Meta'=>'2.150010','Pod::Html'=>'1.2201','Pod::Perldoc'=>'3.27','Pod::Perldoc::BaseTo'=>'3.27','Pod::Perldoc::GetOptsOO'=>'3.27','Pod::Perldoc::ToANSI'=>'3.27','Pod::Perldoc::ToChecker'=>'3.27','Pod::Perldoc::ToMan'=>'3.27','Pod::Perldoc::ToNroff'=>'3.27','Pod::Perldoc::ToPod'=>'3.27','Pod::Perldoc::ToRtf'=>'3.27','Pod::Perldoc::ToTerm'=>'3.27','Pod::Perldoc::ToText'=>'3.27','Pod::Perldoc::ToTk'=>'3.27','Pod::Perldoc::ToXml'=>'3.27','Storable'=>'2.57','Sys::Syslog'=>'0.34_01','TAP::Base'=>'3.36_01','TAP::Formatter::Base'=>'3.36_01','TAP::Formatter::Color'=>'3.36_01','TAP::Formatter::Console'=>'3.36_01','TAP::Formatter::Console::ParallelSession'=>'3.36_01','TAP::Formatter::Console::Session'=>'3.36_01','TAP::Formatter::File'=>'3.36_01','TAP::Formatter::File::Session'=>'3.36_01','TAP::Formatter::Session'=>'3.36_01','TAP::Harness'=>'3.36_01','TAP::Harness::Env'=>'3.36_01','TAP::Object'=>'3.36_01','TAP::Parser'=>'3.36_01','TAP::Parser::Aggregator'=>'3.36_01','TAP::Parser::Grammar'=>'3.36_01','TAP::Parser::Iterator'=>'3.36_01','TAP::Parser::Iterator::Array'=>'3.36_01','TAP::Parser::Iterator::Process'=>'3.36_01','TAP::Parser::Iterator::Stream'=>'3.36_01','TAP::Parser::IteratorFactory'=>'3.36_01','TAP::Parser::Multiplexer'=>'3.36_01','TAP::Parser::Result'=>'3.36_01','TAP::Parser::Result::Bailout'=>'3.36_01','TAP::Parser::Result::Comment'=>'3.36_01','TAP::Parser::Result::Plan'=>'3.36_01','TAP::Parser::Result::Pragma'=>'3.36_01','TAP::Parser::Result::Test'=>'3.36_01','TAP::Parser::Result::Unknown'=>'3.36_01','TAP::Parser::Result::Version'=>'3.36_01','TAP::Parser::Result::YAML'=>'3.36_01','TAP::Parser::ResultFactory'=>'3.36_01','TAP::Parser::Scheduler'=>'3.36_01','TAP::Parser::Scheduler::Job'=>'3.36_01','TAP::Parser::Scheduler::Spinner'=>'3.36_01','TAP::Parser::Source'=>'3.36_01','TAP::Parser::SourceHandler'=>'3.36_01','TAP::Parser::SourceHandler::Executable'=>'3.36_01','TAP::Parser::SourceHandler::File'=>'3.36_01','TAP::Parser::SourceHandler::Handle'=>'3.36_01','TAP::Parser::SourceHandler::Perl'=>'3.36_01','TAP::Parser::SourceHandler::RawTAP'=>'3.36_01','TAP::Parser::YAMLish::Reader'=>'3.36_01','TAP::Parser::YAMLish::Writer'=>'3.36_01','Test'=>'1.29','Test2'=>'1.302052','Test2::API'=>'1.302052','Test2::API::Breakage'=>'1.302052','Test2::API::Context'=>'1.302052','Test2::API::Instance'=>'1.302052','Test2::API::Stack'=>'1.302052','Test2::Event'=>'1.302052','Test2::Event::Bail'=>'1.302052','Test2::Event::Diag'=>'1.302052','Test2::Event::Exception'=>'1.302052','Test2::Event::Generic'=>'1.302052','Test2::Event::Info'=>'1.302052','Test2::Event::Note'=>'1.302052','Test2::Event::Ok'=>'1.302052','Test2::Event::Plan'=>'1.302052','Test2::Event::Skip'=>'1.302052','Test2::Event::Subtest'=>'1.302052','Test2::Event::Waiting'=>'1.302052','Test2::Formatter'=>'1.302052','Test2::Formatter::TAP'=>'1.302052','Test2::Hub'=>'1.302052','Test2::Hub::Interceptor'=>'1.302052','Test2::Hub::Interceptor::Terminator'=>'1.302052','Test2::Hub::Subtest'=>'1.302052','Test2::IPC'=>'1.302052','Test2::IPC::Driver'=>'1.302052','Test2::IPC::Driver::Files'=>'1.302052','Test2::Util'=>'1.302052','Test2::Util::ExternalMeta'=>'1.302052','Test2::Util::HashBase'=>'1.302052','Test2::Util::Trace'=>'1.302052','Test::Builder'=>'1.302052','Test::Builder::Formatter'=>'1.302052','Test::Builder::Module'=>'1.302052','Test::Builder::Tester'=>'1.302052','Test::Builder::Tester::Color'=>'1.302052','Test::Builder::TodoDiag'=>'1.302052','Test::Harness'=>'3.36_01','Test::More'=>'1.302052','Test::Simple'=>'1.302052','Test::Tester'=>'1.302052','Test::Tester::Capture'=>'1.302052','Test::Tester::CaptureRunner'=>'1.302052','Test::Tester::Delegate'=>'1.302052','Test::use::ok'=>'1.302052','Tie::Hash::NamedCapture'=>'0.10','Time::Local'=>'1.24','XS::APItest'=>'0.83','arybase'=>'0.12','base'=>'2.24','bigint'=>'0.43_01','bignum'=>'0.43_01','bigrat'=>'0.43_01','encoding'=>'2.18','ok'=>'1.302052',},removed=>{}},5.025005=>{delta_from=>5.025004,changed=>{'B::Op_private'=>'5.025005','Config'=>'5.025005','Filter::Simple'=>'0.93','Locale::Codes'=>'3.40','Locale::Codes::Constants'=>'3.40','Locale::Codes::Country'=>'3.40','Locale::Codes::Country_Codes'=>'3.40','Locale::Codes::Country_Retired'=>'3.40','Locale::Codes::Currency'=>'3.40','Locale::Codes::Currency_Codes'=>'3.40','Locale::Codes::Currency_Retired'=>'3.40','Locale::Codes::LangExt'=>'3.40','Locale::Codes::LangExt_Codes'=>'3.40','Locale::Codes::LangExt_Retired'=>'3.40','Locale::Codes::LangFam'=>'3.40','Locale::Codes::LangFam_Codes'=>'3.40','Locale::Codes::LangFam_Retired'=>'3.40','Locale::Codes::LangVar'=>'3.40','Locale::Codes::LangVar_Codes'=>'3.40','Locale::Codes::LangVar_Retired'=>'3.40','Locale::Codes::Language'=>'3.40','Locale::Codes::Language_Codes'=>'3.40','Locale::Codes::Language_Retired'=>'3.40','Locale::Codes::Script'=>'3.40','Locale::Codes::Script_Codes'=>'3.40','Locale::Codes::Script_Retired'=>'3.40','Locale::Country'=>'3.40','Locale::Currency'=>'3.40','Locale::Language'=>'3.40','Locale::Script'=>'3.40','Module::CoreList'=>'5.20160920','Module::CoreList::TieHashDelta'=>'5.20160920','Module::CoreList::Utils'=>'5.20160920','POSIX'=>'1.72','Sys::Syslog'=>'0.35','Test2'=>'1.302056','Test2::API'=>'1.302056','Test2::API::Breakage'=>'1.302056','Test2::API::Context'=>'1.302056','Test2::API::Instance'=>'1.302056','Test2::API::Stack'=>'1.302056','Test2::Event'=>'1.302056','Test2::Event::Bail'=>'1.302056','Test2::Event::Diag'=>'1.302056','Test2::Event::Exception'=>'1.302056','Test2::Event::Generic'=>'1.302056','Test2::Event::Info'=>'1.302056','Test2::Event::Note'=>'1.302056','Test2::Event::Ok'=>'1.302056','Test2::Event::Plan'=>'1.302056','Test2::Event::Skip'=>'1.302056','Test2::Event::Subtest'=>'1.302056','Test2::Event::Waiting'=>'1.302056','Test2::Formatter'=>'1.302056','Test2::Formatter::TAP'=>'1.302056','Test2::Hub'=>'1.302056','Test2::Hub::Interceptor'=>'1.302056','Test2::Hub::Interceptor::Terminator'=>'1.302056','Test2::Hub::Subtest'=>'1.302056','Test2::IPC'=>'1.302056','Test2::IPC::Driver'=>'1.302056','Test2::IPC::Driver::Files'=>'1.302056','Test2::Util'=>'1.302056','Test2::Util::ExternalMeta'=>'1.302056','Test2::Util::HashBase'=>'1.302056','Test2::Util::Trace'=>'1.302056','Test::Builder'=>'1.302056','Test::Builder::Formatter'=>'1.302056','Test::Builder::Module'=>'1.302056','Test::Builder::Tester'=>'1.302056','Test::Builder::Tester::Color'=>'1.302056','Test::Builder::TodoDiag'=>'1.302056','Test::More'=>'1.302056','Test::Simple'=>'1.302056','Test::Tester'=>'1.302056','Test::Tester::Capture'=>'1.302056','Test::Tester::CaptureRunner'=>'1.302056','Test::Tester::Delegate'=>'1.302056','Test::use::ok'=>'1.302056','Thread::Semaphore'=>'2.13','XS::APItest'=>'0.84','XSLoader'=>'0.24','ok'=>'1.302056',},removed=>{}},5.025006=>{delta_from=>5.025005,changed=>{'Archive::Tar'=>'2.14','Archive::Tar::Constant'=>'2.14','Archive::Tar::File'=>'2.14','B'=>'1.64','B::Concise'=>'0.999','B::Deparse'=>'1.39','B::Op_private'=>'5.025006','Config'=>'5.025006','Data::Dumper'=>'2.162','Devel::Peek'=>'1.25','HTTP::Tiny'=>'0.070','List::Util'=>'1.46','List::Util::XS'=>'1.46','Module::CoreList'=>'5.20161020','Module::CoreList::TieHashDelta'=>'5.20161020','Module::CoreList::Utils'=>'5.20161020','Net::Ping'=>'2.51','OS2::DLL'=>'1.07','Opcode'=>'1.38','POSIX'=>'1.73','PerlIO::encoding'=>'0.25','Pod::Man'=>'4.08','Pod::ParseLink'=>'4.08','Pod::Text'=>'4.08','Pod::Text::Color'=>'4.08','Pod::Text::Overstrike'=>'4.08','Pod::Text::Termcap'=>'4.08','Scalar::Util'=>'1.46','Storable'=>'2.58','Sub::Util'=>'1.46','Test2'=>'1.302059','Test2::API'=>'1.302059','Test2::API::Breakage'=>'1.302059','Test2::API::Context'=>'1.302059','Test2::API::Instance'=>'1.302059','Test2::API::Stack'=>'1.302059','Test2::Event'=>'1.302059','Test2::Event::Bail'=>'1.302059','Test2::Event::Diag'=>'1.302059','Test2::Event::Exception'=>'1.302059','Test2::Event::Generic'=>'1.302059','Test2::Event::Info'=>'1.302059','Test2::Event::Note'=>'1.302059','Test2::Event::Ok'=>'1.302059','Test2::Event::Plan'=>'1.302059','Test2::Event::Skip'=>'1.302059','Test2::Event::Subtest'=>'1.302059','Test2::Event::Waiting'=>'1.302059','Test2::Formatter'=>'1.302059','Test2::Formatter::TAP'=>'1.302059','Test2::Hub'=>'1.302059','Test2::Hub::Interceptor'=>'1.302059','Test2::Hub::Interceptor::Terminator'=>'1.302059','Test2::Hub::Subtest'=>'1.302059','Test2::IPC'=>'1.302059','Test2::IPC::Driver'=>'1.302059','Test2::IPC::Driver::Files'=>'1.302059','Test2::Util'=>'1.302059','Test2::Util::ExternalMeta'=>'1.302059','Test2::Util::HashBase'=>'1.302059','Test2::Util::Trace'=>'1.302059','Test::Builder'=>'1.302059','Test::Builder::Formatter'=>'1.302059','Test::Builder::Module'=>'1.302059','Test::Builder::Tester'=>'1.302059','Test::Builder::Tester::Color'=>'1.302059','Test::Builder::TodoDiag'=>'1.302059','Test::More'=>'1.302059','Test::Simple'=>'1.302059','Test::Tester'=>'1.302059','Test::Tester::Capture'=>'1.302059','Test::Tester::CaptureRunner'=>'1.302059','Test::Tester::Delegate'=>'1.302059','Test::use::ok'=>'1.302059','Time::HiRes'=>'1.9740_01','VMS::Stdio'=>'2.42','XS::APItest'=>'0.86','attributes'=>'0.28','mro'=>'1.19','ok'=>'1.302059','overload'=>'1.27','parent'=>'0.236',},removed=>{}},5.025007=>{delta_from=>5.025006,changed=>{'Archive::Tar'=>'2.18','Archive::Tar::Constant'=>'2.18','Archive::Tar::File'=>'2.18','B'=>'1.65','B::Op_private'=>'5.025007','Config'=>'5.025007','Cwd'=>'3.66','Data::Dumper'=>'2.165','Devel::Peek'=>'1.26','DynaLoader'=>'1.40','Errno'=>'1.27','ExtUtils::ParseXS::Utilities'=>'3.34','File::Spec'=>'3.66','File::Spec::AmigaOS'=>'3.66','File::Spec::Cygwin'=>'3.66','File::Spec::Epoc'=>'3.66','File::Spec::Functions'=>'3.66','File::Spec::Mac'=>'3.66','File::Spec::OS2'=>'3.66','File::Spec::Unix'=>'3.66','File::Spec::VMS'=>'3.66','File::Spec::Win32'=>'3.66','Hash::Util'=>'0.22','JSON::PP'=>'2.27400_02','List::Util'=>'1.46_02','List::Util::XS'=>'1.46_02','Math::BigFloat'=>'1.999727','Math::BigInt'=>'1.999727','Math::BigInt::Calc'=>'1.999727','Math::BigInt::CalcEmu'=>'1.999727','Math::Complex'=>'1.5901','Module::CoreList'=>'5.20161120','Module::CoreList::TieHashDelta'=>'5.20161120','Module::CoreList::Utils'=>'5.20161120','Net::Ping'=>'2.55','Opcode'=>'1.39','POSIX'=>'1.75','Pod::Man'=>'4.09','Pod::ParseLink'=>'4.09','Pod::Text'=>'4.09','Pod::Text::Color'=>'4.09','Pod::Text::Overstrike'=>'4.09','Pod::Text::Termcap'=>'4.09','Scalar::Util'=>'1.46_02','Storable'=>'2.59','Sub::Util'=>'1.46_02','Term::ANSIColor'=>'4.06','Test2'=>'1.302062','Test2::API'=>'1.302062','Test2::API::Breakage'=>'1.302062','Test2::API::Context'=>'1.302062','Test2::API::Instance'=>'1.302062','Test2::API::Stack'=>'1.302062','Test2::Event'=>'1.302062','Test2::Event::Bail'=>'1.302062','Test2::Event::Diag'=>'1.302062','Test2::Event::Exception'=>'1.302062','Test2::Event::Generic'=>'1.302062','Test2::Event::Info'=>'1.302062','Test2::Event::Note'=>'1.302062','Test2::Event::Ok'=>'1.302062','Test2::Event::Plan'=>'1.302062','Test2::Event::Skip'=>'1.302062','Test2::Event::Subtest'=>'1.302062','Test2::Event::Waiting'=>'1.302062','Test2::Formatter'=>'1.302062','Test2::Formatter::TAP'=>'1.302062','Test2::Hub'=>'1.302062','Test2::Hub::Interceptor'=>'1.302062','Test2::Hub::Interceptor::Terminator'=>'1.302062','Test2::Hub::Subtest'=>'1.302062','Test2::IPC'=>'1.302062','Test2::IPC::Driver'=>'1.302062','Test2::IPC::Driver::Files'=>'1.302062','Test2::Util'=>'1.302062','Test2::Util::ExternalMeta'=>'1.302062','Test2::Util::HashBase'=>'1.302062','Test2::Util::Trace'=>'1.302062','Test::Builder'=>'1.302062','Test::Builder::Formatter'=>'1.302062','Test::Builder::Module'=>'1.302062','Test::Builder::Tester'=>'1.302062','Test::Builder::Tester::Color'=>'1.302062','Test::Builder::TodoDiag'=>'1.302062','Test::More'=>'1.302062','Test::Simple'=>'1.302062','Test::Tester'=>'1.302062','Test::Tester::Capture'=>'1.302062','Test::Tester::CaptureRunner'=>'1.302062','Test::Tester::Delegate'=>'1.302062','Test::use::ok'=>'1.302062','Time::HiRes'=>'1.9740_03','Unicode::Collate'=>'1.18','Unicode::Collate::CJK::Big5'=>'1.18','Unicode::Collate::CJK::GB2312'=>'1.18','Unicode::Collate::CJK::JISX0208'=>'1.18','Unicode::Collate::CJK::Korean'=>'1.18','Unicode::Collate::CJK::Pinyin'=>'1.18','Unicode::Collate::CJK::Stroke'=>'1.18','Unicode::Collate::CJK::Zhuyin'=>'1.18','Unicode::Collate::Locale'=>'1.18','Unicode::UCD'=>'0.67','XS::APItest'=>'0.87','XS::Typemap'=>'0.15','mro'=>'1.20','ok'=>'1.302062','threads'=>'2.10',},removed=>{}},5.025008=>{delta_from=>5.025007,changed=>{'Archive::Tar'=>'2.24','Archive::Tar::Constant'=>'2.24','Archive::Tar::File'=>'2.24','B::Debug'=>'1.24','B::Op_private'=>'5.025008','Config'=>'5.025008','Data::Dumper'=>'2.166','Encode'=>'2.88','Encode::Alias'=>'2.21','Encode::CN::HZ'=>'2.08','Encode::MIME::Header'=>'2.24','Encode::MIME::Name'=>'1.02','Encode::Unicode'=>'2.1501','IO'=>'1.38','Locale::Codes'=>'3.42','Locale::Codes::Constants'=>'3.42','Locale::Codes::Country'=>'3.42','Locale::Codes::Country_Codes'=>'3.42','Locale::Codes::Country_Retired'=>'3.42','Locale::Codes::Currency'=>'3.42','Locale::Codes::Currency_Codes'=>'3.42','Locale::Codes::Currency_Retired'=>'3.42','Locale::Codes::LangExt'=>'3.42','Locale::Codes::LangExt_Codes'=>'3.42','Locale::Codes::LangExt_Retired'=>'3.42','Locale::Codes::LangFam'=>'3.42','Locale::Codes::LangFam_Codes'=>'3.42','Locale::Codes::LangFam_Retired'=>'3.42','Locale::Codes::LangVar'=>'3.42','Locale::Codes::LangVar_Codes'=>'3.42','Locale::Codes::LangVar_Retired'=>'3.42','Locale::Codes::Language'=>'3.42','Locale::Codes::Language_Codes'=>'3.42','Locale::Codes::Language_Retired'=>'3.42','Locale::Codes::Script'=>'3.42','Locale::Codes::Script_Codes'=>'3.42','Locale::Codes::Script_Retired'=>'3.42','Locale::Country'=>'3.42','Locale::Currency'=>'3.42','Locale::Language'=>'3.42','Locale::Script'=>'3.42','Math::BigFloat'=>'1.999806','Math::BigFloat::Trace'=>'0.47','Math::BigInt'=>'1.999806','Math::BigInt::Calc'=>'1.999806','Math::BigInt::CalcEmu'=>'1.999806','Math::BigInt::FastCalc'=>'0.5005','Math::BigInt::Lib'=>'1.999806','Math::BigInt::Trace'=>'0.47','Math::BigRat'=>'0.2611','Module::CoreList'=>'5.20161220','Module::CoreList::TieHashDelta'=>'5.20161220','Module::CoreList::Utils'=>'5.20161220','POSIX'=>'1.76','PerlIO::scalar'=>'0.25','Pod::Simple'=>'3.35','Pod::Simple::BlackBox'=>'3.35','Pod::Simple::Checker'=>'3.35','Pod::Simple::Debug'=>'3.35','Pod::Simple::DumpAsText'=>'3.35','Pod::Simple::DumpAsXML'=>'3.35','Pod::Simple::HTML'=>'3.35','Pod::Simple::HTMLBatch'=>'3.35','Pod::Simple::LinkSection'=>'3.35','Pod::Simple::Methody'=>'3.35','Pod::Simple::Progress'=>'3.35','Pod::Simple::PullParser'=>'3.35','Pod::Simple::PullParserEndToken'=>'3.35','Pod::Simple::PullParserStartToken'=>'3.35','Pod::Simple::PullParserTextToken'=>'3.35','Pod::Simple::PullParserToken'=>'3.35','Pod::Simple::RTF'=>'3.35','Pod::Simple::Search'=>'3.35','Pod::Simple::SimpleTree'=>'3.35','Pod::Simple::Text'=>'3.35','Pod::Simple::TextContent'=>'3.35','Pod::Simple::TiedOutFH'=>'3.35','Pod::Simple::Transcode'=>'3.35','Pod::Simple::TranscodeDumb'=>'3.35','Pod::Simple::TranscodeSmart'=>'3.35','Pod::Simple::XHTML'=>'3.35','Pod::Simple::XMLOutStream'=>'3.35','Test2'=>'1.302073','Test2::API'=>'1.302073','Test2::API::Breakage'=>'1.302073','Test2::API::Context'=>'1.302073','Test2::API::Instance'=>'1.302073','Test2::API::Stack'=>'1.302073','Test2::Event'=>'1.302073','Test2::Event::Bail'=>'1.302073','Test2::Event::Diag'=>'1.302073','Test2::Event::Encoding'=>'1.302073','Test2::Event::Exception'=>'1.302073','Test2::Event::Generic'=>'1.302073','Test2::Event::Info'=>'1.302073','Test2::Event::Note'=>'1.302073','Test2::Event::Ok'=>'1.302073','Test2::Event::Plan'=>'1.302073','Test2::Event::Skip'=>'1.302073','Test2::Event::Subtest'=>'1.302073','Test2::Event::TAP::Version'=>'1.302073','Test2::Event::Waiting'=>'1.302073','Test2::Formatter'=>'1.302073','Test2::Formatter::TAP'=>'1.302073','Test2::Hub'=>'1.302073','Test2::Hub::Interceptor'=>'1.302073','Test2::Hub::Interceptor::Terminator'=>'1.302073','Test2::Hub::Subtest'=>'1.302073','Test2::IPC'=>'1.302073','Test2::IPC::Driver'=>'1.302073','Test2::IPC::Driver::Files'=>'1.302073','Test2::Tools::Tiny'=>'1.302073','Test2::Util'=>'1.302073','Test2::Util::ExternalMeta'=>'1.302073','Test2::Util::HashBase'=>'0.002','Test2::Util::Trace'=>'1.302073','Test::Builder'=>'1.302073','Test::Builder::Formatter'=>'1.302073','Test::Builder::Module'=>'1.302073','Test::Builder::Tester'=>'1.302073','Test::Builder::Tester::Color'=>'1.302073','Test::Builder::TodoDiag'=>'1.302073','Test::More'=>'1.302073','Test::Simple'=>'1.302073','Test::Tester'=>'1.302073','Test::Tester::Capture'=>'1.302073','Test::Tester::CaptureRunner'=>'1.302073','Test::Tester::Delegate'=>'1.302073','Test::use::ok'=>'1.302073','Time::HiRes'=>'1.9741','Time::Local'=>'1.25','Unicode::Collate'=>'1.19','Unicode::Collate::CJK::Big5'=>'1.19','Unicode::Collate::CJK::GB2312'=>'1.19','Unicode::Collate::CJK::JISX0208'=>'1.19','Unicode::Collate::CJK::Korean'=>'1.19','Unicode::Collate::CJK::Pinyin'=>'1.19','Unicode::Collate::CJK::Stroke'=>'1.19','Unicode::Collate::CJK::Zhuyin'=>'1.19','Unicode::Collate::Locale'=>'1.19','bigint'=>'0.47','bignum'=>'0.47','bigrat'=>'0.47','encoding'=>'2.19','ok'=>'1.302073',},removed=>{}},5.022003=>{delta_from=>5.022002,changed=>{'App::Cpan'=>'1.63_01','App::Prove'=>'3.35_01','App::Prove::State'=>'3.35_01','App::Prove::State::Result'=>'3.35_01','App::Prove::State::Result::Test'=>'3.35_01','Archive::Tar'=>'2.04_01','Archive::Tar::Constant'=>'2.04_01','Archive::Tar::File'=>'2.04_01','B::Op_private'=>'5.022003','CPAN'=>'2.11_01','Compress::Zlib'=>'2.068_001','Config'=>'5.022003','Cwd'=>'3.56_02','Digest'=>'1.17_01','Digest::SHA'=>'5.95_01','Encode'=>'2.72_01','ExtUtils::Command'=>'1.20_01','ExtUtils::Command::MM'=>'7.04_02','ExtUtils::Liblist'=>'7.04_02','ExtUtils::Liblist::Kid'=>'7.04_02','ExtUtils::MM'=>'7.04_02','ExtUtils::MM_AIX'=>'7.04_02','ExtUtils::MM_Any'=>'7.04_02','ExtUtils::MM_BeOS'=>'7.04_02','ExtUtils::MM_Cygwin'=>'7.04_02','ExtUtils::MM_DOS'=>'7.04_02','ExtUtils::MM_Darwin'=>'7.04_02','ExtUtils::MM_MacOS'=>'7.04_02','ExtUtils::MM_NW5'=>'7.04_02','ExtUtils::MM_OS2'=>'7.04_02','ExtUtils::MM_QNX'=>'7.04_02','ExtUtils::MM_UWIN'=>'7.04_02','ExtUtils::MM_Unix'=>'7.04_02','ExtUtils::MM_VMS'=>'7.04_02','ExtUtils::MM_VOS'=>'7.04_02','ExtUtils::MM_Win32'=>'7.04_02','ExtUtils::MM_Win95'=>'7.04_02','ExtUtils::MY'=>'7.04_02','ExtUtils::MakeMaker'=>'7.04_02','ExtUtils::MakeMaker::Config'=>'7.04_02','ExtUtils::Mkbootstrap'=>'7.04_02','ExtUtils::Mksymlists'=>'7.04_02','ExtUtils::testlib'=>'7.04_02','File::Fetch'=>'0.48_01','File::Spec'=>'3.56_02','File::Spec::Cygwin'=>'3.56_02','File::Spec::Epoc'=>'3.56_02','File::Spec::Functions'=>'3.56_02','File::Spec::Mac'=>'3.56_02','File::Spec::OS2'=>'3.56_02','File::Spec::Unix'=>'3.56_02','File::Spec::VMS'=>'3.56_02','File::Spec::Win32'=>'3.56_02','HTTP::Tiny'=>'0.054_01','I18N::LangTags::Detect'=>'1.05_01','IO'=>'1.35_01','IO::Compress::Adapter::Bzip2'=>'2.068_001','IO::Compress::Adapter::Deflate'=>'2.068_001','IO::Compress::Adapter::Identity'=>'2.068_001','IO::Compress::Base'=>'2.068_001','IO::Compress::Base::Common'=>'2.068_001','IO::Compress::Bzip2'=>'2.068_001','IO::Compress::Deflate'=>'2.068_001','IO::Compress::Gzip'=>'2.068_001','IO::Compress::Gzip::Constants'=>'2.068_001','IO::Compress::RawDeflate'=>'2.068_001','IO::Compress::Zip'=>'2.068_001','IO::Compress::Zip::Constants'=>'2.068_001','IO::Compress::Zlib::Constants'=>'2.068_001','IO::Compress::Zlib::Extra'=>'2.068_001','IO::Uncompress::Adapter::Bunzip2'=>'2.068_001','IO::Uncompress::Adapter::Identity'=>'2.068_001','IO::Uncompress::Adapter::Inflate'=>'2.068_001','IO::Uncompress::AnyInflate'=>'2.068_001','IO::Uncompress::AnyUncompress'=>'2.068_001','IO::Uncompress::Base'=>'2.068_001','IO::Uncompress::Bunzip2'=>'2.068_001','IO::Uncompress::Gunzip'=>'2.068_001','IO::Uncompress::Inflate'=>'2.068_001','IO::Uncompress::RawInflate'=>'2.068_001','IO::Uncompress::Unzip'=>'2.068_001','IPC::Cmd'=>'0.92_01','JSON::PP'=>'2.27300_01','Locale::Maketext'=>'1.26_01','Locale::Maketext::Simple'=>'0.21_01','Memoize'=>'1.03_01','Module::CoreList'=>'5.20170114_22','Module::CoreList::TieHashDelta'=>'5.20170114_22','Module::CoreList::Utils'=>'5.20170114_22','Module::Metadata::corpus::BOMTest::UTF16BE'=>undef,'Module::Metadata::corpus::BOMTest::UTF16LE'=>undef,'Module::Metadata::corpus::BOMTest::UTF8'=>'1','Net::Cmd'=>'3.05_01','Net::Config'=>'3.05_01','Net::Domain'=>'3.05_01','Net::FTP'=>'3.05_01','Net::FTP::A'=>'3.05_01','Net::FTP::E'=>'3.05_01','Net::FTP::I'=>'3.05_01','Net::FTP::L'=>'3.05_01','Net::FTP::dataconn'=>'3.05_01','Net::NNTP'=>'3.05_01','Net::Netrc'=>'3.05_01','Net::POP3'=>'3.05_01','Net::Ping'=>'2.43_01','Net::SMTP'=>'3.05_01','Net::Time'=>'3.05_01','Parse::CPAN::Meta'=>'1.4414_001','Pod::Html'=>'1.2201','Pod::Perldoc'=>'3.25_01','Storable'=>'2.53_02','Sys::Syslog'=>'0.33_01','TAP::Base'=>'3.35_01','TAP::Formatter::Base'=>'3.35_01','TAP::Formatter::Color'=>'3.35_01','TAP::Formatter::Console'=>'3.35_01','TAP::Formatter::Console::ParallelSession'=>'3.35_01','TAP::Formatter::Console::Session'=>'3.35_01','TAP::Formatter::File'=>'3.35_01','TAP::Formatter::File::Session'=>'3.35_01','TAP::Formatter::Session'=>'3.35_01','TAP::Harness'=>'3.35_01','TAP::Harness::Env'=>'3.35_01','TAP::Object'=>'3.35_01','TAP::Parser'=>'3.35_01','TAP::Parser::Aggregator'=>'3.35_01','TAP::Parser::Grammar'=>'3.35_01','TAP::Parser::Iterator'=>'3.35_01','TAP::Parser::Iterator::Array'=>'3.35_01','TAP::Parser::Iterator::Process'=>'3.35_01','TAP::Parser::Iterator::Stream'=>'3.35_01','TAP::Parser::IteratorFactory'=>'3.35_01','TAP::Parser::Multiplexer'=>'3.35_01','TAP::Parser::Result'=>'3.35_01','TAP::Parser::Result::Bailout'=>'3.35_01','TAP::Parser::Result::Comment'=>'3.35_01','TAP::Parser::Result::Plan'=>'3.35_01','TAP::Parser::Result::Pragma'=>'3.35_01','TAP::Parser::Result::Test'=>'3.35_01','TAP::Parser::Result::Unknown'=>'3.35_01','TAP::Parser::Result::Version'=>'3.35_01','TAP::Parser::Result::YAML'=>'3.35_01','TAP::Parser::ResultFactory'=>'3.35_01','TAP::Parser::Scheduler'=>'3.35_01','TAP::Parser::Scheduler::Job'=>'3.35_01','TAP::Parser::Scheduler::Spinner'=>'3.35_01','TAP::Parser::Source'=>'3.35_01','TAP::Parser::SourceHandler'=>'3.35_01','TAP::Parser::SourceHandler::Executable'=>'3.35_01','TAP::Parser::SourceHandler::File'=>'3.35_01','TAP::Parser::SourceHandler::Handle'=>'3.35_01','TAP::Parser::SourceHandler::Perl'=>'3.35_01','TAP::Parser::SourceHandler::RawTAP'=>'3.35_01','TAP::Parser::YAMLish::Reader'=>'3.35_01','TAP::Parser::YAMLish::Writer'=>'3.35_01','Test'=>'1.26_01','Test::Harness'=>'3.35_01','XSLoader'=>'0.20_01','bigint'=>'0.39_01','bignum'=>'0.39_01','bigrat'=>'0.39_01',},removed=>{}},5.024001=>{delta_from=>5.024000,changed=>{'App::Cpan'=>'1.63_01','App::Prove'=>'3.36_01','App::Prove::State'=>'3.36_01','App::Prove::State::Result'=>'3.36_01','App::Prove::State::Result::Test'=>'3.36_01','Archive::Tar'=>'2.04_01','Archive::Tar::Constant'=>'2.04_01','Archive::Tar::File'=>'2.04_01','B::Op_private'=>'5.024001','CPAN'=>'2.11_01','Compress::Zlib'=>'2.069_001','Config'=>'5.024001','Cwd'=>'3.63_01','Digest'=>'1.17_01','Digest::SHA'=>'5.95_01','Encode'=>'2.80_01','ExtUtils::Command'=>'7.10_02','ExtUtils::Command::MM'=>'7.10_02','ExtUtils::Liblist'=>'7.10_02','ExtUtils::Liblist::Kid'=>'7.10_02','ExtUtils::MM'=>'7.10_02','ExtUtils::MM_AIX'=>'7.10_02','ExtUtils::MM_Any'=>'7.10_02','ExtUtils::MM_BeOS'=>'7.10_02','ExtUtils::MM_Cygwin'=>'7.10_02','ExtUtils::MM_DOS'=>'7.10_02','ExtUtils::MM_Darwin'=>'7.10_02','ExtUtils::MM_MacOS'=>'7.10_02','ExtUtils::MM_NW5'=>'7.10_02','ExtUtils::MM_OS2'=>'7.10_02','ExtUtils::MM_QNX'=>'7.10_02','ExtUtils::MM_UWIN'=>'7.10_02','ExtUtils::MM_Unix'=>'7.10_02','ExtUtils::MM_VMS'=>'7.10_02','ExtUtils::MM_VOS'=>'7.10_02','ExtUtils::MM_Win32'=>'7.10_02','ExtUtils::MM_Win95'=>'7.10_02','ExtUtils::MY'=>'7.10_02','ExtUtils::MakeMaker'=>'7.10_02','ExtUtils::MakeMaker::Config'=>'7.10_02','ExtUtils::Mkbootstrap'=>'7.10_02','ExtUtils::Mksymlists'=>'7.10_02','ExtUtils::testlib'=>'7.10_02','File::Fetch'=>'0.48_01','File::Spec'=>'3.63_01','File::Spec::Cygwin'=>'3.63_01','File::Spec::Epoc'=>'3.63_01','File::Spec::Functions'=>'3.63_01','File::Spec::Mac'=>'3.63_01','File::Spec::OS2'=>'3.63_01','File::Spec::Unix'=>'3.63_01','File::Spec::VMS'=>'3.63_01','File::Spec::Win32'=>'3.63_01','HTTP::Tiny'=>'0.056_001','I18N::LangTags::Detect'=>'1.05_01','IO'=>'1.36_01','IO::Compress::Adapter::Bzip2'=>'2.069_001','IO::Compress::Adapter::Deflate'=>'2.069_001','IO::Compress::Adapter::Identity'=>'2.069_001','IO::Compress::Base'=>'2.069_001','IO::Compress::Base::Common'=>'2.069_001','IO::Compress::Bzip2'=>'2.069_001','IO::Compress::Deflate'=>'2.069_001','IO::Compress::Gzip'=>'2.069_001','IO::Compress::Gzip::Constants'=>'2.069_001','IO::Compress::RawDeflate'=>'2.069_001','IO::Compress::Zip'=>'2.069_001','IO::Compress::Zip::Constants'=>'2.069_001','IO::Compress::Zlib::Constants'=>'2.069_001','IO::Compress::Zlib::Extra'=>'2.069_001','IO::Uncompress::Adapter::Bunzip2'=>'2.069_001','IO::Uncompress::Adapter::Identity'=>'2.069_001','IO::Uncompress::Adapter::Inflate'=>'2.069_001','IO::Uncompress::AnyInflate'=>'2.069_001','IO::Uncompress::AnyUncompress'=>'2.069_001','IO::Uncompress::Base'=>'2.069_001','IO::Uncompress::Bunzip2'=>'2.069_001','IO::Uncompress::Gunzip'=>'2.069_001','IO::Uncompress::Inflate'=>'2.069_001','IO::Uncompress::RawInflate'=>'2.069_001','IO::Uncompress::Unzip'=>'2.069_001','IPC::Cmd'=>'0.92_01','JSON::PP'=>'2.27300_01','Locale::Maketext'=>'1.26_01','Locale::Maketext::Simple'=>'0.21_01','Math::BigFloat::Trace'=>'0.42_01','Math::BigInt::Trace'=>'0.42_01','Memoize'=>'1.03_01','Module::CoreList'=>'5.20170114_24','Module::CoreList::TieHashDelta'=>'5.20170114_24','Module::CoreList::Utils'=>'5.20170114_24','Module::Metadata::corpus::BOMTest::UTF16BE'=>undef,'Module::Metadata::corpus::BOMTest::UTF16LE'=>undef,'Module::Metadata::corpus::BOMTest::UTF8'=>'1','Net::Cmd'=>'3.08_01','Net::Config'=>'3.08_01','Net::Domain'=>'3.08_01','Net::FTP'=>'3.08_01','Net::FTP::A'=>'3.08_01','Net::FTP::E'=>'3.08_01','Net::FTP::I'=>'3.08_01','Net::FTP::L'=>'3.08_01','Net::FTP::dataconn'=>'3.08_01','Net::NNTP'=>'3.08_01','Net::Netrc'=>'3.08_01','Net::POP3'=>'3.08_01','Net::Ping'=>'2.43_01','Net::SMTP'=>'3.08_01','Net::Time'=>'3.08_01','Parse::CPAN::Meta'=>'1.4417_001','Pod::Html'=>'1.2201','Pod::Perldoc'=>'3.25_03','Storable'=>'2.56_01','Sys::Syslog'=>'0.33_01','TAP::Base'=>'3.36_01','TAP::Formatter::Base'=>'3.36_01','TAP::Formatter::Color'=>'3.36_01','TAP::Formatter::Console'=>'3.36_01','TAP::Formatter::Console::ParallelSession'=>'3.36_01','TAP::Formatter::Console::Session'=>'3.36_01','TAP::Formatter::File'=>'3.36_01','TAP::Formatter::File::Session'=>'3.36_01','TAP::Formatter::Session'=>'3.36_01','TAP::Harness'=>'3.36_01','TAP::Harness::Env'=>'3.36_01','TAP::Object'=>'3.36_01','TAP::Parser'=>'3.36_01','TAP::Parser::Aggregator'=>'3.36_01','TAP::Parser::Grammar'=>'3.36_01','TAP::Parser::Iterator'=>'3.36_01','TAP::Parser::Iterator::Array'=>'3.36_01','TAP::Parser::Iterator::Process'=>'3.36_01','TAP::Parser::Iterator::Stream'=>'3.36_01','TAP::Parser::IteratorFactory'=>'3.36_01','TAP::Parser::Multiplexer'=>'3.36_01','TAP::Parser::Result'=>'3.36_01','TAP::Parser::Result::Bailout'=>'3.36_01','TAP::Parser::Result::Comment'=>'3.36_01','TAP::Parser::Result::Plan'=>'3.36_01','TAP::Parser::Result::Pragma'=>'3.36_01','TAP::Parser::Result::Test'=>'3.36_01','TAP::Parser::Result::Unknown'=>'3.36_01','TAP::Parser::Result::Version'=>'3.36_01','TAP::Parser::Result::YAML'=>'3.36_01','TAP::Parser::ResultFactory'=>'3.36_01','TAP::Parser::Scheduler'=>'3.36_01','TAP::Parser::Scheduler::Job'=>'3.36_01','TAP::Parser::Scheduler::Spinner'=>'3.36_01','TAP::Parser::Source'=>'3.36_01','TAP::Parser::SourceHandler'=>'3.36_01','TAP::Parser::SourceHandler::Executable'=>'3.36_01','TAP::Parser::SourceHandler::File'=>'3.36_01','TAP::Parser::SourceHandler::Handle'=>'3.36_01','TAP::Parser::SourceHandler::Perl'=>'3.36_01','TAP::Parser::SourceHandler::RawTAP'=>'3.36_01','TAP::Parser::YAMLish::Reader'=>'3.36_01','TAP::Parser::YAMLish::Writer'=>'3.36_01','Test'=>'1.28_01','Test::Harness'=>'3.36_01','XSLoader'=>'0.22','bigint'=>'0.42_01','bignum'=>'0.42_01','bigrat'=>'0.42_01',},removed=>{}},5.025009=>{delta_from=>5.025008,changed=>{'App::Cpan'=>'1.66','B::Deparse'=>'1.40','B::Op_private'=>'5.025009','B::Terse'=>'1.07','B::Xref'=>'1.06','CPAN'=>'2.16','CPAN::Bundle'=>'5.5002','CPAN::Distribution'=>'2.16','CPAN::Exception::RecursiveDependency'=>'5.5001','CPAN::FTP'=>'5.5008','CPAN::FirstTime'=>'5.5310','CPAN::HandleConfig'=>'5.5008','CPAN::Module'=>'5.5003','Compress::Raw::Bzip2'=>'2.070','Compress::Raw::Zlib'=>'2.070','Config'=>'5.025009','DB_File'=>'1.840','Data::Dumper'=>'2.167','Devel::SelfStubber'=>'1.06','DynaLoader'=>'1.41','Errno'=>'1.28','ExtUtils::Embed'=>'1.34','File::Glob'=>'1.28','I18N::LangTags'=>'0.42','Module::CoreList'=>'5.20170120','Module::CoreList::TieHashDelta'=>'5.20170120','Module::CoreList::Utils'=>'5.20170120','OS2::Process'=>'1.12','PerlIO::scalar'=>'0.26','Pod::Html'=>'1.2202','Storable'=>'2.61','Symbol'=>'1.08','Term::ReadLine'=>'1.16','Test'=>'1.30','Unicode::UCD'=>'0.68','VMS::DCLsym'=>'1.08','XS::APItest'=>'0.88','XSLoader'=>'0.26','attributes'=>'0.29','diagnostics'=>'1.36','feature'=>'1.46','lib'=>'0.64','overload'=>'1.28','re'=>'0.34','threads'=>'2.12','threads::shared'=>'1.54',},removed=>{}},5.025010=>{delta_from=>5.025009,changed=>{'B'=>'1.68','B::Op_private'=>'5.025010','CPAN'=>'2.17','CPAN::Distribution'=>'2.17','Config'=>'5.02501','Getopt::Std'=>'1.12','Module::CoreList'=>'5.20170220','Module::CoreList::TieHashDelta'=>'5.20170220','Module::CoreList::Utils'=>'5.20170220','PerlIO'=>'1.10','Storable'=>'2.62','Thread::Queue'=>'3.12','feature'=>'1.47','open'=>'1.11','threads'=>'2.13',},removed=>{}},5.025011=>{delta_from=>5.025010,changed=>{'App::Prove'=>'3.38','App::Prove::State'=>'3.38','App::Prove::State::Result'=>'3.38','App::Prove::State::Result::Test'=>'3.38','B::Op_private'=>'5.025011','Compress::Raw::Bzip2'=>'2.074','Compress::Raw::Zlib'=>'2.074','Compress::Zlib'=>'2.074','Config'=>'5.025011','Config::Perl::V'=>'0.28','Cwd'=>'3.67','ExtUtils::ParseXS'=>'3.34','ExtUtils::ParseXS::Constants'=>'3.34','ExtUtils::ParseXS::CountLines'=>'3.34','ExtUtils::ParseXS::Eval'=>'3.34','ExtUtils::Typemaps'=>'3.34','ExtUtils::Typemaps::Cmd'=>'3.34','ExtUtils::Typemaps::InputMap'=>'3.34','ExtUtils::Typemaps::OutputMap'=>'3.34','ExtUtils::Typemaps::Type'=>'3.34','File::Spec'=>'3.67','File::Spec::AmigaOS'=>'3.67','File::Spec::Cygwin'=>'3.67','File::Spec::Epoc'=>'3.67','File::Spec::Functions'=>'3.67','File::Spec::Mac'=>'3.67','File::Spec::OS2'=>'3.67','File::Spec::Unix'=>'3.67','File::Spec::VMS'=>'3.67','File::Spec::Win32'=>'3.67','IO::Compress::Adapter::Bzip2'=>'2.074','IO::Compress::Adapter::Deflate'=>'2.074','IO::Compress::Adapter::Identity'=>'2.074','IO::Compress::Base'=>'2.074','IO::Compress::Base::Common'=>'2.074','IO::Compress::Bzip2'=>'2.074','IO::Compress::Deflate'=>'2.074','IO::Compress::Gzip'=>'2.074','IO::Compress::Gzip::Constants'=>'2.074','IO::Compress::RawDeflate'=>'2.074','IO::Compress::Zip'=>'2.074','IO::Compress::Zip::Constants'=>'2.074','IO::Compress::Zlib::Constants'=>'2.074','IO::Compress::Zlib::Extra'=>'2.074','IO::Uncompress::Adapter::Bunzip2'=>'2.074','IO::Uncompress::Adapter::Identity'=>'2.074','IO::Uncompress::Adapter::Inflate'=>'2.074','IO::Uncompress::AnyInflate'=>'2.074','IO::Uncompress::AnyUncompress'=>'2.074','IO::Uncompress::Base'=>'2.074','IO::Uncompress::Bunzip2'=>'2.074','IO::Uncompress::Gunzip'=>'2.074','IO::Uncompress::Inflate'=>'2.074','IO::Uncompress::RawInflate'=>'2.074','IO::Uncompress::Unzip'=>'2.074','Module::CoreList'=>'5.20170320','Module::CoreList::TieHashDelta'=>'5.20170230','Module::CoreList::Utils'=>'5.20170320','Pod::Perldoc'=>'3.28','Pod::Perldoc::BaseTo'=>'3.28','Pod::Perldoc::GetOptsOO'=>'3.28','Pod::Perldoc::ToANSI'=>'3.28','Pod::Perldoc::ToChecker'=>'3.28','Pod::Perldoc::ToMan'=>'3.28','Pod::Perldoc::ToNroff'=>'3.28','Pod::Perldoc::ToPod'=>'3.28','Pod::Perldoc::ToRtf'=>'3.28','Pod::Perldoc::ToTerm'=>'3.28','Pod::Perldoc::ToText'=>'3.28','Pod::Perldoc::ToTk'=>'3.28','Pod::Perldoc::ToXml'=>'3.28','TAP::Base'=>'3.38','TAP::Formatter::Base'=>'3.38','TAP::Formatter::Color'=>'3.38','TAP::Formatter::Console'=>'3.38','TAP::Formatter::Console::ParallelSession'=>'3.38','TAP::Formatter::Console::Session'=>'3.38','TAP::Formatter::File'=>'3.38','TAP::Formatter::File::Session'=>'3.38','TAP::Formatter::Session'=>'3.38','TAP::Harness'=>'3.38','TAP::Harness::Env'=>'3.38','TAP::Object'=>'3.38','TAP::Parser'=>'3.38','TAP::Parser::Aggregator'=>'3.38','TAP::Parser::Grammar'=>'3.38','TAP::Parser::Iterator'=>'3.38','TAP::Parser::Iterator::Array'=>'3.38','TAP::Parser::Iterator::Process'=>'3.38','TAP::Parser::Iterator::Stream'=>'3.38','TAP::Parser::IteratorFactory'=>'3.38','TAP::Parser::Multiplexer'=>'3.38','TAP::Parser::Result'=>'3.38','TAP::Parser::Result::Bailout'=>'3.38','TAP::Parser::Result::Comment'=>'3.38','TAP::Parser::Result::Plan'=>'3.38','TAP::Parser::Result::Pragma'=>'3.38','TAP::Parser::Result::Test'=>'3.38','TAP::Parser::Result::Unknown'=>'3.38','TAP::Parser::Result::Version'=>'3.38','TAP::Parser::Result::YAML'=>'3.38','TAP::Parser::ResultFactory'=>'3.38','TAP::Parser::Scheduler'=>'3.38','TAP::Parser::Scheduler::Job'=>'3.38','TAP::Parser::Scheduler::Spinner'=>'3.38','TAP::Parser::Source'=>'3.38','TAP::Parser::SourceHandler'=>'3.38','TAP::Parser::SourceHandler::Executable'=>'3.38','TAP::Parser::SourceHandler::File'=>'3.38','TAP::Parser::SourceHandler::Handle'=>'3.38','TAP::Parser::SourceHandler::Perl'=>'3.38','TAP::Parser::SourceHandler::RawTAP'=>'3.38','TAP::Parser::YAMLish::Reader'=>'3.38','TAP::Parser::YAMLish::Writer'=>'3.38','Test::Harness'=>'3.38','VMS::Stdio'=>'2.41','threads'=>'2.15','threads::shared'=>'1.55',},removed=>{}},5.025012=>{delta_from=>5.025011,changed=>{'B::Op_private'=>'5.025012','CPAN'=>'2.18','CPAN::Bundle'=>'5.5003','CPAN::Distribution'=>'2.18','Config'=>'5.025012','DynaLoader'=>'1.42','Module::CoreList'=>'5.20170420','Module::CoreList::TieHashDelta'=>'5.20170420','Module::CoreList::Utils'=>'5.20170420','Safe'=>'2.40','XSLoader'=>'0.27','base'=>'2.25','threads::shared'=>'1.56',},removed=>{}},5.026000=>{delta_from=>5.025012,changed=>{'B::Op_private'=>'5.026000','Config'=>'5.026','Module::CoreList'=>'5.20170530','Module::CoreList::TieHashDelta'=>'5.20170530','Module::CoreList::Utils'=>'5.20170530',},removed=>{}},5.027000=>{delta_from=>5.026000,changed=>{'Attribute::Handlers'=>'1.00','B::Concise'=>'1.000','B::Deparse'=>'1.41','B::Op_private'=>'5.027000','Config'=>'5.027','Module::CoreList'=>'5.20170531','Module::CoreList::TieHashDelta'=>'5.20170531','Module::CoreList::Utils'=>'5.20170531','O'=>'1.02','attributes'=>'0.3','feature'=>'1.48',},removed=>{}},5.027001=>{delta_from=>5.027,changed=>{'App::Prove'=>'3.39','App::Prove::State'=>'3.39','App::Prove::State::Result'=>'3.39','App::Prove::State::Result::Test'=>'3.39','Archive::Tar'=>'2.26','Archive::Tar::Constant'=>'2.26','Archive::Tar::File'=>'2.26','B::Op_private'=>'5.027001','B::Terse'=>'1.08','Config'=>'5.027001','Devel::PPPort'=>'3.36','DirHandle'=>'1.05','ExtUtils::Command'=>'7.30','ExtUtils::Command::MM'=>'7.30','ExtUtils::Install'=>'2.14','ExtUtils::Installed'=>'2.14','ExtUtils::Liblist'=>'7.30','ExtUtils::Liblist::Kid'=>'7.30','ExtUtils::MM'=>'7.30','ExtUtils::MM_AIX'=>'7.30','ExtUtils::MM_Any'=>'7.30','ExtUtils::MM_BeOS'=>'7.30','ExtUtils::MM_Cygwin'=>'7.30','ExtUtils::MM_DOS'=>'7.30','ExtUtils::MM_Darwin'=>'7.30','ExtUtils::MM_MacOS'=>'7.30','ExtUtils::MM_NW5'=>'7.30','ExtUtils::MM_OS2'=>'7.30','ExtUtils::MM_QNX'=>'7.30','ExtUtils::MM_UWIN'=>'7.30','ExtUtils::MM_Unix'=>'7.30','ExtUtils::MM_VMS'=>'7.30','ExtUtils::MM_VOS'=>'7.30','ExtUtils::MM_Win32'=>'7.30','ExtUtils::MM_Win95'=>'7.30','ExtUtils::MY'=>'7.30','ExtUtils::MakeMaker'=>'7.30','ExtUtils::MakeMaker::Config'=>'7.30','ExtUtils::MakeMaker::Locale'=>'7.30','ExtUtils::MakeMaker::version'=>'7.30','ExtUtils::MakeMaker::version::regex'=>'7.30','ExtUtils::Mkbootstrap'=>'7.30','ExtUtils::Mksymlists'=>'7.30','ExtUtils::Packlist'=>'2.14','ExtUtils::testlib'=>'7.30','File::Path'=>'2.14','Filter::Util::Call'=>'1.57','GDBM_File'=>'1.16','Getopt::Long'=>'2.5','IO::Socket::IP'=>'0.39','IPC::Cmd'=>'0.98','JSON::PP'=>'2.94','JSON::PP::Boolean'=>'2.94','Locale::Codes'=>'3.52','Locale::Codes::Constants'=>'3.52','Locale::Codes::Country'=>'3.52','Locale::Codes::Country_Codes'=>'3.52','Locale::Codes::Country_Retired'=>'3.52','Locale::Codes::Currency'=>'3.52','Locale::Codes::Currency_Codes'=>'3.52','Locale::Codes::Currency_Retired'=>'3.52','Locale::Codes::LangExt'=>'3.52','Locale::Codes::LangExt_Codes'=>'3.52','Locale::Codes::LangExt_Retired'=>'3.52','Locale::Codes::LangFam'=>'3.52','Locale::Codes::LangFam_Codes'=>'3.52','Locale::Codes::LangFam_Retired'=>'3.52','Locale::Codes::LangVar'=>'3.52','Locale::Codes::LangVar_Codes'=>'3.52','Locale::Codes::LangVar_Retired'=>'3.52','Locale::Codes::Language'=>'3.52','Locale::Codes::Language_Codes'=>'3.52','Locale::Codes::Language_Retired'=>'3.52','Locale::Codes::Script'=>'3.52','Locale::Codes::Script_Codes'=>'3.52','Locale::Codes::Script_Retired'=>'3.52','Locale::Country'=>'3.52','Locale::Currency'=>'3.52','Locale::Language'=>'3.52','Locale::Script'=>'3.52','Module::CoreList'=>'5.20170621','Module::CoreList::TieHashDelta'=>'5.20170621','Module::CoreList::Utils'=>'5.20170621','PerlIO::scalar'=>'0.27','PerlIO::via'=>'0.17','Storable'=>'2.63','TAP::Base'=>'3.39','TAP::Formatter::Base'=>'3.39','TAP::Formatter::Color'=>'3.39','TAP::Formatter::Console'=>'3.39','TAP::Formatter::Console::ParallelSession'=>'3.39','TAP::Formatter::Console::Session'=>'3.39','TAP::Formatter::File'=>'3.39','TAP::Formatter::File::Session'=>'3.39','TAP::Formatter::Session'=>'3.39','TAP::Harness'=>'3.39','TAP::Harness::Env'=>'3.39','TAP::Object'=>'3.39','TAP::Parser'=>'3.39','TAP::Parser::Aggregator'=>'3.39','TAP::Parser::Grammar'=>'3.39','TAP::Parser::Iterator'=>'3.39','TAP::Parser::Iterator::Array'=>'3.39','TAP::Parser::Iterator::Process'=>'3.39','TAP::Parser::Iterator::Stream'=>'3.39','TAP::Parser::IteratorFactory'=>'3.39','TAP::Parser::Multiplexer'=>'3.39','TAP::Parser::Result'=>'3.39','TAP::Parser::Result::Bailout'=>'3.39','TAP::Parser::Result::Comment'=>'3.39','TAP::Parser::Result::Plan'=>'3.39','TAP::Parser::Result::Pragma'=>'3.39','TAP::Parser::Result::Test'=>'3.39','TAP::Parser::Result::Unknown'=>'3.39','TAP::Parser::Result::Version'=>'3.39','TAP::Parser::Result::YAML'=>'3.39','TAP::Parser::ResultFactory'=>'3.39','TAP::Parser::Scheduler'=>'3.39','TAP::Parser::Scheduler::Job'=>'3.39','TAP::Parser::Scheduler::Spinner'=>'3.39','TAP::Parser::Source'=>'3.39','TAP::Parser::SourceHandler'=>'3.39','TAP::Parser::SourceHandler::Executable'=>'3.39','TAP::Parser::SourceHandler::File'=>'3.39','TAP::Parser::SourceHandler::Handle'=>'3.39','TAP::Parser::SourceHandler::Perl'=>'3.39','TAP::Parser::SourceHandler::RawTAP'=>'3.39','TAP::Parser::YAMLish::Reader'=>'3.39','TAP::Parser::YAMLish::Writer'=>'3.39','Test::Harness'=>'3.39','XS::APItest'=>'0.89','_charnames'=>'1.45','charnames'=>'1.45','if'=>'0.0607','mro'=>'1.21','threads'=>'2.16','threads::shared'=>'1.57','version'=>'0.9918','version::regex'=>'0.9918',},removed=>{}},5.022004=>{delta_from=>5.022003,changed=>{'B::Op_private'=>'5.022004','Config'=>'5.022004','Module::CoreList'=>'5.20170715_22','Module::CoreList::TieHashDelta'=>'5.20170715_22','Module::CoreList::Utils'=>'5.20170715_22','base'=>'2.22_01',},removed=>{}},5.024002=>{delta_from=>5.024001,changed=>{'B::Op_private'=>'5.024002','Config'=>'5.024002','Module::CoreList'=>'5.20170715_24','Module::CoreList::TieHashDelta'=>'5.20170715_24','Module::CoreList::Utils'=>'5.20170715_24','base'=>'2.23_01',},removed=>{}},5.027002=>{delta_from=>5.027001,changed=>{'B::Op_private'=>'5.027002','Carp'=>'1.43','Carp::Heavy'=>'1.43','Config'=>'5.027002','Cwd'=>'3.68','Encode'=>'2.92','Encode::Alias'=>'2.23','Encode::CN::HZ'=>'2.09','Encode::Encoding'=>'2.08','Encode::GSM0338'=>'2.07','Encode::Guess'=>'2.07','Encode::JP::JIS7'=>'2.07','Encode::KR::2022_KR'=>'2.04','Encode::MIME::Header'=>'2.27','Encode::MIME::Header::ISO_2022_JP'=>'1.09','Encode::Unicode'=>'2.16','Encode::Unicode::UTF7'=>'2.10','ExtUtils::CBuilder'=>'0.280228','ExtUtils::CBuilder::Base'=>'0.280228','ExtUtils::CBuilder::Platform::Unix'=>'0.280228','ExtUtils::CBuilder::Platform::VMS'=>'0.280228','ExtUtils::CBuilder::Platform::Windows'=>'0.280228','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280228','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280228','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280228','ExtUtils::CBuilder::Platform::aix'=>'0.280228','ExtUtils::CBuilder::Platform::android'=>'0.280228','ExtUtils::CBuilder::Platform::cygwin'=>'0.280228','ExtUtils::CBuilder::Platform::darwin'=>'0.280228','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280228','ExtUtils::CBuilder::Platform::os2'=>'0.280228','File::Glob'=>'1.29','File::Spec'=>'3.68','File::Spec::AmigaOS'=>'3.68','File::Spec::Cygwin'=>'3.68','File::Spec::Epoc'=>'3.68','File::Spec::Functions'=>'3.68','File::Spec::Mac'=>'3.68','File::Spec::OS2'=>'3.68','File::Spec::Unix'=>'3.68','File::Spec::VMS'=>'3.68','File::Spec::Win32'=>'3.68','List::Util'=>'1.48','List::Util::XS'=>'1.48','Math::BigRat'=>'0.2613','Module::CoreList'=>'5.20170720','Module::CoreList::TieHashDelta'=>'5.20170720','Module::CoreList::Utils'=>'5.20170720','Opcode'=>'1.40','POSIX'=>'1.77','PerlIO::scalar'=>'0.29','Scalar::Util'=>'1.48','Sub::Util'=>'1.48','Time::HiRes'=>'1.9743','Time::Piece'=>'1.3201','Time::Seconds'=>'1.3201','Unicode'=>'10.0.0','XS::APItest'=>'0.90','arybase'=>'0.13','encoding'=>'2.20','feature'=>'1.49','re'=>'0.35',},removed=>{}},5.027003=>{delta_from=>5.027002,changed=>{'B'=>'1.69','B::Concise'=>'1.001','B::Debug'=>'1.25','B::Deparse'=>'1.42','B::Op_private'=>'5.027003','Config'=>'5.027003','Data::Dumper'=>'2.167_02','Devel::Peek'=>'1.27','ExtUtils::Constant'=>'0.24','ExtUtils::Constant::Base'=>'0.06','ExtUtils::Constant::ProxySubs'=>'0.09','ExtUtils::Constant::Utils'=>'0.04','ExtUtils::ParseXS'=>'3.35','ExtUtils::ParseXS::Constants'=>'3.35','ExtUtils::ParseXS::CountLines'=>'3.35','ExtUtils::ParseXS::Eval'=>'3.35','ExtUtils::ParseXS::Utilities'=>'3.35','ExtUtils::Typemaps'=>'3.35','ExtUtils::Typemaps::Cmd'=>'3.35','ExtUtils::Typemaps::InputMap'=>'3.35','ExtUtils::Typemaps::OutputMap'=>'3.35','ExtUtils::Typemaps::Type'=>'3.35','Filter::Simple'=>'0.94','Module::CoreList'=>'5.20170821','Module::CoreList::TieHashDelta'=>'5.20170821','Module::CoreList::Utils'=>'5.20170821','SelfLoader'=>'1.24','Storable'=>'2.64','XS::APItest'=>'0.91','base'=>'2.26','threads'=>'2.17','utf8'=>'1.20',},removed=>{}},5.027004=>{delta_from=>5.027003,changed=>{'B::Op_private'=>'5.027004','Config'=>'5.027004','File::Glob'=>'1.30','I18N::Langinfo'=>'0.14','Module::CoreList'=>'5.20170920','Module::CoreList::TieHashDelta'=>'5.20170920','Module::CoreList::Utils'=>'5.20170920','Term::ReadLine'=>'1.17','VMS::Stdio'=>'2.42','XS::APItest'=>'0.92','attributes'=>'0.31','sort'=>'2.03','threads'=>'2.18',},removed=>{}},5.024003=>{delta_from=>5.024002,changed=>{'B::Op_private'=>'5.024003','Config'=>'5.024003','Module::CoreList'=>'5.20170922_24','Module::CoreList::TieHashDelta'=>'5.20170922_24','Module::CoreList::Utils'=>'5.20170922_24','POSIX'=>'1.65_01','Time::HiRes'=>'1.9741',},removed=>{}},5.026001=>{delta_from=>5.026000,changed=>{'B::Op_private'=>'5.026001','Config'=>'5.026001','Module::CoreList'=>'5.20170922_26','Module::CoreList::TieHashDelta'=>'5.20170922_26','Module::CoreList::Utils'=>'5.20170922_26','_charnames'=>'1.45','base'=>'2.26','charnames'=>'1.45',},removed=>{}},5.027005=>{delta_from=>5.027004,changed=>{'B'=>'1.70','B::Concise'=>'1.002','B::Deparse'=>'1.43','B::Op_private'=>'5.027005','B::Xref'=>'1.07','Config'=>'5.027005','Config::Perl::V'=>'0.29','Digest::SHA'=>'5.98','Encode'=>'2.93','Encode::CN::HZ'=>'2.10','Encode::JP::JIS7'=>'2.08','Encode::MIME::Header'=>'2.28','Encode::MIME::Name'=>'1.03','File::Fetch'=>'0.54','File::Path'=>'2.15','List::Util'=>'1.49','List::Util::XS'=>'1.49','Locale::Codes'=>'3.54','Locale::Codes::Constants'=>'3.54','Locale::Codes::Country'=>'3.54','Locale::Codes::Country_Codes'=>'3.54','Locale::Codes::Country_Retired'=>'3.54','Locale::Codes::Currency'=>'3.54','Locale::Codes::Currency_Codes'=>'3.54','Locale::Codes::Currency_Retired'=>'3.54','Locale::Codes::LangExt'=>'3.54','Locale::Codes::LangExt_Codes'=>'3.54','Locale::Codes::LangExt_Retired'=>'3.54','Locale::Codes::LangFam'=>'3.54','Locale::Codes::LangFam_Codes'=>'3.54','Locale::Codes::LangFam_Retired'=>'3.54','Locale::Codes::LangVar'=>'3.54','Locale::Codes::LangVar_Codes'=>'3.54','Locale::Codes::LangVar_Retired'=>'3.54','Locale::Codes::Language'=>'3.54','Locale::Codes::Language_Codes'=>'3.54','Locale::Codes::Language_Retired'=>'3.54','Locale::Codes::Script'=>'3.54','Locale::Codes::Script_Codes'=>'3.54','Locale::Codes::Script_Retired'=>'3.54','Locale::Country'=>'3.54','Locale::Currency'=>'3.54','Locale::Language'=>'3.54','Locale::Script'=>'3.54','Math::BigFloat'=>'1.999811','Math::BigInt'=>'1.999811','Math::BigInt::Calc'=>'1.999811','Math::BigInt::CalcEmu'=>'1.999811','Math::BigInt::FastCalc'=>'0.5006','Math::BigInt::Lib'=>'1.999811','Module::CoreList'=>'5.20171020','Module::CoreList::TieHashDelta'=>'5.20171020','Module::CoreList::Utils'=>'5.20171020','NEXT'=>'0.67_01','POSIX'=>'1.78','Pod::Perldoc'=>'3.2801','Scalar::Util'=>'1.49','Sub::Util'=>'1.49','Sys::Hostname'=>'1.21','Test2'=>'1.302103','Test2::API'=>'1.302103','Test2::API::Breakage'=>'1.302103','Test2::API::Context'=>'1.302103','Test2::API::Instance'=>'1.302103','Test2::API::Stack'=>'1.302103','Test2::Event'=>'1.302103','Test2::Event::Bail'=>'1.302103','Test2::Event::Diag'=>'1.302103','Test2::Event::Encoding'=>'1.302103','Test2::Event::Exception'=>'1.302103','Test2::Event::Fail'=>'1.302103','Test2::Event::Generic'=>'1.302103','Test2::Event::Note'=>'1.302103','Test2::Event::Ok'=>'1.302103','Test2::Event::Pass'=>'1.302103','Test2::Event::Plan'=>'1.302103','Test2::Event::Skip'=>'1.302103','Test2::Event::Subtest'=>'1.302103','Test2::Event::TAP::Version'=>'1.302103','Test2::Event::Waiting'=>'1.302103','Test2::EventFacet'=>'1.302103','Test2::EventFacet::About'=>'1.302103','Test2::EventFacet::Amnesty'=>'1.302103','Test2::EventFacet::Assert'=>'1.302103','Test2::EventFacet::Control'=>'1.302103','Test2::EventFacet::Error'=>'1.302103','Test2::EventFacet::Info'=>'1.302103','Test2::EventFacet::Meta'=>'1.302103','Test2::EventFacet::Parent'=>'1.302103','Test2::EventFacet::Plan'=>'1.302103','Test2::EventFacet::Trace'=>'1.302103','Test2::Formatter'=>'1.302103','Test2::Formatter::TAP'=>'1.302103','Test2::Hub'=>'1.302103','Test2::Hub::Interceptor'=>'1.302103','Test2::Hub::Interceptor::Terminator'=>'1.302103','Test2::Hub::Subtest'=>'1.302103','Test2::IPC'=>'1.302103','Test2::IPC::Driver'=>'1.302103','Test2::IPC::Driver::Files'=>'1.302103','Test2::Tools::Tiny'=>'1.302103','Test2::Util'=>'1.302103','Test2::Util::ExternalMeta'=>'1.302103','Test2::Util::Facets2Legacy'=>'1.302103','Test2::Util::HashBase'=>'0.005','Test2::Util::Trace'=>'1.302103','Test::Builder'=>'1.302103','Test::Builder::Formatter'=>'1.302103','Test::Builder::IO::Scalar'=>'2.114','Test::Builder::Module'=>'1.302103','Test::Builder::Tester'=>'1.302103','Test::Builder::Tester::Color'=>'1.302103','Test::Builder::TodoDiag'=>'1.302103','Test::More'=>'1.302103','Test::Simple'=>'1.302103','Test::Tester'=>'1.302103','Test::Tester::Capture'=>'1.302103','Test::Tester::CaptureRunner'=>'1.302103','Test::Tester::Delegate'=>'1.302103','Test::use::ok'=>'1.302103','Time::HiRes'=>'1.9746','Time::Piece'=>'1.3202','Time::Seconds'=>'1.3202','arybase'=>'0.14','encoding'=>'2.21','ok'=>'1.302103',},removed=>{'Test2::Event::Info'=>1,}},5.027006=>{delta_from=>5.027005,changed=>{'Attribute::Handlers'=>'1.01','B'=>'1.72','B::Concise'=>'1.003','B::Deparse'=>'1.45','B::Op_private'=>'5.027006','Carp'=>'1.44','Carp::Heavy'=>'1.44','Compress::Raw::Zlib'=>'2.075','Config'=>'5.027006','Config::Extensions'=>'0.02','Cwd'=>'3.70','DynaLoader'=>'1.44','ExtUtils::CBuilder'=>'0.280229','ExtUtils::CBuilder::Platform::Unix'=>'0.280229','ExtUtils::CBuilder::Platform::VMS'=>'0.280229','ExtUtils::CBuilder::Platform::Windows'=>'0.280229','ExtUtils::CBuilder::Platform::aix'=>'0.280229','ExtUtils::CBuilder::Platform::android'=>'0.280229','ExtUtils::CBuilder::Platform::cygwin'=>'0.280229','ExtUtils::CBuilder::Platform::darwin'=>'0.280229','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280229','ExtUtils::CBuilder::Platform::os2'=>'0.280229','ExtUtils::Embed'=>'1.35','ExtUtils::Miniperl'=>'1.07','ExtUtils::ParseXS'=>'3.36','ExtUtils::ParseXS::Constants'=>'3.36','ExtUtils::ParseXS::CountLines'=>'3.36','ExtUtils::ParseXS::Eval'=>'3.36','ExtUtils::ParseXS::Utilities'=>'3.36','ExtUtils::Typemaps'=>'3.36','ExtUtils::Typemaps::Cmd'=>'3.36','ExtUtils::Typemaps::InputMap'=>'3.36','ExtUtils::Typemaps::OutputMap'=>'3.36','ExtUtils::Typemaps::Type'=>'3.36','ExtUtils::XSSymSet'=>'1.4','File::Copy'=>'2.33','File::Spec'=>'3.69','File::Spec::AmigaOS'=>'3.69','File::Spec::Cygwin'=>'3.69','File::Spec::Epoc'=>'3.69','File::Spec::Functions'=>'3.69','File::Spec::Mac'=>'3.69','File::Spec::OS2'=>'3.69','File::Spec::Unix'=>'3.69','File::Spec::VMS'=>'3.69','File::Spec::Win32'=>'3.69','File::stat'=>'1.08','FileCache'=>'1.10','Filter::Simple'=>'0.95','Hash::Util::FieldHash'=>'1.20','I18N::LangTags'=>'0.43','I18N::LangTags::Detect'=>'1.07','I18N::LangTags::List'=>'0.40','I18N::Langinfo'=>'0.15','IO::Handle'=>'1.37','IO::Select'=>'1.23','Locale::Maketext'=>'1.29','Module::CoreList'=>'5.20171120','Module::CoreList::TieHashDelta'=>'5.20171120','Module::CoreList::Utils'=>'5.20171120','Net::Cmd'=>'3.11','Net::Config'=>'3.11','Net::Domain'=>'3.11','Net::FTP'=>'3.11','Net::FTP::A'=>'3.11','Net::FTP::E'=>'3.11','Net::FTP::I'=>'3.11','Net::FTP::L'=>'3.11','Net::FTP::dataconn'=>'3.11','Net::NNTP'=>'3.11','Net::Netrc'=>'3.11','Net::POP3'=>'3.11','Net::Ping'=>'2.62','Net::SMTP'=>'3.11','Net::Time'=>'3.11','Net::hostent'=>'1.02','Net::netent'=>'1.01','Net::protoent'=>'1.01','Net::servent'=>'1.02','O'=>'1.03','ODBM_File'=>'1.15','Opcode'=>'1.41','POSIX'=>'1.80','Pod::Html'=>'1.2203','SelfLoader'=>'1.25','Socket'=>'2.020_04','Storable'=>'2.65','Test'=>'1.31','Test2'=>'1.302111','Test2::API'=>'1.302111','Test2::API::Breakage'=>'1.302111','Test2::API::Context'=>'1.302111','Test2::API::Instance'=>'1.302111','Test2::API::Stack'=>'1.302111','Test2::Event'=>'1.302111','Test2::Event::Bail'=>'1.302111','Test2::Event::Diag'=>'1.302111','Test2::Event::Encoding'=>'1.302111','Test2::Event::Exception'=>'1.302111','Test2::Event::Fail'=>'1.302111','Test2::Event::Generic'=>'1.302111','Test2::Event::Note'=>'1.302111','Test2::Event::Ok'=>'1.302111','Test2::Event::Pass'=>'1.302111','Test2::Event::Plan'=>'1.302111','Test2::Event::Skip'=>'1.302111','Test2::Event::Subtest'=>'1.302111','Test2::Event::TAP::Version'=>'1.302111','Test2::Event::Waiting'=>'1.302111','Test2::EventFacet'=>'1.302111','Test2::EventFacet::About'=>'1.302111','Test2::EventFacet::Amnesty'=>'1.302111','Test2::EventFacet::Assert'=>'1.302111','Test2::EventFacet::Control'=>'1.302111','Test2::EventFacet::Error'=>'1.302111','Test2::EventFacet::Info'=>'1.302111','Test2::EventFacet::Meta'=>'1.302111','Test2::EventFacet::Parent'=>'1.302111','Test2::EventFacet::Plan'=>'1.302111','Test2::EventFacet::Trace'=>'1.302111','Test2::Formatter'=>'1.302111','Test2::Formatter::TAP'=>'1.302111','Test2::Hub'=>'1.302111','Test2::Hub::Interceptor'=>'1.302111','Test2::Hub::Interceptor::Terminator'=>'1.302111','Test2::Hub::Subtest'=>'1.302111','Test2::IPC'=>'1.302111','Test2::IPC::Driver'=>'1.302111','Test2::IPC::Driver::Files'=>'1.302111','Test2::Tools::Tiny'=>'1.302111','Test2::Util'=>'1.302111','Test2::Util::ExternalMeta'=>'1.302111','Test2::Util::Facets2Legacy'=>'1.302111','Test2::Util::HashBase'=>'1.302111','Test2::Util::Trace'=>'1.302111','Test::Builder'=>'1.302111','Test::Builder::Formatter'=>'1.302111','Test::Builder::Module'=>'1.302111','Test::Builder::Tester'=>'1.302111','Test::Builder::Tester::Color'=>'1.302111','Test::Builder::TodoDiag'=>'1.302111','Test::More'=>'1.302111','Test::Simple'=>'1.302111','Test::Tester'=>'1.302111','Test::Tester::Capture'=>'1.302111','Test::Tester::CaptureRunner'=>'1.302111','Test::Tester::Delegate'=>'1.302111','Test::use::ok'=>'1.302111','Tie::Array'=>'1.07','Tie::StdHandle'=>'4.5','Time::HiRes'=>'1.9747','Time::gmtime'=>'1.04','Time::localtime'=>'1.03','Unicode::Collate'=>'1.23','Unicode::Collate::CJK::Big5'=>'1.23','Unicode::Collate::CJK::GB2312'=>'1.23','Unicode::Collate::CJK::JISX0208'=>'1.23','Unicode::Collate::CJK::Korean'=>'1.23','Unicode::Collate::CJK::Pinyin'=>'1.23','Unicode::Collate::CJK::Stroke'=>'1.23','Unicode::Collate::CJK::Zhuyin'=>'1.23','Unicode::Collate::Locale'=>'1.23','Unicode::Normalize'=>'1.26','User::grent'=>'1.02','User::pwent'=>'1.01','VMS::DCLsym'=>'1.09','VMS::Stdio'=>'2.44','XS::APItest'=>'0.93','XS::Typemap'=>'0.16','XSLoader'=>'0.28','attributes'=>'0.32','base'=>'2.27','blib'=>'1.07','experimental'=>'0.017','fields'=>'2.24','ok'=>'1.302111','re'=>'0.36','sort'=>'2.04','threads'=>'2.19','warnings'=>'1.38',},removed=>{}},5.027007=>{delta_from=>5.027006,changed=>{'App::Cpan'=>'1.67','B'=>'1.73','B::Debug'=>'1.26','B::Deparse'=>'1.46','B::Op_private'=>'5.027007','CPAN'=>'2.20','CPAN::Distribution'=>'2.19','CPAN::FTP'=>'5.5011','CPAN::FirstTime'=>'5.5311','CPAN::Shell'=>'5.5007','Carp'=>'1.45','Carp::Heavy'=>'1.45','Compress::Raw::Zlib'=>'2.076','Config'=>'5.027007','Cwd'=>'3.71','Data::Dumper'=>'2.169','Devel::PPPort'=>'3.37','Digest::SHA'=>'6.00','DynaLoader'=>'1.45','ExtUtils::CBuilder'=>'0.280230','ExtUtils::CBuilder::Base'=>'0.280230','ExtUtils::CBuilder::Platform::Unix'=>'0.280230','ExtUtils::CBuilder::Platform::VMS'=>'0.280230','ExtUtils::CBuilder::Platform::Windows'=>'0.280230','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280230','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280230','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280230','ExtUtils::CBuilder::Platform::aix'=>'0.280230','ExtUtils::CBuilder::Platform::android'=>'0.280230','ExtUtils::CBuilder::Platform::cygwin'=>'0.280230','ExtUtils::CBuilder::Platform::darwin'=>'0.280230','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280230','ExtUtils::CBuilder::Platform::os2'=>'0.280230','ExtUtils::Typemaps'=>'3.37','File::Fetch'=>'0.56','File::Spec'=>'3.71','File::Spec::AmigaOS'=>'3.71','File::Spec::Cygwin'=>'3.71','File::Spec::Epoc'=>'3.71','File::Spec::Functions'=>'3.71','File::Spec::Mac'=>'3.71','File::Spec::OS2'=>'3.71','File::Spec::Unix'=>'3.71','File::Spec::VMS'=>'3.71','File::Spec::Win32'=>'3.71','Filter::Util::Call'=>'1.58','GDBM_File'=>'1.17','JSON::PP'=>'2.97000','JSON::PP::Boolean'=>'2.97000','Locale::Codes'=>'3.55','Locale::Codes::Constants'=>'3.55','Locale::Codes::Country'=>'3.55','Locale::Codes::Country_Codes'=>'3.55','Locale::Codes::Country_Retired'=>'3.55','Locale::Codes::Currency'=>'3.55','Locale::Codes::Currency_Codes'=>'3.55','Locale::Codes::Currency_Retired'=>'3.55','Locale::Codes::LangExt'=>'3.55','Locale::Codes::LangExt_Codes'=>'3.55','Locale::Codes::LangExt_Retired'=>'3.55','Locale::Codes::LangFam'=>'3.55','Locale::Codes::LangFam_Codes'=>'3.55','Locale::Codes::LangFam_Retired'=>'3.55','Locale::Codes::LangVar'=>'3.55','Locale::Codes::LangVar_Codes'=>'3.55','Locale::Codes::LangVar_Retired'=>'3.55','Locale::Codes::Language'=>'3.55','Locale::Codes::Language_Codes'=>'3.55','Locale::Codes::Language_Retired'=>'3.55','Locale::Codes::Script'=>'3.55','Locale::Codes::Script_Codes'=>'3.55','Locale::Codes::Script_Retired'=>'3.55','Locale::Country'=>'3.55','Locale::Currency'=>'3.55','Locale::Language'=>'3.55','Locale::Script'=>'3.55','Module::CoreList'=>'5.20171220','Module::CoreList::TieHashDelta'=>'5.20171220','Module::CoreList::Utils'=>'5.20171220','Opcode'=>'1.42','POSIX'=>'1.81','Pod::Functions'=>'1.12','Pod::Functions::Functions'=>'1.12','Pod::Html'=>'1.23','Sys::Hostname'=>'1.22','Test2'=>'1.302120','Test2::API'=>'1.302120','Test2::API::Breakage'=>'1.302120','Test2::API::Context'=>'1.302120','Test2::API::Instance'=>'1.302120','Test2::API::Stack'=>'1.302120','Test2::Event'=>'1.302120','Test2::Event::Bail'=>'1.302120','Test2::Event::Diag'=>'1.302120','Test2::Event::Encoding'=>'1.302120','Test2::Event::Exception'=>'1.302120','Test2::Event::Fail'=>'1.302120','Test2::Event::Generic'=>'1.302120','Test2::Event::Note'=>'1.302120','Test2::Event::Ok'=>'1.302120','Test2::Event::Pass'=>'1.302120','Test2::Event::Plan'=>'1.302120','Test2::Event::Skip'=>'1.302120','Test2::Event::Subtest'=>'1.302120','Test2::Event::TAP::Version'=>'1.302120','Test2::Event::Waiting'=>'1.302120','Test2::EventFacet'=>'1.302120','Test2::EventFacet::About'=>'1.302120','Test2::EventFacet::Amnesty'=>'1.302120','Test2::EventFacet::Assert'=>'1.302120','Test2::EventFacet::Control'=>'1.302120','Test2::EventFacet::Error'=>'1.302120','Test2::EventFacet::Info'=>'1.302120','Test2::EventFacet::Meta'=>'1.302120','Test2::EventFacet::Parent'=>'1.302120','Test2::EventFacet::Plan'=>'1.302120','Test2::EventFacet::Trace'=>'1.302120','Test2::Formatter'=>'1.302120','Test2::Formatter::TAP'=>'1.302120','Test2::Hub'=>'1.302120','Test2::Hub::Interceptor'=>'1.302120','Test2::Hub::Interceptor::Terminator'=>'1.302120','Test2::Hub::Subtest'=>'1.302120','Test2::IPC'=>'1.302120','Test2::IPC::Driver'=>'1.302120','Test2::IPC::Driver::Files'=>'1.302120','Test2::Tools::Tiny'=>'1.302120','Test2::Util'=>'1.302120','Test2::Util::ExternalMeta'=>'1.302120','Test2::Util::Facets2Legacy'=>'1.302120','Test2::Util::HashBase'=>'1.302120','Test2::Util::Trace'=>'1.302120','Test::Builder'=>'1.302120','Test::Builder::Formatter'=>'1.302120','Test::Builder::Module'=>'1.302120','Test::Builder::Tester'=>'1.302120','Test::Builder::Tester::Color'=>'1.302120','Test::Builder::TodoDiag'=>'1.302120','Test::More'=>'1.302120','Test::Simple'=>'1.302120','Test::Tester'=>'1.302120','Test::Tester::Capture'=>'1.302120','Test::Tester::CaptureRunner'=>'1.302120','Test::Tester::Delegate'=>'1.302120','Test::use::ok'=>'1.302120','Time::HiRes'=>'1.9748','Time::Piece'=>'1.3203','Time::Seconds'=>'1.3203','Unicode::Collate'=>'1.25','Unicode::Collate::CJK::Big5'=>'1.25','Unicode::Collate::CJK::GB2312'=>'1.25','Unicode::Collate::CJK::JISX0208'=>'1.25','Unicode::Collate::CJK::Korean'=>'1.25','Unicode::Collate::CJK::Pinyin'=>'1.25','Unicode::Collate::CJK::Stroke'=>'1.25','Unicode::Collate::CJK::Zhuyin'=>'1.25','Unicode::Collate::Locale'=>'1.25','Unicode::UCD'=>'0.69','XS::APItest'=>'0.94','XSLoader'=>'0.29','arybase'=>'0.15','autodie::exception'=>'2.29001','autodie::hints'=>'2.29001','experimental'=>'0.019','feature'=>'1.50','ok'=>'1.302120','overload'=>'1.29','threads'=>'2.21','threads::shared'=>'1.58','warnings'=>'1.39',},removed=>{}},5.027008=>{delta_from=>5.027007,changed=>{'B'=>'1.74','B::Deparse'=>'1.47','B::Op_private'=>'5.027008','Config'=>'5.027008','Cwd'=>'3.72','Data::Dumper'=>'2.170','Devel::PPPort'=>'3.38','Digest::SHA'=>'6.01','Encode'=>'2.94','Encode::Alias'=>'2.24','ExtUtils::Miniperl'=>'1.08','File::Spec'=>'3.72','File::Spec::AmigaOS'=>'3.72','File::Spec::Cygwin'=>'3.72','File::Spec::Epoc'=>'3.72','File::Spec::Functions'=>'3.72','File::Spec::Mac'=>'3.72','File::Spec::OS2'=>'3.72','File::Spec::Unix'=>'3.72','File::Spec::VMS'=>'3.72','File::Spec::Win32'=>'3.72','JSON::PP'=>'2.97001','JSON::PP::Boolean'=>'2.97001','Module::CoreList'=>'5.20180120','Module::CoreList::TieHashDelta'=>'5.20180120','Module::CoreList::Utils'=>'5.20180120','Opcode'=>'1.43','Pod::Functions'=>'1.13','Pod::Functions::Functions'=>'1.13','Pod::Html'=>'1.24','Pod::Man'=>'4.10','Pod::ParseLink'=>'4.10','Pod::Text'=>'4.10','Pod::Text::Color'=>'4.10','Pod::Text::Overstrike'=>'4.10','Pod::Text::Termcap'=>'4.10','Socket'=>'2.027','Time::HiRes'=>'1.9752','Unicode::UCD'=>'0.70','XS::APItest'=>'0.95','XSLoader'=>'0.30','autodie::exception'=>'2.29002','feature'=>'1.51','overload'=>'1.30','utf8'=>'1.21','warnings'=>'1.40',},removed=>{}},5.027009=>{delta_from=>5.027008,changed=>{'B::Op_private'=>'5.027009','Carp'=>'1.46','Carp::Heavy'=>'1.46','Config'=>'5.027009','Cwd'=>'3.74','Devel::PPPort'=>'3.39','Encode'=>'2.96','Encode::Unicode'=>'2.17','Errno'=>'1.29','ExtUtils::Command'=>'7.32','ExtUtils::Command::MM'=>'7.32','ExtUtils::Liblist'=>'7.32','ExtUtils::Liblist::Kid'=>'7.32','ExtUtils::MM'=>'7.32','ExtUtils::MM_AIX'=>'7.32','ExtUtils::MM_Any'=>'7.32','ExtUtils::MM_BeOS'=>'7.32','ExtUtils::MM_Cygwin'=>'7.32','ExtUtils::MM_DOS'=>'7.32','ExtUtils::MM_Darwin'=>'7.32','ExtUtils::MM_MacOS'=>'7.32','ExtUtils::MM_NW5'=>'7.32','ExtUtils::MM_OS2'=>'7.32','ExtUtils::MM_QNX'=>'7.32','ExtUtils::MM_UWIN'=>'7.32','ExtUtils::MM_Unix'=>'7.32','ExtUtils::MM_VMS'=>'7.32','ExtUtils::MM_VOS'=>'7.32','ExtUtils::MM_Win32'=>'7.32','ExtUtils::MM_Win95'=>'7.32','ExtUtils::MY'=>'7.32','ExtUtils::MakeMaker'=>'7.32','ExtUtils::MakeMaker::Config'=>'7.32','ExtUtils::MakeMaker::Locale'=>'7.32','ExtUtils::MakeMaker::version'=>'7.32','ExtUtils::MakeMaker::version::regex'=>'7.32','ExtUtils::Mkbootstrap'=>'7.32','ExtUtils::Mksymlists'=>'7.32','ExtUtils::ParseXS'=>'3.38','ExtUtils::ParseXS::Constants'=>'3.38','ExtUtils::ParseXS::CountLines'=>'3.38','ExtUtils::ParseXS::Eval'=>'3.38','ExtUtils::ParseXS::Utilities'=>'3.38','ExtUtils::Typemaps'=>'3.38','ExtUtils::Typemaps::Cmd'=>'3.38','ExtUtils::Typemaps::InputMap'=>'3.38','ExtUtils::Typemaps::OutputMap'=>'3.38','ExtUtils::Typemaps::Type'=>'3.38','ExtUtils::testlib'=>'7.32','File::Spec'=>'3.74','File::Spec::AmigaOS'=>'3.74','File::Spec::Cygwin'=>'3.74','File::Spec::Epoc'=>'3.74','File::Spec::Functions'=>'3.74','File::Spec::Mac'=>'3.74','File::Spec::OS2'=>'3.74','File::Spec::Unix'=>'3.74','File::Spec::VMS'=>'3.74','File::Spec::Win32'=>'3.74','IPC::Cmd'=>'1.00','Math::BigFloat::Trace'=>'0.49','Math::BigInt::Trace'=>'0.49','Module::CoreList'=>'5.20180220','Module::CoreList::Utils'=>'5.20180220','POSIX'=>'1.82','PerlIO::encoding'=>'0.26','Storable'=>'3.06','Storable::Limit'=>undef,'Test2'=>'1.302122','Test2::API'=>'1.302122','Test2::API::Breakage'=>'1.302122','Test2::API::Context'=>'1.302122','Test2::API::Instance'=>'1.302122','Test2::API::Stack'=>'1.302122','Test2::Event'=>'1.302122','Test2::Event::Bail'=>'1.302122','Test2::Event::Diag'=>'1.302122','Test2::Event::Encoding'=>'1.302122','Test2::Event::Exception'=>'1.302122','Test2::Event::Fail'=>'1.302122','Test2::Event::Generic'=>'1.302122','Test2::Event::Note'=>'1.302122','Test2::Event::Ok'=>'1.302122','Test2::Event::Pass'=>'1.302122','Test2::Event::Plan'=>'1.302122','Test2::Event::Skip'=>'1.302122','Test2::Event::Subtest'=>'1.302122','Test2::Event::TAP::Version'=>'1.302122','Test2::Event::Waiting'=>'1.302122','Test2::EventFacet'=>'1.302122','Test2::EventFacet::About'=>'1.302122','Test2::EventFacet::Amnesty'=>'1.302122','Test2::EventFacet::Assert'=>'1.302122','Test2::EventFacet::Control'=>'1.302122','Test2::EventFacet::Error'=>'1.302122','Test2::EventFacet::Info'=>'1.302122','Test2::EventFacet::Meta'=>'1.302122','Test2::EventFacet::Parent'=>'1.302122','Test2::EventFacet::Plan'=>'1.302122','Test2::EventFacet::Render'=>'1.302122','Test2::EventFacet::Trace'=>'1.302122','Test2::Formatter'=>'1.302122','Test2::Formatter::TAP'=>'1.302122','Test2::Hub'=>'1.302122','Test2::Hub::Interceptor'=>'1.302122','Test2::Hub::Interceptor::Terminator'=>'1.302122','Test2::Hub::Subtest'=>'1.302122','Test2::IPC'=>'1.302122','Test2::IPC::Driver'=>'1.302122','Test2::IPC::Driver::Files'=>'1.302122','Test2::Tools::Tiny'=>'1.302122','Test2::Util'=>'1.302122','Test2::Util::ExternalMeta'=>'1.302122','Test2::Util::Facets2Legacy'=>'1.302122','Test2::Util::HashBase'=>'1.302122','Test2::Util::Trace'=>'1.302122','Test::Builder'=>'1.302122','Test::Builder::Formatter'=>'1.302122','Test::Builder::Module'=>'1.302122','Test::Builder::Tester'=>'1.302122','Test::Builder::Tester::Color'=>'1.302122','Test::Builder::TodoDiag'=>'1.302122','Test::More'=>'1.302122','Test::Simple'=>'1.302122','Test::Tester'=>'1.302122','Test::Tester::Capture'=>'1.302122','Test::Tester::CaptureRunner'=>'1.302122','Test::Tester::Delegate'=>'1.302122','Test::use::ok'=>'1.302122','Time::HiRes'=>'1.9753','XS::APItest'=>'0.96','bigint'=>'0.49','bignum'=>'0.49','bigrat'=>'0.49','encoding'=>'2.22','if'=>'0.0608','mro'=>'1.22','ok'=>'1.302122','threads'=>'2.22','warnings'=>'1.41',},removed=>{'Module::CoreList::TieHashDelta'=>1,}},5.027010=>{delta_from=>5.027009,changed=>{'App::Prove'=>'3.42','App::Prove::State'=>'3.42','App::Prove::State::Result'=>'3.42','App::Prove::State::Result::Test'=>'3.42','B::Deparse'=>'1.48','B::Op_private'=>'5.027010','Carp'=>'1.49','Carp::Heavy'=>'1.49','Config'=>'5.02701','Encode'=>'2.97','ExtUtils::Command'=>'7.34','ExtUtils::Command::MM'=>'7.34','ExtUtils::Liblist'=>'7.34','ExtUtils::Liblist::Kid'=>'7.34','ExtUtils::MM'=>'7.34','ExtUtils::MM_AIX'=>'7.34','ExtUtils::MM_Any'=>'7.34','ExtUtils::MM_BeOS'=>'7.34','ExtUtils::MM_Cygwin'=>'7.34','ExtUtils::MM_DOS'=>'7.34','ExtUtils::MM_Darwin'=>'7.34','ExtUtils::MM_MacOS'=>'7.34','ExtUtils::MM_NW5'=>'7.34','ExtUtils::MM_OS2'=>'7.34','ExtUtils::MM_QNX'=>'7.34','ExtUtils::MM_UWIN'=>'7.34','ExtUtils::MM_Unix'=>'7.34','ExtUtils::MM_VMS'=>'7.34','ExtUtils::MM_VOS'=>'7.34','ExtUtils::MM_Win32'=>'7.34','ExtUtils::MM_Win95'=>'7.34','ExtUtils::MY'=>'7.34','ExtUtils::MakeMaker'=>'7.34','ExtUtils::MakeMaker::Config'=>'7.34','ExtUtils::MakeMaker::Locale'=>'7.34','ExtUtils::MakeMaker::version'=>'7.34','ExtUtils::MakeMaker::version::regex'=>'7.34','ExtUtils::Mkbootstrap'=>'7.34','ExtUtils::Mksymlists'=>'7.34','ExtUtils::ParseXS'=>'3.39','ExtUtils::ParseXS::Constants'=>'3.39','ExtUtils::ParseXS::CountLines'=>'3.39','ExtUtils::ParseXS::Eval'=>'3.39','ExtUtils::ParseXS::Utilities'=>'3.39','ExtUtils::testlib'=>'7.34','File::Glob'=>'1.31','I18N::Langinfo'=>'0.16','List::Util'=>'1.50','List::Util::XS'=>'1.50','Locale::Codes'=>'3.56','Locale::Codes::Constants'=>'3.56','Locale::Codes::Country'=>'3.56','Locale::Codes::Country_Codes'=>'3.56','Locale::Codes::Country_Retired'=>'3.56','Locale::Codes::Currency'=>'3.56','Locale::Codes::Currency_Codes'=>'3.56','Locale::Codes::Currency_Retired'=>'3.56','Locale::Codes::LangExt'=>'3.56','Locale::Codes::LangExt_Codes'=>'3.56','Locale::Codes::LangExt_Retired'=>'3.56','Locale::Codes::LangFam'=>'3.56','Locale::Codes::LangFam_Codes'=>'3.56','Locale::Codes::LangFam_Retired'=>'3.56','Locale::Codes::LangVar'=>'3.56','Locale::Codes::LangVar_Codes'=>'3.56','Locale::Codes::LangVar_Retired'=>'3.56','Locale::Codes::Language'=>'3.56','Locale::Codes::Language_Codes'=>'3.56','Locale::Codes::Language_Retired'=>'3.56','Locale::Codes::Script'=>'3.56','Locale::Codes::Script_Codes'=>'3.56','Locale::Codes::Script_Retired'=>'3.56','Locale::Country'=>'3.56','Locale::Currency'=>'3.56','Locale::Language'=>'3.56','Locale::Script'=>'3.56','Module::CoreList'=>'5.20180221','Module::CoreList::Utils'=>'5.20180221','POSIX'=>'1.83','Scalar::Util'=>'1.50','Sub::Util'=>'1.50','TAP::Base'=>'3.42','TAP::Formatter::Base'=>'3.42','TAP::Formatter::Color'=>'3.42','TAP::Formatter::Console'=>'3.42','TAP::Formatter::Console::ParallelSession'=>'3.42','TAP::Formatter::Console::Session'=>'3.42','TAP::Formatter::File'=>'3.42','TAP::Formatter::File::Session'=>'3.42','TAP::Formatter::Session'=>'3.42','TAP::Harness'=>'3.42','TAP::Harness::Env'=>'3.42','TAP::Object'=>'3.42','TAP::Parser'=>'3.42','TAP::Parser::Aggregator'=>'3.42','TAP::Parser::Grammar'=>'3.42','TAP::Parser::Iterator'=>'3.42','TAP::Parser::Iterator::Array'=>'3.42','TAP::Parser::Iterator::Process'=>'3.42','TAP::Parser::Iterator::Stream'=>'3.42','TAP::Parser::IteratorFactory'=>'3.42','TAP::Parser::Multiplexer'=>'3.42','TAP::Parser::Result'=>'3.42','TAP::Parser::Result::Bailout'=>'3.42','TAP::Parser::Result::Comment'=>'3.42','TAP::Parser::Result::Plan'=>'3.42','TAP::Parser::Result::Pragma'=>'3.42','TAP::Parser::Result::Test'=>'3.42','TAP::Parser::Result::Unknown'=>'3.42','TAP::Parser::Result::Version'=>'3.42','TAP::Parser::Result::YAML'=>'3.42','TAP::Parser::ResultFactory'=>'3.42','TAP::Parser::Scheduler'=>'3.42','TAP::Parser::Scheduler::Job'=>'3.42','TAP::Parser::Scheduler::Spinner'=>'3.42','TAP::Parser::Source'=>'3.42','TAP::Parser::SourceHandler'=>'3.42','TAP::Parser::SourceHandler::Executable'=>'3.42','TAP::Parser::SourceHandler::File'=>'3.42','TAP::Parser::SourceHandler::Handle'=>'3.42','TAP::Parser::SourceHandler::Perl'=>'3.42','TAP::Parser::SourceHandler::RawTAP'=>'3.42','TAP::Parser::YAMLish::Reader'=>'3.42','TAP::Parser::YAMLish::Writer'=>'3.42','Test2'=>'1.302133','Test2::API'=>'1.302133','Test2::API::Breakage'=>'1.302133','Test2::API::Context'=>'1.302133','Test2::API::Instance'=>'1.302133','Test2::API::Stack'=>'1.302133','Test2::Event'=>'1.302133','Test2::Event::Bail'=>'1.302133','Test2::Event::Diag'=>'1.302133','Test2::Event::Encoding'=>'1.302133','Test2::Event::Exception'=>'1.302133','Test2::Event::Fail'=>'1.302133','Test2::Event::Generic'=>'1.302133','Test2::Event::Note'=>'1.302133','Test2::Event::Ok'=>'1.302133','Test2::Event::Pass'=>'1.302133','Test2::Event::Plan'=>'1.302133','Test2::Event::Skip'=>'1.302133','Test2::Event::Subtest'=>'1.302133','Test2::Event::TAP::Version'=>'1.302133','Test2::Event::V2'=>'1.302133','Test2::Event::Waiting'=>'1.302133','Test2::EventFacet'=>'1.302133','Test2::EventFacet::About'=>'1.302133','Test2::EventFacet::Amnesty'=>'1.302133','Test2::EventFacet::Assert'=>'1.302133','Test2::EventFacet::Control'=>'1.302133','Test2::EventFacet::Error'=>'1.302133','Test2::EventFacet::Hub'=>'1.302133','Test2::EventFacet::Info'=>'1.302133','Test2::EventFacet::Meta'=>'1.302133','Test2::EventFacet::Parent'=>'1.302133','Test2::EventFacet::Plan'=>'1.302133','Test2::EventFacet::Render'=>'1.302133','Test2::EventFacet::Trace'=>'1.302133','Test2::Formatter'=>'1.302133','Test2::Formatter::TAP'=>'1.302133','Test2::Hub'=>'1.302133','Test2::Hub::Interceptor'=>'1.302133','Test2::Hub::Interceptor::Terminator'=>'1.302133','Test2::Hub::Subtest'=>'1.302133','Test2::IPC'=>'1.302133','Test2::IPC::Driver'=>'1.302133','Test2::IPC::Driver::Files'=>'1.302133','Test2::Tools::Tiny'=>'1.302133','Test2::Util'=>'1.302133','Test2::Util::ExternalMeta'=>'1.302133','Test2::Util::Facets2Legacy'=>'1.302133','Test2::Util::HashBase'=>'1.302133','Test2::Util::Trace'=>'1.302133','Test::Builder'=>'1.302133','Test::Builder::Formatter'=>'1.302133','Test::Builder::Module'=>'1.302133','Test::Builder::Tester'=>'1.302133','Test::Builder::Tester::Color'=>'1.302133','Test::Builder::TodoDiag'=>'1.302133','Test::Harness'=>'3.42','Test::More'=>'1.302133','Test::Simple'=>'1.302133','Test::Tester'=>'1.302133','Test::Tester::Capture'=>'1.302133','Test::Tester::CaptureRunner'=>'1.302133','Test::Tester::Delegate'=>'1.302133','Test::use::ok'=>'1.302133','Time::HiRes'=>'1.9757','Time::Piece'=>'1.3204','Time::Seconds'=>'1.3204','attributes'=>'0.33','ok'=>'1.302133','warnings'=>'1.42',},removed=>{}},5.024004=>{delta_from=>5.024003,changed=>{'B::Op_private'=>'5.024004','Config'=>'5.024004','Module::CoreList'=>'5.20180414_24','Module::CoreList::TieHashDelta'=>'5.20180414_24','Module::CoreList::Utils'=>'5.20180414_24',},removed=>{}},5.026002=>{delta_from=>5.026001,changed=>{'B::Op_private'=>'5.026002','Config'=>'5.026002','Module::CoreList'=>'5.20180414_26','Module::CoreList::TieHashDelta'=>'5.20180414_26','Module::CoreList::Utils'=>'5.20180414_26','PerlIO::via'=>'0.17','Term::ReadLine'=>'1.17','Unicode::UCD'=>'0.69',},removed=>{}},5.027011=>{delta_from=>5.027010,changed=>{'B::Op_private'=>'5.027011','Carp'=>'1.50','Carp::Heavy'=>'1.50','Config'=>'5.027011','Devel::PPPort'=>'3.40','Exporter'=>'5.73','Exporter::Heavy'=>'5.73','ExtUtils::Constant'=>'0.25','I18N::Langinfo'=>'0.17','IO'=>'1.39','IO::Dir'=>'1.39','IO::File'=>'1.39','IO::Handle'=>'1.39','IO::Pipe'=>'1.39','IO::Poll'=>'1.39','IO::Seekable'=>'1.39','IO::Select'=>'1.39','IO::Socket'=>'1.39','IO::Socket::INET'=>'1.39','IO::Socket::UNIX'=>'1.39','Module::CoreList'=>'5.20180420','Module::CoreList::Utils'=>'5.20180420','POSIX'=>'1.84','Time::HiRes'=>'1.9759','XS::APItest'=>'0.97','bytes'=>'1.06','subs'=>'1.03','vars'=>'1.04','version'=>'0.9923','version::regex'=>'0.9923',},removed=>{}},5.028000=>{delta_from=>5.027011,changed=>{'Archive::Tar'=>'2.30','Archive::Tar::Constant'=>'2.30','Archive::Tar::File'=>'2.30','B::Op_private'=>'5.028000','Config'=>'5.028','Module::CoreList'=>'5.20180622','Module::CoreList::Utils'=>'5.20180622','Storable'=>'3.08','XS::APItest'=>'0.98','feature'=>'1.52',},removed=>{}},5.029000=>{delta_from=>5.028,changed=>{'B::Op_private'=>'5.029000','Config'=>'5.029','Module::CoreList'=>'5.20180626','Module::CoreList::Utils'=>'5.20180626','Unicode::UCD'=>'0.71','XS::APItest'=>'0.99','feature'=>'1.53',},removed=>{}},5.029001=>{delta_from=>5.029000,changed=>{'B::Op_private'=>'5.029001','Compress::Raw::Bzip2'=>'2.081','Compress::Raw::Zlib'=>'2.081','Compress::Zlib'=>'2.081','Config'=>'5.029001','Config::Perl::V'=>'0.30','DB_File'=>'1.842','Devel::PPPort'=>'3.42','Digest::SHA'=>'6.02','ExtUtils::Manifest'=>'1.71','File::GlobMapper'=>'1.001','File::Temp'=>'0.2308','IO::Compress::Adapter::Bzip2'=>'2.081','IO::Compress::Adapter::Deflate'=>'2.081','IO::Compress::Adapter::Identity'=>'2.081','IO::Compress::Base'=>'2.081','IO::Compress::Base::Common'=>'2.081','IO::Compress::Bzip2'=>'2.081','IO::Compress::Deflate'=>'2.081','IO::Compress::Gzip'=>'2.081','IO::Compress::Gzip::Constants'=>'2.081','IO::Compress::RawDeflate'=>'2.081','IO::Compress::Zip'=>'2.081','IO::Compress::Zip::Constants'=>'2.081','IO::Compress::Zlib::Constants'=>'2.081','IO::Compress::Zlib::Extra'=>'2.081','IO::Uncompress::Adapter::Bunzip2'=>'2.081','IO::Uncompress::Adapter::Identity'=>'2.081','IO::Uncompress::Adapter::Inflate'=>'2.081','IO::Uncompress::AnyInflate'=>'2.081','IO::Uncompress::AnyUncompress'=>'2.081','IO::Uncompress::Base'=>'2.081','IO::Uncompress::Bunzip2'=>'2.081','IO::Uncompress::Gunzip'=>'2.081','IO::Uncompress::Inflate'=>'2.081','IO::Uncompress::RawInflate'=>'2.081','IO::Uncompress::Unzip'=>'2.081','IPC::Cmd'=>'1.02','Locale::Codes'=>'3.57','Locale::Codes::Constants'=>'3.57','Locale::Codes::Country'=>'3.57','Locale::Codes::Country_Codes'=>'3.57','Locale::Codes::Country_Retired'=>'3.57','Locale::Codes::Currency'=>'3.57','Locale::Codes::Currency_Codes'=>'3.57','Locale::Codes::Currency_Retired'=>'3.57','Locale::Codes::LangExt'=>'3.57','Locale::Codes::LangExt_Codes'=>'3.57','Locale::Codes::LangExt_Retired'=>'3.57','Locale::Codes::LangFam'=>'3.57','Locale::Codes::LangFam_Codes'=>'3.57','Locale::Codes::LangFam_Retired'=>'3.57','Locale::Codes::LangVar'=>'3.57','Locale::Codes::LangVar_Codes'=>'3.57','Locale::Codes::LangVar_Retired'=>'3.57','Locale::Codes::Language'=>'3.57','Locale::Codes::Language_Codes'=>'3.57','Locale::Codes::Language_Retired'=>'3.57','Locale::Codes::Script'=>'3.57','Locale::Codes::Script_Codes'=>'3.57','Locale::Codes::Script_Retired'=>'3.57','Locale::Country'=>'3.57','Locale::Currency'=>'3.57','Locale::Language'=>'3.57','Locale::Script'=>'3.57','Math::BigFloat'=>'1.999813','Math::BigFloat::Trace'=>'0.50','Math::BigInt'=>'1.999813','Math::BigInt::Calc'=>'1.999813','Math::BigInt::CalcEmu'=>'1.999813','Math::BigInt::FastCalc'=>'0.5007','Math::BigInt::Lib'=>'1.999813','Math::BigInt::Trace'=>'0.50','Math::BigRat'=>'0.2614','Module::CoreList'=>'5.20180720','Module::CoreList::Utils'=>'5.20180720','Pod::Man'=>'4.11','Pod::ParseLink'=>'4.11','Pod::Text'=>'4.11','Pod::Text::Color'=>'4.11','Pod::Text::Overstrike'=>'4.11','Pod::Text::Termcap'=>'4.11','Storable'=>'3.11','Test2'=>'1.302138','Test2::API'=>'1.302138','Test2::API::Breakage'=>'1.302138','Test2::API::Context'=>'1.302138','Test2::API::Instance'=>'1.302138','Test2::API::Stack'=>'1.302138','Test2::Event'=>'1.302138','Test2::Event::Bail'=>'1.302138','Test2::Event::Diag'=>'1.302138','Test2::Event::Encoding'=>'1.302138','Test2::Event::Exception'=>'1.302138','Test2::Event::Fail'=>'1.302138','Test2::Event::Generic'=>'1.302138','Test2::Event::Note'=>'1.302138','Test2::Event::Ok'=>'1.302138','Test2::Event::Pass'=>'1.302138','Test2::Event::Plan'=>'1.302138','Test2::Event::Skip'=>'1.302138','Test2::Event::Subtest'=>'1.302138','Test2::Event::TAP::Version'=>'1.302138','Test2::Event::V2'=>'1.302138','Test2::Event::Waiting'=>'1.302138','Test2::EventFacet'=>'1.302138','Test2::EventFacet::About'=>'1.302138','Test2::EventFacet::Amnesty'=>'1.302138','Test2::EventFacet::Assert'=>'1.302138','Test2::EventFacet::Control'=>'1.302138','Test2::EventFacet::Error'=>'1.302138','Test2::EventFacet::Hub'=>'1.302138','Test2::EventFacet::Info'=>'1.302138','Test2::EventFacet::Meta'=>'1.302138','Test2::EventFacet::Parent'=>'1.302138','Test2::EventFacet::Plan'=>'1.302138','Test2::EventFacet::Render'=>'1.302138','Test2::EventFacet::Trace'=>'1.302138','Test2::Formatter'=>'1.302138','Test2::Formatter::TAP'=>'1.302138','Test2::Hub'=>'1.302138','Test2::Hub::Interceptor'=>'1.302138','Test2::Hub::Interceptor::Terminator'=>'1.302138','Test2::Hub::Subtest'=>'1.302138','Test2::IPC'=>'1.302138','Test2::IPC::Driver'=>'1.302138','Test2::IPC::Driver::Files'=>'1.302138','Test2::Tools::Tiny'=>'1.302138','Test2::Util'=>'1.302138','Test2::Util::ExternalMeta'=>'1.302138','Test2::Util::Facets2Legacy'=>'1.302138','Test2::Util::HashBase'=>'1.302138','Test2::Util::Trace'=>'1.302138','Test::Builder'=>'1.302138','Test::Builder::Formatter'=>'1.302138','Test::Builder::Module'=>'1.302138','Test::Builder::Tester'=>'1.302138','Test::Builder::Tester::Color'=>'1.302138','Test::Builder::TodoDiag'=>'1.302138','Test::More'=>'1.302138','Test::Simple'=>'1.302138','Test::Tester'=>'1.302138','Test::Tester::Capture'=>'1.302138','Test::Tester::CaptureRunner'=>'1.302138','Test::Tester::Delegate'=>'1.302138','Test::use::ok'=>'1.302138','Thread::Queue'=>'3.13','Time::Local'=>'1.28','bigint'=>'0.50','bignum'=>'0.50','bigrat'=>'0.50','experimental'=>'0.020','ok'=>'1.302138','parent'=>'0.237','perlfaq'=>'5.20180605','version'=>'0.9924','version::regex'=>'0.9924',},removed=>{}},5.029002=>{delta_from=>5.029001,changed=>{'B::Op_private'=>'5.029002','Config'=>'5.029002','Config::Extensions'=>'0.03','Cwd'=>'3.75','Data::Dumper'=>'2.171','Filter::Util::Call'=>'1.59','HTTP::Tiny'=>'0.076','Module::CoreList'=>'5.20180820','Module::CoreList::Utils'=>'5.20180820','PerlIO::scalar'=>'0.30','Storable'=>'3.12','Test2'=>'1.302140','Test2::API'=>'1.302140','Test2::API::Breakage'=>'1.302140','Test2::API::Context'=>'1.302140','Test2::API::Instance'=>'1.302140','Test2::API::Stack'=>'1.302140','Test2::Event'=>'1.302140','Test2::Event::Bail'=>'1.302140','Test2::Event::Diag'=>'1.302140','Test2::Event::Encoding'=>'1.302140','Test2::Event::Exception'=>'1.302140','Test2::Event::Fail'=>'1.302140','Test2::Event::Generic'=>'1.302140','Test2::Event::Note'=>'1.302140','Test2::Event::Ok'=>'1.302140','Test2::Event::Pass'=>'1.302140','Test2::Event::Plan'=>'1.302140','Test2::Event::Skip'=>'1.302140','Test2::Event::Subtest'=>'1.302140','Test2::Event::TAP::Version'=>'1.302140','Test2::Event::V2'=>'1.302140','Test2::Event::Waiting'=>'1.302140','Test2::EventFacet'=>'1.302140','Test2::EventFacet::About'=>'1.302140','Test2::EventFacet::Amnesty'=>'1.302140','Test2::EventFacet::Assert'=>'1.302140','Test2::EventFacet::Control'=>'1.302140','Test2::EventFacet::Error'=>'1.302140','Test2::EventFacet::Hub'=>'1.302140','Test2::EventFacet::Info'=>'1.302140','Test2::EventFacet::Meta'=>'1.302140','Test2::EventFacet::Parent'=>'1.302140','Test2::EventFacet::Plan'=>'1.302140','Test2::EventFacet::Render'=>'1.302140','Test2::EventFacet::Trace'=>'1.302140','Test2::Formatter'=>'1.302140','Test2::Formatter::TAP'=>'1.302140','Test2::Hub'=>'1.302140','Test2::Hub::Interceptor'=>'1.302140','Test2::Hub::Interceptor::Terminator'=>'1.302140','Test2::Hub::Subtest'=>'1.302140','Test2::IPC'=>'1.302140','Test2::IPC::Driver'=>'1.302140','Test2::IPC::Driver::Files'=>'1.302140','Test2::Tools::Tiny'=>'1.302140','Test2::Util'=>'1.302140','Test2::Util::ExternalMeta'=>'1.302140','Test2::Util::Facets2Legacy'=>'1.302140','Test2::Util::HashBase'=>'1.302140','Test2::Util::Trace'=>'1.302140','Test::Builder'=>'1.302140','Test::Builder::Formatter'=>'1.302140','Test::Builder::Module'=>'1.302140','Test::Builder::Tester'=>'1.302140','Test::Builder::Tester::Color'=>'1.302140','Test::Builder::TodoDiag'=>'1.302140','Test::More'=>'1.302140','Test::Simple'=>'1.302140','Test::Tester'=>'1.302140','Test::Tester::Capture'=>'1.302140','Test::Tester::CaptureRunner'=>'1.302140','Test::Tester::Delegate'=>'1.302140','Test::use::ok'=>'1.302140','Time::HiRes'=>'1.9760','Time::Piece'=>'1.33','Time::Seconds'=>'1.33','Unicode'=>'11.0.0','ok'=>'1.302140','warnings'=>'1.43',},removed=>{}},5.029003=>{delta_from=>5.029002,changed=>{'Archive::Tar'=>'2.32','Archive::Tar::Constant'=>'2.32','Archive::Tar::File'=>'2.32','B::Op_private'=>'5.029003','Config'=>'5.029003','Data::Dumper'=>'2.172','Devel::PPPort'=>'3.43','File::Path'=>'2.16','File::Spec'=>'3.75','File::Spec::AmigaOS'=>'3.75','File::Spec::Cygwin'=>'3.75','File::Spec::Epoc'=>'3.75','File::Spec::Functions'=>'3.75','File::Spec::Mac'=>'3.75','File::Spec::OS2'=>'3.75','File::Spec::Unix'=>'3.75','File::Spec::VMS'=>'3.75','File::Spec::Win32'=>'3.75','Module::CoreList'=>'5.20180920','Module::CoreList::Utils'=>'5.20180920','POSIX'=>'1.85','Storable'=>'3.13','User::grent'=>'1.03','perlfaq'=>'5.20180915',},removed=>{'Locale::Codes'=>1,'Locale::Codes::Constants'=>1,'Locale::Codes::Country'=>1,'Locale::Codes::Country_Codes'=>1,'Locale::Codes::Country_Retired'=>1,'Locale::Codes::Currency'=>1,'Locale::Codes::Currency_Codes'=>1,'Locale::Codes::Currency_Retired'=>1,'Locale::Codes::LangExt'=>1,'Locale::Codes::LangExt_Codes'=>1,'Locale::Codes::LangExt_Retired'=>1,'Locale::Codes::LangFam'=>1,'Locale::Codes::LangFam_Codes'=>1,'Locale::Codes::LangFam_Retired'=>1,'Locale::Codes::LangVar'=>1,'Locale::Codes::LangVar_Codes'=>1,'Locale::Codes::LangVar_Retired'=>1,'Locale::Codes::Language'=>1,'Locale::Codes::Language_Codes'=>1,'Locale::Codes::Language_Retired'=>1,'Locale::Codes::Script'=>1,'Locale::Codes::Script_Codes'=>1,'Locale::Codes::Script_Retired'=>1,'Locale::Country'=>1,'Locale::Currency'=>1,'Locale::Language'=>1,'Locale::Script'=>1,}},5.029004=>{delta_from=>5.029003,changed=>{'App::Cpan'=>'1.671','B'=>'1.75','B::Concise'=>'1.004','B::Deparse'=>'1.49','B::Op_private'=>'5.029004','B::Terse'=>'1.09','CPAN'=>'2.21','CPAN::Distribution'=>'2.21','CPAN::Mirrors'=>'2.21','CPAN::Plugin'=>'0.97','CPAN::Shell'=>'5.5008','Config'=>'5.029004','Devel::Peek'=>'1.28','File::Copy'=>'2.34','File::Glob'=>'1.32','Math::BigFloat::Trace'=>'0.51','Math::BigInt::Trace'=>'0.51','Module::CoreList'=>'5.20181020','Module::CoreList::Utils'=>'5.20181020','Unicode::UCD'=>'0.72','bigint'=>'0.51','bignum'=>'0.51','bigrat'=>'0.51','bytes'=>'1.07','feature'=>'1.54','sigtrap'=>'1.09','vars'=>'1.05',},removed=>{'B::Debug'=>1,'arybase'=>1,}},5.029005=>{delta_from=>5.029004,changed=>{'B::Op_private'=>'5.029005','Config'=>'5.029005','Cwd'=>'3.76','Data::Dumper'=>'2.173','Errno'=>'1.30','File::Spec'=>'3.76','File::Spec::AmigaOS'=>'3.76','File::Spec::Cygwin'=>'3.76','File::Spec::Epoc'=>'3.76','File::Spec::Functions'=>'3.76','File::Spec::Mac'=>'3.76','File::Spec::OS2'=>'3.76','File::Spec::Unix'=>'3.76','File::Spec::VMS'=>'3.76','File::Spec::Win32'=>'3.76','GDBM_File'=>'1.18','Module::CoreList'=>'5.20181120','Module::CoreList::Utils'=>'5.20181120','NDBM_File'=>'1.15','ODBM_File'=>'1.16','SDBM_File'=>'1.15','re'=>'0.37',},removed=>{}},5.026003=>{delta_from=>5.026002,changed=>{'Archive::Tar'=>'2.24_01','B::Op_private'=>'5.026003','Config'=>'5.026003','Module::CoreList'=>'5.20181129_26','Module::CoreList::TieHashDelta'=>'5.20181129_26','Module::CoreList::Utils'=>'5.20181129_26',},removed=>{}},5.028001=>{delta_from=>5.028,changed=>{'B::Op_private'=>'5.028001','Config'=>'5.028001','Module::CoreList'=>'5.20181129_28','Module::CoreList::Utils'=>'5.20181129_28',},removed=>{}},5.029006=>{delta_from=>5.029005,changed=>{'B::Op_private'=>'5.029006','Config'=>'5.029006','Config::Perl::V'=>'0.32','ExtUtils::ParseXS'=>'3.40','ExtUtils::ParseXS::Constants'=>'3.40','ExtUtils::ParseXS::CountLines'=>'3.40','ExtUtils::ParseXS::Eval'=>'3.40','ExtUtils::ParseXS::Utilities'=>'3.40','File::Find'=>'1.35','Module::CoreList'=>'5.20181218','Module::CoreList::Utils'=>'5.20181218','POSIX'=>'1.86','Storable'=>'3.14','Test2'=>'1.302141','Test2::API'=>'1.302141','Test2::API::Breakage'=>'1.302141','Test2::API::Context'=>'1.302141','Test2::API::Instance'=>'1.302141','Test2::API::Stack'=>'1.302141','Test2::Event'=>'1.302141','Test2::Event::Bail'=>'1.302141','Test2::Event::Diag'=>'1.302141','Test2::Event::Encoding'=>'1.302141','Test2::Event::Exception'=>'1.302141','Test2::Event::Fail'=>'1.302141','Test2::Event::Generic'=>'1.302141','Test2::Event::Note'=>'1.302141','Test2::Event::Ok'=>'1.302141','Test2::Event::Pass'=>'1.302141','Test2::Event::Plan'=>'1.302141','Test2::Event::Skip'=>'1.302141','Test2::Event::Subtest'=>'1.302141','Test2::Event::TAP::Version'=>'1.302141','Test2::Event::V2'=>'1.302141','Test2::Event::Waiting'=>'1.302141','Test2::EventFacet'=>'1.302141','Test2::EventFacet::About'=>'1.302141','Test2::EventFacet::Amnesty'=>'1.302141','Test2::EventFacet::Assert'=>'1.302141','Test2::EventFacet::Control'=>'1.302141','Test2::EventFacet::Error'=>'1.302141','Test2::EventFacet::Hub'=>'1.302141','Test2::EventFacet::Info'=>'1.302141','Test2::EventFacet::Meta'=>'1.302141','Test2::EventFacet::Parent'=>'1.302141','Test2::EventFacet::Plan'=>'1.302141','Test2::EventFacet::Render'=>'1.302141','Test2::EventFacet::Trace'=>'1.302141','Test2::Formatter'=>'1.302141','Test2::Formatter::TAP'=>'1.302141','Test2::Hub'=>'1.302141','Test2::Hub::Interceptor'=>'1.302141','Test2::Hub::Interceptor::Terminator'=>'1.302141','Test2::Hub::Subtest'=>'1.302141','Test2::IPC'=>'1.302141','Test2::IPC::Driver'=>'1.302141','Test2::IPC::Driver::Files'=>'1.302141','Test2::Tools::Tiny'=>'1.302141','Test2::Util'=>'1.302141','Test2::Util::ExternalMeta'=>'1.302141','Test2::Util::Facets2Legacy'=>'1.302141','Test2::Util::HashBase'=>'1.302141','Test2::Util::Trace'=>'1.302141','Test::Builder'=>'1.302141','Test::Builder::Formatter'=>'1.302141','Test::Builder::Module'=>'1.302141','Test::Builder::Tester'=>'1.302141','Test::Builder::Tester::Color'=>'1.302141','Test::Builder::TodoDiag'=>'1.302141','Test::More'=>'1.302141','Test::Simple'=>'1.302141','Test::Tester'=>'1.302141','Test::Tester::Capture'=>'1.302141','Test::Tester::CaptureRunner'=>'1.302141','Test::Tester::Delegate'=>'1.302141','Test::use::ok'=>'1.302141','ok'=>'1.302141','threads::shared'=>'1.59',},removed=>{'Storable::Limit'=>1,}},5.029007=>{delta_from=>5.029006,changed=>{'App::Cpan'=>'1.672','B::Op_private'=>'5.029007','CPAN'=>'2.22','CPAN::Distribution'=>'2.22','CPAN::Plugin::Specfile'=>'0.02','Compress::Raw::Bzip2'=>'2.084','Compress::Raw::Zlib'=>'2.084','Compress::Zlib'=>'2.084','Config'=>'5.029007','Cwd'=>'3.77','DB_File'=>'1.843','File::Find'=>'1.36','File::Spec'=>'3.77','File::Spec::AmigaOS'=>'3.77','File::Spec::Cygwin'=>'3.77','File::Spec::Epoc'=>'3.77','File::Spec::Functions'=>'3.77','File::Spec::Mac'=>'3.77','File::Spec::OS2'=>'3.77','File::Spec::Unix'=>'3.77','File::Spec::VMS'=>'3.77','File::Spec::Win32'=>'3.77','File::Temp'=>'0.2309','IO::Compress::Adapter::Bzip2'=>'2.084','IO::Compress::Adapter::Deflate'=>'2.084','IO::Compress::Adapter::Identity'=>'2.084','IO::Compress::Base'=>'2.084','IO::Compress::Base::Common'=>'2.084','IO::Compress::Bzip2'=>'2.084','IO::Compress::Deflate'=>'2.084','IO::Compress::Gzip'=>'2.084','IO::Compress::Gzip::Constants'=>'2.084','IO::Compress::RawDeflate'=>'2.084','IO::Compress::Zip'=>'2.084','IO::Compress::Zip::Constants'=>'2.084','IO::Compress::Zlib::Constants'=>'2.084','IO::Compress::Zlib::Extra'=>'2.084','IO::Uncompress::Adapter::Bunzip2'=>'2.084','IO::Uncompress::Adapter::Identity'=>'2.084','IO::Uncompress::Adapter::Inflate'=>'2.084','IO::Uncompress::AnyInflate'=>'2.084','IO::Uncompress::AnyUncompress'=>'2.084','IO::Uncompress::Base'=>'2.084','IO::Uncompress::Bunzip2'=>'2.084','IO::Uncompress::Gunzip'=>'2.084','IO::Uncompress::Inflate'=>'2.084','IO::Uncompress::RawInflate'=>'2.084','IO::Uncompress::Unzip'=>'2.084','Math::BigFloat'=>'1.999816','Math::BigInt'=>'1.999816','Math::BigInt::Calc'=>'1.999816','Math::BigInt::FastCalc'=>'0.5008','Math::BigInt::Lib'=>'1.999816','Module::CoreList'=>'5.20190120','Module::CoreList::Utils'=>'5.20190120','Test2'=>'1.302160','Test2::API'=>'1.302160','Test2::API::Breakage'=>'1.302160','Test2::API::Context'=>'1.302160','Test2::API::Instance'=>'1.302160','Test2::API::Stack'=>'1.302160','Test2::Event'=>'1.302160','Test2::Event::Bail'=>'1.302160','Test2::Event::Diag'=>'1.302160','Test2::Event::Encoding'=>'1.302160','Test2::Event::Exception'=>'1.302160','Test2::Event::Fail'=>'1.302160','Test2::Event::Generic'=>'1.302160','Test2::Event::Note'=>'1.302160','Test2::Event::Ok'=>'1.302160','Test2::Event::Pass'=>'1.302160','Test2::Event::Plan'=>'1.302160','Test2::Event::Skip'=>'1.302160','Test2::Event::Subtest'=>'1.302160','Test2::Event::TAP::Version'=>'1.302160','Test2::Event::V2'=>'1.302160','Test2::Event::Waiting'=>'1.302160','Test2::EventFacet'=>'1.302160','Test2::EventFacet::About'=>'1.302160','Test2::EventFacet::Amnesty'=>'1.302160','Test2::EventFacet::Assert'=>'1.302160','Test2::EventFacet::Control'=>'1.302160','Test2::EventFacet::Error'=>'1.302160','Test2::EventFacet::Hub'=>'1.302160','Test2::EventFacet::Info'=>'1.302160','Test2::EventFacet::Info::Table'=>undef,'Test2::EventFacet::Meta'=>'1.302160','Test2::EventFacet::Parent'=>'1.302160','Test2::EventFacet::Plan'=>'1.302160','Test2::EventFacet::Render'=>'1.302160','Test2::EventFacet::Trace'=>'1.302160','Test2::Formatter'=>'1.302160','Test2::Formatter::TAP'=>'1.302160','Test2::Hub'=>'1.302160','Test2::Hub::Interceptor'=>'1.302160','Test2::Hub::Interceptor::Terminator'=>'1.302160','Test2::Hub::Subtest'=>'1.302160','Test2::IPC'=>'1.302160','Test2::IPC::Driver'=>'1.302160','Test2::IPC::Driver::Files'=>'1.302160','Test2::Tools::Tiny'=>'1.302160','Test2::Util'=>'1.302160','Test2::Util::ExternalMeta'=>'1.302160','Test2::Util::Facets2Legacy'=>'1.302160','Test2::Util::HashBase'=>'1.302160','Test2::Util::Trace'=>'1.302160','Test::Builder'=>'1.302160','Test::Builder::Formatter'=>'1.302160','Test::Builder::Module'=>'1.302160','Test::Builder::Tester'=>'1.302160','Test::Builder::Tester::Color'=>'1.302160','Test::Builder::TodoDiag'=>'1.302160','Test::More'=>'1.302160','Test::Simple'=>'1.302160','Test::Tester'=>'1.302160','Test::Tester::Capture'=>'1.302160','Test::Tester::CaptureRunner'=>'1.302160','Test::Tester::Delegate'=>'1.302160','Test::use::ok'=>'1.302160','Unicode::Collate'=>'1.27','Unicode::Collate::CJK::Big5'=>'1.27','Unicode::Collate::CJK::GB2312'=>'1.27','Unicode::Collate::CJK::JISX0208'=>'1.27','Unicode::Collate::CJK::Korean'=>'1.27','Unicode::Collate::CJK::Pinyin'=>'1.27','Unicode::Collate::CJK::Stroke'=>'1.27','Unicode::Collate::CJK::Zhuyin'=>'1.27','Unicode::Collate::Locale'=>'1.27','lib'=>'0.65','ok'=>'1.302160',},removed=>{'Math::BigInt::CalcEmu'=>1,}},5.029008=>{delta_from=>5.029007,changed=>{'B'=>'1.76','B::Op_private'=>'5.029008','Config'=>'5.029008','Devel::PPPort'=>'3.44','Encode'=>'3.00','Encode::Unicode'=>'2.18','ExtUtils::Miniperl'=>'1.09','IO'=>'1.40','IO::Dir'=>'1.40','IO::File'=>'1.40','IO::Handle'=>'1.40','IO::Pipe'=>'1.40','IO::Poll'=>'1.40','IO::Seekable'=>'1.40','IO::Select'=>'1.40','IO::Socket'=>'1.40','IO::Socket::INET'=>'1.40','IO::Socket::UNIX'=>'1.40','JSON::PP'=>'4.00','JSON::PP::Boolean'=>'4.00','Module::CoreList'=>'5.20190220','Module::CoreList::Utils'=>'5.20190220','Module::Load'=>'0.34','Net::Ping'=>'2.71','POSIX'=>'1.87','Test2'=>'1.302162','Test2::API'=>'1.302162','Test2::API::Breakage'=>'1.302162','Test2::API::Context'=>'1.302162','Test2::API::Instance'=>'1.302162','Test2::API::Stack'=>'1.302162','Test2::Event'=>'1.302162','Test2::Event::Bail'=>'1.302162','Test2::Event::Diag'=>'1.302162','Test2::Event::Encoding'=>'1.302162','Test2::Event::Exception'=>'1.302162','Test2::Event::Fail'=>'1.302162','Test2::Event::Generic'=>'1.302162','Test2::Event::Note'=>'1.302162','Test2::Event::Ok'=>'1.302162','Test2::Event::Pass'=>'1.302162','Test2::Event::Plan'=>'1.302162','Test2::Event::Skip'=>'1.302162','Test2::Event::Subtest'=>'1.302162','Test2::Event::TAP::Version'=>'1.302162','Test2::Event::V2'=>'1.302162','Test2::Event::Waiting'=>'1.302162','Test2::EventFacet'=>'1.302162','Test2::EventFacet::About'=>'1.302162','Test2::EventFacet::Amnesty'=>'1.302162','Test2::EventFacet::Assert'=>'1.302162','Test2::EventFacet::Control'=>'1.302162','Test2::EventFacet::Error'=>'1.302162','Test2::EventFacet::Hub'=>'1.302162','Test2::EventFacet::Info'=>'1.302162','Test2::EventFacet::Meta'=>'1.302162','Test2::EventFacet::Parent'=>'1.302162','Test2::EventFacet::Plan'=>'1.302162','Test2::EventFacet::Render'=>'1.302162','Test2::EventFacet::Trace'=>'1.302162','Test2::Formatter'=>'1.302162','Test2::Formatter::TAP'=>'1.302162','Test2::Hub'=>'1.302162','Test2::Hub::Interceptor'=>'1.302162','Test2::Hub::Interceptor::Terminator'=>'1.302162','Test2::Hub::Subtest'=>'1.302162','Test2::IPC'=>'1.302162','Test2::IPC::Driver'=>'1.302162','Test2::IPC::Driver::Files'=>'1.302162','Test2::Tools::Tiny'=>'1.302162','Test2::Util'=>'1.302162','Test2::Util::ExternalMeta'=>'1.302162','Test2::Util::Facets2Legacy'=>'1.302162','Test2::Util::HashBase'=>'1.302162','Test2::Util::Trace'=>'1.302162','Test::Builder'=>'1.302162','Test::Builder::Formatter'=>'1.302162','Test::Builder::Module'=>'1.302162','Test::Builder::Tester'=>'1.302162','Test::Builder::Tester::Color'=>'1.302162','Test::Builder::TodoDiag'=>'1.302162','Test::More'=>'1.302162','Test::Simple'=>'1.302162','Test::Tester'=>'1.302162','Test::Tester::Capture'=>'1.302162','Test::Tester::CaptureRunner'=>'1.302162','Test::Tester::Delegate'=>'1.302162','Test::use::ok'=>'1.302162','XS::APItest'=>'1.00','deprecate'=>'0.04','ok'=>'1.302162','perlfaq'=>'5.20190126',},removed=>{}},5.029009=>{delta_from=>5.029008,changed=>{'B::Op_private'=>'5.029009','Config'=>'5.029009','Devel::PPPort'=>'3.45','Encode'=>'3.01','ExtUtils::Manifest'=>'1.72','JSON::PP'=>'4.02','JSON::PP::Boolean'=>'4.02','Module::CoreList'=>'5.20190320','Module::CoreList::Utils'=>'5.20190320','PerlIO::encoding'=>'0.27','Unicode'=>'12.0.0','threads::shared'=>'1.60','utf8'=>'1.22','warnings'=>'1.44',},removed=>{}},5.028002=>{delta_from=>5.028001,changed=>{'B::Op_private'=>'5.028002','Config'=>'5.028002','Module::CoreList'=>'5.20190419','Module::CoreList::Utils'=>'5.20190419','PerlIO::scalar'=>'0.30','Storable'=>'3.08_01',},removed=>{}},5.029010=>{delta_from=>5.029009,changed=>{'B::Op_private'=>'5.029010','Config'=>'5.02901','Cwd'=>'3.78','Data::Dumper'=>'2.174','ExtUtils::CBuilder'=>'0.280231','ExtUtils::CBuilder::Base'=>'0.280231','ExtUtils::CBuilder::Platform::Unix'=>'0.280231','ExtUtils::CBuilder::Platform::VMS'=>'0.280231','ExtUtils::CBuilder::Platform::Windows'=>'0.280231','ExtUtils::CBuilder::Platform::Windows::BCC'=>'0.280231','ExtUtils::CBuilder::Platform::Windows::GCC'=>'0.280231','ExtUtils::CBuilder::Platform::Windows::MSVC'=>'0.280231','ExtUtils::CBuilder::Platform::aix'=>'0.280231','ExtUtils::CBuilder::Platform::android'=>'0.280231','ExtUtils::CBuilder::Platform::cygwin'=>'0.280231','ExtUtils::CBuilder::Platform::darwin'=>'0.280231','ExtUtils::CBuilder::Platform::dec_osf'=>'0.280231','ExtUtils::CBuilder::Platform::os2'=>'0.280231','File::Spec'=>'3.78','File::Spec::AmigaOS'=>'3.78','File::Spec::Cygwin'=>'3.78','File::Spec::Epoc'=>'3.78','File::Spec::Functions'=>'3.78','File::Spec::Mac'=>'3.78','File::Spec::OS2'=>'3.78','File::Spec::Unix'=>'3.78','File::Spec::VMS'=>'3.78','File::Spec::Win32'=>'3.78','I18N::Langinfo'=>'0.18','Module::CoreList'=>'5.20190420','Module::CoreList::Utils'=>'5.20190420','Module::Metadata'=>'1.000036','POSIX'=>'1.88','Storable'=>'3.15','Unicode'=>'12.1.0',},removed=>{}},5.030000=>{delta_from=>5.02901,changed=>{'B::Op_private'=>'5.030000','Config'=>'5.03','Devel::PPPort'=>'3.52','Module::CoreList'=>'5.20190522','Module::CoreList::Utils'=>'5.20190522','XS::Typemap'=>'0.17',},removed=>{}},5.031000=>{delta_from=>5.03,changed=>{'B::Op_private'=>'5.031000','Config'=>'5.031','Module::CoreList'=>'5.20190524','Module::CoreList::Utils'=>'5.20190524','Pod::Simple'=>'3.36','Pod::Simple::BlackBox'=>'3.36','Pod::Simple::Checker'=>'3.36','Pod::Simple::Debug'=>'3.36','Pod::Simple::DumpAsText'=>'3.36','Pod::Simple::DumpAsXML'=>'3.36','Pod::Simple::HTML'=>'3.36','Pod::Simple::HTMLBatch'=>'3.36','Pod::Simple::JustPod'=>undef,'Pod::Simple::LinkSection'=>'3.36','Pod::Simple::Methody'=>'3.36','Pod::Simple::Progress'=>'3.36','Pod::Simple::PullParser'=>'3.36','Pod::Simple::PullParserEndToken'=>'3.36','Pod::Simple::PullParserStartToken'=>'3.36','Pod::Simple::PullParserTextToken'=>'3.36','Pod::Simple::PullParserToken'=>'3.36','Pod::Simple::RTF'=>'3.36','Pod::Simple::Search'=>'3.36','Pod::Simple::SimpleTree'=>'3.36','Pod::Simple::Text'=>'3.36','Pod::Simple::TextContent'=>'3.36','Pod::Simple::TiedOutFH'=>'3.36','Pod::Simple::Transcode'=>'3.36','Pod::Simple::TranscodeDumb'=>'3.36','Pod::Simple::TranscodeSmart'=>'3.36','Pod::Simple::XHTML'=>'3.36','Pod::Simple::XMLOutStream'=>'3.36','Socket'=>'2.029','feature'=>'1.55',},removed=>{}},5.031001=>{delta_from=>5.031000,changed=>{'App::Cpan'=>'1.675','B::Op_private'=>'5.031001','CPAN'=>'2.27','CPAN::Bundle'=>'5.5005','CPAN::Distribution'=>'2.27','CPAN::FTP'=>'5.5012','CPAN::FirstTime'=>'5.5314','CPAN::HandleConfig'=>'5.5011','CPAN::Mirrors'=>'2.27','CPAN::Queue'=>'5.5003','CPAN::Shell'=>'5.5009','CPAN::Tarzip'=>'5.5013','Class::Struct'=>'0.66','Compress::Raw::Bzip2'=>'2.086','Compress::Raw::Zlib'=>'2.086','Compress::Zlib'=>'2.086','Config'=>'5.031001','DB_File'=>'1.852','Devel::PPPort'=>'3.53','ExtUtils::CBuilder'=>'0.280232','ExtUtils::Command'=>'7.36','ExtUtils::Command::MM'=>'7.36','ExtUtils::Liblist'=>'7.36','ExtUtils::Liblist::Kid'=>'7.36','ExtUtils::MM'=>'7.36','ExtUtils::MM_AIX'=>'7.36','ExtUtils::MM_Any'=>'7.36','ExtUtils::MM_BeOS'=>'7.36','ExtUtils::MM_Cygwin'=>'7.36','ExtUtils::MM_DOS'=>'7.36','ExtUtils::MM_Darwin'=>'7.36','ExtUtils::MM_MacOS'=>'7.36','ExtUtils::MM_NW5'=>'7.36','ExtUtils::MM_OS2'=>'7.36','ExtUtils::MM_QNX'=>'7.36','ExtUtils::MM_UWIN'=>'7.36','ExtUtils::MM_Unix'=>'7.36','ExtUtils::MM_VMS'=>'7.36','ExtUtils::MM_VOS'=>'7.36','ExtUtils::MM_Win32'=>'7.36','ExtUtils::MM_Win95'=>'7.36','ExtUtils::MY'=>'7.36','ExtUtils::MakeMaker'=>'7.36','ExtUtils::MakeMaker::Config'=>'7.36','ExtUtils::MakeMaker::Locale'=>'7.36','ExtUtils::MakeMaker::version'=>'7.36','ExtUtils::MakeMaker::version::regex'=>'7.36','ExtUtils::Mkbootstrap'=>'7.36','ExtUtils::Mksymlists'=>'7.36','ExtUtils::testlib'=>'7.36','File::Spec::Win32'=>'3.79','I18N::LangTags'=>'0.44','IO'=>'1.41','IO::Compress::Adapter::Bzip2'=>'2.086','IO::Compress::Adapter::Deflate'=>'2.086','IO::Compress::Adapter::Identity'=>'2.086','IO::Compress::Base'=>'2.086','IO::Compress::Base::Common'=>'2.086','IO::Compress::Bzip2'=>'2.086','IO::Compress::Deflate'=>'2.086','IO::Compress::Gzip'=>'2.086','IO::Compress::Gzip::Constants'=>'2.086','IO::Compress::RawDeflate'=>'2.086','IO::Compress::Zip'=>'2.086','IO::Compress::Zip::Constants'=>'2.086','IO::Compress::Zlib::Constants'=>'2.086','IO::Compress::Zlib::Extra'=>'2.086','IO::Dir'=>'1.41','IO::File'=>'1.41','IO::Handle'=>'1.41','IO::Pipe'=>'1.41','IO::Poll'=>'1.41','IO::Seekable'=>'1.41','IO::Select'=>'1.41','IO::Socket'=>'1.41','IO::Socket::INET'=>'1.41','IO::Socket::UNIX'=>'1.41','IO::Uncompress::Adapter::Bunzip2'=>'2.086','IO::Uncompress::Adapter::Identity'=>'2.086','IO::Uncompress::Adapter::Inflate'=>'2.086','IO::Uncompress::AnyInflate'=>'2.086','IO::Uncompress::AnyUncompress'=>'2.086','IO::Uncompress::Base'=>'2.086','IO::Uncompress::Bunzip2'=>'2.086','IO::Uncompress::Gunzip'=>'2.086','IO::Uncompress::Inflate'=>'2.086','IO::Uncompress::RawInflate'=>'2.086','IO::Uncompress::Unzip'=>'2.086','Module::CoreList'=>'5.20190620','Module::CoreList::Utils'=>'5.20190620','POSIX'=>'1.89','Pod::Man'=>'4.12','Pod::ParseLink'=>'4.12','Pod::Simple'=>'3.38','Pod::Simple::BlackBox'=>'3.38','Pod::Simple::Checker'=>'3.38','Pod::Simple::Debug'=>'3.38','Pod::Simple::DumpAsText'=>'3.38','Pod::Simple::DumpAsXML'=>'3.38','Pod::Simple::HTML'=>'3.38','Pod::Simple::HTMLBatch'=>'3.38','Pod::Simple::LinkSection'=>'3.38','Pod::Simple::Methody'=>'3.38','Pod::Simple::Progress'=>'3.38','Pod::Simple::PullParser'=>'3.38','Pod::Simple::PullParserEndToken'=>'3.38','Pod::Simple::PullParserStartToken'=>'3.38','Pod::Simple::PullParserTextToken'=>'3.38','Pod::Simple::PullParserToken'=>'3.38','Pod::Simple::RTF'=>'3.38','Pod::Simple::Search'=>'3.38','Pod::Simple::SimpleTree'=>'3.38','Pod::Simple::Text'=>'3.38','Pod::Simple::TextContent'=>'3.38','Pod::Simple::TiedOutFH'=>'3.38','Pod::Simple::Transcode'=>'3.38','Pod::Simple::TranscodeDumb'=>'3.38','Pod::Simple::TranscodeSmart'=>'3.38','Pod::Simple::XHTML'=>'3.38','Pod::Simple::XMLOutStream'=>'3.38','Pod::Text'=>'4.12','Pod::Text::Color'=>'4.12','Pod::Text::Overstrike'=>'4.12','Pod::Text::Termcap'=>'4.12','SelfLoader'=>'1.26','Storable'=>'3.16','Sys::Hostname'=>'1.23','Test2'=>'1.302164','Test2::API'=>'1.302164','Test2::API::Breakage'=>'1.302164','Test2::API::Context'=>'1.302164','Test2::API::Instance'=>'1.302164','Test2::API::Stack'=>'1.302164','Test2::Event'=>'1.302164','Test2::Event::Bail'=>'1.302164','Test2::Event::Diag'=>'1.302164','Test2::Event::Encoding'=>'1.302164','Test2::Event::Exception'=>'1.302164','Test2::Event::Fail'=>'1.302164','Test2::Event::Generic'=>'1.302164','Test2::Event::Note'=>'1.302164','Test2::Event::Ok'=>'1.302164','Test2::Event::Pass'=>'1.302164','Test2::Event::Plan'=>'1.302164','Test2::Event::Skip'=>'1.302164','Test2::Event::Subtest'=>'1.302164','Test2::Event::TAP::Version'=>'1.302164','Test2::Event::V2'=>'1.302164','Test2::Event::Waiting'=>'1.302164','Test2::EventFacet'=>'1.302164','Test2::EventFacet::About'=>'1.302164','Test2::EventFacet::Amnesty'=>'1.302164','Test2::EventFacet::Assert'=>'1.302164','Test2::EventFacet::Control'=>'1.302164','Test2::EventFacet::Error'=>'1.302164','Test2::EventFacet::Hub'=>'1.302164','Test2::EventFacet::Info'=>'1.302164','Test2::EventFacet::Info::Table'=>'1.302164','Test2::EventFacet::Meta'=>'1.302164','Test2::EventFacet::Parent'=>'1.302164','Test2::EventFacet::Plan'=>'1.302164','Test2::EventFacet::Render'=>'1.302164','Test2::EventFacet::Trace'=>'1.302164','Test2::Formatter'=>'1.302164','Test2::Formatter::TAP'=>'1.302164','Test2::Hub'=>'1.302164','Test2::Hub::Interceptor'=>'1.302164','Test2::Hub::Interceptor::Terminator'=>'1.302164','Test2::Hub::Subtest'=>'1.302164','Test2::IPC'=>'1.302164','Test2::IPC::Driver'=>'1.302164','Test2::IPC::Driver::Files'=>'1.302164','Test2::Tools::Tiny'=>'1.302164','Test2::Util'=>'1.302164','Test2::Util::ExternalMeta'=>'1.302164','Test2::Util::Facets2Legacy'=>'1.302164','Test2::Util::HashBase'=>'1.302164','Test2::Util::Trace'=>'1.302164','Test::Builder'=>'1.302164','Test::Builder::Formatter'=>'1.302164','Test::Builder::Module'=>'1.302164','Test::Builder::Tester'=>'1.302164','Test::Builder::Tester::Color'=>'1.302164','Test::Builder::TodoDiag'=>'1.302164','Test::More'=>'1.302164','Test::Simple'=>'1.302164','Test::Tester'=>'1.302164','Test::Tester::Capture'=>'1.302164','Test::Tester::CaptureRunner'=>'1.302164','Test::Tester::Delegate'=>'1.302164','Test::use::ok'=>'1.302164','Tie::File'=>'1.03','Tie::Hash::NamedCapture'=>'0.11','Time::HiRes'=>'1.9761','Unicode::Normalize'=>'1.27','Unicode::UCD'=>'0.73','XS::APItest'=>'1.01','ok'=>'1.302164','overload'=>'1.31','warnings'=>'1.45',},removed=>{'Pod::Find'=>1,'Pod::InputObjects'=>1,'Pod::ParseUtils'=>1,'Pod::Parser'=>1,'Pod::PlainText'=>1,'Pod::Select'=>1,}},5.031002=>{delta_from=>5.031001,changed=>{'B::Op_private'=>'5.031002','Config'=>'5.031002','Devel::PPPort'=>'3.54','Exporter'=>'5.74','Exporter::Heavy'=>'5.74','IPC::Cmd'=>'1.04','JSON::PP'=>'4.04','JSON::PP::Boolean'=>'4.04','Module::CoreList'=>'5.20190720','Module::CoreList::Utils'=>'5.20190720','Opcode'=>'1.44','PerlIO::encoding'=>'0.28','Pod::Simple'=>'3.39','Pod::Simple::BlackBox'=>'3.39','Pod::Simple::Checker'=>'3.39','Pod::Simple::Debug'=>'3.39','Pod::Simple::DumpAsText'=>'3.39','Pod::Simple::DumpAsXML'=>'3.39','Pod::Simple::HTML'=>'3.39','Pod::Simple::HTMLBatch'=>'3.39','Pod::Simple::LinkSection'=>'3.39','Pod::Simple::Methody'=>'3.39','Pod::Simple::Progress'=>'3.39','Pod::Simple::PullParser'=>'3.39','Pod::Simple::PullParserEndToken'=>'3.39','Pod::Simple::PullParserStartToken'=>'3.39','Pod::Simple::PullParserTextToken'=>'3.39','Pod::Simple::PullParserToken'=>'3.39','Pod::Simple::RTF'=>'3.39','Pod::Simple::Search'=>'3.39','Pod::Simple::SimpleTree'=>'3.39','Pod::Simple::Text'=>'3.39','Pod::Simple::TextContent'=>'3.39','Pod::Simple::TiedOutFH'=>'3.39','Pod::Simple::Transcode'=>'3.39','Pod::Simple::TranscodeDumb'=>'3.39','Pod::Simple::TranscodeSmart'=>'3.39','Pod::Simple::XHTML'=>'3.39','Pod::Simple::XMLOutStream'=>'3.39','threads::shared'=>'1.61',},removed=>{}},5.031003=>{delta_from=>5.031002,changed=>{'B::Op_private'=>'5.031003','Compress::Raw::Bzip2'=>'2.087','Compress::Raw::Zlib'=>'2.087','Compress::Zlib'=>'2.087','Config'=>'5.031003','Devel::PPPort'=>'3.55','File::Find'=>'1.37','Getopt::Long'=>'2.51','I18N::LangTags::Detect'=>'1.08','IO::Compress::Adapter::Bzip2'=>'2.087','IO::Compress::Adapter::Deflate'=>'2.087','IO::Compress::Adapter::Identity'=>'2.087','IO::Compress::Base'=>'2.087','IO::Compress::Base::Common'=>'2.087','IO::Compress::Bzip2'=>'2.087','IO::Compress::Deflate'=>'2.087','IO::Compress::Gzip'=>'2.087','IO::Compress::Gzip::Constants'=>'2.087','IO::Compress::RawDeflate'=>'2.087','IO::Compress::Zip'=>'2.087','IO::Compress::Zip::Constants'=>'2.087','IO::Compress::Zlib::Constants'=>'2.087','IO::Compress::Zlib::Extra'=>'2.087','IO::Uncompress::Adapter::Bunzip2'=>'2.087','IO::Uncompress::Adapter::Identity'=>'2.087','IO::Uncompress::Adapter::Inflate'=>'2.087','IO::Uncompress::AnyInflate'=>'2.087','IO::Uncompress::AnyUncompress'=>'2.087','IO::Uncompress::Base'=>'2.087','IO::Uncompress::Bunzip2'=>'2.087','IO::Uncompress::Gunzip'=>'2.087','IO::Uncompress::Inflate'=>'2.087','IO::Uncompress::RawInflate'=>'2.087','IO::Uncompress::Unzip'=>'2.087','Module::CoreList'=>'5.20190820','Module::CoreList::Utils'=>'5.20190820','PerlIO::via'=>'0.18','Storable'=>'3.17','Test2'=>'1.302166','Test2::API'=>'1.302166','Test2::API::Breakage'=>'1.302166','Test2::API::Context'=>'1.302166','Test2::API::Instance'=>'1.302166','Test2::API::Stack'=>'1.302166','Test2::Event'=>'1.302166','Test2::Event::Bail'=>'1.302166','Test2::Event::Diag'=>'1.302166','Test2::Event::Encoding'=>'1.302166','Test2::Event::Exception'=>'1.302166','Test2::Event::Fail'=>'1.302166','Test2::Event::Generic'=>'1.302166','Test2::Event::Note'=>'1.302166','Test2::Event::Ok'=>'1.302166','Test2::Event::Pass'=>'1.302166','Test2::Event::Plan'=>'1.302166','Test2::Event::Skip'=>'1.302166','Test2::Event::Subtest'=>'1.302166','Test2::Event::TAP::Version'=>'1.302166','Test2::Event::V2'=>'1.302166','Test2::Event::Waiting'=>'1.302166','Test2::EventFacet'=>'1.302166','Test2::EventFacet::About'=>'1.302166','Test2::EventFacet::Amnesty'=>'1.302166','Test2::EventFacet::Assert'=>'1.302166','Test2::EventFacet::Control'=>'1.302166','Test2::EventFacet::Error'=>'1.302166','Test2::EventFacet::Hub'=>'1.302166','Test2::EventFacet::Info'=>'1.302166','Test2::EventFacet::Info::Table'=>'1.302166','Test2::EventFacet::Meta'=>'1.302166','Test2::EventFacet::Parent'=>'1.302166','Test2::EventFacet::Plan'=>'1.302166','Test2::EventFacet::Render'=>'1.302166','Test2::EventFacet::Trace'=>'1.302166','Test2::Formatter'=>'1.302166','Test2::Formatter::TAP'=>'1.302166','Test2::Hub'=>'1.302166','Test2::Hub::Interceptor'=>'1.302166','Test2::Hub::Interceptor::Terminator'=>'1.302166','Test2::Hub::Subtest'=>'1.302166','Test2::IPC'=>'1.302166','Test2::IPC::Driver'=>'1.302166','Test2::IPC::Driver::Files'=>'1.302166','Test2::Tools::Tiny'=>'1.302166','Test2::Util'=>'1.302166','Test2::Util::ExternalMeta'=>'1.302166','Test2::Util::Facets2Legacy'=>'1.302166','Test2::Util::HashBase'=>'1.302166','Test2::Util::Trace'=>'1.302166','Test::Builder'=>'1.302166','Test::Builder::Formatter'=>'1.302166','Test::Builder::Module'=>'1.302166','Test::Builder::Tester'=>'1.302166','Test::Builder::Tester::Color'=>'1.302166','Test::Builder::TodoDiag'=>'1.302166','Test::More'=>'1.302166','Test::Simple'=>'1.302166','Test::Tester'=>'1.302166','Test::Tester::Capture'=>'1.302166','Test::Tester::CaptureRunner'=>'1.302166','Test::Tester::Delegate'=>'1.302166','Test::use::ok'=>'1.302166','Thread'=>'3.05','Time::HiRes'=>'1.9762','Win32'=>'0.53','XS::APItest'=>'1.02','ok'=>'1.302166',},removed=>{}},5.031004=>{delta_from=>5.031003,changed=>{'B::Op_private'=>'5.031004','Config'=>'5.031004','ExtUtils::Command'=>'7.38','ExtUtils::Command::MM'=>'7.38','ExtUtils::Liblist'=>'7.38','ExtUtils::Liblist::Kid'=>'7.38','ExtUtils::MM'=>'7.38','ExtUtils::MM_AIX'=>'7.38','ExtUtils::MM_Any'=>'7.38','ExtUtils::MM_BeOS'=>'7.38','ExtUtils::MM_Cygwin'=>'7.38','ExtUtils::MM_DOS'=>'7.38','ExtUtils::MM_Darwin'=>'7.38','ExtUtils::MM_MacOS'=>'7.38','ExtUtils::MM_NW5'=>'7.38','ExtUtils::MM_OS2'=>'7.38','ExtUtils::MM_QNX'=>'7.38','ExtUtils::MM_UWIN'=>'7.38','ExtUtils::MM_Unix'=>'7.38','ExtUtils::MM_VMS'=>'7.38','ExtUtils::MM_VOS'=>'7.38','ExtUtils::MM_Win32'=>'7.38','ExtUtils::MM_Win95'=>'7.38','ExtUtils::MY'=>'7.38','ExtUtils::MakeMaker'=>'7.38','ExtUtils::MakeMaker::Config'=>'7.38','ExtUtils::MakeMaker::Locale'=>'7.38','ExtUtils::MakeMaker::version'=>'7.38','ExtUtils::MakeMaker::version::regex'=>'7.38','ExtUtils::Mkbootstrap'=>'7.38','ExtUtils::Mksymlists'=>'7.38','ExtUtils::testlib'=>'7.38','I18N::Langinfo'=>'0.19','List::Util'=>'1.52','List::Util::XS'=>'1.52','Module::CoreList'=>'5.20190920','Module::CoreList::Utils'=>'5.20190920','Module::Metadata'=>'1.000037','Scalar::Util'=>'1.52','Sub::Util'=>'1.52','Test2'=>'1.302168','Test2::API'=>'1.302168','Test2::API::Breakage'=>'1.302168','Test2::API::Context'=>'1.302168','Test2::API::Instance'=>'1.302168','Test2::API::Stack'=>'1.302168','Test2::Event'=>'1.302168','Test2::Event::Bail'=>'1.302168','Test2::Event::Diag'=>'1.302168','Test2::Event::Encoding'=>'1.302168','Test2::Event::Exception'=>'1.302168','Test2::Event::Fail'=>'1.302168','Test2::Event::Generic'=>'1.302168','Test2::Event::Note'=>'1.302168','Test2::Event::Ok'=>'1.302168','Test2::Event::Pass'=>'1.302168','Test2::Event::Plan'=>'1.302168','Test2::Event::Skip'=>'1.302168','Test2::Event::Subtest'=>'1.302168','Test2::Event::TAP::Version'=>'1.302168','Test2::Event::V2'=>'1.302168','Test2::Event::Waiting'=>'1.302168','Test2::EventFacet'=>'1.302168','Test2::EventFacet::About'=>'1.302168','Test2::EventFacet::Amnesty'=>'1.302168','Test2::EventFacet::Assert'=>'1.302168','Test2::EventFacet::Control'=>'1.302168','Test2::EventFacet::Error'=>'1.302168','Test2::EventFacet::Hub'=>'1.302168','Test2::EventFacet::Info'=>'1.302168','Test2::EventFacet::Info::Table'=>'1.302168','Test2::EventFacet::Meta'=>'1.302168','Test2::EventFacet::Parent'=>'1.302168','Test2::EventFacet::Plan'=>'1.302168','Test2::EventFacet::Render'=>'1.302168','Test2::EventFacet::Trace'=>'1.302168','Test2::Formatter'=>'1.302168','Test2::Formatter::TAP'=>'1.302168','Test2::Hub'=>'1.302168','Test2::Hub::Interceptor'=>'1.302168','Test2::Hub::Interceptor::Terminator'=>'1.302168','Test2::Hub::Subtest'=>'1.302168','Test2::IPC'=>'1.302168','Test2::IPC::Driver'=>'1.302168','Test2::IPC::Driver::Files'=>'1.302168','Test2::Tools::Tiny'=>'1.302168','Test2::Util'=>'1.302168','Test2::Util::ExternalMeta'=>'1.302168','Test2::Util::Facets2Legacy'=>'1.302168','Test2::Util::HashBase'=>'1.302168','Test2::Util::Trace'=>'1.302168','Test::Builder'=>'1.302168','Test::Builder::Formatter'=>'1.302168','Test::Builder::Module'=>'1.302168','Test::Builder::Tester'=>'1.302168','Test::Builder::Tester::Color'=>'1.302168','Test::Builder::TodoDiag'=>'1.302168','Test::More'=>'1.302168','Test::Simple'=>'1.302168','Test::Tester'=>'1.302168','Test::Tester::Capture'=>'1.302168','Test::Tester::CaptureRunner'=>'1.302168','Test::Tester::Delegate'=>'1.302168','Test::use::ok'=>'1.302168','Time::HiRes'=>'1.9763','XS::APItest'=>'1.03','ok'=>'1.302168','re'=>'0.38',},removed=>{}},5.031005=>{delta_from=>5.031004,changed=>{'B'=>'1.77','B::Deparse'=>'1.50','B::Op_private'=>'5.031005','Config'=>'5.031005','Devel::PPPort'=>'3.54','Digest::MD5'=>'2.55_01','Dumpvalue'=>'1.21','ExtUtils::CBuilder'=>'0.280233','Math::BigFloat'=>'1.999817_01','Math::BigInt'=>'1.999817_01','Math::BigInt::Calc'=>'1.999817_01','Math::BigInt::FastCalc'=>'0.5009','Math::BigInt::Lib'=>'1.999817_01','Module::CoreList'=>'5.20191020','Module::CoreList::Utils'=>'5.20191020','Safe'=>'2.41','Time::HiRes'=>'1.9764','XS::APItest'=>'1.04','threads'=>'2.23',},removed=>{}},5.030001=>{delta_from=>5.030000,changed=>{'B::Op_private'=>'5.030001','Config'=>'5.030001','Module::CoreList'=>'5.20191110','Module::CoreList::Utils'=>'5.20191110',},removed=>{}},5.031006=>{delta_from=>5.031005,changed=>{'B::Deparse'=>'1.51','B::Op_private'=>'5.031006','Compress::Raw::Bzip2'=>'2.090','Compress::Raw::Zlib'=>'2.090','Compress::Zlib'=>'2.090','Config'=>'5.031006','Devel::PPPort'=>'3.55','DynaLoader'=>'1.46','IO::Compress::Adapter::Bzip2'=>'2.090','IO::Compress::Adapter::Deflate'=>'2.090','IO::Compress::Adapter::Identity'=>'2.090','IO::Compress::Base'=>'2.090','IO::Compress::Base::Common'=>'2.090','IO::Compress::Bzip2'=>'2.090','IO::Compress::Deflate'=>'2.090','IO::Compress::Gzip'=>'2.090','IO::Compress::Gzip::Constants'=>'2.090','IO::Compress::RawDeflate'=>'2.090','IO::Compress::Zip'=>'2.090','IO::Compress::Zip::Constants'=>'2.090','IO::Compress::Zlib::Constants'=>'2.090','IO::Compress::Zlib::Extra'=>'2.090','IO::Uncompress::Adapter::Bunzip2'=>'2.090','IO::Uncompress::Adapter::Identity'=>'2.090','IO::Uncompress::Adapter::Inflate'=>'2.090','IO::Uncompress::AnyInflate'=>'2.090','IO::Uncompress::AnyUncompress'=>'2.090','IO::Uncompress::Base'=>'2.090','IO::Uncompress::Bunzip2'=>'2.090','IO::Uncompress::Gunzip'=>'2.090','IO::Uncompress::Inflate'=>'2.090','IO::Uncompress::RawInflate'=>'2.090','IO::Uncompress::Unzip'=>'2.090','List::Util'=>'1.53','List::Util::XS'=>'1.53','Math::BigFloat'=>'1.999818','Math::BigInt'=>'1.999818','Math::BigInt::Calc'=>'1.999818','Math::BigInt::Lib'=>'1.999818','Module::CoreList'=>'5.20191120','Module::CoreList::Utils'=>'5.20191120','Module::Load::Conditional'=>'0.70','POSIX'=>'1.90','Pod::Simple'=>'3.40','Pod::Simple::BlackBox'=>'3.40','Pod::Simple::Checker'=>'3.40','Pod::Simple::Debug'=>'3.40','Pod::Simple::DumpAsText'=>'3.40','Pod::Simple::DumpAsXML'=>'3.40','Pod::Simple::HTML'=>'3.40','Pod::Simple::HTMLBatch'=>'3.40','Pod::Simple::LinkSection'=>'3.40','Pod::Simple::Methody'=>'3.40','Pod::Simple::Progress'=>'3.40','Pod::Simple::PullParser'=>'3.40','Pod::Simple::PullParserEndToken'=>'3.40','Pod::Simple::PullParserStartToken'=>'3.40','Pod::Simple::PullParserTextToken'=>'3.40','Pod::Simple::PullParserToken'=>'3.40','Pod::Simple::RTF'=>'3.40','Pod::Simple::Search'=>'3.40','Pod::Simple::SimpleTree'=>'3.40','Pod::Simple::Text'=>'3.40','Pod::Simple::TextContent'=>'3.40','Pod::Simple::TiedOutFH'=>'3.40','Pod::Simple::Transcode'=>'3.40','Pod::Simple::TranscodeDumb'=>'3.40','Pod::Simple::TranscodeSmart'=>'3.40','Pod::Simple::XHTML'=>'3.40','Pod::Simple::XMLOutStream'=>'3.40','Scalar::Util'=>'1.53','Sub::Util'=>'1.53','Sys::Syslog'=>'0.36','Test2'=>'1.302169','Test2::API'=>'1.302169','Test2::API::Breakage'=>'1.302169','Test2::API::Context'=>'1.302169','Test2::API::Instance'=>'1.302169','Test2::API::Stack'=>'1.302169','Test2::Event'=>'1.302169','Test2::Event::Bail'=>'1.302169','Test2::Event::Diag'=>'1.302169','Test2::Event::Encoding'=>'1.302169','Test2::Event::Exception'=>'1.302169','Test2::Event::Fail'=>'1.302169','Test2::Event::Generic'=>'1.302169','Test2::Event::Note'=>'1.302169','Test2::Event::Ok'=>'1.302169','Test2::Event::Pass'=>'1.302169','Test2::Event::Plan'=>'1.302169','Test2::Event::Skip'=>'1.302169','Test2::Event::Subtest'=>'1.302169','Test2::Event::TAP::Version'=>'1.302169','Test2::Event::V2'=>'1.302169','Test2::Event::Waiting'=>'1.302169','Test2::EventFacet'=>'1.302169','Test2::EventFacet::About'=>'1.302169','Test2::EventFacet::Amnesty'=>'1.302169','Test2::EventFacet::Assert'=>'1.302169','Test2::EventFacet::Control'=>'1.302169','Test2::EventFacet::Error'=>'1.302169','Test2::EventFacet::Hub'=>'1.302169','Test2::EventFacet::Info'=>'1.302169','Test2::EventFacet::Info::Table'=>'1.302169','Test2::EventFacet::Meta'=>'1.302169','Test2::EventFacet::Parent'=>'1.302169','Test2::EventFacet::Plan'=>'1.302169','Test2::EventFacet::Render'=>'1.302169','Test2::EventFacet::Trace'=>'1.302169','Test2::Formatter'=>'1.302169','Test2::Formatter::TAP'=>'1.302169','Test2::Hub'=>'1.302169','Test2::Hub::Interceptor'=>'1.302169','Test2::Hub::Interceptor::Terminator'=>'1.302169','Test2::Hub::Subtest'=>'1.302169','Test2::IPC'=>'1.302169','Test2::IPC::Driver'=>'1.302169','Test2::IPC::Driver::Files'=>'1.302169','Test2::Tools::Tiny'=>'1.302169','Test2::Util'=>'1.302169','Test2::Util::ExternalMeta'=>'1.302169','Test2::Util::Facets2Legacy'=>'1.302169','Test2::Util::HashBase'=>'1.302169','Test2::Util::Trace'=>'1.302169','Test::Builder'=>'1.302169','Test::Builder::Formatter'=>'1.302169','Test::Builder::Module'=>'1.302169','Test::Builder::Tester'=>'1.302169','Test::Builder::Tester::Color'=>'1.302169','Test::Builder::TodoDiag'=>'1.302169','Test::More'=>'1.302169','Test::Simple'=>'1.302169','Test::Tester'=>'1.302169','Test::Tester::Capture'=>'1.302169','Test::Tester::CaptureRunner'=>'1.302169','Test::Tester::Delegate'=>'1.302169','Test::use::ok'=>'1.302169','Tie::StdHandle'=>'4.6','Unicode::UCD'=>'0.74','Win32API::File'=>'0.1203_01','feature'=>'1.56','mro'=>'1.23','ok'=>'1.302169','perlfaq'=>'5.20191102',},removed=>{}},);sub is_core {shift if defined $_[1]and $_[1]=~ /^\w/ and _looks_like_invocant $_[0];my$module=shift;my$module_version=@_ > 0 ? shift : undef;my$perl_version=@_ > 0 ? shift : $];my$first_release=first_release($module);return 0 if!defined($first_release)|| $first_release > $perl_version;my$final_release=removed_from($module);return 0 if defined($final_release)&& $perl_version >= $final_release;if (defined($module_version)){my$module_version_object=eval {version->parse($module_version)};if (!defined($module_version_object)){(my$err=$@)=~ s/^Invalid version format\b/Invalid version '$module_version' specified/;die$err}my@releases=($perl_version);my$rel=$perl_version;while (defined($rel)){my$this_delta=$delta{$rel}|| $delta{sprintf '%0.6f',$rel };$rel=$this_delta->{delta_from};unshift(@releases,$rel)if defined($rel)}RELEASE: foreach my$prn (@releases){next RELEASE if$prn < $first_release;last RELEASE if$prn > $perl_version;next unless defined(my$next_module_version =$delta{$prn}->{changed}->{$module});return 1 if eval {version->parse($next_module_version)>= $module_version_object}}return 0}return 1 if!defined($final_release);return$perl_version <= $final_release}%version=_undelta(\%delta);%deprecated=(5.011=>{changed=>{map {$_=>1}qw/Class::ISA Pod::Plainer Shell Switch/},},5.011001=>{delta_from=>5.011 },5.011002=>{delta_from=>5.011001 },5.011003=>{delta_from=>5.011002 },5.011004=>{delta_from=>5.011003 },5.011005=>{delta_from=>5.011004 },5.012=>{delta_from=>5.011005 },5.012001=>{delta_from=>5.012 },5.012002=>{delta_from=>5.012001 },5.012003=>{delta_from=>5.012002 },5.012004=>{delta_from=>5.012003 },5.012005=>{delta_from=>5.012004 },5.013=>{delta_from=>5.012005 },5.013001=>{delta_from=>5.013,removed=>{map {$_=>1}qw/Class::ISA Pod::Plainer Switch/},},5.013002=>{delta_from=>5.013001 },5.013003=>{delta_from=>5.013002 },5.013004=>{delta_from=>5.013003 },5.013005=>{delta_from=>5.013004 },5.013006=>{delta_from=>5.013005 },5.013007=>{delta_from=>5.013006 },5.013008=>{delta_from=>5.013007 },5.013009=>{delta_from=>5.013008 },5.01301=>{delta_from=>5.013009 },5.013011=>{delta_from=>5.01301 },5.014=>{delta_from=>5.013011 },5.014001=>{delta_from=>5.014 },5.014002=>{delta_from=>5.014001 },5.014003=>{delta_from=>5.014002 },5.014004=>{delta_from=>5.014003 },5.015=>{delta_from=>5.014004,removed=>{Shell=>1 },},5.015001=>{delta_from=>5.015 },5.015002=>{delta_from=>5.015001 },5.015003=>{delta_from=>5.015002 },5.015004=>{delta_from=>5.015003 },5.015005=>{delta_from=>5.015004 },5.015006=>{delta_from=>5.015005 },5.015007=>{delta_from=>5.015006 },5.015008=>{delta_from=>5.015007 },5.015009=>{delta_from=>5.015008 },5.016=>{delta_from=>5.015009 },5.016001=>{delta_from=>5.016 },5.016002=>{delta_from=>5.016001 },5.016003=>{delta_from=>5.016002 },5.017=>{delta_from=>5.016003 },5.017001=>{delta_from=>5.017 },5.017002=>{delta_from=>5.017001 },5.017003=>{delta_from=>5.017002 },5.017004=>{delta_from=>5.017003 },5.017005=>{delta_from=>5.017004 },5.017006=>{delta_from=>5.017005 },5.017007=>{delta_from=>5.017006 },5.017008=>{delta_from=>5.017007,changed=>{'Pod::LaTeX'=>1 },},5.017009=>{delta_from=>5.017008,changed=>{map {$_=>1}qw/Archive::Extract B::Lint B::Lint::Debug CPANPLUS CPANPLUS::Backend CPANPLUS::Backend::RV CPANPLUS::Config CPANPLUS::Config::HomeEnv CPANPLUS::Configure CPANPLUS::Configure::Setup CPANPLUS::Dist CPANPLUS::Dist::Autobundle CPANPLUS::Dist::Base CPANPLUS::Dist::Build CPANPLUS::Dist::Build::Constants CPANPLUS::Dist::MM CPANPLUS::Dist::Sample CPANPLUS::Error CPANPLUS::Internals CPANPLUS::Internals::Constants CPANPLUS::Internals::Constants::Report CPANPLUS::Internals::Extract CPANPLUS::Internals::Fetch CPANPLUS::Internals::Report CPANPLUS::Internals::Search CPANPLUS::Internals::Source CPANPLUS::Internals::Source::Memory CPANPLUS::Internals::Source::SQLite CPANPLUS::Internals::Source::SQLite::Tie CPANPLUS::Internals::Utils CPANPLUS::Internals::Utils::Autoflush CPANPLUS::Module CPANPLUS::Module::Author CPANPLUS::Module::Author::Fake CPANPLUS::Module::Checksums CPANPLUS::Module::Fake CPANPLUS::Module::Signature CPANPLUS::Selfupdate CPANPLUS::Shell CPANPLUS::Shell::Classic CPANPLUS::Shell::Default CPANPLUS::Shell::Default::Plugins::CustomSource CPANPLUS::Shell::Default::Plugins::Remote CPANPLUS::Shell::Default::Plugins::Source Devel::InnerPackage File::CheckTree Log::Message Log::Message::Config Log::Message::Handlers Log::Message::Item Log::Message::Simple Module::Pluggable Module::Pluggable::Object Object::Accessor Term::UI Term::UI::History Text::Soundex/},},5.01701=>{delta_from=>5.017009 },5.017011=>{delta_from=>5.01701 },5.018=>{delta_from=>5.017011 },5.018001=>{delta_from=>5.018,changed=>{},removed=>{}},5.018002=>{delta_from=>5.018001,changed=>{},removed=>{}},5.018003=>{delta_from=>5.018,changed=>{},removed=>{}},5.018004=>{delta_from=>5.018,changed=>{},removed=>{}},5.019=>{delta_from=>5.018,changed=>{'Module::Build'=>1 },removed=>{map {$_=>1}qw/Archive::Extract B::Lint B::Lint::Debug CPANPLUS CPANPLUS::Backend CPANPLUS::Backend::RV CPANPLUS::Config CPANPLUS::Config::HomeEnv CPANPLUS::Configure CPANPLUS::Configure::Setup CPANPLUS::Dist CPANPLUS::Dist::Autobundle CPANPLUS::Dist::Base CPANPLUS::Dist::Build CPANPLUS::Dist::Build::Constants CPANPLUS::Dist::MM CPANPLUS::Dist::Sample CPANPLUS::Error CPANPLUS::Internals CPANPLUS::Internals::Constants CPANPLUS::Internals::Constants::Report CPANPLUS::Internals::Extract CPANPLUS::Internals::Fetch CPANPLUS::Internals::Report CPANPLUS::Internals::Search CPANPLUS::Internals::Source CPANPLUS::Internals::Source::Memory CPANPLUS::Internals::Source::SQLite CPANPLUS::Internals::Source::SQLite::Tie CPANPLUS::Internals::Utils CPANPLUS::Internals::Utils::Autoflush CPANPLUS::Module CPANPLUS::Module::Author CPANPLUS::Module::Author::Fake CPANPLUS::Module::Checksums CPANPLUS::Module::Fake CPANPLUS::Module::Signature CPANPLUS::Selfupdate CPANPLUS::Shell CPANPLUS::Shell::Classic CPANPLUS::Shell::Default CPANPLUS::Shell::Default::Plugins::CustomSource CPANPLUS::Shell::Default::Plugins::Remote CPANPLUS::Shell::Default::Plugins::Source Devel::InnerPackage File::CheckTree Log::Message Log::Message::Config Log::Message::Handlers Log::Message::Item Log::Message::Simple Module::Pluggable Module::Pluggable::Object Object::Accessor Pod::LaTeX Term::UI Term::UI::History Text::Soundex/}},5.019001=>{delta_from=>5.019,changed=>{},removed=>{}},5.019002=>{delta_from=>5.019001,changed=>{},removed=>{}},5.019003=>{delta_from=>5.019002,changed=>{},removed=>{}},5.019004=>{delta_from=>5.019003,changed=>{'Module::Build::Base'=>'1','Module::Build::Compat'=>'1','Module::Build::Config'=>'1','Module::Build::ConfigData'=>'1','Module::Build::Cookbook'=>'1','Module::Build::Dumper'=>'1','Module::Build::ModuleInfo'=>'1','Module::Build::Notes'=>'1','Module::Build::PPMMaker'=>'1','Module::Build::Platform::Default'=>'1','Module::Build::Platform::MacOS'=>'1','Module::Build::Platform::Unix'=>'1','Module::Build::Platform::VMS'=>'1','Module::Build::Platform::VOS'=>'1','Module::Build::Platform::Windows'=>'1','Module::Build::Platform::aix'=>'1','Module::Build::Platform::cygwin'=>'1','Module::Build::Platform::darwin'=>'1','Module::Build::Platform::os2'=>'1','Module::Build::PodParser'=>'1','Module::Build::Version'=>'1','Module::Build::YAML'=>'1','inc::latest'=>'1',},removed=>{}},5.019005=>{delta_from=>5.019004,changed=>{},removed=>{}},5.019006=>{delta_from=>5.019005,changed=>{'Package::Constants'=>'1',},removed=>{}},5.019007=>{delta_from=>5.019006,changed=>{'CGI'=>'1','CGI::Apache'=>'1','CGI::Carp'=>'1','CGI::Cookie'=>'1','CGI::Fast'=>'1','CGI::Pretty'=>'1','CGI::Push'=>'1','CGI::Switch'=>'1','CGI::Util'=>'1',},removed=>{}},5.019008=>{delta_from=>5.019007,changed=>{},removed=>{}},5.019009=>{delta_from=>5.019008,changed=>{},removed=>{}},5.01901=>{delta_from=>5.019009,changed=>{},removed=>{}},5.019011=>{delta_from=>5.019010,changed=>{},removed=>{}},5.020000=>{delta_from=>5.019011,changed=>{},removed=>{}},5.021000=>{delta_from=>5.020000,changed=>{},removed=>{'CGI'=>1,'CGI::Apache'=>1,'CGI::Carp'=>1,'CGI::Cookie'=>1,'CGI::Fast'=>1,'CGI::Pretty'=>1,'CGI::Push'=>1,'CGI::Switch'=>1,'CGI::Util'=>1,'Module::Build'=>1,'Module::Build::Base'=>1,'Module::Build::Compat'=>1,'Module::Build::Config'=>1,'Module::Build::ConfigData'=>1,'Module::Build::Cookbook'=>1,'Module::Build::Dumper'=>1,'Module::Build::ModuleInfo'=>1,'Module::Build::Notes'=>1,'Module::Build::PPMMaker'=>1,'Module::Build::Platform::Default'=>1,'Module::Build::Platform::MacOS'=>1,'Module::Build::Platform::Unix'=>1,'Module::Build::Platform::VMS'=>1,'Module::Build::Platform::VOS'=>1,'Module::Build::Platform::Windows'=>1,'Module::Build::Platform::aix'=>1,'Module::Build::Platform::cygwin'=>1,'Module::Build::Platform::darwin'=>1,'Module::Build::Platform::os2'=>1,'Module::Build::PodParser'=>1,'Module::Build::Version'=>1,'Module::Build::YAML'=>1,'Package::Constants'=>1,'inc::latest'=>1,}},5.021001=>{delta_from=>5.021000,changed=>{},removed=>{}},5.021002=>{delta_from=>5.021001,changed=>{},removed=>{}},5.021003=>{delta_from=>5.021002,changed=>{},removed=>{}},5.020001=>{delta_from=>5.020000,changed=>{},removed=>{}},5.021004=>{delta_from=>5.021003,changed=>{},removed=>{}},5.021005=>{delta_from=>5.021004,changed=>{},removed=>{}},5.021006=>{delta_from=>5.021005,changed=>{},removed=>{}},5.021007=>{delta_from=>5.021006,changed=>{},removed=>{}},5.021008=>{delta_from=>5.021007,changed=>{},removed=>{}},5.020002=>{delta_from=>5.020001,changed=>{},removed=>{}},5.021009=>{delta_from=>5.021008,changed=>{},removed=>{}},5.021010=>{delta_from=>5.021009,changed=>{},removed=>{}},5.021011=>{delta_from=>5.02101,changed=>{},removed=>{}},5.022000=>{delta_from=>5.021011,changed=>{},removed=>{}},5.023000=>{delta_from=>5.022000,changed=>{},removed=>{}},5.023001=>{delta_from=>5.023000,changed=>{},removed=>{}},5.023002=>{delta_from=>5.023001,changed=>{},removed=>{}},5.020003=>{delta_from=>5.020002,changed=>{},removed=>{}},5.023003=>{delta_from=>5.023002,changed=>{},removed=>{}},5.023004=>{delta_from=>5.023003,changed=>{},removed=>{}},5.023005=>{delta_from=>5.023004,changed=>{},removed=>{}},5.022001=>{delta_from=>5.022,changed=>{},removed=>{}},5.023006=>{delta_from=>5.023005,changed=>{},removed=>{}},5.023007=>{delta_from=>5.023006,changed=>{},removed=>{}},5.023008=>{delta_from=>5.023007,changed=>{},removed=>{}},5.023009=>{delta_from=>5.023008,changed=>{},removed=>{}},5.022002=>{delta_from=>5.022001,changed=>{},removed=>{}},5.024000=>{delta_from=>5.023009,changed=>{},removed=>{}},5.025000=>{delta_from=>5.024,changed=>{},removed=>{}},5.025001=>{delta_from=>5.025,changed=>{},removed=>{}},5.025002=>{delta_from=>5.025001,changed=>{},removed=>{}},5.025003=>{delta_from=>5.025002,changed=>{},removed=>{}},5.025004=>{delta_from=>5.025003,changed=>{},removed=>{}},5.025005=>{delta_from=>5.025004,changed=>{},removed=>{}},5.025006=>{delta_from=>5.025005,changed=>{},removed=>{}},5.025007=>{delta_from=>5.025006,changed=>{},removed=>{}},5.025008=>{delta_from=>5.025007,changed=>{},removed=>{}},5.022003=>{delta_from=>5.022002,changed=>{},removed=>{}},5.024001=>{delta_from=>5.024000,changed=>{},removed=>{}},5.025009=>{delta_from=>5.025008,changed=>{},removed=>{}},5.025010=>{delta_from=>5.025009,changed=>{},removed=>{}},5.025011=>{delta_from=>5.025010,changed=>{},removed=>{}},5.025012=>{delta_from=>5.025011,changed=>{},removed=>{}},5.026000=>{delta_from=>5.025012,changed=>{},removed=>{}},5.027000=>{delta_from=>5.026,changed=>{},removed=>{}},5.027001=>{delta_from=>5.027,changed=>{},removed=>{}},5.022004=>{delta_from=>5.022003,changed=>{},removed=>{}},5.024002=>{delta_from=>5.024001,changed=>{},removed=>{}},5.027002=>{delta_from=>5.027001,changed=>{},removed=>{}},5.027003=>{delta_from=>5.027002,changed=>{'B::Debug'=>'1',},removed=>{}},5.027004=>{delta_from=>5.027003,changed=>{},removed=>{}},5.024003=>{delta_from=>5.024002,changed=>{},removed=>{}},5.026001=>{delta_from=>5.026000,changed=>{},removed=>{}},5.027005=>{delta_from=>5.027004,changed=>{},removed=>{}},5.027006=>{delta_from=>5.027005,changed=>{},removed=>{}},5.027007=>{delta_from=>5.027006,changed=>{},removed=>{}},5.027008=>{delta_from=>5.027007,changed=>{},removed=>{}},5.027009=>{delta_from=>5.027008,changed=>{},removed=>{}},5.027010=>{delta_from=>5.027009,changed=>{},removed=>{}},5.024004=>{delta_from=>5.024003,changed=>{},removed=>{}},5.026002=>{delta_from=>5.026001,changed=>{},removed=>{}},5.027011=>{delta_from=>5.02701,changed=>{},removed=>{}},5.028000=>{delta_from=>5.027011,changed=>{},removed=>{}},5.029000=>{delta_from=>5.028,changed=>{},removed=>{}},5.029001=>{delta_from=>5.029,changed=>{},removed=>{}},5.029002=>{delta_from=>5.029001,changed=>{},removed=>{}},5.029003=>{delta_from=>5.029002,changed=>{},removed=>{}},5.029004=>{delta_from=>5.029003,changed=>{},removed=>{arybase=>'1',}},5.029005=>{delta_from=>5.027002,changed=>{},removed=>{}},5.026003=>{delta_from=>5.026002,changed=>{},removed=>{}},5.028001=>{delta_from=>5.028000,changed=>{},removed=>{}},5.029006=>{delta_from=>5.029005,changed=>{},removed=>{}},5.029007=>{delta_from=>5.029006,changed=>{},removed=>{}},5.029008=>{delta_from=>5.029007,changed=>{},removed=>{}},5.029009=>{delta_from=>5.029008,changed=>{},removed=>{}},5.028002=>{delta_from=>5.028001,changed=>{},removed=>{}},5.029010=>{delta_from=>5.029009,changed=>{},removed=>{}},5.030000=>{delta_from=>5.02901,changed=>{},removed=>{}},5.031000=>{delta_from=>5.030000,changed=>{},removed=>{}},5.031001=>{delta_from=>5.031000,changed=>{},removed=>{}},5.031002=>{delta_from=>5.031001,changed=>{},removed=>{}},5.031003=>{delta_from=>5.031002,changed=>{},removed=>{}},5.031004=>{delta_from=>5.031003,changed=>{},removed=>{}},5.031005=>{delta_from=>5.031004,changed=>{},removed=>{}},5.030001=>{delta_from=>5.030000,changed=>{},removed=>{}},5.031006=>{delta_from=>5.031005,changed=>{},removed=>{}},);%deprecated=_undelta(\%deprecated);%upstream=('App::Cpan'=>'cpan','App::Prove'=>'cpan','App::Prove::State'=>'cpan','App::Prove::State::Result'=>'cpan','App::Prove::State::Result::Test'=>'cpan','Archive::Tar'=>'cpan','Archive::Tar::Constant'=>'cpan','Archive::Tar::File'=>'cpan','AutoLoader'=>'cpan','AutoSplit'=>'cpan','CPAN'=>'cpan','CPAN::Author'=>'cpan','CPAN::Bundle'=>'cpan','CPAN::CacheMgr'=>'cpan','CPAN::Complete'=>'cpan','CPAN::Debug'=>'cpan','CPAN::DeferredCode'=>'cpan','CPAN::Distribution'=>'cpan','CPAN::Distroprefs'=>'cpan','CPAN::Distrostatus'=>'cpan','CPAN::Exception::RecursiveDependency'=>'cpan','CPAN::Exception::blocked_urllist'=>'cpan','CPAN::Exception::yaml_not_installed'=>'cpan','CPAN::Exception::yaml_process_error'=>'cpan','CPAN::FTP'=>'cpan','CPAN::FTP::netrc'=>'cpan','CPAN::FirstTime'=>'cpan','CPAN::HTTP::Client'=>'cpan','CPAN::HTTP::Credentials'=>'cpan','CPAN::HandleConfig'=>'cpan','CPAN::Index'=>'cpan','CPAN::InfoObj'=>'cpan','CPAN::Kwalify'=>'cpan','CPAN::LWP::UserAgent'=>'cpan','CPAN::Meta'=>'cpan','CPAN::Meta::Converter'=>'cpan','CPAN::Meta::Feature'=>'cpan','CPAN::Meta::History'=>'cpan','CPAN::Meta::Merge'=>'cpan','CPAN::Meta::Prereqs'=>'cpan','CPAN::Meta::Requirements'=>'cpan','CPAN::Meta::Spec'=>'cpan','CPAN::Meta::Validator'=>'cpan','CPAN::Meta::YAML'=>'cpan','CPAN::Mirrors'=>'cpan','CPAN::Module'=>'cpan','CPAN::Nox'=>'cpan','CPAN::Plugin'=>'cpan','CPAN::Plugin::Specfile'=>'cpan','CPAN::Prompt'=>'cpan','CPAN::Queue'=>'cpan','CPAN::Shell'=>'cpan','CPAN::Tarzip'=>'cpan','CPAN::URL'=>'cpan','CPAN::Version'=>'cpan','Compress::Raw::Bzip2'=>'cpan','Compress::Raw::Zlib'=>'cpan','Compress::Zlib'=>'cpan','Config::Perl::V'=>'cpan','DB_File'=>'cpan','Digest'=>'cpan','Digest::MD5'=>'cpan','Digest::SHA'=>'cpan','Digest::base'=>'cpan','Digest::file'=>'cpan','Encode'=>'cpan','Encode::Alias'=>'cpan','Encode::Byte'=>'cpan','Encode::CJKConstants'=>'cpan','Encode::CN'=>'cpan','Encode::CN::HZ'=>'cpan','Encode::Config'=>'cpan','Encode::EBCDIC'=>'cpan','Encode::Encoder'=>'cpan','Encode::Encoding'=>'cpan','Encode::GSM0338'=>'cpan','Encode::Guess'=>'cpan','Encode::JP'=>'cpan','Encode::JP::H2Z'=>'cpan','Encode::JP::JIS7'=>'cpan','Encode::KR'=>'cpan','Encode::KR::2022_KR'=>'cpan','Encode::MIME::Header'=>'cpan','Encode::MIME::Header::ISO_2022_JP'=>'cpan','Encode::MIME::Name'=>'cpan','Encode::Symbol'=>'cpan','Encode::TW'=>'cpan','Encode::Unicode'=>'cpan','Encode::Unicode::UTF7'=>'cpan','ExtUtils::Command'=>'cpan','ExtUtils::Command::MM'=>'cpan','ExtUtils::Constant'=>'cpan','ExtUtils::Constant::Base'=>'cpan','ExtUtils::Constant::ProxySubs'=>'cpan','ExtUtils::Constant::Utils'=>'cpan','ExtUtils::Constant::XS'=>'cpan','ExtUtils::Install'=>'cpan','ExtUtils::Installed'=>'cpan','ExtUtils::Liblist'=>'cpan','ExtUtils::Liblist::Kid'=>'cpan','ExtUtils::MM'=>'cpan','ExtUtils::MM_AIX'=>'cpan','ExtUtils::MM_Any'=>'cpan','ExtUtils::MM_BeOS'=>'cpan','ExtUtils::MM_Cygwin'=>'cpan','ExtUtils::MM_DOS'=>'cpan','ExtUtils::MM_Darwin'=>'cpan','ExtUtils::MM_MacOS'=>'cpan','ExtUtils::MM_NW5'=>'cpan','ExtUtils::MM_OS2'=>'cpan','ExtUtils::MM_QNX'=>'cpan','ExtUtils::MM_UWIN'=>'cpan','ExtUtils::MM_Unix'=>'cpan','ExtUtils::MM_VMS'=>'cpan','ExtUtils::MM_VOS'=>'cpan','ExtUtils::MM_Win32'=>'cpan','ExtUtils::MM_Win95'=>'cpan','ExtUtils::MY'=>'cpan','ExtUtils::MakeMaker'=>'cpan','ExtUtils::MakeMaker::Config'=>'cpan','ExtUtils::MakeMaker::Locale'=>'cpan','ExtUtils::MakeMaker::version'=>'cpan','ExtUtils::MakeMaker::version::regex'=>'cpan','ExtUtils::Manifest'=>'cpan','ExtUtils::Mkbootstrap'=>'cpan','ExtUtils::Mksymlists'=>'cpan','ExtUtils::Packlist'=>'cpan','ExtUtils::testlib'=>'cpan','Fatal'=>'cpan','File::Fetch'=>'cpan','File::GlobMapper'=>'cpan','File::Path'=>'cpan','File::Temp'=>'cpan','Filter::Util::Call'=>'cpan','Getopt::Long'=>'cpan','HTTP::Tiny'=>'cpan','IO::Compress::Adapter::Bzip2'=>'cpan','IO::Compress::Adapter::Deflate'=>'cpan','IO::Compress::Adapter::Identity'=>'cpan','IO::Compress::Base'=>'cpan','IO::Compress::Base::Common'=>'cpan','IO::Compress::Bzip2'=>'cpan','IO::Compress::Deflate'=>'cpan','IO::Compress::Gzip'=>'cpan','IO::Compress::Gzip::Constants'=>'cpan','IO::Compress::RawDeflate'=>'cpan','IO::Compress::Zip'=>'cpan','IO::Compress::Zip::Constants'=>'cpan','IO::Compress::Zlib::Constants'=>'cpan','IO::Compress::Zlib::Extra'=>'cpan','IO::Socket::IP'=>'cpan','IO::Uncompress::Adapter::Bunzip2'=>'cpan','IO::Uncompress::Adapter::Identity'=>'cpan','IO::Uncompress::Adapter::Inflate'=>'cpan','IO::Uncompress::AnyInflate'=>'cpan','IO::Uncompress::AnyUncompress'=>'cpan','IO::Uncompress::Base'=>'cpan','IO::Uncompress::Bunzip2'=>'cpan','IO::Uncompress::Gunzip'=>'cpan','IO::Uncompress::Inflate'=>'cpan','IO::Uncompress::RawInflate'=>'cpan','IO::Uncompress::Unzip'=>'cpan','IO::Zlib'=>'cpan','IPC::Cmd'=>'cpan','IPC::Msg'=>'cpan','IPC::Semaphore'=>'cpan','IPC::SharedMem'=>'cpan','IPC::SysV'=>'cpan','JSON::PP'=>'cpan','JSON::PP::Boolean'=>'cpan','List::Util'=>'cpan','List::Util::XS'=>'cpan','Locale::Maketext::Simple'=>'cpan','MIME::Base64'=>'cpan','MIME::QuotedPrint'=>'cpan','Math::BigFloat'=>'cpan','Math::BigFloat::Trace'=>'cpan','Math::BigInt'=>'cpan','Math::BigInt::Calc'=>'cpan','Math::BigInt::FastCalc'=>'cpan','Math::BigInt::Lib'=>'cpan','Math::BigInt::Trace'=>'cpan','Math::BigRat'=>'cpan','Math::Complex'=>'cpan','Math::Trig'=>'cpan','Memoize'=>'cpan','Memoize::AnyDBM_File'=>'cpan','Memoize::Expire'=>'cpan','Memoize::ExpireFile'=>'cpan','Memoize::ExpireTest'=>'cpan','Memoize::NDBM_File'=>'cpan','Memoize::SDBM_File'=>'cpan','Memoize::Storable'=>'cpan','Module::Load'=>'cpan','Module::Load::Conditional'=>'cpan','Module::Loaded'=>'cpan','Module::Metadata'=>'cpan','NEXT'=>'cpan','Net::Cmd'=>'cpan','Net::Config'=>'cpan','Net::Domain'=>'cpan','Net::FTP'=>'cpan','Net::FTP::A'=>'cpan','Net::FTP::E'=>'cpan','Net::FTP::I'=>'cpan','Net::FTP::L'=>'cpan','Net::FTP::dataconn'=>'cpan','Net::NNTP'=>'cpan','Net::Netrc'=>'cpan','Net::POP3'=>'cpan','Net::SMTP'=>'cpan','Net::Time'=>'cpan','Params::Check'=>'cpan','Parse::CPAN::Meta'=>'cpan','Perl::OSType'=>'cpan','PerlIO::via::QuotedPrint'=>'cpan','Pod::Checker'=>'cpan','Pod::Escapes'=>'cpan','Pod::Man'=>'cpan','Pod::ParseLink'=>'cpan','Pod::Perldoc'=>'cpan','Pod::Perldoc::BaseTo'=>'cpan','Pod::Perldoc::GetOptsOO'=>'cpan','Pod::Perldoc::ToANSI'=>'cpan','Pod::Perldoc::ToChecker'=>'cpan','Pod::Perldoc::ToMan'=>'cpan','Pod::Perldoc::ToNroff'=>'cpan','Pod::Perldoc::ToPod'=>'cpan','Pod::Perldoc::ToRtf'=>'cpan','Pod::Perldoc::ToTerm'=>'cpan','Pod::Perldoc::ToText'=>'cpan','Pod::Perldoc::ToTk'=>'cpan','Pod::Perldoc::ToXml'=>'cpan','Pod::Simple'=>'cpan','Pod::Simple::BlackBox'=>'cpan','Pod::Simple::Checker'=>'cpan','Pod::Simple::Debug'=>'cpan','Pod::Simple::DumpAsText'=>'cpan','Pod::Simple::DumpAsXML'=>'cpan','Pod::Simple::HTML'=>'cpan','Pod::Simple::HTMLBatch'=>'cpan','Pod::Simple::HTMLLegacy'=>'cpan','Pod::Simple::JustPod'=>'cpan','Pod::Simple::LinkSection'=>'cpan','Pod::Simple::Methody'=>'cpan','Pod::Simple::Progress'=>'cpan','Pod::Simple::PullParser'=>'cpan','Pod::Simple::PullParserEndToken'=>'cpan','Pod::Simple::PullParserStartToken'=>'cpan','Pod::Simple::PullParserTextToken'=>'cpan','Pod::Simple::PullParserToken'=>'cpan','Pod::Simple::RTF'=>'cpan','Pod::Simple::Search'=>'cpan','Pod::Simple::SimpleTree'=>'cpan','Pod::Simple::Text'=>'cpan','Pod::Simple::TextContent'=>'cpan','Pod::Simple::TiedOutFH'=>'cpan','Pod::Simple::Transcode'=>'cpan','Pod::Simple::TranscodeDumb'=>'cpan','Pod::Simple::TranscodeSmart'=>'cpan','Pod::Simple::XHTML'=>'cpan','Pod::Simple::XMLOutStream'=>'cpan','Pod::Text'=>'cpan','Pod::Text::Color'=>'cpan','Pod::Text::Overstrike'=>'cpan','Pod::Text::Termcap'=>'cpan','Pod::Usage'=>'cpan','Scalar::Util'=>'cpan','Socket'=>'cpan','Sub::Util'=>'cpan','Sys::Syslog'=>'cpan','Sys::Syslog::Win32'=>'cpan','TAP::Base'=>'cpan','TAP::Formatter::Base'=>'cpan','TAP::Formatter::Color'=>'cpan','TAP::Formatter::Console'=>'cpan','TAP::Formatter::Console::ParallelSession'=>'cpan','TAP::Formatter::Console::Session'=>'cpan','TAP::Formatter::File'=>'cpan','TAP::Formatter::File::Session'=>'cpan','TAP::Formatter::Session'=>'cpan','TAP::Harness'=>'cpan','TAP::Harness::Env'=>'cpan','TAP::Object'=>'cpan','TAP::Parser'=>'cpan','TAP::Parser::Aggregator'=>'cpan','TAP::Parser::Grammar'=>'cpan','TAP::Parser::Iterator'=>'cpan','TAP::Parser::Iterator::Array'=>'cpan','TAP::Parser::Iterator::Process'=>'cpan','TAP::Parser::Iterator::Stream'=>'cpan','TAP::Parser::IteratorFactory'=>'cpan','TAP::Parser::Multiplexer'=>'cpan','TAP::Parser::Result'=>'cpan','TAP::Parser::Result::Bailout'=>'cpan','TAP::Parser::Result::Comment'=>'cpan','TAP::Parser::Result::Plan'=>'cpan','TAP::Parser::Result::Pragma'=>'cpan','TAP::Parser::Result::Test'=>'cpan','TAP::Parser::Result::Unknown'=>'cpan','TAP::Parser::Result::Version'=>'cpan','TAP::Parser::Result::YAML'=>'cpan','TAP::Parser::ResultFactory'=>'cpan','TAP::Parser::Scheduler'=>'cpan','TAP::Parser::Scheduler::Job'=>'cpan','TAP::Parser::Scheduler::Spinner'=>'cpan','TAP::Parser::Source'=>'cpan','TAP::Parser::SourceHandler'=>'cpan','TAP::Parser::SourceHandler::Executable'=>'cpan','TAP::Parser::SourceHandler::File'=>'cpan','TAP::Parser::SourceHandler::Handle'=>'cpan','TAP::Parser::SourceHandler::Perl'=>'cpan','TAP::Parser::SourceHandler::RawTAP'=>'cpan','TAP::Parser::YAMLish::Reader'=>'cpan','TAP::Parser::YAMLish::Writer'=>'cpan','Term::ANSIColor'=>'cpan','Term::Cap'=>'cpan','Test2'=>'cpan','Test2::API'=>'cpan','Test2::API::Breakage'=>'cpan','Test2::API::Context'=>'cpan','Test2::API::Instance'=>'cpan','Test2::API::Stack'=>'cpan','Test2::Event'=>'cpan','Test2::Event::Bail'=>'cpan','Test2::Event::Diag'=>'cpan','Test2::Event::Encoding'=>'cpan','Test2::Event::Exception'=>'cpan','Test2::Event::Fail'=>'cpan','Test2::Event::Generic'=>'cpan','Test2::Event::Note'=>'cpan','Test2::Event::Ok'=>'cpan','Test2::Event::Pass'=>'cpan','Test2::Event::Plan'=>'cpan','Test2::Event::Skip'=>'cpan','Test2::Event::Subtest'=>'cpan','Test2::Event::TAP::Version'=>'cpan','Test2::Event::V2'=>'cpan','Test2::Event::Waiting'=>'cpan','Test2::EventFacet'=>'cpan','Test2::EventFacet::About'=>'cpan','Test2::EventFacet::Amnesty'=>'cpan','Test2::EventFacet::Assert'=>'cpan','Test2::EventFacet::Control'=>'cpan','Test2::EventFacet::Error'=>'cpan','Test2::EventFacet::Hub'=>'cpan','Test2::EventFacet::Info'=>'cpan','Test2::EventFacet::Info::Table'=>'cpan','Test2::EventFacet::Meta'=>'cpan','Test2::EventFacet::Parent'=>'cpan','Test2::EventFacet::Plan'=>'cpan','Test2::EventFacet::Render'=>'cpan','Test2::EventFacet::Trace'=>'cpan','Test2::Formatter'=>'cpan','Test2::Formatter::TAP'=>'cpan','Test2::Hub'=>'cpan','Test2::Hub::Interceptor'=>'cpan','Test2::Hub::Interceptor::Terminator'=>'cpan','Test2::Hub::Subtest'=>'cpan','Test2::IPC'=>'cpan','Test2::IPC::Driver'=>'cpan','Test2::IPC::Driver::Files'=>'cpan','Test2::Tools::Tiny'=>'cpan','Test2::Util'=>'cpan','Test2::Util::ExternalMeta'=>'cpan','Test2::Util::Facets2Legacy'=>'cpan','Test2::Util::HashBase'=>'cpan','Test2::Util::Trace'=>'cpan','Test::Builder'=>'cpan','Test::Builder::Formatter'=>'cpan','Test::Builder::IO::Scalar'=>'cpan','Test::Builder::Module'=>'cpan','Test::Builder::Tester'=>'cpan','Test::Builder::Tester::Color'=>'cpan','Test::Builder::TodoDiag'=>'cpan','Test::Harness'=>'cpan','Test::More'=>'cpan','Test::Simple'=>'cpan','Test::Tester'=>'cpan','Test::Tester::Capture'=>'cpan','Test::Tester::CaptureRunner'=>'cpan','Test::Tester::Delegate'=>'cpan','Test::use::ok'=>'cpan','Text::Balanced'=>'cpan','Text::ParseWords'=>'cpan','Text::Tabs'=>'cpan','Text::Wrap'=>'cpan','Tie::RefHash'=>'cpan','Time::Local'=>'cpan','Time::Piece'=>'cpan','Time::Seconds'=>'cpan','Unicode::Collate'=>'cpan','Unicode::Collate::CJK::Big5'=>'cpan','Unicode::Collate::CJK::GB2312'=>'cpan','Unicode::Collate::CJK::JISX0208'=>'cpan','Unicode::Collate::CJK::Korean'=>'cpan','Unicode::Collate::CJK::Pinyin'=>'cpan','Unicode::Collate::CJK::Stroke'=>'cpan','Unicode::Collate::CJK::Zhuyin'=>'cpan','Unicode::Collate::Locale'=>'cpan','Win32'=>'cpan','Win32API::File'=>'cpan','Win32API::File::inc::ExtUtils::Myconst2perl'=>'cpan','autodie'=>'cpan','autodie::Scope::Guard'=>'cpan','autodie::Scope::GuardStack'=>'cpan','autodie::Util'=>'cpan','autodie::exception'=>'cpan','autodie::exception::system'=>'cpan','autodie::hints'=>'cpan','autodie::skip'=>'cpan','bigint'=>'cpan','bignum'=>'cpan','bigrat'=>'cpan','encoding'=>'cpan','experimental'=>'cpan','ok'=>'cpan','parent'=>'cpan','perlfaq'=>'cpan','version'=>'cpan','version::regex'=>'cpan',);%bug_tracker=('App::Cpan'=>undef,'App::Prove'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','App::Prove::State'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','App::Prove::State::Result'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','App::Prove::State::Result::Test'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','Archive::Tar'=>undef,'Archive::Tar::Constant'=>undef,'Archive::Tar::File'=>undef,'CPAN'=>undef,'CPAN::Author'=>undef,'CPAN::Bundle'=>undef,'CPAN::CacheMgr'=>undef,'CPAN::Complete'=>undef,'CPAN::Debug'=>undef,'CPAN::DeferredCode'=>undef,'CPAN::Distribution'=>undef,'CPAN::Distroprefs'=>undef,'CPAN::Distrostatus'=>undef,'CPAN::Exception::RecursiveDependency'=>undef,'CPAN::Exception::blocked_urllist'=>undef,'CPAN::Exception::yaml_not_installed'=>undef,'CPAN::Exception::yaml_process_error'=>undef,'CPAN::FTP'=>undef,'CPAN::FTP::netrc'=>undef,'CPAN::FirstTime'=>undef,'CPAN::HTTP::Client'=>undef,'CPAN::HTTP::Credentials'=>undef,'CPAN::HandleConfig'=>undef,'CPAN::Index'=>undef,'CPAN::InfoObj'=>undef,'CPAN::Kwalify'=>undef,'CPAN::LWP::UserAgent'=>undef,'CPAN::Meta'=>'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues','CPAN::Meta::Converter'=>'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues','CPAN::Meta::Feature'=>'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues','CPAN::Meta::History'=>'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues','CPAN::Meta::Merge'=>'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues','CPAN::Meta::Prereqs'=>'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues','CPAN::Meta::Requirements'=>'https://github.com/Perl-Toolchain-Gang/CPAN-Meta-Requirements/issues','CPAN::Meta::Spec'=>'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues','CPAN::Meta::Validator'=>'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues','CPAN::Meta::YAML'=>'https://github.com/Perl-Toolchain-Gang/YAML-Tiny/issues','CPAN::Mirrors'=>undef,'CPAN::Module'=>undef,'CPAN::Nox'=>undef,'CPAN::Plugin'=>undef,'CPAN::Plugin::Specfile'=>undef,'CPAN::Prompt'=>undef,'CPAN::Queue'=>undef,'CPAN::Shell'=>undef,'CPAN::Tarzip'=>undef,'CPAN::URL'=>undef,'CPAN::Version'=>undef,'Compress::Raw::Bzip2'=>'https://github.com/pmqs/Compress-Raw-Bzip2/issues','Compress::Raw::Zlib'=>'https://github.com/pmqs/Compress-Raw-Zlib/issues','Compress::Zlib'=>'https://github.com/pmqs/IO-Compress/issues','Config::Perl::V'=>undef,'DB_File'=>'https://github.com/pmqs/DB_File/issues','Digest'=>undef,'Digest::MD5'=>undef,'Digest::SHA'=>undef,'Digest::base'=>undef,'Digest::file'=>undef,'Encode'=>undef,'Encode::Alias'=>undef,'Encode::Byte'=>undef,'Encode::CJKConstants'=>undef,'Encode::CN'=>undef,'Encode::CN::HZ'=>undef,'Encode::Config'=>undef,'Encode::EBCDIC'=>undef,'Encode::Encoder'=>undef,'Encode::Encoding'=>undef,'Encode::GSM0338'=>undef,'Encode::Guess'=>undef,'Encode::JP'=>undef,'Encode::JP::H2Z'=>undef,'Encode::JP::JIS7'=>undef,'Encode::KR'=>undef,'Encode::KR::2022_KR'=>undef,'Encode::MIME::Header'=>undef,'Encode::MIME::Header::ISO_2022_JP'=>undef,'Encode::MIME::Name'=>undef,'Encode::Symbol'=>undef,'Encode::TW'=>undef,'Encode::Unicode'=>undef,'Encode::Unicode::UTF7'=>undef,'ExtUtils::Command'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::Command::MM'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::Constant'=>undef,'ExtUtils::Constant::Base'=>undef,'ExtUtils::Constant::ProxySubs'=>undef,'ExtUtils::Constant::Utils'=>undef,'ExtUtils::Constant::XS'=>undef,'ExtUtils::Install'=>'https://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-Install','ExtUtils::Installed'=>'https://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-Install','ExtUtils::Liblist'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::Liblist::Kid'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MM'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MM_AIX'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MM_Any'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MM_BeOS'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MM_Cygwin'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MM_DOS'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MM_Darwin'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MM_MacOS'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MM_NW5'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MM_OS2'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MM_QNX'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MM_UWIN'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MM_Unix'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MM_VMS'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MM_VOS'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MM_Win32'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MM_Win95'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MY'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MakeMaker'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MakeMaker::Config'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MakeMaker::Locale'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MakeMaker::version'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::MakeMaker::version::regex'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::Manifest'=>'http://github.com/Perl-Toolchain-Gang/ExtUtils-Manifest/issues','ExtUtils::Mkbootstrap'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::Mksymlists'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','ExtUtils::Packlist'=>'https://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-Install','ExtUtils::testlib'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=ExtUtils-MakeMaker','Fatal'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie','File::Fetch'=>undef,'File::GlobMapper'=>'https://github.com/pmqs/IO-Compress/issues','File::Path'=>undef,'File::Temp'=>'https://rt.cpan.org/Public/Dist/Display.html?Name=File-Temp','Filter::Util::Call'=>undef,'Getopt::Long'=>undef,'HTTP::Tiny'=>'https://github.com/chansen/p5-http-tiny/issues','IO::Compress::Adapter::Bzip2'=>'https://github.com/pmqs/IO-Compress/issues','IO::Compress::Adapter::Deflate'=>'https://github.com/pmqs/IO-Compress/issues','IO::Compress::Adapter::Identity'=>'https://github.com/pmqs/IO-Compress/issues','IO::Compress::Base'=>'https://github.com/pmqs/IO-Compress/issues','IO::Compress::Base::Common'=>'https://github.com/pmqs/IO-Compress/issues','IO::Compress::Bzip2'=>'https://github.com/pmqs/IO-Compress/issues','IO::Compress::Deflate'=>'https://github.com/pmqs/IO-Compress/issues','IO::Compress::Gzip'=>'https://github.com/pmqs/IO-Compress/issues','IO::Compress::Gzip::Constants'=>'https://github.com/pmqs/IO-Compress/issues','IO::Compress::RawDeflate'=>'https://github.com/pmqs/IO-Compress/issues','IO::Compress::Zip'=>'https://github.com/pmqs/IO-Compress/issues','IO::Compress::Zip::Constants'=>'https://github.com/pmqs/IO-Compress/issues','IO::Compress::Zlib::Constants'=>'https://github.com/pmqs/IO-Compress/issues','IO::Compress::Zlib::Extra'=>'https://github.com/pmqs/IO-Compress/issues','IO::Socket::IP'=>undef,'IO::Uncompress::Adapter::Bunzip2'=>'https://github.com/pmqs/IO-Compress/issues','IO::Uncompress::Adapter::Identity'=>'https://github.com/pmqs/IO-Compress/issues','IO::Uncompress::Adapter::Inflate'=>'https://github.com/pmqs/IO-Compress/issues','IO::Uncompress::AnyInflate'=>'https://github.com/pmqs/IO-Compress/issues','IO::Uncompress::AnyUncompress'=>'https://github.com/pmqs/IO-Compress/issues','IO::Uncompress::Base'=>'https://github.com/pmqs/IO-Compress/issues','IO::Uncompress::Bunzip2'=>'https://github.com/pmqs/IO-Compress/issues','IO::Uncompress::Gunzip'=>'https://github.com/pmqs/IO-Compress/issues','IO::Uncompress::Inflate'=>'https://github.com/pmqs/IO-Compress/issues','IO::Uncompress::RawInflate'=>'https://github.com/pmqs/IO-Compress/issues','IO::Uncompress::Unzip'=>'https://github.com/pmqs/IO-Compress/issues','IO::Zlib'=>undef,'IPC::Cmd'=>undef,'IPC::Msg'=>undef,'IPC::Semaphore'=>undef,'IPC::SharedMem'=>undef,'IPC::SysV'=>undef,'JSON::PP'=>'https://github.com/makamaka/JSON-PP/issues','JSON::PP::Boolean'=>'https://github.com/makamaka/JSON-PP/issues','List::Util'=>'https://rt.cpan.org/Public/Dist/Display.html?Name=Scalar-List-Utils','List::Util::XS'=>'https://rt.cpan.org/Public/Dist/Display.html?Name=Scalar-List-Utils','Locale::Maketext::Simple'=>undef,'MIME::Base64'=>undef,'MIME::QuotedPrint'=>undef,'Math::BigFloat'=>undef,'Math::BigFloat::Trace'=>undef,'Math::BigInt'=>undef,'Math::BigInt::Calc'=>undef,'Math::BigInt::FastCalc'=>undef,'Math::BigInt::Lib'=>undef,'Math::BigInt::Trace'=>undef,'Math::BigRat'=>undef,'Math::Complex'=>undef,'Math::Trig'=>undef,'Memoize'=>undef,'Memoize::AnyDBM_File'=>undef,'Memoize::Expire'=>undef,'Memoize::ExpireFile'=>undef,'Memoize::ExpireTest'=>undef,'Memoize::NDBM_File'=>undef,'Memoize::SDBM_File'=>undef,'Memoize::Storable'=>undef,'Module::Load'=>undef,'Module::Load::Conditional'=>undef,'Module::Loaded'=>undef,'Module::Metadata'=>'https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Metadata','NEXT'=>undef,'Net::Cmd'=>undef,'Net::Config'=>undef,'Net::Domain'=>undef,'Net::FTP'=>undef,'Net::FTP::A'=>undef,'Net::FTP::E'=>undef,'Net::FTP::I'=>undef,'Net::FTP::L'=>undef,'Net::FTP::dataconn'=>undef,'Net::NNTP'=>undef,'Net::Netrc'=>undef,'Net::POP3'=>undef,'Net::SMTP'=>undef,'Net::Time'=>undef,'Params::Check'=>undef,'Parse::CPAN::Meta'=>'https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues','Perl::OSType'=>'https://github.com/Perl-Toolchain-Gang/Perl-OSType/issues','PerlIO::via::QuotedPrint'=>undef,'Pod::Checker'=>undef,'Pod::Escapes'=>undef,'Pod::Man'=>'https://rt.cpan.org/Dist/Display.html?Name=podlators','Pod::ParseLink'=>'https://rt.cpan.org/Dist/Display.html?Name=podlators','Pod::Perldoc'=>undef,'Pod::Perldoc::BaseTo'=>undef,'Pod::Perldoc::GetOptsOO'=>undef,'Pod::Perldoc::ToANSI'=>undef,'Pod::Perldoc::ToChecker'=>undef,'Pod::Perldoc::ToMan'=>undef,'Pod::Perldoc::ToNroff'=>undef,'Pod::Perldoc::ToPod'=>undef,'Pod::Perldoc::ToRtf'=>undef,'Pod::Perldoc::ToTerm'=>undef,'Pod::Perldoc::ToText'=>undef,'Pod::Perldoc::ToTk'=>undef,'Pod::Perldoc::ToXml'=>undef,'Pod::Simple'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::BlackBox'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::Checker'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::Debug'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::DumpAsText'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::DumpAsXML'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::HTML'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::HTMLBatch'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::HTMLLegacy'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::JustPod'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::LinkSection'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::Methody'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::Progress'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::PullParser'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::PullParserEndToken'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::PullParserStartToken'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::PullParserTextToken'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::PullParserToken'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::RTF'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::Search'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::SimpleTree'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::Text'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::TextContent'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::TiedOutFH'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::Transcode'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::TranscodeDumb'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::TranscodeSmart'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::XHTML'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Simple::XMLOutStream'=>'https://github.com/perl-pod/pod-simple/issues','Pod::Text'=>'https://rt.cpan.org/Dist/Display.html?Name=podlators','Pod::Text::Color'=>'https://rt.cpan.org/Dist/Display.html?Name=podlators','Pod::Text::Overstrike'=>'https://rt.cpan.org/Dist/Display.html?Name=podlators','Pod::Text::Termcap'=>'https://rt.cpan.org/Dist/Display.html?Name=podlators','Pod::Usage'=>undef,'Scalar::Util'=>'https://rt.cpan.org/Public/Dist/Display.html?Name=Scalar-List-Utils','Socket'=>undef,'Sub::Util'=>'https://rt.cpan.org/Public/Dist/Display.html?Name=Scalar-List-Utils','Sys::Syslog'=>undef,'Sys::Syslog::Win32'=>undef,'TAP::Base'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Formatter::Base'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Formatter::Color'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Formatter::Console'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Formatter::Console::ParallelSession'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Formatter::Console::Session'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Formatter::File'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Formatter::File::Session'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Formatter::Session'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Harness'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Harness::Env'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Object'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Aggregator'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Grammar'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Iterator'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Iterator::Array'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Iterator::Process'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Iterator::Stream'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::IteratorFactory'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Multiplexer'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Result'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Result::Bailout'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Result::Comment'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Result::Plan'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Result::Pragma'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Result::Test'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Result::Unknown'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Result::Version'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Result::YAML'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::ResultFactory'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Scheduler'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Scheduler::Job'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Scheduler::Spinner'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::Source'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::SourceHandler'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::SourceHandler::Executable'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::SourceHandler::File'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::SourceHandler::Handle'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::SourceHandler::Perl'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::SourceHandler::RawTAP'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::YAMLish::Reader'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','TAP::Parser::YAMLish::Writer'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','Term::ANSIColor'=>'https://rt.cpan.org/Dist/Display.html?Name=Term-ANSIColor','Term::Cap'=>undef,'Test2'=>'http://github.com/Test-More/test-more/issues','Test2::API'=>'http://github.com/Test-More/test-more/issues','Test2::API::Breakage'=>'http://github.com/Test-More/test-more/issues','Test2::API::Context'=>'http://github.com/Test-More/test-more/issues','Test2::API::Instance'=>'http://github.com/Test-More/test-more/issues','Test2::API::Stack'=>'http://github.com/Test-More/test-more/issues','Test2::Event'=>'http://github.com/Test-More/test-more/issues','Test2::Event::Bail'=>'http://github.com/Test-More/test-more/issues','Test2::Event::Diag'=>'http://github.com/Test-More/test-more/issues','Test2::Event::Encoding'=>'http://github.com/Test-More/test-more/issues','Test2::Event::Exception'=>'http://github.com/Test-More/test-more/issues','Test2::Event::Fail'=>'http://github.com/Test-More/test-more/issues','Test2::Event::Generic'=>'http://github.com/Test-More/test-more/issues','Test2::Event::Note'=>'http://github.com/Test-More/test-more/issues','Test2::Event::Ok'=>'http://github.com/Test-More/test-more/issues','Test2::Event::Pass'=>'http://github.com/Test-More/test-more/issues','Test2::Event::Plan'=>'http://github.com/Test-More/test-more/issues','Test2::Event::Skip'=>'http://github.com/Test-More/test-more/issues','Test2::Event::Subtest'=>'http://github.com/Test-More/test-more/issues','Test2::Event::TAP::Version'=>'http://github.com/Test-More/test-more/issues','Test2::Event::V2'=>'http://github.com/Test-More/test-more/issues','Test2::Event::Waiting'=>'http://github.com/Test-More/test-more/issues','Test2::EventFacet'=>'http://github.com/Test-More/test-more/issues','Test2::EventFacet::About'=>'http://github.com/Test-More/test-more/issues','Test2::EventFacet::Amnesty'=>'http://github.com/Test-More/test-more/issues','Test2::EventFacet::Assert'=>'http://github.com/Test-More/test-more/issues','Test2::EventFacet::Control'=>'http://github.com/Test-More/test-more/issues','Test2::EventFacet::Error'=>'http://github.com/Test-More/test-more/issues','Test2::EventFacet::Hub'=>'http://github.com/Test-More/test-more/issues','Test2::EventFacet::Info'=>'http://github.com/Test-More/test-more/issues','Test2::EventFacet::Info::Table'=>'http://github.com/Test-More/test-more/issues','Test2::EventFacet::Meta'=>'http://github.com/Test-More/test-more/issues','Test2::EventFacet::Parent'=>'http://github.com/Test-More/test-more/issues','Test2::EventFacet::Plan'=>'http://github.com/Test-More/test-more/issues','Test2::EventFacet::Render'=>'http://github.com/Test-More/test-more/issues','Test2::EventFacet::Trace'=>'http://github.com/Test-More/test-more/issues','Test2::Formatter'=>'http://github.com/Test-More/test-more/issues','Test2::Formatter::TAP'=>'http://github.com/Test-More/test-more/issues','Test2::Hub'=>'http://github.com/Test-More/test-more/issues','Test2::Hub::Interceptor'=>'http://github.com/Test-More/test-more/issues','Test2::Hub::Interceptor::Terminator'=>'http://github.com/Test-More/test-more/issues','Test2::Hub::Subtest'=>'http://github.com/Test-More/test-more/issues','Test2::IPC'=>'http://github.com/Test-More/test-more/issues','Test2::IPC::Driver'=>'http://github.com/Test-More/test-more/issues','Test2::IPC::Driver::Files'=>'http://github.com/Test-More/test-more/issues','Test2::Tools::Tiny'=>'http://github.com/Test-More/test-more/issues','Test2::Util'=>'http://github.com/Test-More/test-more/issues','Test2::Util::ExternalMeta'=>'http://github.com/Test-More/test-more/issues','Test2::Util::Facets2Legacy'=>'http://github.com/Test-More/test-more/issues','Test2::Util::HashBase'=>'http://github.com/Test-More/test-more/issues','Test2::Util::Trace'=>'http://github.com/Test-More/test-more/issues','Test::Builder'=>'http://github.com/Test-More/test-more/issues','Test::Builder::Formatter'=>'http://github.com/Test-More/test-more/issues','Test::Builder::IO::Scalar'=>'http://github.com/Test-More/test-more/issues','Test::Builder::Module'=>'http://github.com/Test-More/test-more/issues','Test::Builder::Tester'=>'http://github.com/Test-More/test-more/issues','Test::Builder::Tester::Color'=>'http://github.com/Test-More/test-more/issues','Test::Builder::TodoDiag'=>'http://github.com/Test-More/test-more/issues','Test::Harness'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=Test-Harness','Test::More'=>'http://github.com/Test-More/test-more/issues','Test::Simple'=>'http://github.com/Test-More/test-more/issues','Test::Tester'=>'http://github.com/Test-More/test-more/issues','Test::Tester::Capture'=>'http://github.com/Test-More/test-more/issues','Test::Tester::CaptureRunner'=>'http://github.com/Test-More/test-more/issues','Test::Tester::Delegate'=>'http://github.com/Test-More/test-more/issues','Test::use::ok'=>'http://github.com/Test-More/test-more/issues','Text::Balanced'=>undef,'Text::ParseWords'=>undef,'Text::Tabs'=>undef,'Text::Wrap'=>undef,'Tie::RefHash'=>undef,'Time::Local'=>'https://github.com/houseabsolute/Time-Local/issues','Time::Piece'=>undef,'Time::Seconds'=>undef,'Unicode::Collate'=>undef,'Unicode::Collate::CJK::Big5'=>undef,'Unicode::Collate::CJK::GB2312'=>undef,'Unicode::Collate::CJK::JISX0208'=>undef,'Unicode::Collate::CJK::Korean'=>undef,'Unicode::Collate::CJK::Pinyin'=>undef,'Unicode::Collate::CJK::Stroke'=>undef,'Unicode::Collate::CJK::Zhuyin'=>undef,'Unicode::Collate::Locale'=>undef,'Win32'=>'https://github.com/perl-libwin32/win32/issues','Win32API::File'=>undef,'Win32API::File::inc::ExtUtils::Myconst2perl'=>undef,'autodie'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie','autodie::Scope::Guard'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie','autodie::Scope::GuardStack'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie','autodie::Util'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie','autodie::exception'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie','autodie::exception::system'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie','autodie::hints'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie','autodie::skip'=>'http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie','bigint'=>undef,'bignum'=>undef,'bigrat'=>undef,'encoding'=>undef,'experimental'=>'http://rt.cpan.org/Public/Dist/Display.html?Name=experimental','ok'=>'http://github.com/Test-More/test-more/issues','parent'=>undef,'perlfaq'=>'https://github.com/perl-doc-cats/perlfaq/issues','version'=>'https://rt.cpan.org/Public/Dist/Display.html?Name=version','version::regex'=>'https://rt.cpan.org/Public/Dist/Display.html?Name=version',);$released{'5.000'}=$released{5};$version{'5.000'}=$version{5};_create_aliases(\%delta);_create_aliases(\%released);_create_aliases(\%version);_create_aliases(\%deprecated);sub _create_aliases {my ($hash)=@_;for my$version (keys %$hash){next unless$version >= 5.006;my$padded=sprintf "%0.6f",$version;if ($padded ne $version && $version==$padded){$hash->{$padded}=$hash->{$version}}}}1;
MODULE_CORELIST

$fatpacked{"Module/CoreList/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CORELIST_UTILS';
  package Module::CoreList::Utils;use strict;use warnings;use Module::CoreList;our$VERSION='5.20191120';our%utilities;sub utilities {my$perl=shift;$perl=shift if eval {$perl->isa(__PACKAGE__)};return unless$perl or exists$utilities{$perl};return sort keys %{$utilities{$perl}}}sub _released_order {(substr($Module::CoreList::released{$a},0,1)eq "?")? ((substr($Module::CoreList::released{$b},0,1)eq "?")? 0 : 1): ((substr($Module::CoreList::released{$b},0,1)eq "?")? -1 : $Module::CoreList::released{$a}cmp $Module::CoreList::released{$b})}sub first_release_raw {my$util=shift;$util=shift if eval {$util->isa(__PACKAGE__)};my$version=shift;my@perls=$version ? grep {exists$utilities{$_}{$util }&& $utilities{$_}{$util }ge $version}keys%utilities : grep {exists$utilities{$_}{$util }}keys%utilities;return grep {exists$Module::CoreList::released{$_}}@perls}sub first_release_by_date {my@perls=&first_release_raw;return unless@perls;return (sort _released_order@perls)[0]}sub first_release {my@perls=&first_release_raw;return unless@perls;return (sort {$a cmp $b}@perls)[0]}sub removed_from {my@perls=&removed_raw;return shift@perls}sub removed_from_by_date {my@perls=sort _released_order&removed_raw;return shift@perls}sub removed_raw {my$util=shift;$util=shift if eval {$util->isa(__PACKAGE__)};return unless my@perls=sort {$a cmp $b}first_release_raw($util);@perls=grep {exists$Module::CoreList::released{$_}}@perls;my$last=pop@perls;my@removed=grep {$_ > $last}sort {$a cmp $b}keys%utilities;return@removed}my%delta=(5=>{changed=>{'a2p'=>'1','c2ph'=>'1','cppstdin'=>'1','find2perl'=>'1','pstruct'=>'1','s2p'=>'1',},removed=>{}},5.001=>{delta_from=>5,changed=>{'h2xs'=>'1',},removed=>{}},5.002=>{delta_from=>5.001,changed=>{'h2ph'=>'1','perlbug'=>'1','perldoc'=>'1','pod2html'=>'1','pod2latex'=>'1','pod2man'=>'1','pod2text'=>'1',},removed=>{}},5.00307=>{delta_from=>5.002,changed=>{'pl2pm'=>'1',},removed=>{'cppstdin'=>1,'pstruct'=>1,}},5.004=>{delta_from=>5.00307,changed=>{'splain'=>'1',},removed=>{}},5.005=>{delta_from=>5.00405,changed=>{'perlcc'=>'1',},removed=>{}},5.00503=>{delta_from=>5.005,changed=>{},removed=>{}},5.00405=>{delta_from=>5.004,changed=>{},removed=>{}},5.006=>{delta_from=>5.00504,changed=>{'dprofpp'=>'1','pod2usage'=>'1','podchecker'=>'1','podselect'=>'1','pstruct'=>'1',},removed=>{}},5.006001=>{delta_from=>5.006,changed=>{},removed=>{}},5.007003=>{delta_from=>5.006002,changed=>{'libnetcfg'=>'1','perlivp'=>'1','psed'=>'1','xsubpp'=>'1',},removed=>{}},5.008=>{delta_from=>5.007003,changed=>{'enc2xs'=>'1','piconv'=>'1',},removed=>{}},5.008001=>{delta_from=>5.008,changed=>{'cpan'=>'1',},removed=>{}},5.009=>{delta_from=>5.008009,changed=>{},removed=>{'corelist'=>1,'instmodsh'=>1,'prove'=>1,}},5.008002=>{delta_from=>5.008001,changed=>{},removed=>{}},5.006002=>{delta_from=>5.006001,changed=>{},removed=>{}},5.008003=>{delta_from=>5.008002,changed=>{'instmodsh'=>'1','prove'=>'1',},removed=>{}},5.00504=>{delta_from=>5.00503,changed=>{},removed=>{}},5.009001=>{delta_from=>5.009,changed=>{'instmodsh'=>'1','prove'=>'1',},removed=>{}},5.008004=>{delta_from=>5.008003,changed=>{},removed=>{}},5.008005=>{delta_from=>5.008004,changed=>{},removed=>{}},5.008006=>{delta_from=>5.008005,changed=>{},removed=>{}},5.009002=>{delta_from=>5.009001,changed=>{'corelist'=>'1',},removed=>{}},5.008007=>{delta_from=>5.008006,changed=>{},removed=>{}},5.009003=>{delta_from=>5.009002,changed=>{'ptar'=>'1','ptardiff'=>'1','shasum'=>'1',},removed=>{}},5.008008=>{delta_from=>5.008007,changed=>{},removed=>{}},5.009004=>{delta_from=>5.009003,changed=>{'config_data'=>'1',},removed=>{}},5.009005=>{delta_from=>5.009004,changed=>{'cpan2dist'=>'1','cpanp'=>'1','cpanp-run-perl'=>'1',},removed=>{'perlcc'=>1,}},5.010000=>{delta_from=>5.009005,changed=>{},removed=>{}},5.008009=>{delta_from=>5.008008,changed=>{'corelist'=>'1',},removed=>{}},5.010001=>{delta_from=>5.010000,changed=>{},removed=>{}},5.011=>{delta_from=>5.010001,changed=>{},removed=>{}},5.011001=>{delta_from=>5.011,changed=>{},removed=>{}},5.011002=>{delta_from=>5.011001,changed=>{'perlthanks'=>'1',},removed=>{}},5.011003=>{delta_from=>5.011002,changed=>{},removed=>{}},5.011004=>{delta_from=>5.011003,changed=>{},removed=>{}},5.011005=>{delta_from=>5.011004,changed=>{},removed=>{}},5.012=>{delta_from=>5.011005,changed=>{},removed=>{}},5.013=>{delta_from=>5.012005,changed=>{},removed=>{}},5.012001=>{delta_from=>5.012,changed=>{},removed=>{}},5.013001=>{delta_from=>5.013,changed=>{},removed=>{}},5.013002=>{delta_from=>5.013001,changed=>{},removed=>{}},5.013003=>{delta_from=>5.013002,changed=>{},removed=>{}},5.013004=>{delta_from=>5.013003,changed=>{},removed=>{}},5.012002=>{delta_from=>5.012001,changed=>{},removed=>{}},5.013005=>{delta_from=>5.013004,changed=>{},removed=>{}},5.013006=>{delta_from=>5.013005,changed=>{},removed=>{}},5.013007=>{delta_from=>5.013006,changed=>{'ptargrep'=>'1',},removed=>{}},5.013008=>{delta_from=>5.013007,changed=>{},removed=>{}},5.013009=>{delta_from=>5.013008,changed=>{'json_pp'=>'1',},removed=>{}},5.012003=>{delta_from=>5.012002,changed=>{},removed=>{}},5.013010=>{delta_from=>5.013009,changed=>{},removed=>{}},5.013011=>{delta_from=>5.013010,changed=>{},removed=>{}},5.014=>{delta_from=>5.013011,changed=>{},removed=>{}},5.014001=>{delta_from=>5.014,changed=>{},removed=>{}},5.015=>{delta_from=>5.014004,changed=>{},removed=>{'dprofpp'=>1,}},5.012004=>{delta_from=>5.012003,changed=>{},removed=>{}},5.015001=>{delta_from=>5.015,changed=>{},removed=>{}},5.015002=>{delta_from=>5.015001,changed=>{},removed=>{}},5.015003=>{delta_from=>5.015002,changed=>{},removed=>{}},5.014002=>{delta_from=>5.014001,changed=>{},removed=>{}},5.015004=>{delta_from=>5.015003,changed=>{},removed=>{}},5.015005=>{delta_from=>5.015004,changed=>{},removed=>{}},5.015006=>{delta_from=>5.015005,changed=>{'zipdetails'=>'1',},removed=>{}},5.015007=>{delta_from=>5.015006,changed=>{},removed=>{}},5.015008=>{delta_from=>5.015007,changed=>{},removed=>{}},5.015009=>{delta_from=>5.015008,changed=>{},removed=>{}},5.016=>{delta_from=>5.015009,changed=>{},removed=>{}},5.017=>{delta_from=>5.016003,changed=>{},removed=>{}},5.017001=>{delta_from=>5.017,changed=>{},removed=>{}},5.017002=>{delta_from=>5.017001,changed=>{},removed=>{}},5.016001=>{delta_from=>5.016,changed=>{},removed=>{}},5.017003=>{delta_from=>5.017002,changed=>{},removed=>{}},5.017004=>{delta_from=>5.017003,changed=>{},removed=>{}},5.014003=>{delta_from=>5.014002,changed=>{},removed=>{}},5.017005=>{delta_from=>5.017004,changed=>{},removed=>{}},5.016002=>{delta_from=>5.016001,changed=>{},removed=>{}},5.012005=>{delta_from=>5.012004,changed=>{},removed=>{}},5.017006=>{delta_from=>5.017005,changed=>{},removed=>{}},5.017007=>{delta_from=>5.017006,changed=>{},removed=>{}},5.017008=>{delta_from=>5.017007,changed=>{},removed=>{}},5.017009=>{delta_from=>5.017008,changed=>{},removed=>{}},5.014004=>{delta_from=>5.014003,changed=>{},removed=>{}},5.016003=>{delta_from=>5.016002,changed=>{},removed=>{}},5.017010=>{delta_from=>5.017009,changed=>{},removed=>{}},5.017011=>{delta_from=>5.017010,changed=>{},removed=>{}},5.018000=>{delta_from=>5.017011,changed=>{},removed=>{}},5.018001=>{delta_from=>5.018000,changed=>{},removed=>{}},5.018002=>{delta_from=>5.018001,changed=>{},removed=>{}},5.018003=>{delta_from=>5.018000,changed=>{},removed=>{}},5.018004=>{delta_from=>5.018000,changed=>{},removed=>{}},5.019000=>{delta_from=>5.018000,changed=>{},removed=>{'cpan2dist'=>'1','cpanp'=>'1','cpanp-run-perl'=>'1','pod2latex'=>'1',}},5.019001=>{delta_from=>5.019000,changed=>{},removed=>{}},5.019002=>{delta_from=>5.019001,changed=>{},removed=>{}},5.019003=>{delta_from=>5.019002,changed=>{},removed=>{}},5.019004=>{delta_from=>5.019003,changed=>{},removed=>{}},5.019005=>{delta_from=>5.019004,changed=>{},removed=>{}},5.019006=>{delta_from=>5.019005,changed=>{},removed=>{}},5.019007=>{delta_from=>5.019006,changed=>{},removed=>{}},5.019008=>{delta_from=>5.019007,changed=>{},removed=>{}},5.019009=>{delta_from=>5.019008,changed=>{},removed=>{}},5.019010=>{delta_from=>5.019009,changed=>{},removed=>{}},5.019011=>{delta_from=>5.019010,changed=>{},removed=>{}},5.020000=>{delta_from=>5.019011,changed=>{},removed=>{}},5.021000=>{delta_from=>5.020000,changed=>{},removed=>{}},5.021001=>{delta_from=>5.021000,changed=>{},removed=>{'a2p'=>1,'config_data'=>1,'find2perl'=>1,'psed'=>1,'s2p'=>1,}},5.021002=>{delta_from=>5.021001,changed=>{},removed=>{}},5.021003=>{delta_from=>5.021002,changed=>{},removed=>{}},5.020001=>{delta_from=>5.02,changed=>{},removed=>{}},5.021004=>{delta_from=>5.021003,changed=>{},removed=>{}},5.021005=>{delta_from=>5.021004,changed=>{},removed=>{}},5.021006=>{delta_from=>5.021005,changed=>{},removed=>{}},5.021007=>{delta_from=>5.021006,changed=>{},removed=>{}},5.021008=>{delta_from=>5.021007,changed=>{},removed=>{}},5.020002=>{delta_from=>5.020001,changed=>{},removed=>{}},5.021009=>{delta_from=>5.021008,changed=>{'encguess'=>'1',},removed=>{}},5.021010=>{delta_from=>5.021009,changed=>{},removed=>{}},5.021011=>{delta_from=>5.02101,changed=>{},removed=>{}},5.022000=>{delta_from=>5.021011,changed=>{},removed=>{}},5.023000=>{delta_from=>5.022000,changed=>{},removed=>{}},5.023001=>{delta_from=>5.023,changed=>{},removed=>{}},5.023002=>{delta_from=>5.023001,changed=>{},removed=>{}},5.020003=>{delta_from=>5.020002,changed=>{},removed=>{}},5.023003=>{delta_from=>5.023002,changed=>{},removed=>{}},5.023004=>{delta_from=>5.023003,changed=>{},removed=>{}},5.023005=>{delta_from=>5.023004,changed=>{},removed=>{}},5.022001=>{delta_from=>5.022,changed=>{},removed=>{}},5.023006=>{delta_from=>5.023005,changed=>{},removed=>{}},5.023007=>{delta_from=>5.023006,changed=>{},removed=>{}},5.023008=>{delta_from=>5.023007,changed=>{},removed=>{}},5.023009=>{delta_from=>5.023008,changed=>{},removed=>{}},5.022002=>{delta_from=>5.022001,changed=>{},removed=>{}},5.024000=>{delta_from=>5.023009,changed=>{},removed=>{}},5.025000=>{delta_from=>5.024000,changed=>{},removed=>{}},5.025001=>{delta_from=>5.025000,changed=>{},removed=>{}},5.025002=>{delta_from=>5.025001,changed=>{},removed=>{}},5.025003=>{delta_from=>5.025002,changed=>{},removed=>{}},5.025004=>{delta_from=>5.025003,changed=>{},removed=>{}},5.025005=>{delta_from=>5.025004,changed=>{},removed=>{}},5.025006=>{delta_from=>5.025005,changed=>{},removed=>{}},5.025007=>{delta_from=>5.025006,changed=>{},removed=>{}},5.025008=>{delta_from=>5.025007,changed=>{},removed=>{}},5.022003=>{delta_from=>5.022002,changed=>{},removed=>{}},5.024001=>{delta_from=>5.024000,changed=>{},removed=>{}},5.025009=>{delta_from=>5.025008,changed=>{},removed=>{'c2ph'=>1,'pstruct'=>1,}},5.025010=>{delta_from=>5.025009,changed=>{},removed=>{}},5.025011=>{delta_from=>5.025010,changed=>{},removed=>{}},5.025012=>{delta_from=>5.025011,changed=>{},removed=>{}},5.026000=>{delta_from=>5.025012,changed=>{},removed=>{}},5.027000=>{delta_from=>5.026000,changed=>{},removed=>{}},5.027001=>{delta_from=>5.027000,changed=>{},removed=>{}},5.022004=>{delta_from=>5.022003,changed=>{},removed=>{}},5.024002=>{delta_from=>5.024001,changed=>{},removed=>{}},5.027002=>{delta_from=>5.027001,changed=>{},removed=>{}},5.027003=>{delta_from=>5.027002,changed=>{},removed=>{}},5.027004=>{delta_from=>5.027003,changed=>{},removed=>{}},5.024003=>{delta_from=>5.024002,changed=>{},removed=>{}},5.026001=>{delta_from=>5.026000,changed=>{},removed=>{}},5.027005=>{delta_from=>5.027004,changed=>{},removed=>{}},5.027006=>{delta_from=>5.027005,changed=>{},removed=>{}},5.027007=>{delta_from=>5.027006,changed=>{},removed=>{}},5.027008=>{delta_from=>5.027007,changed=>{},removed=>{}},5.027009=>{delta_from=>5.027008,changed=>{},removed=>{}},5.027010=>{delta_from=>5.027009,changed=>{},removed=>{}},5.024004=>{delta_from=>5.024003,changed=>{},removed=>{}},5.026002=>{delta_from=>5.026001,changed=>{},removed=>{}},5.027011=>{delta_from=>5.027010,changed=>{},removed=>{}},5.028000=>{delta_from=>5.027011,changed=>{},removed=>{}},5.029000=>{delta_from=>5.028,changed=>{},removed=>{}},5.029001=>{delta_from=>5.029000,changed=>{},removed=>{}},5.029002=>{delta_from=>5.029001,changed=>{},removed=>{}},5.029003=>{delta_from=>5.029002,changed=>{},removed=>{}},5.029004=>{delta_from=>5.029003,changed=>{},removed=>{}},5.029005=>{delta_from=>5.029004,changed=>{},removed=>{}},5.026003=>{delta_from=>5.026002,changed=>{},removed=>{}},5.028001=>{delta_from=>5.028000,changed=>{},removed=>{}},5.029006=>{delta_from=>5.029005,changed=>{},removed=>{}},5.029007=>{delta_from=>5.029006,changed=>{},removed=>{}},5.029008=>{delta_from=>5.029007,changed=>{},removed=>{}},5.029009=>{delta_from=>5.029008,changed=>{},removed=>{}},5.028002=>{delta_from=>5.028001,changed=>{},removed=>{}},5.029010=>{delta_from=>5.029009,changed=>{},removed=>{}},5.030000=>{delta_from=>5.029010,changed=>{},removed=>{}},5.031000=>{delta_from=>5.03,changed=>{},removed=>{}},5.031001=>{delta_from=>5.031,changed=>{},removed=>{'podselect'=>1,}},5.031002=>{delta_from=>5.031001,changed=>{},removed=>{}},5.031003=>{delta_from=>5.031002,changed=>{},removed=>{}},5.031004=>{delta_from=>5.031003,changed=>{},removed=>{}},5.031005=>{delta_from=>5.031004,changed=>{},removed=>{}},5.030001=>{delta_from=>5.03,changed=>{},removed=>{}},5.031006=>{delta_from=>5.031005,changed=>{'streamzip'=>'1',},removed=>{}},);%utilities=Module::CoreList::_undelta(\%delta);$utilities{'5.000'}=$utilities{5};_create_aliases(\%utilities);sub _create_aliases {my ($hash)=@_;for my$version (keys %$hash){next unless$version >= 5.010;my$padded=sprintf "%0.6f",$version;if ($padded ne $version && $version==$padded){$hash->{$padded}=$hash->{$version}}}}'foo';
MODULE_CORELIST_UTILS

$fatpacked{"Module/Load.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_LOAD';
  package Module::Load;$VERSION='0.34';use strict;use warnings;use File::Spec ();sub import {my$who=_who();my$h;shift;{no strict 'refs';@_ or (*{"${who}::load"}=\&load,*{"${who}::autoload"}=\&autoload,return);map {$h->{$_}=()if defined $_}@_;(exists$h->{none}or exists$h->{''})and shift,last;((exists$h->{autoload}and shift,1)or (exists$h->{all}and shift))and *{"${who}::autoload"}=\&autoload;((exists$h->{load}and shift,1)or exists$h->{all})and *{"${who}::load"}=\&load;((exists$h->{load_remote}and shift,1)or exists$h->{all})and *{"${who}::load_remote"}=\&load_remote;((exists$h->{autoload_remote}and shift,1)or exists$h->{all})and *{"${who}::autoload_remote"}=\&autoload_remote}}sub load(*;@){goto&_load}sub autoload(*;@){unshift @_,'autoimport';goto&_load}sub load_remote($$;@){my ($dst,$src,@exp)=@_;eval "package $dst;Module::Load::load('$src', qw/@exp/);";$@ && die "$@"}sub autoload_remote($$;@){my ($dst,$src,@exp)=@_;eval "package $dst;Module::Load::autoload('$src', qw/@exp/);";$@ && die "$@"}sub _load{my$autoimport=$_[0]eq 'autoimport' and shift;my$mod=shift or return;my$who=_who();if(_is_file($mod)){require$mod}else {LOAD: {my$err;for my$flag (qw[1 0]){my$file=_to_file($mod,$flag);eval {require$file};$@ ? $err .= $@ : last LOAD}die$err if$err}}{no strict 'refs';my$import;((@_ or $autoimport)and ($import=$mod->can('import'))and (unshift(@_,$mod),goto &$import))}}sub _to_file{local $_=shift;my$pm=shift || '';my@parts=split /::|'/,$_,-1;shift@parts if@parts &&!$parts[0];my$file=$^O eq 'MSWin32' ? join "/",@parts : File::Spec->catfile(@parts);$file .= '.pm' if$pm;$file=VMS::Filespec::unixify($file)if $^O eq 'VMS';return$file}sub _who {(caller(1))[0]}sub _is_file {local $_=shift;return /^\./ ? 1 : /[^\w:']/ ? 1 : undef}1;
MODULE_LOAD

$fatpacked{"Module/Load/Conditional.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_LOAD_CONDITIONAL';
  package Module::Load::Conditional;use strict;use Module::Load qw/load autoload_remote/;use Params::Check qw[check];use Locale::Maketext::Simple Style=>'gettext';use Carp ();use File::Spec ();use FileHandle ();use version;use Module::Metadata ();use constant ON_VMS=>$^O eq 'VMS';use constant ON_WIN32=>$^O eq 'MSWin32' ? 1 : 0;use constant QUOTE=>do {ON_WIN32 ? q["] : q[']};BEGIN {use vars qw[$VERSION @ISA $VERBOSE $CACHE @EXPORT_OK $DEPRECATED $FIND_VERSION $ERROR $CHECK_INC_HASH $FORCE_SAFE_INC];use Exporter;@ISA=qw[Exporter];$VERSION='0.70';$VERBOSE=0;$DEPRECATED=0;$FIND_VERSION=1;$CHECK_INC_HASH=0;$FORCE_SAFE_INC=0;@EXPORT_OK=qw[check_install can_load requires]}sub check_install {my%hash=@_;my$tmpl={version=>{default=>'0.0' },module=>{required=>1 },verbose=>{default=>$VERBOSE },};my$args;unless($args=check($tmpl,\%hash,$VERBOSE)){warn loc(q[A problem occurred checking arguments])if$VERBOSE;return}my$file=File::Spec->catfile(split /::/,$args->{module}).'.pm';my$file_inc=File::Spec::Unix->catfile(split /::/,$args->{module}).'.pm';my$href={file=>undef,version=>undef,uptodate=>undef,};my$filename;if($CHECK_INC_HASH){$filename=$href->{'file'}=$INC{$file_inc }if defined$INC{$file_inc };if(defined$filename && $FIND_VERSION){no strict 'refs';$href->{version}=${"$args->{module}"."::VERSION"}}}unless($filename){local@INC=@INC[0..$#INC-1]if$FORCE_SAFE_INC && $INC[-1]eq '.';DIR: for my$dir (@INC){my$fh;if (ref$dir){my$existed_in_inc=$INC{$file_inc};if (UNIVERSAL::isa($dir,'CODE')){($fh)=$dir->($dir,$file)}elsif (UNIVERSAL::isa($dir,'ARRAY')){($fh)=$dir->[0]->($dir,$file,@{$dir}{1..$#{$dir}})}elsif (UNIVERSAL::can($dir,'INC')){($fh)=$dir->INC($file)}if (!UNIVERSAL::isa($fh,'GLOB')){warn loc(q[Cannot open file '%1': %2],$file,$!)if$args->{verbose};next}$filename=$INC{$file_inc}|| $file;delete$INC{$file_inc}if not $existed_in_inc}else {$filename=File::Spec->catfile($dir,$file);next unless -e $filename;$fh=new FileHandle;if (!$fh->open($filename)){warn loc(q[Cannot open file '%1': %2],$file,$!)if$args->{verbose};next}}$href->{dir}=$dir;$href->{file}=ON_VMS ? VMS::Filespec::unixify($filename): $filename;last DIR unless$FIND_VERSION;{local$SIG{__WARN__}=sub {};my$ver=eval {my$mod_info=Module::Metadata->new_from_handle($fh,$filename);$mod_info->version($args->{module})};if(defined$ver){$href->{version}=$ver;last DIR}}}}return unless defined$href->{file};if($FIND_VERSION and not defined$href->{version}){{local $^W;warn loc(q[Could not check version on '%1'],$args->{module})if$args->{verbose}and $args->{version}> 0}$href->{uptodate}=1}else {local $^W;eval {$href->{uptodate}=version->new($args->{version})<= version->new($href->{version})? 1 : 0}}if ($DEPRECATED and "$]" >= 5.011){local@INC=@INC[0..$#INC-1]if$FORCE_SAFE_INC && $INC[-1]eq '.';require Module::CoreList;require Config;$href->{uptodate}=0 if exists$Module::CoreList::version{0+$] }{$args->{module}}and Module::CoreList::is_deprecated($args->{module})and $Config::Config{privlibexp}eq $href->{dir}and $Config::Config{privlibexp}ne $Config::Config{sitelibexp}}return$href}sub can_load {my%hash=@_;my$tmpl={modules=>{default=>{},strict_type=>1 },verbose=>{default=>$VERBOSE },nocache=>{default=>0 },autoload=>{default=>0 },};my$args;unless($args=check($tmpl,\%hash,$VERBOSE)){$ERROR=loc(q[Problem validating arguments!]);warn$ERROR if$VERBOSE;return}$CACHE ||= {};my$error;BLOCK: {my$href=$args->{modules};my@load;for my$mod (keys %$href){next if$CACHE->{$mod}->{usable}&&!$args->{nocache};if (!$args->{nocache}&& defined$CACHE->{$mod}->{usable}&& (version->new($CACHE->{$mod}->{version}||0)>= version->new($href->{$mod}))){$error=loc(q[Already tried to use '%1', which was unsuccessful],$mod);last BLOCK}my$mod_data=check_install(module=>$mod,version=>$href->{$mod});if(!$mod_data or!defined$mod_data->{file}){$error=loc(q[Could not find or check module '%1'],$mod);$CACHE->{$mod}->{usable}=0;last BLOCK}map {$CACHE->{$mod}->{$_}=$mod_data->{$_}}qw[version file uptodate];push@load,$mod}for my$mod (@load){if ($CACHE->{$mod}->{uptodate}){local@INC=@INC[0..$#INC-1]if$FORCE_SAFE_INC && $INC[-1]eq '.';if ($args->{autoload}){my$who=(caller())[0];eval {autoload_remote$who,$mod}}else {eval {load$mod}}if($@){$error=$@;$CACHE->{$mod}->{usable}=0;last BLOCK}else {$CACHE->{$mod}->{usable}=1}}else {$error=loc(q[Module '%1' is not uptodate!],$mod);$CACHE->{$mod}->{usable}=0;last BLOCK}}}if(defined$error){$ERROR=$error;Carp::carp(loc(q|%1 [THIS MAY BE A PROBLEM!]|,$error))if$args->{verbose};return}else {return 1}}sub requires {my$who=shift;unless(check_install(module=>$who)){warn loc(q[You do not have module '%1' installed],$who)if$VERBOSE;return undef}local@INC=@INC[0..$#INC-1]if$FORCE_SAFE_INC && $INC[-1]eq '.';my$lib=join " ",map {qq["-I$_"]}@INC;my$oneliner='print(join(qq[\n],map{qq[BONG=$_]}keys(%INC)),qq[\n])';my$cmd=join '',qq["$^X" $lib -M$who -e],QUOTE,$oneliner,QUOTE;return sort grep {!/^$who$/}map {chomp;s|/|::|g;$_}grep {s|\.pm$||i}map {s!^BONG\=!!;$_}grep {m!^BONG\=!}`$cmd`}1;
MODULE_LOAD_CONDITIONAL

$fatpacked{"Module/Metadata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_METADATA';
  package Module::Metadata;sub __clean_eval {eval $_[0]}use strict;use warnings;our$VERSION='1.000037';use Carp qw/croak/;use File::Spec;BEGIN {eval {require Fcntl;Fcntl->import('SEEK_SET');1}or *SEEK_SET=sub {0}}use version 0.87;BEGIN {if ($INC{'Log/Contextual.pm'}){require "Log/Contextual/WarnLogger.pm";Log::Contextual->import('log_info','-default_logger'=>Log::Contextual::WarnLogger->new({env_prefix=>'MODULE_METADATA',}),)}else {*log_info=sub (&) {warn $_[0]->()}}}use File::Find qw(find);my$V_NUM_REGEXP=qr{v?[0-9._]+};my$PKG_FIRST_WORD_REGEXP=qr{ # the FIRST word in a package name
    [a-zA-Z_]                     # the first word CANNOT start with a digit
      (?:
        [\w']?                    # can contain letters, digits, _, or ticks
        \w                        # But, NO multi-ticks or trailing ticks
      )*
  }x;my$PKG_ADDL_WORD_REGEXP=qr{ # the 2nd+ word in a package name
    \w                           # the 2nd+ word CAN start with digits
      (?:
        [\w']?                   # and can contain letters or ticks
        \w                       # But, NO multi-ticks or trailing ticks
      )*
  }x;my$PKG_NAME_REGEXP=qr{ # match a package name
    (?: :: )?               # a pkg name can start with arisdottle
    $PKG_FIRST_WORD_REGEXP  # a package word
    (?:
      (?: :: )+             ### arisdottle (allow one or many times)
      $PKG_ADDL_WORD_REGEXP ### a package word
    )*                      # ^ zero, one or many times
    (?:
      ::                    # allow trailing arisdottle
    )?
  }x;my$PKG_REGEXP=qr{   # match a package declaration
    ^[\s\{;]*             # intro chars on a line
    package               # the word 'package'
    \s+                   # whitespace
    ($PKG_NAME_REGEXP)    # a package name
    \s*                   # optional whitespace
    ($V_NUM_REGEXP)?        # optional version number
    \s*                   # optional whitesapce
    [;\{]                 # semicolon line terminator or block start (since 5.16)
  }x;my$VARNAME_REGEXP=qr{ # match fully-qualified VERSION name
    ([\$*])         # sigil - $ or *
    (
      (             # optional leading package name
        (?:::|\')?  # possibly starting like just :: (a la $::VERSION)
        (?:\w+(?:::|\'))*  # Foo::Bar:: ...
      )?
      VERSION
    )\b
  }x;my$VERS_REGEXP=qr{ # match a VERSION definition
    (?:
      \(\s*$VARNAME_REGEXP\s*\) # with parens
    |
      $VARNAME_REGEXP           # without parens
    )
    \s*
    =[^=~>]  # = but not ==, nor =~, nor =>
  }x;sub new_from_file {my$class=shift;my$filename=File::Spec->rel2abs(shift);return undef unless defined($filename)&& -f $filename;return$class->_init(undef,$filename,@_)}sub new_from_handle {my$class=shift;my$handle=shift;my$filename=shift;return undef unless defined($handle)&& defined($filename);$filename=File::Spec->rel2abs($filename);return$class->_init(undef,$filename,@_,handle=>$handle)}sub new_from_module {my$class=shift;my$module=shift;my%props=@_;$props{inc}||= \@INC;my$filename=$class->find_module_by_name($module,$props{inc});return undef unless defined($filename)&& -f $filename;return$class->_init($module,$filename,%props)}{my$compare_versions=sub {my ($v1,$op,$v2)=@_;$v1=version->new($v1)unless UNIVERSAL::isa($v1,'version');my$eval_str="\$v1 $op \$v2";my$result=eval$eval_str;log_info {"error comparing versions: '$eval_str' $@"}if $@;return$result};my$normalize_version=sub {my ($version)=@_;if ($version =~ /[=<>!,]/){}elsif (ref$version eq 'version'){$version=$version->is_qv ? $version->normal : $version->stringify}elsif ($version =~ /^[^v][^.]*\.[^.]+\./){$version="v$version"}else {}return$version};my$resolve_module_versions=sub {my$packages=shift;my($file,$version);my$err='';for my$p (@$packages){if (defined($p->{version})){if (defined($version)){if ($compare_versions->($version,'!=',$p->{version})){$err .= "  $p->{file} ($p->{version})\n"}else {}}else {$file=$p->{file};$version=$p->{version}}}$file ||= $p->{file}if defined($p->{file})}if ($err){$err="  $file ($version)\n" .$err}my%result=(file=>$file,version=>$version,err=>$err);return \%result};sub provides {my$class=shift;croak "provides() requires key/value pairs \n" if @_ % 2;my%args=@_;croak "provides() takes only one of 'dir' or 'files'\n" if$args{dir}&& $args{files};croak "provides() requires a 'version' argument" unless defined$args{version};croak "provides() does not support version '$args{version}' metadata" unless grep$args{version}eq $_,qw/1.4 2/;$args{prefix}='lib' unless defined$args{prefix};my$p;if ($args{dir}){$p=$class->package_versions_from_directory($args{dir})}else {croak "provides() requires 'files' to be an array reference\n" unless ref$args{files}eq 'ARRAY';$p=$class->package_versions_from_directory($args{files})}if (length$args{prefix}){$args{prefix}=~ s{/$}{};for my$v (values %$p){$v->{file}="$args{prefix}/$v->{file}"}}return$p}sub package_versions_from_directory {my ($class,$dir,$files)=@_;my@files;if ($files){@files=@$files}else {find({wanted=>sub {push@files,$_ if -f $_ && /\.pm$/},no_chdir=>1,},$dir)}my(%prime,%alt);for my$file (@files){my$mapped_filename=File::Spec->abs2rel($file,$dir);my@path=File::Spec->splitdir($mapped_filename);(my$prime_package=join('::',@path))=~ s/\.pm$//;my$pm_info=$class->new_from_file($file);for my$package ($pm_info->packages_inside){next if$package eq 'main';next if$package eq 'DB';next if grep /^_/,split(/::/,$package);my$version=$pm_info->version($package);$prime_package=$package if lc($prime_package)eq lc($package);if ($package eq $prime_package){if (exists($prime{$package})){croak "Unexpected conflict in '$package'; multiple versions found.\n"}else {$mapped_filename="$package.pm" if lc("$package.pm")eq lc($mapped_filename);$prime{$package}{file}=$mapped_filename;$prime{$package}{version}=$version if defined($version)}}else {push(@{$alt{$package}},{file=>$mapped_filename,version=>$version,})}}}for my$package (keys(%alt)){my$result=$resolve_module_versions->($alt{$package});if (exists($prime{$package})){if ($result->{err}){log_info {"Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" .$result->{err}}}elsif (defined($result->{version})){if (exists($prime{$package}{version})&& defined($prime{$package}{version})){if ($compare_versions->($prime{$package}{version},'!=',$result->{version})){log_info {"Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" ."  $result->{file} ($result->{version})\n"}}}else {$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}}}else {}}else {if ($result->{err}){log_info {"Found conflicting versions for package '$package'\n" .$result->{err}}}$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}if defined($result->{version})}}for (grep defined $_->{version},values%prime){$_->{version}=$normalize_version->($_->{version})}return \%prime}}sub _init {my$class=shift;my$module=shift;my$filename=shift;my%props=@_;my$handle=delete$props{handle};my(%valid_props,@valid_props);@valid_props=qw(collect_pod inc decode_pod);@valid_props{@valid_props}=delete(@props{@valid_props});warn "Unknown properties: @{[keys %props]}\n" if scalar(%props);my%data=(module=>$module,filename=>$filename,version=>undef,packages=>[],versions=>{},pod=>{},pod_headings=>[],collect_pod=>0,%valid_props,);my$self=bless(\%data,$class);if (not $handle){my$filename=$self->{filename};open$handle,'<',$filename or croak("Can't open '$filename': $!");$self->_handle_bom($handle,$filename)}$self->_parse_fh($handle);@{$self->{packages}}=__uniq(@{$self->{packages}});unless($self->{module}and length($self->{module})){if ($self->{filename}=~ /\.pm$/){my ($v,$d,$f)=File::Spec->splitpath($self->{filename});$f =~ s/\..+$//;my@candidates=grep /(^|::)$f$/,@{$self->{packages}};$self->{module}=shift(@candidates)}else {if ((grep /main/,@{$self->{packages}})or (grep /main/,keys %{$self->{versions}})){$self->{module}='main'}else {$self->{module}=$self->{packages}[0]|| ''}}}$self->{version}=$self->{versions}{$self->{module}}if defined($self->{module});return$self}sub _do_find_module {my$class=shift;my$module=shift || croak 'find_module_by_name() requires a package name';my$dirs=shift || \@INC;my$file=File::Spec->catfile(split(/::/,$module));for my$dir (@$dirs){my$testfile=File::Spec->catfile($dir,$file);return [File::Spec->rel2abs($testfile),$dir ]if -e $testfile and!-d _;$testfile .= '.pm';return [File::Spec->rel2abs($testfile),$dir ]if -e $testfile}return}sub find_module_by_name {my$found=shift()->_do_find_module(@_)or return;return$found->[0]}sub find_module_dir_by_name {my$found=shift()->_do_find_module(@_)or return;return$found->[1]}sub _parse_version_expression {my$self=shift;my$line=shift;my($sigil,$variable_name,$package);if ($line =~ /$VERS_REGEXP/o){($sigil,$variable_name,$package)=$2 ? ($1,$2,$3): ($4,$5,$6);if ($package){$package=($package eq '::')? 'main' : $package;$package =~ s/::$//}}return ($sigil,$variable_name,$package)}sub _handle_bom {my ($self,$fh,$filename)=@_;my$pos=tell$fh;return unless defined$pos;my$buf=' ' x 2;my$count=read$fh,$buf,length$buf;return unless defined$count and $count >= 2;my$encoding;if ($buf eq "\x{FE}\x{FF}"){$encoding='UTF-16BE'}elsif ($buf eq "\x{FF}\x{FE}"){$encoding='UTF-16LE'}elsif ($buf eq "\x{EF}\x{BB}"){$buf=' ';$count=read$fh,$buf,length$buf;if (defined$count and $count >= 1 and $buf eq "\x{BF}"){$encoding='UTF-8'}}if (defined$encoding){if ("$]" >= 5.008){binmode($fh,":encoding($encoding)")}}else {seek$fh,$pos,SEEK_SET or croak(sprintf "Can't reset position to the top of '$filename'")}return$encoding}sub _parse_fh {my ($self,$fh)=@_;my($in_pod,$seen_end,$need_vers)=(0,0,0);my(@packages,%vers,%pod,@pod);my$package='main';my$pod_sect='';my$pod_data='';my$in_end=0;my$encoding='';while (defined(my$line=<$fh>)){my$line_num=$.;chomp($line);my$is_cut;if ($line =~ /^=([a-zA-Z].*)/){my$cmd=$1;$is_cut=$cmd =~ /^cut(?:[^a-zA-Z]|$)/;$in_pod=!$is_cut}if ($in_pod){if ($line =~ /^=head[1-4]\s+(.+)\s*$/){push(@pod,$1);if ($self->{collect_pod}&& length($pod_data)){$pod{$pod_sect}=$pod_data;$pod_data=''}$pod_sect=$1}elsif ($self->{collect_pod}){if ($self->{decode_pod}&& $line =~ /^=encoding ([\w-]+)/){$encoding=$1}$pod_data .= "$line\n"}next}elsif ($is_cut){if ($self->{collect_pod}&& length($pod_data)){$pod{$pod_sect}=$pod_data;$pod_data=''}$pod_sect='';next}next if$in_end;next if$line =~ /^\s*#/;if ($line eq '__END__'){$in_end++;next}last if$line eq '__DATA__';my($version_sigil,$version_fullname,$version_package)=index($line,'VERSION')>= 1 ? $self->_parse_version_expression($line): ();if ($line =~ /$PKG_REGEXP/o){$package=$1;my$version=$2;push(@packages,$package)unless grep($package eq $_,@packages);$need_vers=defined$version ? 0 : 1;if (not exists$vers{$package}and defined$version){my$dwim_version=eval {_dwim_version($version)};croak "Version '$version' from $self->{filename} does not appear to be valid:\n$line\n\nThe fatal error was: $@\n" unless defined$dwim_version;$vers{$package}=$dwim_version}}elsif ($version_fullname && $version_package){$need_vers=0 if$version_package eq $package;unless (defined$vers{$version_package}&& length$vers{$version_package}){$vers{$version_package}=$self->_evaluate_version_line($version_sigil,$version_fullname,$line)}}elsif ($package eq 'main' && $version_fullname &&!exists($vers{main})){$need_vers=0;my$v=$self->_evaluate_version_line($version_sigil,$version_fullname,$line);$vers{$package}=$v;push(@packages,'main')}elsif ($package eq 'main' &&!exists($vers{main})&& $line =~ /\w/){$need_vers=1;$vers{main}='';push(@packages,'main')}elsif ($version_fullname && $need_vers){$need_vers=0;my$v=$self->_evaluate_version_line($version_sigil,$version_fullname,$line);unless (defined$vers{$package}&& length$vers{$package}){$vers{$package}=$v}}}if ($self->{collect_pod}&& length($pod_data)){$pod{$pod_sect}=$pod_data}if ($self->{decode_pod}&& $encoding){require Encode;$_=Encode::decode($encoding,$_)for values%pod}$self->{versions}=\%vers;$self->{packages}=\@packages;$self->{pod}=\%pod;$self->{pod_headings}=\@pod}sub __uniq (@) {my (%seen,$key);grep!$seen{$key=$_ }++,@_}{my$pn=0;sub _evaluate_version_line {my$self=shift;my($sigil,$variable_name,$line)=@_;$pn++;my$eval=qq{ my \$dummy = q#  Hide from _packages_inside()
      #; package Module::Metadata::_version::p${pn};
      use version;
      sub {
        local $sigil$variable_name;
        $line;
        return \$$variable_name if defined \$$variable_name;
        return \$Module::Metadata::_version::p${pn}::$variable_name;
      };
    };$eval=$1 if$eval =~ m{^(.+)}s;local $^W;my$vsub=__clean_eval($eval);if ($@ =~ /Can't locate/ && -d 'lib'){local@INC=('lib',@INC);$vsub=__clean_eval($eval)}warn "Error evaling version line '$eval' in $self->{filename}: $@\n" if $@;(ref($vsub)eq 'CODE')or croak "failed to build version sub for $self->{filename}";my$result=eval {$vsub->()};croak "Could not get version from $self->{filename} by executing:\n$eval\n\nThe fatal error was: $@\n" if $@;my$version=eval {_dwim_version($result)};croak "Version '$result' from $self->{filename} does not appear to be valid:\n$eval\n\nThe fatal error was: $@\n" unless defined$version;return$version}}{my@version_prep=(sub {return shift},sub {my$v=shift;$v =~ s{([0-9])[a-z-].*$}{$1}i;return$v},sub {my$v=shift;my$num_dots=()=$v =~ m{(\.)}g;my$num_unders=()=$v =~ m{(_)}g;my$leading_v=substr($v,0,1)eq 'v';if (!$leading_v && $num_dots < 2 && $num_unders > 1){$v =~ s{_}{}g;$num_unders=()=$v =~ m{(_)}g}return$v},sub {my$v=shift;no warnings 'numeric';return 0 + $v},);sub _dwim_version {my ($result)=shift;return$result if ref($result)eq 'version';my ($version,$error);for my$f (@version_prep){$result=$f->($result);$version=eval {version->new($result)};$error ||= $@ if $@;last if defined$version}croak$error unless defined$version;return$version}}sub name {$_[0]->{module}}sub filename {$_[0]->{filename}}sub packages_inside {@{$_[0]->{packages}}}sub pod_inside {@{$_[0]->{pod_headings}}}sub contains_pod {0+@{$_[0]->{pod_headings}}}sub version {my$self=shift;my$mod=shift || $self->{module};my$vers;if (defined($mod)&& length($mod)&& exists($self->{versions}{$mod})){return$self->{versions}{$mod}}else {return undef}}sub pod {my$self=shift;my$sect=shift;if (defined($sect)&& length($sect)&& exists($self->{pod}{$sect})){return$self->{pod}{$sect}}else {return undef}}sub is_indexable {my ($self,$package)=@_;my@indexable_packages=grep $_ ne 'main',$self->packages_inside;return!!grep $_ eq $package,@indexable_packages if$package;return!!@indexable_packages}1;
MODULE_METADATA

$fatpacked{"Params/Check.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARAMS_CHECK';
  package Params::Check;use strict;use Carp qw[carp croak];use Locale::Maketext::Simple Style=>'gettext';BEGIN {use Exporter ();use vars qw[@ISA $VERSION @EXPORT_OK $VERBOSE $ALLOW_UNKNOWN $STRICT_TYPE $STRIP_LEADING_DASHES $NO_DUPLICATES $PRESERVE_CASE $ONLY_ALLOW_DEFINED $WARNINGS_FATAL $SANITY_CHECK_TEMPLATE $CALLER_DEPTH $_ERROR_STRING];@ISA=qw[Exporter];@EXPORT_OK=qw[check allow last_error];$VERSION='0.38';$VERBOSE=$^W ? 1 : 0;$NO_DUPLICATES=0;$STRIP_LEADING_DASHES=0;$STRICT_TYPE=0;$ALLOW_UNKNOWN=0;$PRESERVE_CASE=0;$ONLY_ALLOW_DEFINED=0;$SANITY_CHECK_TEMPLATE=1;$WARNINGS_FATAL=0;$CALLER_DEPTH=0}my%known_keys=map {$_=>1}qw|required allow default strict_type no_override store defined|;sub check {my ($utmpl,$href,$verbose)=@_;_clear_error();if (!$utmpl or!$href){_store_error(loc('check() expects two arguments'));return unless$WARNINGS_FATAL;croak(__PACKAGE__->last_error)}$verbose ||= $VERBOSE || 0;my$args;if($PRESERVE_CASE and!$STRIP_LEADING_DASHES){$args=$href}else {for my$key (keys %$href){my$org=$key;$key=lc$key unless$PRESERVE_CASE;$key =~ s/^-// if$STRIP_LEADING_DASHES;$args->{$key}=$href->{$org}}}my%defs;my@want_store;my$fail;for my$key (keys %$utmpl){my$tmpl=$utmpl->{$key};if($tmpl->{'required'}and not exists$args->{$key}){_store_error(loc(q|Required option '%1' is not provided for %2 by %3|,$key,_who_was_it(),_who_was_it(1)),$verbose);$fail++;next}$defs{$key}=$tmpl->{'default'}if exists$tmpl->{'default'};if($SANITY_CHECK_TEMPLATE){map {_store_error(loc(q|Template type '%1' not supported [at key '%2']|,$_,$key),1,0)}grep {not $known_keys{$_}}keys %$tmpl;if (exists$tmpl->{'store'}){_store_error(loc(q|Store variable for '%1' is not a reference!|,$key),1,0)unless ref$tmpl->{'store'}}}push@want_store,$key if$tmpl->{'store'}}return if$fail;my$wrong;my$warned;for my$key (keys %$args){my$arg=$args->{$key};unless($utmpl->{$key}){if($ALLOW_UNKNOWN){$defs{$key}=$arg}else {_store_error(loc("Key '%1' is not a valid key for %2 provided by %3",$key,_who_was_it(),_who_was_it(1)),$verbose);$warned ||= 1}next}my%tmpl=%{$utmpl->{$key}};if($tmpl{'no_override'}){_store_error(loc(q[You are not allowed to override key '%1'].q[for %2 from %3],$key,_who_was_it(),_who_was_it(1)),$verbose);$warned ||= 1;next}if(($tmpl{'defined'}|| $ONLY_ALLOW_DEFINED)and not defined$arg){_store_error(loc(q|Key '%1' must be defined when passed|,$key),$verbose);$wrong ||= 1;next}if(($tmpl{'strict_type'}|| $STRICT_TYPE)and (ref$arg ne ref$tmpl{'default'})){_store_error(loc(q|Key '%1' needs to be of type '%2'|,$key,ref$tmpl{'default'}|| 'SCALAR'),$verbose);$wrong ||= 1;next}if(exists$tmpl{'allow'}and not do {local$_ERROR_STRING;allow($arg,$tmpl{'allow'})}){_store_error(loc(q|Key '%1' (%2) is of invalid type for '%3' |.q|provided by %4|,$key,"$arg",_who_was_it(),_who_was_it(1)),$verbose);$wrong ||= 1;next}$defs{$key}=$arg}croak(__PACKAGE__->last_error)if ($wrong || $warned)&& $WARNINGS_FATAL;return if$wrong;for my$key (@want_store){next unless exists$defs{$key};my$ref=$utmpl->{$key}{'store'};$$ref=$NO_DUPLICATES ? delete$defs{$key}: $defs{$key}}return \%defs}sub allow {if(ref $_[1]eq 'Regexp'){local $^W;return if $_[0]!~ /$_[1]/}elsif (ref $_[1]eq 'CODE'){return unless $_[1]->($_[0])}elsif (ref $_[1]eq 'ARRAY'){for (@{$_[1]}){return 1 if allow($_[0],$_)}return}else {return unless _safe_eq($_[0],$_[1])}return 1}sub _safe_eq {return defined($_[0])&& defined($_[1])? $_[0]eq $_[1]: defined($_[0])eq defined($_[1])}sub _who_was_it {my$level=$_[0]|| 0;return (caller(2 + $CALLER_DEPTH + $level))[3]|| 'ANON'}{$_ERROR_STRING='';sub _store_error {my($err,$verbose,$offset)=@_[0..2];$verbose ||= 0;$offset ||= 0;my$level=1 + $offset;local$Carp::CarpLevel=$level;carp$err if$verbose;$_ERROR_STRING .= $err ."\n"}sub _clear_error {$_ERROR_STRING=''}sub last_error {$_ERROR_STRING}}1;
PARAMS_CHECK

$fatpacked{"Parse/CPAN/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSE_CPAN_META';
  use 5.008001;use strict;use warnings;package Parse::CPAN::Meta;our$VERSION='2.150010';use Exporter;use Carp 'croak';our@ISA=qw/Exporter/;our@EXPORT_OK=qw/Load LoadFile/;sub load_file {my ($class,$filename)=@_;my$meta=_slurp($filename);if ($filename =~ /\.ya?ml$/){return$class->load_yaml_string($meta)}elsif ($filename =~ /\.json$/){return$class->load_json_string($meta)}else {$class->load_string($meta)}}sub load_string {my ($class,$string)=@_;if ($string =~ /^---/){return$class->load_yaml_string($string)}elsif ($string =~ /^\s*\{/){return$class->load_json_string($string)}else {return$class->load_yaml_string($string)}}sub load_yaml_string {my ($class,$string)=@_;my$backend=$class->yaml_backend();my$data=eval {no strict 'refs';&{"$backend\::Load"}($string)};croak $@ if $@;return$data || {}}sub load_json_string {my ($class,$string)=@_;require Encode;my$encoded=Encode::encode('UTF-8',$string,Encode::PERLQQ());my$data=eval {$class->json_decoder()->can('decode_json')->($encoded)};croak $@ if $@;return$data || {}}sub yaml_backend {if ($ENV{PERL_CORE}or not defined$ENV{PERL_YAML_BACKEND}){_can_load('CPAN::Meta::YAML',0.011)or croak "CPAN::Meta::YAML 0.011 is not available\n";return "CPAN::Meta::YAML"}else {my$backend=$ENV{PERL_YAML_BACKEND};_can_load($backend)or croak "Could not load PERL_YAML_BACKEND '$backend'\n";$backend->can("Load")or croak "PERL_YAML_BACKEND '$backend' does not implement Load()\n";return$backend}}sub json_decoder {if ($ENV{PERL_CORE}){_can_load('JSON::PP'=>2.27300)or croak "JSON::PP 2.27300 is not available\n";return 'JSON::PP'}if (my$decoder=$ENV{CPAN_META_JSON_DECODER}){_can_load($decoder)or croak "Could not load CPAN_META_JSON_DECODER '$decoder'\n";$decoder->can('decode_json')or croak "No decode_json sub provided by CPAN_META_JSON_DECODER '$decoder'\n";return$decoder}return $_[0]->json_backend}sub json_backend {if ($ENV{PERL_CORE}){_can_load('JSON::PP'=>2.27300)or croak "JSON::PP 2.27300 is not available\n";return 'JSON::PP'}if (my$backend=$ENV{CPAN_META_JSON_BACKEND}){_can_load($backend)or croak "Could not load CPAN_META_JSON_BACKEND '$backend'\n";$backend->can('new')or croak "No constructor provided by CPAN_META_JSON_BACKEND '$backend'\n";return$backend}if (!$ENV{PERL_JSON_BACKEND}or $ENV{PERL_JSON_BACKEND}eq 'JSON::PP'){_can_load('JSON::PP'=>2.27300)or croak "JSON::PP 2.27300 is not available\n";return 'JSON::PP'}else {_can_load('JSON'=>2.5)or croak "JSON 2.5 is required for " ."\$ENV{PERL_JSON_BACKEND} = '$ENV{PERL_JSON_BACKEND}'\n";return "JSON"}}sub _slurp {require Encode;open my$fh,"<:raw","$_[0]" or die "can't open $_[0] for reading: $!";my$content=do {local $/;<$fh>};$content=Encode::decode('UTF-8',$content,Encode::PERLQQ());return$content}sub _can_load {my ($module,$version)=@_;(my$file=$module)=~ s{::}{/}g;$file .= ".pm";return 1 if$INC{$file};return 0 if exists$INC{$file};eval {require$file;1}or return 0;if (defined$version){eval {$module->VERSION($version);1}or return 0}return 1}sub LoadFile ($) {return Load(_slurp(shift))}sub Load ($) {require CPAN::Meta::YAML;my$object=eval {CPAN::Meta::YAML::Load(shift)};croak $@ if $@;return$object}1;
PARSE_CPAN_META

$fatpacked{"Parse/PMFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSE_PMFILE';
  package Parse::PMFile;sub __clean_eval {eval $_[0]}use strict;use warnings;use Safe;use JSON::PP ();use Dumpvalue;use version ();use File::Spec ();our$VERSION='0.42';our$VERBOSE=0;our$ALLOW_DEV_VERSION=0;our$FORK=0;our$UNSAFE=$] < 5.010000 ? 1 : 0;sub new {my ($class,$meta,$opts)=@_;bless {%{$opts || {}},META_CONTENT=>$meta},$class}sub parse {my ($self,$pmfile)=@_;$pmfile =~ s|\\|/|g;my($filemtime)=(stat$pmfile)[9];$self->{MTIME}=$filemtime;$self->{PMFILE}=$pmfile;unless ($self->_version_from_meta_ok){my$version;unless (eval {$version=$self->_parse_version;1}){$self->_verbose(1,"error with version in $pmfile: $@");return}$self->{VERSION}=$version;if ($self->{VERSION}=~ /^\{.*\}$/){}elsif ($self->{VERSION}=~ /[_\s]/ &&!$self->{ALLOW_DEV_VERSION}&&!$ALLOW_DEV_VERSION){return}}my($ppp)=$self->_packages_per_pmfile;my@keys_ppp=$self->_filter_ppps(sort keys %$ppp);$self->_verbose(1,"Will check keys_ppp[@keys_ppp]\n");my ($package,%errors);my%checked_in;DBPACK: foreach$package (@keys_ppp){if ($package !~ /^\w[\w\:\']*\w?\z/ || $package !~ /\w\z/ || $package =~ /:/ && $package !~ /::/ || $package =~ /\w:\w/ || $package =~ /:::/){$self->_verbose(1,"Package[$package] did not pass the ultimate sanity check");delete$ppp->{$package};next}if ($self->{USERID}&& $self->{PERMISSIONS}&&!$self->_perm_check($package)){delete$ppp->{$package};next}{my (undef,$module)=split m{/lib/},$self->{PMFILE},2;if ($module){$module =~ s{\.pm\z}{};$module =~ s{/}{::}g;if (lc$module eq lc$package && $module ne $package){$errors{$package}={indexing_warning=>"Capitalization of package ($package) does not match filename!",infile=>$self->{PMFILE},}}}}my$pp=$ppp->{$package};if ($pp->{version}&& $pp->{version}=~ /^\{.*\}$/){my$err=JSON::PP::decode_json($pp->{version});if ($err->{x_normalize}){$errors{$package}={normalize=>$err->{version},infile=>$pp->{infile},};$pp->{version}="undef"}elsif ($err->{openerr}){$pp->{version}="undef";$self->_verbose(1,qq{Parse::PMFile was not able to
          read the file. It issued the following error: C< $err->{r} >},);$errors{$package}={open=>$err->{r},infile=>$pp->{infile},}}else {$pp->{version}="undef";$self->_verbose(1,qq{Parse::PMFile was not able to
          parse the following line in that file: C< $err->{line} >
  
          Note: the indexer is running in a Safe compartement and cannot
          provide the full functionality of perl in the VERSION line. It
          is trying hard, but sometime it fails. As a workaround, please
          consider writing a META.yml that contains a 'provides'
          attribute or contact the CPAN admins to investigate (yet
          another) workaround against "Safe" limitations.)},);$errors{$package}={parse_version=>$err->{line},infile=>$err->{file},}}}for ($package,$pp->{version},){if (!defined || /^\s*$/ || /\s/){delete$ppp->{$package};next}}unless ($self->_version_ok($pp)){$errors{$package}={long_version=>qq{Version string exceeds maximum allowed length of 16b: "$pp->{version}"},infile=>$pp->{infile},};next}$checked_in{$package}=$ppp->{$package}}return (wantarray && %errors)? (\%checked_in,\%errors): \%checked_in}sub _version_ok {my ($self,$pp)=@_;return if length($pp->{version}|| 0)> 16;return 1}sub _perm_check {my ($self,$package)=@_;my$userid=$self->{USERID};my$module=$self->{PERMISSIONS}->module_permissions($package);return 1 if!$module;return 1 if defined$module->m && $module->m eq $userid;return 1 if defined$module->f && $module->f eq $userid;return 1 if defined$module->c && grep {$_ eq $userid}@{$module->c};return}sub _parse_version {my$self=shift;use strict;my$pmfile=$self->{PMFILE};my$tmpfile=File::Spec->catfile(File::Spec->tmpdir,"ParsePMFile$$" .rand(1000));my$pmcp=$pmfile;for ($pmcp){s/([^\\](\\\\)*)@/$1\\@/g}my($v);{package main;my$pid;if ($self->{FORK}|| $FORK){$pid=fork();die "Can't fork: $!" unless defined$pid}if ($pid){waitpid($pid,0);if (open my$fh,'<',$tmpfile){$v=<$fh>}}else {my($comp)=Safe->new;my$eval=qq{
                  local(\$^W) = 0;
                  Parse::PMFile::_parse_version_safely("$pmcp");
              };$comp->permit("entereval");$comp->share("*Parse::PMFile::_parse_version_safely");$comp->share("*version::new");$comp->share("*version::numify");$comp->share_from('main',['*version::','*charstar::','*Exporter::','*DynaLoader::']);$comp->share_from('version',['&qv']);$comp->permit(":base_math");$comp->deny(qw/enteriter iter unstack goto/);version->import('qv')if$self->{UNSAFE}|| $UNSAFE;{no strict;$v=($self->{UNSAFE}|| $UNSAFE)? eval$eval : $comp->reval($eval)}if ($@){my$err=$@;if (ref$err){if ($err->{line}=~ /([\$*])([\w\:\']*)\bVERSION\b.*?\=(.*)/){local($^W)=0;my ($sigil,$vstr)=($1,$3);$self->_restore_overloaded_stuff(1)if$err->{line}=~ /use\s+version\b|version\->|qv\(/;$v=($self->{UNSAFE}|| $UNSAFE)? eval$vstr : $comp->reval($vstr);$v=$$v if$sigil eq '*' && ref$v}if ($@ or!$v){$self->_verbose(1,sprintf("reval failed: err[%s] for eval[%s]",JSON::PP::encode_json($err),$eval,));$v=JSON::PP::encode_json($err)}}else {$v=JSON::PP::encode_json({openerr=>$err })}}if (defined$v){no warnings;$v=$v->numify if ref($v)=~ /^version(::vpp)?$/}else {$v=""}if ($self->{FORK}|| $FORK){open my$fh,'>:utf8',$tmpfile;print$fh $v;exit 0}else {utf8::encode($v);$v=undef if defined$v &&!length$v;$comp->erase;$self->_restore_overloaded_stuff}}}unlink$tmpfile if ($self->{FORK}|| $FORK)&& -e $tmpfile;return$self->_normalize_version($v)}sub _restore_overloaded_stuff {my ($self,$used_version_in_safe)=@_;return if$self->{UNSAFE}|| $UNSAFE;no strict 'refs';no warnings 'redefine';my$restored;if ($INC{'version/vxs.pm'}){*{'version::(""'}=\&version::vxs::stringify;*{'version::(0+'}=\&version::vxs::numify;*{'version::(cmp'}=\&version::vxs::VCMP;*{'version::(<=>'}=\&version::vxs::VCMP;*{'version::(bool'}=\&version::vxs::boolean;$restored=1}if ($INC{'version/vpp.pm'}){{package charstar;overload->import}if (!$used_version_in_safe){package version::vpp;overload->import}unless ($restored){*{'version::(""'}=\&version::vpp::stringify;*{'version::(0+'}=\&version::vpp::numify;*{'version::(cmp'}=\&version::vpp::vcmp;*{'version::(<=>'}=\&version::vpp::vcmp;*{'version::(bool'}=\&version::vpp::vbool}*{'version::vpp::(""'}=\&version::vpp::stringify;*{'version::vpp::(0+'}=\&version::vpp::numify;*{'version::vpp::(cmp'}=\&version::vpp::vcmp;*{'version::vpp::(<=>'}=\&version::vpp::vcmp;*{'version::vpp::(bool'}=\&version::vpp::vbool;*{'charstar::(""'}=\&charstar::thischar;*{'charstar::(0+'}=\&charstar::thischar;*{'charstar::(++'}=\&charstar::increment;*{'charstar::(--'}=\&charstar::decrement;*{'charstar::(+'}=\&charstar::plus;*{'charstar::(-'}=\&charstar::minus;*{'charstar::(*'}=\&charstar::multiply;*{'charstar::(cmp'}=\&charstar::cmp;*{'charstar::(<=>'}=\&charstar::spaceship;*{'charstar::(bool'}=\&charstar::thischar;*{'charstar::(='}=\&charstar::clone;$restored=1}if (!$restored){*{'version::(""'}=\&version::stringify;*{'version::(0+'}=\&version::numify;*{'version::(cmp'}=\&version::vcmp;*{'version::(<=>'}=\&version::vcmp;*{'version::(bool'}=\&version::boolean}}sub _packages_per_pmfile {my$self=shift;my$ppp={};my$pmfile=$self->{PMFILE};my$filemtime=$self->{MTIME};my$version=$self->{VERSION};open my$fh,"<","$pmfile" or return$ppp;local $/="\n";my$inpod=0;PLINE: while (<$fh>){chomp;my($pline)=$_;$inpod=$pline =~ /^=(?!cut)/ ? 1 : $pline =~ /^=cut/ ? 0 : $inpod;next if$inpod;next if substr($pline,0,4)eq "=cut";$pline =~ s/\#.*//;next if$pline =~ /^\s*$/;if ($pline =~ /^__(?:END|DATA)__\b/ and $pmfile !~ /\.PL$/){last PLINE}my$pkg;my$strict_version;if ($pline =~ m{
                        # (.*) # takes too much time if $pline is long
                        #(?<![*\$\\@%&]) # no sigils
                        ^[\s\{;]*
                        \bpackage\s+
                        ([\w\:\']+)
                        \s*
                        (?: $ | [\}\;] | \{ | \s+($version::STRICT) )
                      }x){$pkg=$1;$strict_version=$2;if ($pkg eq "DB"){next PLINE}}if ($pkg){$pkg =~ s/\'/::/g;next PLINE unless$pkg =~ /^[A-Za-z]/;next PLINE unless$pkg =~ /\w$/;next PLINE if$pkg eq "main";next PLINE if length($pkg)> 128;$ppp->{$pkg}{parsed}++;$ppp->{$pkg}{infile}=$pmfile;if ($self->_simile($pmfile,$pkg)){$ppp->{$pkg}{simile}=$pmfile;if ($self->_version_from_meta_ok){my$provides=$self->{META_CONTENT}{provides};if (exists$provides->{$pkg}){if (defined$provides->{$pkg}{version}){my$v=$provides->{$pkg}{version};if ($v =~ /[_\s]/ &&!$self->{ALLOW_DEV_VERSION}&&!$ALLOW_DEV_VERSION){next PLINE}unless (eval {$version=$self->_normalize_version($v);1}){$self->_verbose(1,"error with version in $pmfile: $@");next}$ppp->{$pkg}{version}=$version}else {$ppp->{$pkg}{version}="undef"}}}else {if (defined$strict_version){$ppp->{$pkg}{version}=$strict_version }else {$ppp->{$pkg}{version}=defined$version ? $version : ""}no warnings;if ($version eq 'undef'){$ppp->{$pkg}{version}=$version unless defined$ppp->{$pkg}{version}}else {$ppp->{$pkg}{version}=$version if$version > $ppp->{$pkg}{version}|| $version gt $ppp->{$pkg}{version}}}}else {$ppp->{$pkg}{version}=$version unless defined$ppp->{$pkg}{version}&& length($ppp->{$pkg}{version})}$ppp->{$pkg}{filemtime}=$filemtime}else {}}close$fh;$ppp}{no strict;sub _parse_version_safely {my($parsefile)=@_;my$result;local*FH;local $/="\n";open(FH,$parsefile)or die "Could not open '$parsefile': $!";my$inpod=0;while (<FH>){$inpod=/^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;next if$inpod || /^\s*#/;last if /^__(?:END|DATA)__\b/;chop;if (my ($ver)=/package \s+ \S+ \s+ (\S+) \s* [;{]/x){return$ver if version::is_lax($ver)}next unless /(?<!\\)([\$*])(([\w\:\']*)\bVERSION)\b.*(?<![!><=])\=(?![=>])/;my$current_parsed_line=$_;my$eval=qq{
                  package #
                      ExtUtils::MakeMaker::_version;
  
                  local $1$2;
                  \$$2=undef; do {
                      $_
                  }; \$$2
              };local $^W=0;local$SIG{__WARN__}=sub {};$result=__clean_eval($eval);if ($@ or!defined$result){die +{eval=>$eval,line=>$current_parsed_line,file=>$parsefile,err=>$@,}}last}close FH;$result="undef" unless defined$result;if ((ref$result)=~ /^version(?:::vpp)?\b/){no warnings;$result=$result->numify}return$result}}sub _filter_ppps {my($self,@ppps)=@_;my@res;MANI: for my$ppp (@ppps){if ($self->{META_CONTENT}){my$no_index=$self->{META_CONTENT}{no_index}|| $self->{META_CONTENT}{private};if (ref($no_index)eq 'HASH'){my%map=(package=>qr{\z},namespace=>qr{::},);for my$k (qw(package namespace)){next unless my$v=$no_index->{$k};my$rest=$map{$k};if (ref$v eq "ARRAY"){for my$ve (@$v){$ve =~ s|::$||;if ($ppp =~ /^$ve$rest/){$self->_verbose(1,"Skipping ppp[$ppp] due to ve[$ve]");next MANI}else {$self->_verbose(1,"NOT skipping ppp[$ppp] due to ve[$ve]")}}}else {$v =~ s|::$||;if ($ppp =~ /^$v$rest/){$self->_verbose(1,"Skipping ppp[$ppp] due to v[$v]");next MANI}else {$self->_verbose(1,"NOT skipping ppp[$ppp] due to v[$v]")}}}}else {$self->_verbose(1,"No keyword 'no_index' or 'private' in META_CONTENT")}}else {}push@res,$ppp}$self->_verbose(1,"Result of filter_ppps: res[@res]");@res}sub _simile {my($self,$file,$package)=@_;$file =~ s|.*/||;$file =~ s|\.pm(?:\.PL)?||;my$ret=$package =~ m/\b\Q$file\E$/;$ret ||= 0;unless ($ret){$ret=1 if lc$file eq 'version'}$self->_verbose(1,"Result of simile(): file[$file] package[$package] ret[$ret]\n");$ret}sub _normalize_version {my($self,$v)=@_;$v="undef" unless defined$v;my$dv=Dumpvalue->new;my$sdv=$dv->stringify($v,1);$self->_verbose(1,"Result of normalize_version: sdv[$sdv]\n");return$v if$v eq "undef";return$v if$v =~ /^\{.*\}$/;$v =~ s/^\s+//;$v =~ s/\s+\z//;if ($v =~ /_/){return$v }if (!version::is_lax($v)){return JSON::PP::encode_json({x_normalize=>'version::is_lax failed',version=>$v })}my$vv=eval {no warnings;version->new($v)->numify};if ($@){return JSON::PP::encode_json({x_normalize=>$@,version=>$v })}if ($vv eq $v){}else {my$forced=$self->_force_numeric($v);if ($forced eq $vv){}elsif ($forced =~ /^v(.+)/){no warnings;$vv=version->new($1)->numify}else {if ($forced==$vv){$vv=$forced}}}return$vv}sub _force_numeric {my($self,$v)=@_;$v=$self->_readable($v);if ($v =~ /^(\+?)(\d*)(\.(\d*))?/ && (defined $2 && length $2 || defined $4 && length $4)){my$two=defined $2 ? $2 : "";my$three=defined $3 ? $3 : "";$v="$two$three"}$v}sub _version_from_meta_ok {my($self)=@_;return$self->{VERSION_FROM_META_OK}if exists$self->{VERSION_FROM_META_OK};my$c=$self->{META_CONTENT};return($self->{VERSION_FROM_META_OK}=0)unless$c->{provides};my ($mb_v)=(defined$c->{generated_by}? $c->{generated_by}: '')=~ /Module::Build version ([\d\.]+)/;return($self->{VERSION_FROM_META_OK}=1)unless$mb_v;return($self->{VERSION_FROM_META_OK}=1)if$mb_v eq '0.250.0';if ($mb_v >= 0.19 && $mb_v < 0.26 &&!keys %{$c->{provides}}){return($self->{VERSION_FROM_META_OK}=0)}return($self->{VERSION_FROM_META_OK}=1)}sub _verbose {my($self,$level,@what)=@_;warn@what if$level <= ((ref$self && $self->{VERBOSE})|| $VERBOSE)}sub _vcmp {my($self,$l,$r)=@_;local($^W)=0;$self->_verbose(9,"l[$l] r[$r]");return 0 if$l eq $r;for ($l,$r){s/_//g}$self->_verbose(9,"l[$l] r[$r]");for ($l,$r){next unless tr/.// > 1 || /^v/;s/^v?/v/;1 while s/\.0+(\d)/.$1/}$self->_verbose(9,"l[$l] r[$r]");if ($l=~/^v/ <=> $r=~/^v/){for ($l,$r){next if /^v/;$_=$self->_float2vv($_)}}$self->_verbose(9,"l[$l] r[$r]");my$lvstring="v0";my$rvstring="v0";if ($] >= 5.006 && $l =~ /^v/ && $r =~ /^v/){$lvstring=$self->_vstring($l);$rvstring=$self->_vstring($r);$self->_verbose(9,sprintf "lv[%vd] rv[%vd]",$lvstring,$rvstring)}return (($l ne "undef")<=> ($r ne "undef")|| $lvstring cmp $rvstring || $l <=> $r || $l cmp $r)}sub _vgt {my($self,$l,$r)=@_;$self->_vcmp($l,$r)> 0}sub _vlt {my($self,$l,$r)=@_;$self->_vcmp($l,$r)< 0}sub _vge {my($self,$l,$r)=@_;$self->_vcmp($l,$r)>= 0}sub _vle {my($self,$l,$r)=@_;$self->_vcmp($l,$r)<= 0}sub _vstring {my($self,$n)=@_;$n =~ s/^v// or die "Parse::PMFile::_vstring() called with invalid arg [$n]";pack "U*",split /\./,$n}sub _float2vv {my($self,$n)=@_;my($rev)=int($n);$rev ||= 0;my($mantissa)=$n =~ /\.(\d{1,12})/;$mantissa ||= 0;$mantissa .= "0" while length($mantissa)%3;my$ret="v" .$rev;while ($mantissa){$mantissa =~ s/(\d{1,3})// or die "Panic: length>0 but not a digit? mantissa[$mantissa]";$ret .= ".".int($1)}$ret =~ s/(\.0)+/.0/;$ret}sub _readable {my($self,$n)=@_;$n =~ /^([\w\-\+\.]+)/;return $1 if defined $1 && length($1)>0;if ($] < 5.006){$self->_verbose(9,"Suspicious version string seen [$n]\n");return$n}my$better=sprintf "v%vd",$n;$self->_verbose(9,"n[$n] better[$better]");return$better}1;
PARSE_PMFILE

$fatpacked{"Perl/OSType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_OSTYPE';
  use strict;use warnings;package Perl::OSType;our$VERSION='1.010';require Exporter;our@ISA=qw(Exporter);our%EXPORT_TAGS=(all=>[qw(os_type is_os_type)]);our@EXPORT_OK=@{$EXPORT_TAGS{all}};my%OSTYPES=qw(aix Unix bsdos Unix beos Unix bitrig Unix dgux Unix dragonfly Unix dynixptx Unix freebsd Unix linux Unix haiku Unix hpux Unix iphoneos Unix irix Unix darwin Unix machten Unix midnightbsd Unix minix Unix mirbsd Unix next Unix openbsd Unix netbsd Unix dec_osf Unix nto Unix svr4 Unix svr5 Unix sco Unix sco_sv Unix unicos Unix unicosmk Unix solaris Unix sunos Unix cygwin Unix msys Unix os2 Unix interix Unix gnu Unix gnukfreebsd Unix nto Unix qnx Unix android Unix dos Windows MSWin32 Windows os390 EBCDIC os400 EBCDIC posix-bc EBCDIC vmesa EBCDIC MacOS MacOS VMS VMS vos VOS riscos RiscOS amigaos Amiga mpeix MPEiX);sub os_type {my ($os)=@_;$os=$^O unless defined$os;return$OSTYPES{$os}|| q{}}sub is_os_type {my ($type,$os)=@_;return unless$type;$os=$^O unless defined$os;return os_type($os)eq $type}1;
PERL_OSTYPE

$fatpacked{"Pod/Escapes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_ESCAPES';
  package Pod::Escapes;use strict;use warnings;use 5.006;use vars qw(%Code2USASCII %Name2character %Name2character_number %Latin1Code_to_fallback %Latin1Char_to_fallback $FAR_CHAR $FAR_CHAR_NUMBER $NOT_ASCII @ISA $VERSION @EXPORT_OK %EXPORT_TAGS);require Exporter;@ISA=('Exporter');$VERSION='1.07';@EXPORT_OK=qw(%Code2USASCII %Name2character %Name2character_number %Latin1Code_to_fallback %Latin1Char_to_fallback e2char e2charnum);%EXPORT_TAGS=('ALL'=>\@EXPORT_OK);$FAR_CHAR="?" unless defined$FAR_CHAR;$FAR_CHAR_NUMBER=ord($FAR_CHAR)unless defined$FAR_CHAR_NUMBER;$NOT_ASCII='A' ne chr(65)unless defined$NOT_ASCII;sub e2char {my$in=$_[0];return undef unless defined$in and length$in;if($in =~ m/^(0[0-7]*)$/s){$in=oct$in}elsif($in =~ m/^0?x([0-9a-fA-F]+)$/s){$in=hex $1}if($in =~ m/^\d+$/s){if($] < 5.007 and $in > 255){return$FAR_CHAR}elsif ($] >= 5.007003){return chr(utf8::unicode_to_native($in))}elsif ($NOT_ASCII){return$Code2USASCII{$in}|| $Latin1Code_to_fallback{$in}|| $FAR_CHAR}else {return chr($in)}}else {return$Name2character{$in}}}sub e2charnum {my$in=$_[0];return undef unless defined$in and length$in;if($in =~ m/^(0[0-7]*)$/s){$in=oct$in}elsif($in =~ m/^0?x([0-9a-fA-F]+)$/s){$in=hex $1}if($in =~ m/^[0-9]+$/s){return 0 + $in}else {return$Name2character_number{$in}}}%Code2USASCII=(32,' ',33,'!',34,'"',35,'#',36,'$',37,'%',38,'&',39,"'",40,'(',41,')',42,'*',43,'+',44,',',45,'-',46,'.',47,'/',48,'0',49,'1',50,'2',51,'3',52,'4',53,'5',54,'6',55,'7',56,'8',57,'9',58,':',59,';',60,'<',61,'=',62,'>',63,'?',64,'@',65,'A',66,'B',67,'C',68,'D',69,'E',70,'F',71,'G',72,'H',73,'I',74,'J',75,'K',76,'L',77,'M',78,'N',79,'O',80,'P',81,'Q',82,'R',83,'S',84,'T',85,'U',86,'V',87,'W',88,'X',89,'Y',90,'Z',91,'[',92,"\\",93,']',94,'^',95,'_',96,'`',97,'a',98,'b',99,'c',100,'d',101,'e',102,'f',103,'g',104,'h',105,'i',106,'j',107,'k',108,'l',109,'m',110,'n',111,'o',112,'p',113,'q',114,'r',115,'s',116,'t',117,'u',118,'v',119,'w',120,'x',121,'y',122,'z',123,'{',124,'|',125,'}',126,'~',);%Latin1Code_to_fallback=();@Latin1Code_to_fallback{0xA0 .. 0xFF}=(' ',qq{!},qq{C/},'PS',qq{\$?},qq{Y=},qq{|},'SS',qq{"},qq{(c)},'a',qq{<<},qq{!},"",qq{(r)},qq{-},'deg',qq{+-},'2','3',qq{'},'u','P',qq{*},qq{,},'1','o',qq{>>},qq{1/4},qq{1/2},qq{3/4},qq{?},'A','A','A','A','A','A','AE','C','E','E','E','E','I','I','I','I','D','N','O','O','O','O','O','x','O','U','U','U','U','U','Th','ss','a','a','a','a','a','a','ae','c','e','e','e','e','i','i','i','i','d','n','o','o','o','o','o',qq{/},'o','u','u','u','u','y','th','y',);{%Latin1Char_to_fallback=();my($k,$v);while(($k,$v)=each%Latin1Code_to_fallback){$Latin1Char_to_fallback{chr$k}=$v}}%Name2character_number=('lt'=>60,'gt'=>62,'quot'=>34,'amp'=>38,'apos'=>39,'sol'=>47,'verbar'=>124,'lchevron'=>171,'rchevron'=>187,'nbsp',160,'iexcl',161,'cent',162,'pound',163,'curren',164,'yen',165,'brvbar',166,'sect',167,'uml',168,'copy',169,'ordf',170,'laquo',171,'not',172,'shy',173,'reg',174,'macr',175,'deg',176,'plusmn',177,'sup2',178,'sup3',179,'acute',180,'micro',181,'para',182,'middot',183,'cedil',184,'sup1',185,'ordm',186,'raquo',187,'frac14',188,'frac12',189,'frac34',190,'iquest',191,'Agrave',192,'Aacute',193,'Acirc',194,'Atilde',195,'Auml',196,'Aring',197,'AElig',198,'Ccedil',199,'Egrave',200,'Eacute',201,'Ecirc',202,'Euml',203,'Igrave',204,'Iacute',205,'Icirc',206,'Iuml',207,'ETH',208,'Ntilde',209,'Ograve',210,'Oacute',211,'Ocirc',212,'Otilde',213,'Ouml',214,'times',215,'Oslash',216,'Ugrave',217,'Uacute',218,'Ucirc',219,'Uuml',220,'Yacute',221,'THORN',222,'szlig',223,'agrave',224,'aacute',225,'acirc',226,'atilde',227,'auml',228,'aring',229,'aelig',230,'ccedil',231,'egrave',232,'eacute',233,'ecirc',234,'euml',235,'igrave',236,'iacute',237,'icirc',238,'iuml',239,'eth',240,'ntilde',241,'ograve',242,'oacute',243,'ocirc',244,'otilde',245,'ouml',246,'divide',247,'oslash',248,'ugrave',249,'uacute',250,'ucirc',251,'uuml',252,'yacute',253,'thorn',254,'yuml',255,'fnof',402,'Alpha',913,'Beta',914,'Gamma',915,'Delta',916,'Epsilon',917,'Zeta',918,'Eta',919,'Theta',920,'Iota',921,'Kappa',922,'Lambda',923,'Mu',924,'Nu',925,'Xi',926,'Omicron',927,'Pi',928,'Rho',929,'Sigma',931,'Tau',932,'Upsilon',933,'Phi',934,'Chi',935,'Psi',936,'Omega',937,'alpha',945,'beta',946,'gamma',947,'delta',948,'epsilon',949,'zeta',950,'eta',951,'theta',952,'iota',953,'kappa',954,'lambda',955,'mu',956,'nu',957,'xi',958,'omicron',959,'pi',960,'rho',961,'sigmaf',962,'sigma',963,'tau',964,'upsilon',965,'phi',966,'chi',967,'psi',968,'omega',969,'thetasym',977,'upsih',978,'piv',982,'bull',8226,'hellip',8230,'prime',8242,'Prime',8243,'oline',8254,'frasl',8260,'weierp',8472,'image',8465,'real',8476,'trade',8482,'alefsym',8501,'larr',8592,'uarr',8593,'rarr',8594,'darr',8595,'harr',8596,'crarr',8629,'lArr',8656,'uArr',8657,'rArr',8658,'dArr',8659,'hArr',8660,'forall',8704,'part',8706,'exist',8707,'empty',8709,'nabla',8711,'isin',8712,'notin',8713,'ni',8715,'prod',8719,'sum',8721,'minus',8722,'lowast',8727,'radic',8730,'prop',8733,'infin',8734,'ang',8736,'and',8743,'or',8744,'cap',8745,'cup',8746,'int',8747,'there4',8756,'sim',8764,'cong',8773,'asymp',8776,'ne',8800,'equiv',8801,'le',8804,'ge',8805,'sub',8834,'sup',8835,'nsub',8836,'sube',8838,'supe',8839,'oplus',8853,'otimes',8855,'perp',8869,'sdot',8901,'lceil',8968,'rceil',8969,'lfloor',8970,'rfloor',8971,'lang',9001,'rang',9002,'loz',9674,'spades',9824,'clubs',9827,'hearts',9829,'diams',9830,'OElig',338,'oelig',339,'Scaron',352,'scaron',353,'Yuml',376,'circ',710,'tilde',732,'ensp',8194,'emsp',8195,'thinsp',8201,'zwnj',8204,'zwj',8205,'lrm',8206,'rlm',8207,'ndash',8211,'mdash',8212,'lsquo',8216,'rsquo',8217,'sbquo',8218,'ldquo',8220,'rdquo',8221,'bdquo',8222,'dagger',8224,'Dagger',8225,'permil',8240,'lsaquo',8249,'rsaquo',8250,'euro',8364,);{%Name2character=();my($name,$number);while(($name,$number)=each%Name2character_number){if($] < 5.007 and $number > 255){$Name2character{$name}=$FAR_CHAR}elsif ($] >= 5.007003){$Name2character{$name}=chr utf8::unicode_to_native($number)}elsif (exists$Code2USASCII{$number}){$Name2character{$name}=$Code2USASCII{$number}}elsif ($NOT_ASCII && $number > 127 && $number < 256){if (exists$Latin1Code_to_fallback{$number}){$Name2character{$name}=$Latin1Code_to_fallback{$number}}else {$Name2character{$name}=$FAR_CHAR}}else {$Name2character{$name}=chr$number}}}1;
POD_ESCAPES

$fatpacked{"Pod/Man.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_MAN';
  package Pod::Man;use 5.006;use strict;use warnings;use subs qw(makespace);use vars qw(@ISA %ESCAPES $PREAMBLE $VERSION);use Carp qw(carp croak);use Pod::Simple ();our$HAS_ENCODE;BEGIN {$HAS_ENCODE=eval {require Encode}}@ISA=qw(Pod::Simple);$VERSION='4.12';BEGIN {my$parent=defined (&Pod::Simple::DEBUG)? \&Pod::Simple::DEBUG : undef;unless (defined&DEBUG){*DEBUG=$parent || sub () {10}}}BEGIN {*ASCII=\&Pod::Simple::ASCII}BEGIN {*pretty=\&Pod::Simple::pretty}my%FORMATTING=(DEFAULT=>{cleanup=>1,convert=>1,guesswork=>1,literal=>0 },Data=>{cleanup=>0,convert=>0,guesswork=>0,literal=>0 },Verbatim=>{guesswork=>0,literal=>1 },C=>{guesswork=>0,literal=>1 },X=>{cleanup=>0,guesswork=>0 },);sub new {my$class=shift;my$self=$class->SUPER::new;$self->nbsp_for_S (1);if (my$preserve_whitespace=$self->can ('preserve_whitespace')){$self->$preserve_whitespace (1)}else {$self->fullstop_space_harden (1)}$self->accept_targets (qw/man MAN roff ROFF/);$self->merge_text (1);%$self=(%$self,@_);if ($$self{stderr}and not $$self{errors}){$$self{errors}='stderr'}delete $$self{stderr};if (not defined $$self{errors}){$$self{errors}='pod'}if ($$self{errors}eq 'stderr' || $$self{errors}eq 'die'){$self->no_errata_section (1);$self->complain_stderr (1);if ($$self{errors}eq 'die'){$$self{complain_die}=1}}elsif ($$self{errors}eq 'pod'){$self->no_errata_section (0);$self->complain_stderr (0)}elsif ($$self{errors}eq 'none'){$self->no_errata_section (1);$self->no_whining (1)}else {croak (qq(Invalid errors setting: "$$self{errors}"))}delete $$self{errors};if ($$self{utf8}and!$HAS_ENCODE){if (!$ENV{PERL_CORE}){carp ('utf8 mode requested but Encode module not available,' .' falling back to non-utf8')}delete $$self{utf8}}$self->init_fonts;$self->init_quotes;$self->init_page;$$self{MAGIC_CPP}=1;$$self{MAGIC_EMDASH}=1;$$self{MAGIC_FUNC}=1;$$self{MAGIC_MANREF}=1;$$self{MAGIC_SMALLCAPS}=1;$$self{MAGIC_VARS}=1;return$self}sub toescape {(length ($_[0])> 1 ? '\f(' : '\f').$_[0]}sub init_fonts {my ($self)=@_;for (qw/fixed fixedbold fixeditalic fixedbolditalic/){my$font=$$self{$_};if (defined ($font)&& (length ($font)< 1 || length ($font)> 2)){croak qq(roff font should be 1 or 2 chars, not "$font")}}$$self{fixed}||= 'CW';$$self{fixedbold}||= 'CB';$$self{fixeditalic}||= 'CI';$$self{fixedbolditalic}||= 'CB';$$self{FONTS}={'000'=>'\fR','001'=>'\fI','010'=>'\fB','011'=>'\f(BI','100'=>toescape ($$self{fixed}),'101'=>toescape ($$self{fixeditalic}),'110'=>toescape ($$self{fixedbold}),'111'=>toescape ($$self{fixedbolditalic})}}sub init_quotes {my ($self)=(@_);$$self{quotes}||= '"';if ($$self{quotes}eq 'none'){$$self{LQUOTE}=$$self{RQUOTE}=''}elsif (length ($$self{quotes})==1){$$self{LQUOTE}=$$self{RQUOTE}=$$self{quotes}}elsif (length ($$self{quotes})% 2==0){my$length=length ($$self{quotes})/ 2;$$self{LQUOTE}=substr ($$self{quotes},0,$length);$$self{RQUOTE}=substr ($$self{quotes},$length)}else {croak(qq(Invalid quote specification "$$self{quotes}"))}if (defined $$self{lquote}){$$self{LQUOTE}=$$self{lquote}eq 'none' ? q{} : $$self{lquote}}if (defined $$self{rquote}){$$self{RQUOTE}=$$self{rquote}eq 'none' ? q{} : $$self{rquote}}$$self{LQUOTE}=~ s/\"/\"\"/;$$self{RQUOTE}=~ s/\"/\"\"/}sub init_page {my ($self)=@_;my@version=($] =~ /^(\d+)\.(\d{3})(\d{0,3})$/);$version[2]||= 0;$version[2]*= 10 ** (3 - length$version[2]);for (@version){$_ += 0}my$version=join ('.',@version);$$self{center}='User Contributed Perl Documentation' unless defined $$self{center};$$self{release}='perl v' .$version unless defined $$self{release};$$self{indent}=4 unless defined $$self{indent};for (qw/center release/){$$self{$_}=~ s/\"/\"\"/g if $$self{$_}}}sub _handle_text {my ($self,$text)=@_;DEBUG > 3 and print "== $text\n";my$tag=$$self{PENDING}[-1];$$tag[2].= $self->format_text ($$tag[1],$text)}sub method_for_element {my ($self,$element)=@_;$element =~ tr/A-Z-/a-z_/;$element =~ tr/_a-z0-9//cd;return$element}sub _handle_element_start {my ($self,$element,$attrs)=@_;DEBUG > 3 and print "++ $element (<",join ('> <',%$attrs),">)\n";my$method=$self->method_for_element ($element);if ($self->can ("cmd_$method")){DEBUG > 2 and print "<$element> starts saving a tag\n";$$self{IN_NAME}=0 if ($element ne 'Para' && length ($element)> 1);my$formatting={%{$$self{PENDING}[-1][1]|| $FORMATTING{DEFAULT}},%{$FORMATTING{$element}|| {}},};push (@{$$self{PENDING}},[$attrs,$formatting,'' ]);DEBUG > 4 and print "Pending: [",pretty ($$self{PENDING}),"]\n"}elsif (my$start_method=$self->can ("start_$method")){$self->$start_method ($attrs,'')}else {DEBUG > 2 and print "No $method start method, skipping\n"}}sub _handle_element_end {my ($self,$element)=@_;DEBUG > 3 and print "-- $element\n";my$method=$self->method_for_element ($element);if (my$cmd_method=$self->can ("cmd_$method")){DEBUG > 2 and print "</$element> stops saving a tag\n";my$tag=pop @{$$self{PENDING}};DEBUG > 4 and print "Popped: [",pretty ($tag),"]\n";DEBUG > 4 and print "Pending: [",pretty ($$self{PENDING}),"]\n";my$text=$self->$cmd_method ($$tag[0],$$tag[2]);if (defined$text){if (@{$$self{PENDING}}> 1){$$self{PENDING}[-1][2].= $text}else {$self->output ($text)}}}elsif (my$end_method=$self->can ("end_$method")){$self->$end_method ()}else {DEBUG > 2 and print "No $method end method, skipping\n"}}sub format_text {my ($self,$options,$text)=@_;my$guesswork=$$options{guesswork}&&!$$self{IN_NAME};my$cleanup=$$options{cleanup};my$convert=$$options{convert};my$literal=$$options{literal};if ($cleanup){$text =~ s/\\/\\e/g;$text =~ s/-/\\-/g;$text =~ s/_(?=_)/_\\|/g}if ($convert &&!$$self{utf8}&& ASCII){$text =~ s/([^\x00-\x7F])/$ESCAPES{ord ($1)} || "X"/eg}if ($literal){$text =~ s/(?<!\\\*)\'/\\*\(Aq/g;$text =~ s/(?<!\\\*)\`/\\\`/g}if ($guesswork){$text=$self->guesswork ($text)}return$text}sub quote_literal {my$self=shift;local $_=shift;my$index='(?: \[.*\] | \{.*\} )?';return qq{"$_"} if $$self{IN_NAME};m{
        ^\s*
        (?:
           ( [\'\`\"] ) .* \1                             # already quoted
         | \\\*\(Aq .* \\\*\(Aq                           # quoted and escaped
         | \\?\` .* ( \' | \\\*\(Aq )                     # `quoted'
         | \$+ [\#^]? \S $index                           # special ($^Foo, $")
         | [\$\@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
         | [\$\@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
         | [-+]? ( \d[\d.]* | \.\d+ ) (?: [eE][-+]?\d+ )? # a number
         | 0x [a-fA-F\d]+                                 # a hex constant
        )
        \s*\z
       }xso and return '\f(FS' .$_ .'\f(FE';return '\f(FS\*(C`' .$_ ."\\*(C'\\f(FE"}sub guesswork {my$self=shift;local $_=shift;DEBUG > 5 and print "   Guesswork called on [$_]\n";s{
          ( (?:\G|^|\s) [\(\"]* [a-zA-Z] ) ( \\- )?
          ( (?: [a-zA-Z\']+ \\-)+ )
          ( [a-zA-Z\']+ ) (?= [\)\".?!,;:]* (?:\s|\Z|\\\ ) )
          \b
      } {
          my ($prefix, $hyphen, $main, $suffix) = ($1, $2, $3, $4);
          $hyphen ||= '';
          $main =~ s/\\-/-/g;
          $prefix . $hyphen . $main . $suffix;
      }egx;if ($$self{MAGIC_EMDASH}){s{          (\s) \\-\\- (\s)                } { $1 . '\*(--' . $2 }egx;s{ (\b[a-zA-Z]+) \\-\\- (\s|\Z|[a-zA-Z]+\b) } { $1 . '\*(--' . $2 }egx}if ($$self{MAGIC_SMALLCAPS}){s{
              ( ^ | [\s\(\"\'\`\[\{<>] | \\[ ]  )                           # (1)
              ( [A-Z] [A-Z] (?: \s? [/A-Z+:\d_\$&] | \\- | \s? [.,\"] )* )  # (2)
              (?= [\s>\}\]\(\)\'\".?!,;] | \\*\(-- | \\[ ] | $ )            # (3)
          } {
              $1 . '\s-1' . $2 . '\s0'
          }egx}if ($$self{MAGIC_FUNC}){s{
              ( \b | \\s-1 )
              ( [A-Za-z_] ([:\w] | \\s-?[01])+ \(\) )
          } {
              $1 . '\f(BS' . $2 . '\f(BE'
          }egx}if ($$self{MAGIC_MANREF}){s{
              ( \b | \\s-1 )
              (?<! \\ )                                   # rule out \s0(1)
              ( [A-Za-z_] (?:[.:\w] | \\- | \\s-?[01])+ )
              ( \( \d [a-z]* \) )
          } {
              $1 . '\f(BS' . $2 . '\f(BE\|' . $3
          }egx}if ($$self{MAGIC_VARS}){s{
             ( ^ | \s+ )
             ( [\$\@%] [\w:]+ )
             (?! \( )
          } {
              $1 . '\f(FS' . $2 . '\f(FE'
          }egx}s{ \" ([^\"]+) \" } { '\*(L"' . $1 . '\*(R"' }egx;if ($$self{MAGIC_CPP}){s{ \b C\+\+ } {\\*\(C+}gx}DEBUG > 5 and print "   Guesswork returning [$_]\n";return $_}sub mapfonts {my ($self,$text)=@_;my ($fixed,$bold,$italic)=(0,0,0);my%magic=(F=>\$fixed,B=>\$bold,I=>\$italic);my$last='\fR';$text =~ s<
          \\f\((.)(.)
      > <
          my $sequence = '';
          my $f;
          if ($last ne '\fR') { $sequence = '\fP' }
          ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
          $f = $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
          if ($f eq $last) {
              '';
          } else {
              if ($f ne '\fR') { $sequence .= $f }
              $last = $f;
              $sequence;
          }
      >gxe;return$text}sub textmapfonts {my ($self,$text)=@_;my ($fixed,$bold,$italic)=(0,0,0);my%magic=(F=>\$fixed,B=>\$bold,I=>\$italic);$text =~ s<
          \\f\((.)(.)
      > <
          ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
          $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
      >gxe;return$text}sub switchquotes {my ($self,$command,$text,$extra)=@_;$text =~ s/\\\*\([LR]\"/\"/g;my$c_is_quote=($$self{LQUOTE}=~ /\"/)|| ($$self{RQUOTE}=~ /\"/);my$fixedpat=join '|',@{$$self{FONTS}}{'100','101','110','111'};$fixedpat =~ s/\\/\\\\/g;$fixedpat =~ s/\(/\\\(/g;if ($text =~ m/\"/ || $text =~ m/$fixedpat/){$text =~ s/\"/\"\"/g;my$nroff=$text;my$troff=$text;$troff =~ s/\"\"([^\"]*)\"\"/\`\`$1\'\'/g;if ($c_is_quote and $text =~ m/\\\*\(C[\'\`]/){$nroff =~ s/\\\*\(C\`/$$self{LQUOTE}/g;$nroff =~ s/\\\*\(C\'/$$self{RQUOTE}/g;$troff =~ s/\\\*\(C[\'\`]//g}$nroff=qq("$nroff") .($extra ? " $extra" : '');$troff=qq("$troff") .($extra ? " $extra" : '');my$font_end="(?:\\f[PR]|\Q$$self{FONTS}{100}\E)";$nroff =~ s/\Q$$self{FONTS}{100}\E(.*?)\\f([PR])/$1/g;$nroff =~ s/\Q$$self{FONTS}{101}\E(.*?)$font_end/\\fI$1\\fP/g;$nroff =~ s/\Q$$self{FONTS}{110}\E(.*?)$font_end/\\fB$1\\fP/g;$nroff =~ s/\Q$$self{FONTS}{111}\E(.*?)$font_end/\\f\(BI$1\\fP/g;if ($nroff ne $troff){return ".ie n $command $nroff\n.el $command $troff\n"}else {return "$command $nroff\n"}}else {$text=qq("$text") .($extra ? " $extra" : '');return "$command $text\n"}}sub protect {my ($self,$text)=@_;$text =~ s/^([.\'\\])/\\&$1/mg;return$text}sub makespace {my ($self)=@_;$self->output (".PD\n")if $$self{ITEMS}> 1;$$self{ITEMS}=0;$self->output ($$self{INDENT}> 0 ? ".Sp\n" : ".PP\n")if $$self{NEEDSPACE}}sub outindex {my ($self,$section,$index)=@_;my@entries=map {split m%\s*/\s*%}@{$$self{INDEX}};return unless ($section || @entries);$$self{INDEX}=[];my@output;if (@entries){push@output,['Xref',join (' ',@entries)]}if ($section){$index =~ s/\\-/-/g;$index =~ s/\\(?:s-?\d|.\(..|.)//g;push@output,[$section,$index ]}for (@output){my ($type,$entry)=@$_;$entry =~ s/\s+/ /g;$entry =~ s/\"/\"\"/g;$entry =~ s/\\/\\\\/g;$self->output (".IX $type " .'"' .$entry .'"' ."\n")}}sub output {my ($self,@text)=@_;if ($$self{ENCODE}){print {$$self{output_fh}}Encode::encode ('UTF-8',join ('',@text))}else {print {$$self{output_fh}}@text}}sub start_document {my ($self,$attrs)=@_;if ($$attrs{contentless}&&!$$self{ALWAYS_EMIT_SOMETHING}){DEBUG and print "Document is contentless\n";$$self{CONTENTLESS}=1}else {delete $$self{CONTENTLESS}}$$self{ENCODE}=0;if ($$self{utf8}){$$self{ENCODE}=1;eval {my@options=(output=>1,details=>1);my@layers=PerlIO::get_layers (*{$$self{output_fh}},@options);if ($layers[-1]& PerlIO::F_UTF8 ()){$$self{ENCODE}=0}}}if (!$$self{CONTENTLESS}){my ($name,$section);if (defined $$self{name}){$name=$$self{name};$section=$$self{section}|| 1}else {($name,$section)=$self->devise_title}my$date=defined($$self{date})? $$self{date}: $self->devise_date;$self->preamble ($name,$section,$date)unless$self->bare_output or DEBUG > 9}$$self{INDENT}=0;$$self{INDENTS}=[];$$self{INDEX}=[];$$self{IN_NAME}=0;$$self{ITEMS}=0;$$self{ITEMTYPES}=[];$$self{SHIFTWAIT}=0;$$self{SHIFTS}=[];$$self{PENDING}=[[]]}sub end_document {my ($self)=@_;if ($$self{complain_die}&& $self->errors_seen){croak ("POD document had syntax errors")}return if$self->bare_output;return if ($$self{CONTENTLESS}&&!$$self{ALWAYS_EMIT_SOMETHING});$self->output (q(.\" [End document]) ."\n")if DEBUG}sub devise_title {my ($self)=@_;my$name=$self->source_filename || '';my$section=$$self{section}|| 1;$section=3 if (!$$self{section}&& $name =~ /\.pm\z/i);$name =~ s/\.p(od|[lm])\z//i;if ($name =~ /^IO::File(?:=\w+)\(0x[\da-f]+\)$/i){$name=''}if ($name eq ''){$name='STDIN'}if ($section !~ /^3/){require File::Basename;$name=uc File::Basename::basename ($name)}else {require File::Spec;my ($volume,$dirs,$file)=File::Spec->splitpath ($name);my@dirs=File::Spec->splitdir ($dirs);if (@dirs){my$cut=0;my$i;for ($i=0;$i < @dirs;$i++){if ($dirs[$i]=~ /perl/){$cut=$i + 1;$cut++ if ($dirs[$i + 1]&& $dirs[$i + 1]eq 'lib');last}}if ($cut > 0){splice (@dirs,0,$cut);shift@dirs if ($dirs[0]=~ /^(site|vendor)(_perl)?$/);shift@dirs if ($dirs[0]=~ /^[\d.]+$/);shift@dirs if ($dirs[0]=~ /^(.*-$^O|$^O-.*|$^O)$/)}shift@dirs if$dirs[0]eq 'lib';splice (@dirs,0,2)if ($dirs[0]eq 'blib' && $dirs[1]eq 'lib')}$name=join ('::',(grep {$_ ? $_ : ()}@dirs),$file)}return ($name,$section)}sub devise_date {my ($self)=@_;if (defined($ENV{POD_MAN_DATE})){return$ENV{POD_MAN_DATE}}my$time;if (defined($ENV{SOURCE_DATE_EPOCH})&& $ENV{SOURCE_DATE_EPOCH}!~ /\D/){$time=$ENV{SOURCE_DATE_EPOCH}}if (!defined$time){my$input=$self->source_filename;if ($input){$time=(stat($input))[9]|| time()}else {$time=time()}}my ($year,$month,$day)=(gmtime($time))[5,4,3];return sprintf("%04d-%02d-%02d",$year + 1900,$month + 1,$day)}sub preamble {my ($self,$name,$section,$date)=@_;my$preamble=$self->preamble_template (!$$self{utf8});my$index="$name $section";$index =~ s/\"/\"\"/g;for ($name,$section){if (/\s/){s/\"/\"\"/g;$_='"' .$_ .'"'}}$date =~ s/\"/\"\"/g;$preamble =~ s/\@CFONT\@/$$self{fixed}/;$preamble =~ s/\@LQUOTE\@/$$self{LQUOTE}/;$preamble =~ s/\@RQUOTE\@/$$self{RQUOTE}/;chomp$preamble;my$version=$self->version_report;$self->output (<<"----END OF HEADER----");$self->output (".\\\" [End of preamble]\n")if DEBUG}sub cmd_para {my ($self,$attrs,$text)=@_;my$line=$$attrs{start_line};$self->makespace;if ($$self{SHIFTWAIT}){$self->output (".RS $$self{INDENT}\n");push (@{$$self{SHIFTS}},$$self{INDENT});$$self{SHIFTWAIT}=0}$self->output (".\\\" [At source line $line]\n")if defined ($line)&& DEBUG &&!$$self{IN_NAME};$text=reverse$text;$text =~ s/\A\s*?(?= \\|\S|\z)/\n/;$text=reverse$text;$self->output ($self->protect ($self->textmapfonts ($text)));$self->outindex;$$self{NEEDSPACE}=1;return ''}sub cmd_verbatim {my ($self,$attrs,$text)=@_;return unless$text =~ /\S/;$text=reverse$text;$text =~ s/\A\s*/\n/;$text=reverse$text;my@lines=split (/\n/,$text);my$unbroken=0;for (@lines){last if /^\s*$/;$unbroken++}$unbroken=10 if ($unbroken > 12 &&!$$self{MAGIC_VNOPAGEBREAK_LIMIT});$text =~ s/^/\\&/gm;$self->makespace;$self->output (".Vb $unbroken\n$text.Ve\n");$$self{NEEDSPACE}=1;return ''}sub cmd_data {my ($self,$attrs,$text)=@_;$text =~ s/^\n+//;$text =~ s/\n{0,2}$/\n/;$self->output ($text);return ''}sub heading_common {my ($self,$text,$line)=@_;$text =~ s/\s+$//;$text =~ s/\s*\n\s*/ /g;if ($$self{ITEMS}> 1){$$self{ITEMS}=0;$self->output (".PD\n")}$self->output (".\\\" [At source line $line]\n")if defined ($line)&& DEBUG;return$text}sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\\s-?\d//g;$text=$self->heading_common ($text,$$attrs{start_line});my$isname=($text eq 'NAME' || $text =~ /\(NAME\)/);$self->output ($self->switchquotes ('.SH',$self->mapfonts ($text)));$self->outindex ('Header',$text)unless$isname;$$self{NEEDSPACE}=0;$$self{IN_NAME}=$isname;return ''}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text=$self->heading_common ($text,$$attrs{start_line});$self->output ($self->switchquotes ('.SS',$self->mapfonts ($text)));$self->outindex ('Subsection',$text);$$self{NEEDSPACE}=0;return ''}sub cmd_head3 {my ($self,$attrs,$text)=@_;$text=$self->heading_common ($text,$$attrs{start_line});$self->makespace;$self->output ($self->textmapfonts ('\f(IS' .$text .'\f(IE')."\n");$self->outindex ('Subsection',$text);$$self{NEEDSPACE}=1;return ''}sub cmd_head4 {my ($self,$attrs,$text)=@_;$text=$self->heading_common ($text,$$attrs{start_line});$self->makespace;$self->output ($self->textmapfonts ($text)."\n");$self->outindex ('Subsection',$text);$$self{NEEDSPACE}=1;return ''}sub cmd_b {return $_[0]->{IN_NAME}? $_[2]: '\f(BS' .$_[2].'\f(BE'}sub cmd_i {return $_[0]->{IN_NAME}? $_[2]: '\f(IS' .$_[2].'\f(IE'}sub cmd_f {return $_[0]->{IN_NAME}? $_[2]: '\f(IS' .$_[2].'\f(IE'}sub cmd_c {return $_[0]->quote_literal ($_[2])}sub cmd_x {my ($self,$attrs,$text)=@_;push (@{$$self{INDEX}},$text);return ''}sub cmd_l {my ($self,$attrs,$text)=@_;if ($$attrs{type}eq 'url'){my$to=$$attrs{to};if (defined$to){my$tag=$$self{PENDING}[-1];$to=$self->format_text ($$tag[1],$to)}if (not defined ($to)or $to eq $text){return "<$text>"}elsif ($$self{nourls}){return$text}else {return "$text <$$attrs{to}>"}}else {return$text}}sub over_common_start {my ($self,$type,$attrs)=@_;my$line=$$attrs{start_line};my$indent=$$attrs{indent};DEBUG > 3 and print " Starting =over $type (line $line, indent ",($indent || '?'),"\n";unless (defined ($indent)&& $indent =~ /^[-+]?\d{1,4}\s*$/){$indent=$$self{indent}}if (@{$$self{SHIFTS}}< @{$$self{INDENTS}}){$self->output (".RS $$self{INDENT}\n");push (@{$$self{SHIFTS}},$$self{INDENT})}push (@{$$self{INDENTS}},$$self{INDENT});push (@{$$self{ITEMTYPES}},$type);$$self{INDENT}=$indent + 0;$$self{SHIFTWAIT}=1}sub over_common_end {my ($self)=@_;DEBUG > 3 and print " Ending =over\n";$$self{INDENT}=pop @{$$self{INDENTS}};pop @{$$self{ITEMTYPES}};if (@{$$self{SHIFTS}}> @{$$self{INDENTS}}){$self->output (".RE\n");pop @{$$self{SHIFTS}}}if (@{$$self{INDENTS}}> 0){$self->output (".RE\n");$self->output (".RS $$self{INDENT}\n")}$$self{NEEDSPACE}=1;$$self{SHIFTWAIT}=0}sub start_over_bullet {my$s=shift;$s->over_common_start ('bullet',@_)}sub start_over_number {my$s=shift;$s->over_common_start ('number',@_)}sub start_over_text {my$s=shift;$s->over_common_start ('text',@_)}sub start_over_block {my$s=shift;$s->over_common_start ('block',@_)}sub end_over_bullet {$_[0]->over_common_end}sub end_over_number {$_[0]->over_common_end}sub end_over_text {$_[0]->over_common_end}sub end_over_block {$_[0]->over_common_end}sub item_common {my ($self,$type,$attrs,$text)=@_;my$line=$$attrs{start_line};DEBUG > 3 and print "  $type item (line $line): $text\n";$text =~ s/\s+$//;my ($item,$index);if ($type eq 'bullet'){$item="\\\(bu";$text =~ s/\n*$/\n/}elsif ($type eq 'number'){$item=$$attrs{number}.'.'}else {$item=$text;$item =~ s/\s*\n\s*/ /g;$text='';$index=$item if ($item =~ /\w/)}if (@{$$self{SHIFTS}}==@{$$self{INDENTS}}){$self->output (".RE\n");pop @{$$self{SHIFTS}}}$self->output (".PD 0\n")if ($$self{ITEMS}==1);$item=$self->textmapfonts ($item);$self->output ($self->switchquotes ('.IP',$item,$$self{INDENT}));$$self{NEEDSPACE}=0;$$self{ITEMS}++;$$self{SHIFTWAIT}=0;if ($text){$text =~ s/\s*$/\n/;$self->makespace;$self->output ($self->protect ($self->textmapfonts ($text)));$$self{NEEDSPACE}=1}$self->outindex ($index ? ('Item',$index): ())}sub cmd_item_bullet {my$self=shift;$self->item_common ('bullet',@_)}sub cmd_item_number {my$self=shift;$self->item_common ('number',@_)}sub cmd_item_text {my$self=shift;$self->item_common ('text',@_)}sub cmd_item_block {my$self=shift;$self->item_common ('block',@_)}sub parse_from_file {my$self=shift;$self->reinit;if (ref ($_[0])eq 'HASH'){my$opts=shift @_;if (defined ($$opts{-cutting})&&!$$opts{-cutting}){$$self{in_pod}=1;$$self{last_was_blank}=1}}my$retval=$self->SUPER::parse_from_file (@_);my$fh=$self->output_fh ();my$oldfh=select$fh;my$oldflush=$|;$|=1;print$fh '';$|=$oldflush;select$oldfh;return$retval}sub parse_from_filehandle {my$self=shift;return$self->parse_from_file (@_)}sub parse_file {my ($self,$in)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_file ($in)}sub parse_lines {my ($self,@lines)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_lines (@lines)}sub parse_string_document {my ($self,$doc)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_string_document ($doc)}@ESCAPES{0xA0 .. 0xFF}=("\\ ",undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,"\\%",undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,"A\\*`","A\\*'","A\\*^","A\\*~","A\\*:","A\\*o","\\*(Ae","C\\*,","E\\*`","E\\*'","E\\*^","E\\*:","I\\*`","I\\*'","I\\*^","I\\*:","\\*(D-","N\\*~","O\\*`","O\\*'","O\\*^","O\\*~","O\\*:",undef,"O\\*/","U\\*`","U\\*'","U\\*^","U\\*:","Y\\*'","\\*(Th","\\*8","a\\*`","a\\*'","a\\*^","a\\*~","a\\*:","a\\*o","\\*(ae","c\\*,","e\\*`","e\\*'","e\\*^","e\\*:","i\\*`","i\\*'","i\\*^","i\\*:","\\*(d-","n\\*~","o\\*`","o\\*'","o\\*^","o\\*~","o\\*:",undef,"o\\*/","u\\*`","u\\*'","u\\*^","u\\*:","y\\*'","\\*(th","y\\*:",)if ASCII;sub preamble_template {my ($self,$accents)=@_;my$preamble=<<'----END OF PREAMBLE----';if ($accents){$preamble .= <<'----END OF PREAMBLE----'}return$preamble}1;
  .\\" Automatically generated by $version
  .\\"
  .\\" Standard preamble:
  .\\" ========================================================================
  $preamble
  .\\" ========================================================================
  .\\"
  .IX Title "$index"
  .TH $name $section "$date" "$$self{release}" "$$self{center}"
  .\\" For nroff, turn off justification.  Always turn off hyphenation; it makes
  .\\" way too many mistakes in technical documents.
  .if n .ad l
  .nh
  ----END OF HEADER----
  .de Sp \" Vertical space (when we can't use .PP)
  .if t .sp .5v
  .if n .sp
  ..
  .de Vb \" Begin verbatim text
  .ft @CFONT@
  .nf
  .ne \\$1
  ..
  .de Ve \" End verbatim text
  .ft R
  .fi
  ..
  .\" Set up some character translations and predefined strings.  \*(-- will
  .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
  .\" double quote, and \*(R" will give a right double quote.  \*(C+ will
  .\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
  .\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
  .\" nothing in troff, for use with C<>.
  .tr \(*W-
  .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
  .ie n \{\
  .    ds -- \(*W-
  .    ds PI pi
  .    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
  .    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
  .    ds L" ""
  .    ds R" ""
  .    ds C` @LQUOTE@
  .    ds C' @RQUOTE@
  'br\}
  .el\{\
  .    ds -- \|\(em\|
  .    ds PI \(*p
  .    ds L" ``
  .    ds R" ''
  .    ds C`
  .    ds C'
  'br\}
  .\"
  .\" Escape single quotes in literal strings from groff's Unicode transform.
  .ie \n(.g .ds Aq \(aq
  .el       .ds Aq '
  .\"
  .\" If the F register is >0, we'll generate index entries on stderr for
  .\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
  .\" entries marked with X<> in POD.  Of course, you'll have to process the
  .\" output yourself in some meaningful fashion.
  .\"
  .\" Avoid warning from groff about undefined register 'F'.
  .de IX
  ..
  .nr rF 0
  .if \n(.g .if rF .nr rF 1
  .if (\n(rF:(\n(.g==0)) \{\
  .    if \nF \{\
  .        de IX
  .        tm Index:\\$1\t\\n%\t"\\$2"
  ..
  .        if !\nF==2 \{\
  .            nr % 0
  .            nr F 2
  .        \}
  .    \}
  .\}
  .rr rF
  ----END OF PREAMBLE----
  .\"
  .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
  .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
  .    \" fudge factors for nroff and troff
  .if n \{\
  .    ds #H 0
  .    ds #V .8m
  .    ds #F .3m
  .    ds #[ \f1
  .    ds #] \fP
  .\}
  .if t \{\
  .    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
  .    ds #V .6m
  .    ds #F 0
  .    ds #[ \&
  .    ds #] \&
  .\}
  .    \" simple accents for nroff and troff
  .if n \{\
  .    ds ' \&
  .    ds ` \&
  .    ds ^ \&
  .    ds , \&
  .    ds ~ ~
  .    ds /
  .\}
  .if t \{\
  .    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
  .    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
  .    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
  .    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
  .    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
  .    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
  .\}
  .    \" troff and (daisy-wheel) nroff accents
  .ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
  .ds 8 \h'\*(#H'\(*b\h'-\*(#H'
  .ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
  .ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
  .ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
  .ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
  .ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
  .ds ae a\h'-(\w'a'u*4/10)'e
  .ds Ae A\h'-(\w'A'u*4/10)'E
  .    \" corrections for vroff
  .if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
  .if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
  .    \" for low resolution devices (crt and lpr)
  .if \n(.H>23 .if \n(.V>19 \
  \{\
  .    ds : e
  .    ds 8 ss
  .    ds o a
  .    ds d- d\h'-1'\(ga
  .    ds D- D\h'-1'\(hy
  .    ds th \o'bp'
  .    ds Th \o'LP'
  .    ds ae ae
  .    ds Ae AE
  .\}
  .rm #[ #] #H #V #F C
  ----END OF PREAMBLE----
POD_MAN

$fatpacked{"Pod/ParseLink.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PARSELINK';
  package Pod::ParseLink;use 5.006;use strict;use warnings;use vars qw(@EXPORT @ISA $VERSION);use Exporter;@ISA=qw(Exporter);@EXPORT=qw(parselink);$VERSION='4.12';sub _parse_section {my ($link)=@_;$link =~ s/^\s+//;$link =~ s/\s+$//;return (undef,$1)if ($link =~ /^"\s*(.*?)\s*"$/);my ($page,$section)=split (/\s*\/\s*/,$link,2);$section =~ s/^"\s*(.*?)\s*"$/$1/ if$section;if ($page && $page =~ / / &&!defined ($section)){$section=$page;$page=undef}else {$page=undef unless$page;$section=undef unless$section}return ($page,$section)}sub _infer_text {my ($page,$section)=@_;my$inferred;if ($page &&!$section){$inferred=$page}elsif (!$page && $section){$inferred='"' .$section .'"'}elsif ($page && $section){$inferred='"' .$section .'" in ' .$page}return$inferred}sub parselink {my ($link)=@_;$link =~ s/\s+/ /g;my$text;if ($link =~ /\|/){($text,$link)=split (/\|/,$link,2)}if ($link =~ /\A\w+:[^:\s]\S*\Z/){my$inferred;if (defined ($text)&& length ($text)> 0){return ($text,$text,$link,undef,'url')}else {return ($text,$link,$link,undef,'url')}}else {my ($name,$section)=_parse_section ($link);my$inferred;if (defined ($text)&& length ($text)> 0){$inferred=$text}else {$inferred=_infer_text ($name,$section)}my$type=($name && $name =~ /\(\S*\)/)? 'man' : 'pod';return ($text,$inferred,$name,$section,$type)}}1;
POD_PARSELINK

$fatpacked{"Pod/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE';
  require 5;package Pod::Simple;use strict;use Carp ();BEGIN {*DEBUG=sub () {0}unless defined&DEBUG}use integer;use Pod::Escapes 1.04 ();use Pod::Simple::LinkSection ();use Pod::Simple::BlackBox ();use vars qw($VERSION @ISA @Known_formatting_codes @Known_directives %Known_formatting_codes %Known_directives $NL);@ISA=('Pod::Simple::BlackBox');$VERSION='3.40';@Known_formatting_codes=qw(I B C L E F S X Z);%Known_formatting_codes=map(($_=>1),@Known_formatting_codes);@Known_directives=qw(head1 head2 head3 head4 item over back);%Known_directives=map(($_=>'Plain'),@Known_directives);$NL=$/ unless defined$NL;BEGIN {if(defined&ASCII){}elsif(chr(65)eq 'A'){*ASCII=sub () {1}}else {*ASCII=sub () {''}}unless(defined&MANY_LINES){*MANY_LINES=sub () {20}}DEBUG > 4 and print STDERR "MANY_LINES is ",MANY_LINES(),"\n";unless(MANY_LINES()>= 1){die "MANY_LINES is too small (",MANY_LINES(),")!\nAborting"}if(defined&UNICODE){}elsif($] >= 5.008){*UNICODE=sub() {1}}else {*UNICODE=sub() {''}}}if(DEBUG > 2){print STDERR "# We are ",ASCII ? '' : 'not ',"in ASCII-land\n";print STDERR "# We are under a Unicode-safe Perl.\n"}if ($] ge 5.007_003){$Pod::Simple::nbsp=chr utf8::unicode_to_native(0xA0);$Pod::Simple::shy=chr utf8::unicode_to_native(0xAD)}elsif (Pod::Simple::ASCII){$Pod::Simple::nbsp="\xA0";$Pod::Simple::shy="\xAD"}else {$Pod::Simple::nbsp="\x41";$Pod::Simple::shy="\xCA"}__PACKAGE__->_accessorize('_output_is_for_JustPod','nbsp_for_S','source_filename','source_dead','output_fh','hide_line_numbers','line_count','pod_para_count','no_whining','no_errata_section','complain_stderr','doc_has_started','bare_output','keep_encoding_directive','nix_X_codes','merge_text','preserve_whitespace','strip_verbatim_indent','expand_verbatim_tabs','parse_characters','content_seen','errors_seen','codes_in_verbatim','code_handler','cut_handler','pod_handler','whiteline_handler','parse_empty_lists','raw_mode',);sub any_errata_seen {return shift->{'errors_seen'}|| 0}sub errata_seen {return shift->{'all_errata'}|| {}}sub detected_encoding {return shift->{'detected_encoding'}}sub encoding {my$this=shift;return$this->{'encoding'}unless @_;$this->_handle_encoding_line("=encoding $_[0]");if ($this->{'_processed_encoding'}){delete$this->{'_processed_encoding'};if(!$this->{'encoding_command_statuses'}){DEBUG > 2 and print STDERR " CRAZY ERROR: encoding wasn't really handled?!\n"}elsif($this->{'encoding_command_statuses'}[-1]){$this->scream("=encoding $_[0]",sprintf "Couldn't do %s: %s",$this->{'encoding_command_reqs' }[-1],$this->{'encoding_command_statuses'}[-1],)}else {DEBUG > 2 and print STDERR " (encoding successfully handled.)\n"}return$this->{'encoding'}}else {return undef}}BEGIN {*pretty=\&Pod::Simple::BlackBox::pretty;*stringify_lol=\&Pod::Simple::BlackBox::stringify_lol;*my_qr=\&Pod::Simple::BlackBox::my_qr}sub version_report {my$class=ref($_[0])|| $_[0];if($class eq __PACKAGE__){return "$class $VERSION"}else {my$v=$class->VERSION;return "$class $v (" .__PACKAGE__ ." $VERSION)"}}sub output_string {my$this=shift;return$this->{'output_string'}unless @_;require Pod::Simple::TiedOutFH;my$x=(defined($_[0])and ref($_[0]))? $_[0]: \($_[0]);$$x='' unless defined $$x;DEBUG > 4 and print STDERR "# Output string set to $x ($$x)\n";$this->{'output_fh'}=Pod::Simple::TiedOutFH->handle_on($_[0]);return $this->{'output_string'}=$_[0]}sub abandon_output_string {$_[0]->abandon_output_fh;delete $_[0]{'output_string'}}sub abandon_output_fh {$_[0]->output_fh(undef)}sub new {my$class=ref($_[0])|| $_[0];my$obj=bless {'accept_codes'=>{map(($_=>$_),@Known_formatting_codes)},'accept_directives'=>{%Known_directives },'accept_targets'=>{},},$class;$obj->expand_verbatim_tabs(8);return$obj}sub _handle_element_start {my($self,$element_name,$attr_hash_r)=@_;return}sub _handle_element_end {my($self,$element_name)=@_;return}sub _handle_text {my($self,$text)=@_;return}sub accept_directive_as_verbatim {shift->_accept_directives('Verbatim',@_)}sub accept_directive_as_data {shift->_accept_directives('Data',@_)}sub accept_directive_as_processed {shift->_accept_directives('Plain',@_)}sub _accept_directives {my($this,$type)=splice @_,0,2;for my$d (@_){next unless defined$d and length$d;Carp::croak "\"$d\" isn't a valid directive name" unless$d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;Carp::croak "\"$d\" is already a reserved Pod directive name" if exists$Known_directives{$d};$this->{'accept_directives'}{$d}=$type;DEBUG > 2 and print STDERR "Learning to accept \"=$d\" as directive of type $type\n"}DEBUG > 6 and print STDERR "$this\'s accept_directives : ",pretty($this->{'accept_directives'}),"\n";return sort keys %{$this->{'accept_directives'}}if wantarray;return}sub unaccept_directive {shift->unaccept_directives(@_)};sub unaccept_directives {my$this=shift;for my$d (@_){next unless defined$d and length$d;Carp::croak "\"$d\" isn't a valid directive name" unless$d =~ m/^[a-zA-Z][a-zA-Z0-9]*$/s;Carp::croak "But you must accept \"$d\" directives -- it's a builtin!" if exists$Known_directives{$d};delete$this->{'accept_directives'}{$d};DEBUG > 2 and print STDERR "OK, won't accept \"=$d\" as directive.\n"}return sort keys %{$this->{'accept_directives'}}if wantarray;return}sub accept_target {shift->accept_targets(@_)}sub accept_target_as_text {shift->accept_targets_as_text(@_)}sub accept_targets {shift->_accept_targets('1',@_)}sub accept_targets_as_text {shift->_accept_targets('force_resolve',@_)}sub _accept_targets {my($this,$type)=splice @_,0,2;for my$t (@_){next unless defined$t and length$t;$this->{'accept_targets'}{$t}=$type;DEBUG > 2 and print STDERR "Learning to accept \"$t\" as target of type $type\n"}return sort keys %{$this->{'accept_targets'}}if wantarray;return}sub unaccept_target {shift->unaccept_targets(@_)}sub unaccept_targets {my$this=shift;for my$t (@_){next unless defined$t and length$t;delete$this->{'accept_targets'}{$t};DEBUG > 2 and print STDERR "OK, won't accept \"$t\" as target.\n"}return sort keys %{$this->{'accept_targets'}}if wantarray;return}my$xml_name_re=my_qr('[^-.0-8:A-Z_a-z[:^ascii:]]','9');$xml_name_re=qr/[\x00-\x2C\x2F\x39\x3B-\x40\x5B-\x5E\x60\x7B-\x7F]/ unless$xml_name_re;sub accept_code {shift->accept_codes(@_)}sub accept_codes {my$this=shift;for my$new_code (@_){next unless defined$new_code and length$new_code;Carp::croak "\"$new_code\" isn't a valid element name" if$new_code =~ $xml_name_re or $new_code =~ m/^[-\.0-9]/s or $new_code =~ m/:[-\.0-9]/s;$this->{'accept_codes'}{$new_code}=$new_code}return}sub unaccept_code {shift->unaccept_codes(@_)}sub unaccept_codes {my$this=shift;for my$new_code (@_){next unless defined$new_code and length$new_code;Carp::croak "\"$new_code\" isn't a valid element name" if$new_code =~ $xml_name_re or $new_code =~ m/^[-\.0-9]/s or $new_code =~ m/:[-\.0-9]/s;Carp::croak "But you must accept \"$new_code\" codes -- it's a builtin!" if grep$new_code eq $_,@Known_formatting_codes;delete$this->{'accept_codes'}{$new_code};DEBUG > 2 and print STDERR "OK, won't accept the code $new_code<...>.\n"}return}sub parse_string_document {my$self=shift;my@lines;for my$line_group (@_){next unless defined$line_group and length$line_group;pos($line_group)=0;while($line_group =~ m/([^\n\r]*)(\r?\n?)/g){$self->parse_lines($1)if length($1)or length($2)or pos($line_group)!=length($line_group)}}$self->parse_lines(undef);return$self}sub _init_fh_source {my($self,$source)=@_;return}sub parse_file {my($self,$source)=(@_);if(!defined$source){Carp::croak("Can't use empty-string as a source for parse_file")}elsif(ref(\$source)eq 'GLOB'){$self->{'source_filename'}='' .($source)}elsif(ref$source){$self->{'source_filename'}='' .($source)}elsif(!length$source){Carp::croak("Can't use empty-string as a source for parse_file")}else {{local*PODSOURCE;open(PODSOURCE,"<$source")|| Carp::croak("Can't open $source: $!");$self->{'source_filename'}=$source;$source=*PODSOURCE{IO}}$self->_init_fh_source($source)}$self->{'source_fh'}=$source;my($i,@lines);until($self->{'source_dead'}){splice@lines;for($i=MANY_LINES;$i--;){local $/=$NL;push@lines,scalar(<$source>);last unless defined$lines[-1]}my$at_eof=!$lines[-1];pop@lines if$at_eof;s/\r\n?/\n/g for@lines;@lines=split(/(?<=\n)/,join('',@lines));push@lines,undef if$at_eof;$self->parse_lines(@lines)}delete($self->{'source_fh'});return$self}sub parse_from_file {my($self,$source,$to)=@_;$self=$self->new unless ref($self);if(!defined$source){$source=*STDIN{IO}}elsif(ref(\$source)eq 'GLOB'){}elsif(ref($source)){}elsif(!length$source or $source eq '-' or $source =~ m/^<&(?:STDIN|0)$/i){$source=*STDIN{IO}}if(!defined$to){$self->output_fh(*STDOUT{IO})}elsif(ref(\$to)eq 'GLOB'){$self->output_fh($to)}elsif(ref($to)){$self->output_fh($to)}elsif(!length$to or $to eq '-' or $to =~ m/^>&?(?:STDOUT|1)$/i){$self->output_fh(*STDOUT{IO})}elsif($to =~ m/^>&(?:STDERR|2)$/i){$self->output_fh(*STDERR{IO})}else {require Symbol;my$out_fh=Symbol::gensym();DEBUG and print STDERR "Write-opening to $to\n";open($out_fh,">$to")or Carp::croak "Can't write-open $to: $!";binmode($out_fh)if$self->can('write_with_binmode')and $self->write_with_binmode;$self->output_fh($out_fh)}return$self->parse_file($source)}sub whine {my$self=shift(@_);++$self->{'errors_seen'};if($self->{'no_whining'}){DEBUG > 9 and print STDERR "Discarding complaint (at line $_[0]) $_[1]\n because no_whining is on.\n";return}push @{$self->{'all_errata'}{$_[0]}},$_[1];return$self->_complain_warn(@_)if$self->{'complain_stderr'};return$self->_complain_errata(@_)}sub scream {my$self=shift(@_);++$self->{'errors_seen'};push @{$self->{'all_errata'}{$_[0]}},$_[1];return$self->_complain_warn(@_)if$self->{'complain_stderr'};return$self->_complain_errata(@_)}sub _complain_warn {my($self,$line,$complaint)=@_;return printf STDERR "%s around line %s: %s\n",$self->{'source_filename'}|| 'Pod input',$line,$complaint}sub _complain_errata {my($self,$line,$complaint)=@_;if($self->{'no_errata_section'}){DEBUG > 9 and print STDERR "Discarding erratum (at line $line) $complaint\n because no_errata_section is on.\n"}else {DEBUG > 9 and print STDERR "Queuing erratum (at line $line) $complaint\n";push @{$self->{'errata'}{$line}},$complaint}return 1}sub _get_initial_item_type {my($self,$para)=@_;return$para->[1]{'~type'}if$para->[1]{'~type'};return$para->[1]{'~type'}='text' if join("\n",@{$para}[2 .. $#$para])=~ m/^\s*(\d+)\.?\s*$/s and $1 ne '1';return$self->_get_item_type($para)}sub _get_item_type {my($self,$para)=@_;return$para->[1]{'~type'}if$para->[1]{'~type'};my$content=join "\n",@{$para}[2 .. $#$para];if($content =~ m/^\s*\*\s*$/s or $content =~ m/^\s*$/s){splice @$para,2;$para->[1]{'~orig_content'}=$content;return$para->[1]{'~type'}='bullet'}elsif($content =~ m/^\s*\*\s+(.+)/s){$para->[1]{'~orig_content'}=$content;$para->[1]{'~_freaky_para_hack'}=$1;DEBUG > 2 and print STDERR " Tolerating $$para[2] as =item *\\n\\n$1\n";splice @$para,2;return$para->[1]{'~type'}='bullet'}elsif($content =~ m/^\s*(\d+)\.?\s*$/s){$para->[1]{'~orig_content'}=$content;$para->[1]{'number'}=$1;splice @$para,2;return$para->[1]{'~type'}='number'}else {return$para->[1]{'~type'}='text'}}sub _make_treelet {my$self=shift;my$treelet;if(!@_){return ['']}if(ref $_[0]and ref $_[0][0]and $_[0][0][0]eq '~Top'){DEBUG and print STDERR "Applying precooked treelet hack to $_[0][0]\n";$treelet=$_[0][0];splice @$treelet,0,2;return$treelet}else {$treelet=$self->_treelet_from_formatting_codes(@_)}if(!$self->{'_output_is_for_JustPod'}&& $self->_remap_sequences($treelet)){$self->_treat_Zs($treelet);$self->_treat_Ls($treelet);$self->_treat_Es($treelet);$self->_treat_Ss($treelet);$self->_wrap_up($treelet)}else {DEBUG and print STDERR "Formatless treelet gets fast-tracked.\n"}splice @$treelet,0,2;return$treelet}sub _wrap_up {my($self,@stack)=@_;my$nixx=$self->{'nix_X_codes'};my$merge=$self->{'merge_text' };return unless$nixx or $merge;DEBUG > 2 and print STDERR "\nStarting _wrap_up traversal.\n",$merge ? (" Merge mode on\n"): (),$nixx ? (" Nix-X mode on\n"): (),;my($i,$treelet);while($treelet=shift@stack){DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";for($i=2;$i < @$treelet;++$i){DEBUG > 3 and print STDERR " Considering child at $i ",pretty($treelet->[$i]),"\n";if($nixx and ref$treelet->[$i]and $treelet->[$i][0]eq 'X'){DEBUG > 3 and print STDERR "   Nixing X node at $i\n";splice(@$treelet,$i,1);redo}elsif($merge and $i!=2 and !ref$treelet->[$i]and!ref$treelet->[$i - 1]){DEBUG > 3 and print STDERR "   Merging ",$i-1,":[$treelet->[$i-1]] and $i\:[$treelet->[$i]]\n";$treelet->[$i-1].= (splice(@$treelet,$i,1))[0];DEBUG > 4 and print STDERR "    Now: ",$i-1,":[$treelet->[$i-1]]\n";--$i;next}elsif(ref$treelet->[$i]){DEBUG > 4 and print STDERR "  Enqueuing ",pretty($treelet->[$i])," for traversal.\n";push@stack,$treelet->[$i];if($treelet->[$i][0]eq 'L'){my$thing;for my$attrname ('section','to'){if(defined($thing=$treelet->[$i][1]{$attrname})and ref$thing){unshift@stack,$thing;DEBUG > 4 and print STDERR "  +Enqueuing ",pretty($treelet->[$i][1]{$attrname})," as an attribute value to tweak.\n"}}}}}}DEBUG > 2 and print STDERR "End of _wrap_up traversal.\n\n";return}sub _remap_sequences {my($self,@stack)=@_;if(@stack==1 and @{$stack[0]}==3 and!ref$stack[0][2]){DEBUG and print STDERR "Skipping _remap_sequences: formatless treelet.\n";return 0}my$map=($self->{'accept_codes'}|| die "NO accept_codes in $self?!?");my$start_line=$stack[0][1]{'start_line'};DEBUG > 2 and printf "\nAbout to start _remap_sequences on treelet from line %s.\n",$start_line || '[?]' ;DEBUG > 3 and print STDERR " Map: ",join('; ',map "$_=" .(ref($map->{$_})? join(",",@{$map->{$_}}): $map->{$_}),sort keys %$map),("B~C~E~F~I~L~S~X~Z" eq join '~',sort keys %$map)? "  (all normal)\n" : "\n" ;my($is,$was,$i,$treelet);while($treelet=shift@stack){DEBUG > 3 and print STDERR " Considering children of this $treelet->[0] node...\n";for($i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];DEBUG > 4 and print STDERR "  Noting child $i : $treelet->[$i][0]<...>\n";$is=$treelet->[$i][0]=$map->{$was=$treelet->[$i][0]};if(DEBUG > 3){if(!defined$is){print STDERR "   Code $was<> is UNKNOWN!\n"}elsif($is eq $was){DEBUG > 4 and print STDERR "   Code $was<> stays the same.\n"}else {print STDERR "   Code $was<> maps to ",ref($is)? ("tags ",map("$_<",@$is),'...',map('>',@$is),"\n"): "tag $is<...>.\n"}}if(!defined$is){$self->whine($start_line,"Deleting unknown formatting code $was<>");$is=$treelet->[$i][0]='1'}if(ref$is){my@dynasty=@$is;DEBUG > 4 and print STDERR "    Renaming $was node to $dynasty[-1]\n";$treelet->[$i][0]=pop@dynasty;my$nugget;while(@dynasty){DEBUG > 4 and printf "    Grafting a new %s node between %s and %s\n",$dynasty[-1],$treelet->[0],$treelet->[$i][0],;splice @$treelet,$i,1,[pop(@dynasty),{},$treelet->[$i]]}}elsif($is eq '0'){splice(@$treelet,$i,1);--$i}elsif($is eq '1'){splice(@$treelet,$i,1 =>splice @{$treelet->[$i]},2);--$i}else {unshift@stack,$treelet->[$i]}}}DEBUG > 2 and print STDERR "End of _remap_sequences traversal.\n\n";if(@_==2 and @{$_[1]}==3 and!ref $_[1][2]){DEBUG and print STDERR "Noting that the treelet is now formatless.\n";return 0}return 1}sub _ponder_extend {my($self,$para)=@_;my$content=join ' ',splice @$para,2;$content =~ s/^\s+//s;$content =~ s/\s+$//s;DEBUG > 2 and print STDERR "Ogling extensor: =extend $content\n";if($content =~ m/^
        (\S+)         # 1 : new item
        \s+
        (\S+)         # 2 : fallback(s)
        (?:\s+(\S+))? # 3 : element name(s)
        \s*
        $
      /xs){my$new_letter=$1;my$fallbacks_one=$2;my$elements_one;$elements_one=defined($3)? $3 : $1;DEBUG > 2 and print STDERR "Extensor has good syntax.\n";unless($new_letter =~ m/^[A-Z]$/s or $new_letter){DEBUG > 2 and print STDERR " $new_letter isn't a valid thing to entend.\n";$self->whine($para->[1]{'start_line'},"You can extend only formatting codes A-Z, not like \"$new_letter\"");return}if(grep$new_letter eq $_,@Known_formatting_codes){DEBUG > 2 and print STDERR " $new_letter isn't a good thing to extend, because known.\n";$self->whine($para->[1]{'start_line'},"You can't extend an established code like \"$new_letter\"");return}unless($fallbacks_one =~ m/^[A-Z](,[A-Z])*$/s or $fallbacks_one eq '0' or $fallbacks_one eq '1'){$self->whine($para->[1]{'start_line'},"Format for second =extend parameter must be like" ." M or 1 or 0 or M,N or M,N,O but you have it like " .$fallbacks_one);return}unless($elements_one =~ m/^[^ ,]+(,[^ ,]+)*$/s){$self->whine($para->[1]{'start_line'},"Format for third =extend parameter: like foo or bar,Baz,qu:ux but not like " .$elements_one);return}my@fallbacks=split ',',$fallbacks_one,-1;my@elements=split ',',$elements_one,-1;for my$f (@fallbacks){next if exists$Known_formatting_codes{$f}or $f eq '0' or $f eq '1';DEBUG > 2 and print STDERR "  Can't fall back on unknown code $f\n";$self->whine($para->[1]{'start_line'},"Can't use unknown formatting code '$f' as a fallback for '$new_letter'");return}DEBUG > 3 and printf STDERR "Extensor: Fallbacks <%s> Elements <%s>.\n",@fallbacks,@elements;my$canonical_form;for my$e (@elements){if(exists$self->{'accept_codes'}{$e}){DEBUG > 1 and print STDERR " Mapping '$new_letter' to known extension '$e'\n";$canonical_form=$e;last}else {DEBUG > 1 and print STDERR " Can't map '$new_letter' to unknown extension '$e'\n"}}if(defined$canonical_form){$self->{'accept_codes'}{$new_letter}=$canonical_form;DEBUG > 2 and print "Extensor maps $new_letter => known element $canonical_form.\n"}else {$self->{'accept_codes'}{$new_letter}=(@fallbacks==1)? $fallbacks[0]: \@fallbacks;DEBUG > 2 and print "Extensor maps $new_letter => fallbacks @fallbacks.\n"}}else {DEBUG > 2 and print STDERR "Extensor has bad syntax.\n";$self->whine($para->[1]{'start_line'},"Unknown =extend syntax: $content")}return}sub _treat_Zs {my($self,@stack)=@_;my($i,$treelet);my$start_line=$stack[0][1]{'start_line'};while($treelet=shift@stack){for($i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];unless($treelet->[$i][0]eq 'Z'){unshift@stack,$treelet->[$i];next}DEBUG > 1 and print STDERR "Nixing Z node @{$treelet->[$i]}\n";unless(@{$treelet->[$i]}==2 or (@{$treelet->[$i]}==3 and $treelet->[$i][2]eq '')){$self->whine($start_line,"A non-empty Z<>")}splice(@$treelet,$i,1);--$i}}return}sub _treat_Ls {my($self,@stack)=@_;my($i,$treelet);my$start_line=$stack[0][1]{'start_line'};while($treelet=shift@stack){for(my$i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];unless($treelet->[$i][0]eq 'L'){unshift@stack,$treelet->[$i];next}my$ell=$treelet->[$i];DEBUG > 1 and print STDERR "Ogling L node " .pretty($ell)."\n";if (@{$ell}==3 and $ell->[2]=~ m!\A\s*/\s*\z!){$self->whine($start_line,"L<> contains only '/'");$treelet->[$i]='L</>';next}if(@{$ell}==2 or (@{$ell}==3 and $ell->[2]eq '')){$self->whine($start_line,"An empty L<>");$treelet->[$i]='L<>';next}if((!ref$ell->[2]&& $ell->[2]=~ /\A\s/)||(!ref$ell->[-1]&& $ell->[-1]=~ /\s\z/)){$self->whine($start_line,"L<> starts or ends with whitespace")}if (my ($url_index,$text_part,$url_part)=sub {for (2..$#$ell){next if ref$ell->[$_];next unless$ell->[$_]=~ m/^(?:([^|]*)\|)?(\w+:[^:\s]\S*)$/s;return ($_,$1,$2)}return}->()){$ell->[1]{'type'}='url';my@text=@{$ell}[2..$url_index-1];push@text,$text_part if defined$text_part;my@url=@{$ell}[$url_index+1..$#$ell];unshift@url,$url_part;unless (@text){$ell->[1]{'content-implicit'}='yes';@text=@url}$ell->[1]{to}=Pod::Simple::LinkSection->new(@url==1 ? $url[0]: ['',{},@url ],);splice @$ell,2,$#$ell,@text;next}if(@{$ell}==3 and!ref$ell->[2]){my$it=$ell->[2];if($it =~ m{^[^/|]+[(][-a-zA-Z0-9]+[)]$}s){DEBUG > 1 and print STDERR "Catching \"$it\" as manpage link.\n";$ell->[1]{'type'}='man';$ell->[1]{'content-implicit'}='yes';$ell->[1]{'to' }=Pod::Simple::LinkSection->new($it);next}if($it =~ m/^[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+(\:\:[^\/\|,\$\%\@\ \"\<\>\:\#\&\*\{\}\[\]\(\)]+)*$/s){DEBUG > 1 and print STDERR "Catching \"$it\" as ho-hum L<Modulename> link.\n";$ell->[1]{'type'}='pod';$ell->[1]{'content-implicit'}='yes';$ell->[1]{'to' }=Pod::Simple::LinkSection->new($it);next}}DEBUG > 1 and print STDERR "Running a real parse on this non-trivial L\n";my$link_text;my@ell_content=@$ell;splice@ell_content,0,2;DEBUG > 3 and print STDERR " Ell content to start: ",pretty(@ell_content),"\n";DEBUG > 3 and print STDERR "  Peering at L content for a '|' ...\n";for(my$j=0;$j < @ell_content;++$j){next if ref$ell_content[$j];DEBUG > 3 and print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '|'.\n";if($ell_content[$j]=~ m/^([^\|]*)\|(.*)$/s){my@link_text=($1);$ell_content[$j]=$2;DEBUG > 3 and print STDERR "     FOUND a '|' in it.  Splitting into [$1] + [$2]\n";if ($link_text[0]=~ m{[|/]}){$self->whine($start_line,"alternative text '$link_text[0]' contains non-escaped | or /")}unshift@link_text,splice@ell_content,0,$j;@ell_content=grep ref($_)||length($_),@ell_content ;$link_text=[grep ref($_)||length($_),@link_text ];DEBUG > 3 and printf "  So link text is %s\n  and remaining ell content is %s\n",pretty($link_text),pretty(@ell_content);last}}my$section_name;DEBUG > 3 and print STDERR "  Peering at L-content for a '/' ...\n";for(my$j=0;$j < @ell_content;++$j){next if ref$ell_content[$j];DEBUG > 3 and print STDERR "    Peering at L-content text bit \"$ell_content[$j]\" for a '/'.\n";if($ell_content[$j]=~ m/^([^\/]*)\/(.*)$/s){my@section_name=($2);$ell_content[$j]=$1;DEBUG > 3 and print STDERR "     FOUND a '/' in it.","  Splitting to page [...$1] + section [$2...]\n";push@section_name,splice@ell_content,1+$j;@ell_content=grep ref($_)||length($_),@ell_content ;@section_name=grep ref($_)||length($_),@section_name ;if(@section_name and!ref($section_name[0])and!ref($section_name[-1])and $section_name[0]=~ m/^\"/s and $section_name[-1]=~ m/\"$/s and!(@section_name==1 and $section_name[0]eq '"')){$section_name[0]=~ s/^\"//s;$section_name[-1]=~ s/\"$//s;DEBUG > 3 and print STDERR "     Quotes removed: ",pretty(@section_name),"\n"}else {DEBUG > 3 and print STDERR "     No need to remove quotes in ",pretty(@section_name),"\n"}$section_name=\@section_name;last}}if(!$section_name and @ell_content and!ref($ell_content[0])and!ref($ell_content[-1])and $ell_content[0]=~ m/^\"/s and $ell_content[-1]=~ m/\"$/s and!(@ell_content==1 and $ell_content[0]eq '"')){$section_name=[splice@ell_content];$section_name->[0]=~ s/^\"//s;$section_name->[-1]=~ s/\"$//s;$ell->[1]{'~tolerated'}=1}if(!$section_name and!$link_text and @ell_content and grep!ref($_)&& m/ /s,@ell_content){$section_name=[splice@ell_content];$ell->[1]{'~deprecated'}=1}unless($link_text){$ell->[1]{'content-implicit'}='yes';$link_text=[];push @$link_text,'"',@$section_name,'"' if$section_name;if(@ell_content){$link_text->[-1].= ' in ' if$section_name;push @$link_text,@ell_content}}if(@ell_content==1 and!ref($ell_content[0])and $ell_content[0]=~ m{^[^/]+[(][-a-zA-Z0-9]+[)]$}s){$ell->[1]{'type'}='man';DEBUG > 3 and print STDERR "Considering this ($ell_content[0]) a man link.\n"}else {$ell->[1]{'type'}='pod';DEBUG > 3 and print STDERR "Considering this a pod link (not man or url).\n"}if(defined$section_name){$ell->[1]{'section'}=Pod::Simple::LinkSection->new(['',{},@$section_name]);DEBUG > 3 and print STDERR "L-section content: ",pretty($ell->[1]{'section'}),"\n"}if(@ell_content){$ell->[1]{'to'}=Pod::Simple::LinkSection->new(['',{},@ell_content]);DEBUG > 3 and print STDERR "L-to content: ",pretty($ell->[1]{'to'}),"\n"}@$ell=(@$ell[0,1],defined($link_text)? splice(@$link_text): '');DEBUG > 2 and print STDERR "End of L-parsing for this node " .pretty($treelet->[$i])."\n";unshift@stack,$treelet->[$i]}}return}sub _treat_Es {my($self,@stack)=@_;my($i,$treelet,$content,$replacer,$charnum);my$start_line=$stack[0][1]{'start_line'};while($treelet=shift@stack){for(my$i=2;$i < @$treelet;++$i){next unless ref$treelet->[$i];if($treelet->[$i][0]eq 'L'){my$thing;for my$attrname ('section','to'){if(defined($thing=$treelet->[$i][1]{$attrname})and ref$thing){unshift@stack,$thing;DEBUG > 2 and print STDERR "  Enqueuing ",pretty($treelet->[$i][1]{$attrname})," as an attribute value to tweak.\n"}}unshift@stack,$treelet->[$i];next}elsif($treelet->[$i][0]ne 'E'){unshift@stack,$treelet->[$i];next}DEBUG > 1 and print STDERR "Ogling E node ",pretty($treelet->[$i]),"\n";if(@{$treelet->[$i]}==2 or (@{$treelet->[$i]}==3 and $treelet->[$i][2]eq '')){$self->whine($start_line,"An empty E<>");$treelet->[$i]='E<>';next}unless(@{$treelet->[$i]}==3 and!ref($content=$treelet->[$i][2])){$self->whine($start_line,"An E<...> surrounding strange content");$replacer=$treelet->[$i];splice(@$treelet,$i,1,'E<',splice(@$replacer,2),'>');next}DEBUG > 1 and print STDERR "Ogling E<$content>\n";$charnum=Pod::Escapes::e2charnum($content);DEBUG > 1 and print STDERR " Considering E<$content> with char ",defined($charnum)? $charnum : "undef",".\n";if(!defined($charnum)){DEBUG > 1 and print STDERR "I don't know how to deal with E<$content>.\n";$self->whine($start_line,"Unknown E content in E<$content>");$replacer="E<$content>"}elsif($charnum >= 255 and!UNICODE){$replacer=ASCII ? "\xA4" : "?";DEBUG > 1 and print STDERR "This Perl version can't handle ","E<$content> (chr $charnum), so replacing with $replacer\n"}else {$replacer=Pod::Escapes::e2char($content);DEBUG > 1 and print STDERR " Replacing E<$content> with $replacer\n"}splice(@$treelet,$i,1,$replacer)}}return}sub _treat_Ss {my($self,$treelet)=@_;_change_S_to_nbsp($treelet,0)if$self->{'nbsp_for_S'};return}sub _change_S_to_nbsp {my($treelet,$in_s)=@_;my$is_s=('S' eq $treelet->[0]);$in_s ||= $is_s;for(my$i=2;$i < @$treelet;++$i){if(ref$treelet->[$i]){if(_change_S_to_nbsp($treelet->[$i],$in_s)){my$to_pull_up=$treelet->[$i];splice @$to_pull_up,0,2;splice @$treelet,$i,1,@$to_pull_up;$i += @$to_pull_up - 1}}else {$treelet->[$i]=~ s/\s/$Pod::Simple::nbsp/g if$in_s}}return$is_s}sub _accessorize {no strict 'refs';for my$attrname (@_){next if$attrname =~ m/::/;*{caller().'::' .$attrname}=sub {use strict;$Carp::CarpLevel=1,Carp::croak("Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)")unless (@_==1 or @_==2)and ref $_[0];(@_==1)? $_[0]->{$attrname}: ($_[0]->{$attrname}=$_[1])}}return}sub filter {my($class,$source)=@_;my$new=$class->new;$new->output_fh(*STDOUT{IO});if(ref($source || '')eq 'SCALAR'){$new->parse_string_document($$source)}elsif(ref($source)){$new->parse_file($source)}else {$new->parse_file($source)}return$new}sub _out {my$class=shift(@_);my$mutor=shift(@_)if @_ and ref($_[0]|| '')eq 'CODE';DEBUG and print STDERR "\n\n",'#' x 76,"\nAbout to parse source: {{\n$_[0]\n}}\n\n";my$parser=ref$class && $class->isa(__PACKAGE__)? $class : $class->new;$parser->hide_line_numbers(1);my$out='';$parser->output_string(\$out);DEBUG and print STDERR " _out to ",\$out,"\n";$mutor->($parser)if$mutor;$parser->parse_string_document($_[0]);return$out}sub _duo {my$class=shift(@_);Carp::croak "But $class->_duo is useful only in list context!" unless wantarray;my$mutor=shift(@_)if @_ and ref($_[0]|| '')eq 'CODE';Carp::croak "But $class->_duo takes two parameters, not: @_" unless @_==2;my(@out);while(@_){my$parser=$class->new;push@out,'';$parser->output_string(\($out[-1]));DEBUG and print STDERR " _duo out to ",$parser->output_string()," = $parser->{'output_string'}\n";$parser->hide_line_numbers(1);$mutor->($parser)if$mutor;$parser->parse_string_document(shift(@_))}return@out}1;
POD_SIMPLE

$fatpacked{"Pod/Simple/BlackBox.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_BLACKBOX';
  package Pod::Simple::BlackBox;use integer;use strict;use Carp ();use vars qw($VERSION);$VERSION='3.40';sub my_qr ($$) {my ($input_re,$should_match)=@_;my$use_utf8=($] le 5.006002)? 'use utf8;' : "";my$re=eval "no warnings; $use_utf8 qr/$input_re/";return "" if $@;my$matches=eval "no warnings; $use_utf8 '$should_match' =~ /$re/";return "" if $@;return$re if$matches;return ""}BEGIN {require Pod::Simple;*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}my$non_ascii_re=my_qr('[[:^ascii:]]',"\xB6");$non_ascii_re=qr/[\x80-\xFF]/ unless$non_ascii_re;my$cs_re=my_qr('\p{IsCs}',"\x{D800}");my$cn_re=my_qr('\p{IsCn}',"\x{09E4}");my$rare_blocks_re=my_qr('[\p{InIPAExtensions}\p{InSpacingModifierLetters}]',"\x{250}");$rare_blocks_re=my_qr('[\x{0250}-\x{02FF}]',"\x{250}")unless$rare_blocks_re;my$script_run_re=eval 'no warnings "experimental::script_run";
                            qr/(*script_run: ^ .* $ )/x';my$latin_re=my_qr('[\p{IsLatin}\p{IsInherited}\p{IsCommon}]',"\x{100}");unless ($latin_re){$latin_re=my_qr('[\x00-\x{02E9}\x{02EC}-\x{0374}\x{037E}\x{0385}\x{0387}\x{0485}\x{0486}\x{0589}\x{060C}\x{061B}\x{061F}\x{0640}\x{064B}-\x{0655}\x{0670}\x{06DD}\x{0951}-\x{0954}\x{0964}\x{0965}\x{0E3F}\x{10FB}\x{16EB}-\x{16ED}\x{1735}\x{1736}\x{1802}\x{1803}\x{1805}\x{1D00}-\x{1D25}\x{1D2C}-\x{1D5C}\x{1D62}-\x{1D65}\x{1D6B}-\x{1D77}\x{1D79}-\x{1DBE}\x{1DC0}-\x{1EF9}\x{2000}-\x{2125}\x{2127}-\x{27FF}\x{2900}-\x{2B13}\x{2E00}-\x{2E1D}\x{2FF0}-\x{3004}\x{3006}\x{3008}-\x{3020}\x{302A}-\x{302D}\x{3030}-\x{3037}\x{303C}-\x{303F}\x{3099}-\x{309C}\x{30A0}\x{30FB}\x{30FC}\x{3190}-\x{319F}\x{31C0}-\x{31CF}\x{3220}-\x{325F}\x{327F}-\x{32CF}\x{3358}-\x{33FF}\x{4DC0}-\x{4DFF}\x{A700}-\x{A716}\x{FB00}-\x{FB06}\x{FD3E}\x{FD3F}\x{FE00}-\x{FE6B}\x{FEFF}-\x{FF65}\x{FF70}\x{FF9E}\x{FF9F}\x{FFE0}-\x{FFFD}\x{10100}-\x{1013F}\x{1D000}-\x{1D1DD}\x{1D300}-\x{1D7FF}]',"\x{100}")}my$every_char_is_latin_re=my_qr("^(?:$latin_re)*\\z","A");my$later_latin_re=my_qr('[^\P{IsLatin}\p{IsAge=1.1}]',"\x{1F6}");my$deprecated_re=my_qr('\p{IsDeprecated}',"\x{149}");$deprecated_re=qr/\x{149}/ unless$deprecated_re;my$utf8_bom;if (($] ge 5.007_003)){$utf8_bom="\x{FEFF}";utf8::encode($utf8_bom)}else {$utf8_bom="\xEF\xBB\xBF"}my$seen_legal_directive=0;sub parse_line {shift->parse_lines(@_)}sub parse_lines {my$self=shift;my$code_handler=$self->{'code_handler'};my$cut_handler=$self->{'cut_handler'};my$wl_handler=$self->{'whiteline_handler'};$self->{'line_count'}||= 0;my$scratch;DEBUG > 4 and print STDERR "# Parsing starting at line ",$self->{'line_count'},".\n";DEBUG > 5 and print STDERR "#  About to parse lines: ",join(' ',map defined($_)? "[$_]" : "EOF",@_),"\n";my$paras=($self->{'paras'}||= []);$self->{'pod_para_count'}||= 0;my$format_codes=join "",'[',grep {/ ^ [A-Za-z] $/x}keys %{$self->{accept_codes}};$format_codes .= ']';my$pod_chars_re=qr/ ^ = [A-Za-z]+ | $format_codes < /x;my$line;for my$source_line (@_){if($self->{'source_dead'}){DEBUG > 4 and print STDERR "# Source is dead.\n";last}unless(defined$source_line){DEBUG > 4 and print STDERR "# Undef-line seen.\n";push @$paras,['~end',{'start_line'=>$self->{'line_count'}}];push @$paras,$paras->[-1],$paras->[-1];$self->{'source_dead'}=1;$self->_ponder_paragraph_buffer;next}if($self->{'line_count'}++){($line=$source_line)=~ tr/\n\r//d}else {DEBUG > 2 and print STDERR "First line: [$source_line]\n";if(($line=$source_line)=~ s/^$utf8_bom//s){DEBUG and print STDERR "UTF-8 BOM seen.  Faking a '=encoding utf8'.\n";$self->_handle_encoding_line("=encoding utf8");delete$self->{'_processed_encoding'};$line =~ tr/\n\r//d}elsif($line =~ s/^\xFE\xFF//s){DEBUG and print STDERR "Big-endian UTF-16 BOM seen.  Aborting parsing.\n";$self->scream($self->{'line_count'},"UTF16-BE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet.");splice @_;push @_,undef;next}elsif($line =~ s/^\xFF\xFE//s){DEBUG and print STDERR "Little-endian UTF-16 BOM seen.  Aborting parsing.\n";$self->scream($self->{'line_count'},"UTF16-LE Byte Encoding Mark found; but Pod::Simple v$Pod::Simple::VERSION doesn't implement UTF16 yet.");splice @_;push @_,undef;next}else {DEBUG > 2 and print STDERR "First line is BOM-less.\n";($line=$source_line)=~ tr/\n\r//d}}if(!$self->{'parse_characters'}&&!$self->{'encoding'}&& ($self->{'in_pod'}|| $line =~ /^=/s)&& $line =~ /$non_ascii_re/){my$encoding;goto set_1252 if $] lt 5.006_000;my$copy;no warnings 'utf8';if ($] ge 5.007_003){$copy=$line;goto set_1252 if!utf8::decode($copy)}elsif (ord("A")!=65){goto set_utf8}else {use if $] le 5.006002,'utf8';my$char_ord;my$needed;$copy=chr(0x100);for (my$i=0;$i < length$line;$i++){my$byte=substr($line,$i,1);if ($byte !~ $non_ascii_re){$copy .= $byte;next}my$b_ord=ord$byte;my$min_cont=0x80;if ($b_ord < 0xC2){goto set_1252}elsif ($b_ord <= 0xDF){$needed=1;$char_ord=$b_ord & 0x1F}elsif ($b_ord <= 0xEF){$min_cont=0xA0 if$b_ord==0xE0;$needed=2;$char_ord=$b_ord & (0x1F >> 1)}elsif ($b_ord <= 0xF4){$min_cont=0x90 if$b_ord==0xF0;$needed=3;$char_ord=$b_ord & (0x1F >> 2)}else {goto set_1252}goto set_1252 if$i + $needed >= length$line;while ($needed-- > 0){my$cont=substr($line,++$i,1);$b_ord=ord$cont;goto set_1252 if$b_ord < $min_cont || $b_ord > 0xBF;$min_cont=0x80;$char_ord <<= 6;$char_ord |= ($b_ord & 0x3F)}$copy .= chr$char_ord}$copy=substr($copy,1)}goto set_utf8 if ord("A")==65 && $line =~ /[\x81\x8D\x8F\x90\x9D]/;goto set_1252 if ord("A")==65 && $copy =~ /[\x80-\x9F]/;DEBUG > 8 and print STDERR __LINE__,": $copy: surrogate\n" if$copy =~ $cs_re;goto set_1252 if$cs_re && $copy =~ $cs_re;DEBUG > 8 and print STDERR __LINE__,": $copy: unassigned\n" if$cn_re && $copy =~ $cn_re;goto set_1252 if$cn_re && $copy =~ $cn_re;DEBUG > 8 and print STDERR __LINE__,": $copy: deprecated\n" if$copy =~ $deprecated_re;goto set_1252 if$copy =~ $deprecated_re;DEBUG > 8 and print STDERR __LINE__,": $copy: rare\n" if$copy =~ $rare_blocks_re;goto set_1252 if$rare_blocks_re && $copy =~ $rare_blocks_re;DEBUG > 8 and print STDERR __LINE__,": $copy: later_latin\n" if$later_latin_re && $copy =~ $later_latin_re;goto set_1252 if$later_latin_re && $copy =~ $later_latin_re;$copy =~ s/$pod_chars_re//g;if ($script_run_re){goto set_utf8 if$copy =~ $script_run_re;DEBUG > 8 and print STDERR __LINE__,":  not script run\n";goto set_1252}DEBUG > 8 and print STDERR __LINE__,": $copy: not latin\n" if$copy !~ $latin_re;goto set_utf8 if$copy !~ $latin_re;DEBUG > 8 and print STDERR __LINE__,": $copy: all latin\n" if$copy =~ $every_char_is_latin_re;goto set_utf8 if$copy =~ $every_char_is_latin_re;DEBUG > 8 and print STDERR __LINE__,": $copy: mixed\n";set_1252: DEBUG > 9 and print STDERR __LINE__,": $copy: is 1252\n";$encoding='CP1252';goto done_set;set_utf8: DEBUG > 9 and print STDERR __LINE__,": $copy: is UTF-8\n";$encoding='UTF-8';done_set: $self->_handle_encoding_line("=encoding $encoding");delete$self->{'_processed_encoding'};$self->{'_transcoder'}&& $self->{'_transcoder'}->($line);my ($word)=$line =~ /(\S*$non_ascii_re\S*)/;$self->whine($self->{'line_count'},"Non-ASCII character seen before =encoding in '$word'. Assuming $encoding")}DEBUG > 5 and print STDERR "# Parsing line: [$line]\n";if(!$self->{'in_pod'}){if($line =~ m/^=([a-zA-Z][a-zA-Z0-9]*)(?:\s|$)/s){if($1 eq 'cut'){$self->scream($self->{'line_count'},"=cut found outside a pod block.  Skipping to next block.");next}else {$self->{'in_pod'}=$self->{'start_of_pod_block'}=$self->{'last_was_blank'}=1}}else {DEBUG > 5 and print STDERR "# It's a code-line.\n";$code_handler->(map $_,$line,$self->{'line_count'},$self)if$code_handler;if($line =~ m/^#\s*line\s+(\d+)\s*(?:\s"([^"]+)")?\s*$/){DEBUG > 1 and print STDERR "# Setting nextline to $1\n";$self->{'line_count'}=$1 - 1}next}}$self->{'_transcoder'}&& $self->{'_transcoder'}->($line);if($line =~ m/^=encoding\s+\S+\s*$/s){next if$self->parse_characters;$line=$self->_handle_encoding_line($line)}if($line =~ m/^=cut/s){DEBUG > 1 and print STDERR "Noting =cut at line ${$self}{'line_count'}\n";$self->{'in_pod'}=0;$self->_ponder_paragraph_buffer();DEBUG > 6 and print STDERR "Processing any cut handler, line ${$self}{'line_count'}\n";$cut_handler->(map $_,$line,$self->{'line_count'},$self)if$cut_handler}elsif($line =~ m/^(\s*)$/s){if (defined $1 and $1 =~ /[^\S\r\n]/){$wl_handler->(map $_,$line,$self->{'line_count'},$self)if$wl_handler}if(!$self->{'start_of_pod_block'}and @$paras and $paras->[-1][0]eq '~Verbatim'){DEBUG > 1 and print STDERR "Saving blank line at line ${$self}{'line_count'}\n";push @{$paras->[-1]},$line}if(!$self->{'start_of_pod_block'}and!$self->{'last_was_blank'}){DEBUG > 1 and print STDERR "Noting para ends with blank line at ${$self}{'line_count'}\n"}$self->{'last_was_blank'}=1}elsif($self->{'last_was_blank'}){if($line =~ m/^(=[a-zA-Z][a-zA-Z0-9]*)(\s+|$)(.*)/s){my$new=[$1,{'start_line'=>$self->{'line_count'}},$3];$new->[1]{'~orig_spacer'}=$2 if $2 && $2 ne " ";++$self->{'pod_para_count'};$self->_ponder_paragraph_buffer();push @$paras,$new;DEBUG > 1 and print STDERR "Starting new ${$paras}[-1][0] para at line ${$self}{'line_count'}\n"}elsif($line =~ m/^\s/s){if(!$self->{'start_of_pod_block'}and @$paras and $paras->[-1][0]eq '~Verbatim'){DEBUG > 1 and print STDERR "Resuming verbatim para at line ${$self}{'line_count'}\n";push @{$paras->[-1]},$line}else {++$self->{'pod_para_count'};$self->_ponder_paragraph_buffer();DEBUG > 1 and print STDERR "Starting verbatim para at line ${$self}{'line_count'}\n";push @$paras,['~Verbatim',{'start_line'=>$self->{'line_count'}},$line]}}else {++$self->{'pod_para_count'};$self->_ponder_paragraph_buffer();push @$paras,['~Para',{'start_line'=>$self->{'line_count'}},$line];DEBUG > 1 and print STDERR "Starting plain para at line ${$self}{'line_count'}\n"}$self->{'last_was_blank'}=$self->{'start_of_pod_block'}=0}else {if(@$paras){DEBUG > 2 and print STDERR "Line ${$self}{'line_count'} continues current paragraph\n";push @{$paras->[-1]},$line}else {die "Continuing a paragraph but \@\$paras is empty?"}$self->{'last_was_blank'}=$self->{'start_of_pod_block'}=0}}DEBUG > 1 and print STDERR (pretty(@$paras),"\n");return$self}sub _handle_encoding_line {my($self,$line)=@_;return if$self->parse_characters;return$line unless$line =~ m/^=encoding\s+(\S+)\s*$/s;DEBUG > 1 and print STDERR "Found an encoding line \"=encoding $1\"\n";my$e=$1;my$orig=$e;push @{$self->{'encoding_command_reqs'}},"=encoding $orig";my$enc_error;require Pod::Simple::Transcode;if($self->{'encoding'}){my$norm_current=$self->{'encoding'};my$norm_e=$e;for my$that ($norm_current,$norm_e){$that=lc($that);$that =~ s/[-_]//g}if($norm_current eq $norm_e){DEBUG > 1 and print STDERR "The '=encoding $orig' line is ","redundant.  ($norm_current eq $norm_e).  Ignoring.\n";$enc_error=''}else {$enc_error="Encoding is already set to " .$self->{'encoding'};DEBUG > 1 and print STDERR$enc_error}}elsif (do {DEBUG > 1 and print STDERR " Setting encoding to $e\n";$self->{'encoding'}=$e;1}and $e eq 'HACKRAW'){DEBUG and print STDERR " Putting in HACKRAW (no-op) encoding mode.\n"}elsif(Pod::Simple::Transcode::->encoding_is_available($e)){die($enc_error="WHAT? _transcoder is already set?!")if$self->{'_transcoder'};require Pod::Simple::Transcode;$self->{'_transcoder'}=Pod::Simple::Transcode::->make_transcoder($e);eval {my@x=('',"abc","123");$self->{'_transcoder'}->(@x)};$@ && die($enc_error="Really unexpected error setting up encoding $e: $@\nAborting");$self->{'detected_encoding'}=$e}else {my@supported=Pod::Simple::Transcode::->all_encodings;DEBUG and print STDERR " Encoding [$e] is unsupported.","\nSupporteds: @supported\n";my$suggestion='';my$norm=lc($e);$norm =~ tr[-_][]d;my$n;for my$enc (@supported){$n=lc($enc);$n =~ tr[-_][]d;next unless$n eq $norm;$suggestion="  (Maybe \"$e\" should be \"$enc\"?)";last}my$encmodver=Pod::Simple::Transcode::->encmodver;$enc_error=join ''=>"This document probably does not appear as it should, because its ","\"=encoding $e\" line calls for an unsupported encoding.",$suggestion,"  [$encmodver\'s supported encodings are: @supported]" ;$self->scream($self->{'line_count'},$enc_error)}push @{$self->{'encoding_command_statuses'}},$enc_error;if (defined($self->{'_processed_encoding'})){$self->scream($self->{'line_count'},'Cannot have multiple =encoding directives')}$self->{'_processed_encoding'}=$orig;return$line}sub _handle_encoding_second_level {my($self,$para)=@_;my@x=@$para;my$content=join ' ',splice@x,2;$content =~ s/^\s+//s;$content =~ s/\s+$//s;DEBUG > 2 and print STDERR "Ogling encoding directive: =encoding $content\n";if (defined($self->{'_processed_encoding'})){delete$self->{'_processed_encoding'};if(!$self->{'encoding_command_statuses'}){DEBUG > 2 and print STDERR " CRAZY ERROR: It wasn't really handled?!\n"}elsif($self->{'encoding_command_statuses'}[-1]){$self->whine($para->[1]{'start_line'},sprintf "Couldn't do %s: %s",$self->{'encoding_command_reqs' }[-1],$self->{'encoding_command_statuses'}[-1],)}else {DEBUG > 2 and print STDERR " (Yup, it was successfully handled already.)\n"}}else {$self->whine($para->[1]{'start_line'},"Invalid =encoding syntax: $content")}return}{my$m=-321;sub _gen_errata {my$self=$_[0];return()unless$self->{'errata'}and keys %{$self->{'errata'}};my@out;for my$line (sort {$a <=> $b}keys %{$self->{'errata'}}){push@out,['=item',{'start_line'=>$m},"Around line $line:"],map(['~Para',{'start_line'=>$m,'~cooked'=>1},$_ ],@{$self->{'errata'}{$line}})}unshift@out,['=head1',{'start_line'=>$m,'errata'=>1},'POD ERRORS'],['~Para',{'start_line'=>$m,'~cooked'=>1,'errata'=>1},"Hey! ",['B',{},'The above document had some coding errors, which are explained below:' ]],['=over',{'start_line'=>$m,'errata'=>1},''],;push@out,['=back',{'start_line'=>$m,'errata'=>1},''],;DEBUG and print STDERR "\n<<\n",pretty(\@out),"\n>>\n\n";return@out}}sub _ponder_paragraph_buffer {my$self=$_[0];my$paras;return unless @{$paras=$self->{'paras'}};my$curr_open=($self->{'curr_open'}||= []);my$scratch;DEBUG > 10 and print STDERR "# Paragraph buffer: <<",pretty($paras),">>\n";unless($self->{'doc_has_started'}){$self->{'doc_has_started'}=1;my$starting_contentless;$starting_contentless=(!@$curr_open and @$paras and!grep $_->[0]ne '~end',@$paras);DEBUG and print STDERR "# Starting ",$starting_contentless ? 'contentless' : 'contentful'," document\n" ;$self->_handle_element_start(($scratch='Document'),{'start_line'=>$paras->[0][1]{'start_line'},$starting_contentless ? ('contentless'=>1): (),},)}my($para,$para_type);while(@$paras){$seen_legal_directive++ if$paras->[0][0]=~ /^=/;last if @$paras==1 and ($paras->[0][0]eq '=over' or $paras->[0][0]eq '=item' or ($paras->[0][0]eq '~Verbatim' and $self->{'in_pod'}));$para=shift @$paras;$para_type=$para->[0];DEBUG > 1 and print STDERR "Pondering a $para_type paragraph, given the stack: (",$self->_dump_curr_open(),")\n";if($para_type eq '=for'){next if$self->_ponder_for($para,$curr_open,$paras)}elsif($para_type eq '=begin'){next if$self->_ponder_begin($para,$curr_open,$paras)}elsif($para_type eq '=end'){next if$self->_ponder_end($para,$curr_open,$paras)}elsif($para_type eq '~end'){next if$self->_ponder_doc_end($para,$curr_open,$paras)}if(grep $_->[1]{'~ignore'},@$curr_open){DEBUG > 1 and print STDERR "Skipping $para_type paragraph because in ignore mode.\n";next}if($para_type eq '=pod'){$self->_ponder_pod($para,$curr_open,$paras)}elsif($para_type eq '=over'){next if$self->_ponder_over($para,$curr_open,$paras)}elsif($para_type eq '=back'){next if$self->_ponder_back($para,$curr_open,$paras)}else {DEBUG > 1 and print STDERR "Pondering non-magical $para_type\n";my$i;if($para_type =~ m/^=head\d$/s and!$self->{'accept_heads_anywhere'}and @$curr_open and $curr_open->[-1][0]eq '=over'){DEBUG > 2 and print STDERR "'=$para_type' inside an '=over'!\n";$self->whine($para->[1]{'start_line'},"You forgot a '=back' before '$para_type'");unshift @$paras,['=back',{},''],$para;next}if($para_type eq '=item'){my$over;unless(@$curr_open and $over=(grep {$_->[0]eq '=over'}@$curr_open)[-1]){$self->whine($para->[1]{'start_line'},"'=item' outside of any '=over'");unshift @$paras,['=over',{'start_line'=>$para->[1]{'start_line'}},''],$para ;next}my$over_type=$over->[1]{'~type'};if(!$over_type){die "Typeless over in stack, starting at line " .$over->[1]{'start_line'}}elsif($over_type eq 'block'){unless($curr_open->[-1][1]{'~bitched_about'}){$curr_open->[-1][1]{'~bitched_about'}=1;$self->whine($curr_open->[-1][1]{'start_line'},"You can't have =items (as at line " .$para->[1]{'start_line'}.") unless the first thing after the =over is an =item")}$para->[0]='~Para';unshift @$paras,$para;next}elsif($over_type eq 'text'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";if($item_type eq 'text'){}elsif($item_type eq 'number' or $item_type eq 'bullet'){$self->whine($para->[1]{'start_line'},"Expected text after =item, not a $item_type");push @$para,$para->[1]{'~orig_content'};delete$para->[1]{'number'}}else {die "Unhandled item type $item_type"}}elsif($over_type eq 'number'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";my$expected_value=++ $curr_open->[-1][1]{'~counter'};if($item_type eq 'bullet'){$para->[1]{'number'}=$expected_value;$self->whine($para->[1]{'start_line'},"Expected '=item $expected_value'");push @$para,$para->[1]{'~orig_content'}}elsif($item_type eq 'text'){$para->[1]{'number'}=$expected_value;$self->whine($para->[1]{'start_line'},"Expected '=item $expected_value'")}elsif($item_type ne 'number'){die "Unknown item type $item_type"}elsif($expected_value==$para->[1]{'number'}){DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n"}else {DEBUG > 1 and print STDERR " Numeric item has ",$para->[1]{'number'}," instead of the expected value of $expected_value\n";$self->whine($para->[1]{'start_line'},"You have '=item " .$para->[1]{'number'}."' instead of the expected '=item $expected_value'");$para->[1]{'number'}=$expected_value}if(@$para==2){if($paras->[0][0]eq '~Para'){DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";push @$para,splice @{shift @$paras},2}else {DEBUG and print STDERR "Can't assimilate following ",$paras->[0][0],"\n";push @$para,''}}}elsif($over_type eq 'bullet'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";if($item_type eq 'bullet'){if($para->[1]{'~_freaky_para_hack'}){DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";push @$para,$para->[1]{'~_freaky_para_hack'}}}elsif($item_type eq 'number'){$self->whine($para->[1]{'start_line'},"Expected '=item *'");push @$para,$para->[1]{'~orig_content'};delete$para->[1]{'number'}}elsif($item_type eq 'text'){$self->whine($para->[1]{'start_line'},"Expected '=item *'")}else {die "Unhandled item type $item_type"}if(@$para==2){if($paras->[0][0]eq '~Para'){DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";push @$para,splice @{shift @$paras},2}else {DEBUG and print STDERR "Can't assimilate following ",$paras->[0][0],"\n";push @$para,''}}}else {die "Unhandled =over type \"$over_type\"?"}$para_type='Plain';$para->[0].= '-' .$over_type}elsif($para_type eq '=extend'){$self->_ponder_extend($para);next}elsif($para_type eq '=encoding'){$self->_handle_encoding_second_level($para);next unless$self->keep_encoding_directive;$para_type='Plain'}elsif($para_type eq '~Verbatim'){$para->[0]='Verbatim';$para_type='?Verbatim'}elsif($para_type eq '~Para'){$para->[0]='Para';$para_type='?Plain'}elsif($para_type eq 'Data'){$para->[0]='Data';$para_type='?Data'}elsif($para_type =~ s/^=//s and defined($para_type=$self->{'accept_directives'}{$para_type})){DEBUG > 1 and print STDERR " Pondering known directive ${$para}[0] as $para_type\n"}else {$seen_legal_directive--;DEBUG > 1 and printf STDERR "Unhandled directive %s (Handled: %s)\n",$para->[0],join(' ',sort keys %{$self->{'accept_directives'}});$self->whine($para->[1]{'start_line'},"Unknown directive: $para->[0]");next}if($para_type =~ s/^\?//s){if(!@$curr_open){DEBUG and print STDERR "Treating $para_type paragraph as such because stack is empty.\n"}else {my@fors=grep $_->[0]eq '=for',@$curr_open;DEBUG > 1 and print STDERR "Containing fors: ",join(',',map $_->[1]{'target'},@fors),"\n";if(!@fors){DEBUG and print STDERR "Treating $para_type paragraph as such because stack has no =for's\n"}elsif($fors[-1][1]{'~resolve'}){if($para_type eq 'Data'){DEBUG and print STDERR "Treating Data paragraph as Plain/Verbatim because the containing =for ($fors[-1][1]{'target'}) is a resolver\n";$para->[0]='Para';$para_type='Plain'}else {DEBUG and print STDERR "Treating $para_type paragraph as such because the containing =for ($fors[-1][1]{'target'}) is a resolver\n"}}else {DEBUG and print STDERR "Treating $para_type paragraph as Data because the containing =for ($fors[-1][1]{'target'}) is a non-resolver\n";$para->[0]=$para_type='Data'}}}if($para_type eq 'Plain'){$self->_ponder_Plain($para)}elsif($para_type eq 'Verbatim'){$self->_ponder_Verbatim($para)}elsif($para_type eq 'Data'){$self->_ponder_Data($para)}else {die "\$para type is $para_type -- how did that happen?"}$para->[0]=~ s/^[~=]//s;DEBUG and print STDERR "\n",pretty($para),"\n";$self->{'content_seen'}||= 1 if$seen_legal_directive &&!$self->{'~tried_gen_errata'};$self->_traverse_treelet_bit(@$para)}}return}sub _ponder_for {my ($self,$para,$curr_open,$paras)=@_;my$target;if(grep $_->[1]{'~ignore'},@$curr_open){DEBUG > 1 and print STDERR "Ignoring ignorable =for\n";return 1}for(my$i=2;$i < @$para;++$i){if($para->[$i]=~ s/^\s*(\S+)\s*//s){$target=$1;last}}unless(defined$target){$self->whine($para->[1]{'start_line'},"=for without a target?");return 1}DEBUG > 1 and print STDERR "Faking out a =for $target as a =begin $target / =end $target\n";$para->[0]='Data';unshift @$paras,['=begin',{'start_line'=>$para->[1]{'start_line'},'~really'=>'=for'},$target,],$para,['=end',{'start_line'=>$para->[1]{'start_line'},'~really'=>'=for'},$target,],;return 1}sub _ponder_begin {my ($self,$para,$curr_open,$paras)=@_;my$content=join ' ',splice @$para,2;$content =~ s/^\s+//s;$content =~ s/\s+$//s;unless(length($content)){$self->whine($para->[1]{'start_line'},"=begin without a target?");DEBUG and print STDERR "Ignoring targetless =begin\n";return 1}my ($target,$title)=$content =~ m/^(\S+)\s*(.*)$/;$para->[1]{'title'}=$title if ($title);$para->[1]{'target'}=$target;$content=$target;$content =~ s/^:!/!:/s;my$neg;$neg=1 if$content =~ s/^!//s;my$to_resolve;$to_resolve=1 if$content =~ s/^://s;my$dont_ignore;for my$target_name (split(',',$content,-1),$neg ? (): '*'){DEBUG > 2 and print STDERR " Considering whether =begin $content matches $target_name\n";next unless$self->{'accept_targets'}{$target_name};DEBUG > 2 and print STDERR "  It DOES match the acceptable target $target_name!\n";$to_resolve=1 if$self->{'accept_targets'}{$target_name}eq 'force_resolve';$dont_ignore=1;$para->[1]{'target_matching'}=$target_name;last}if($neg){if($dont_ignore){$dont_ignore='';delete$para->[1]{'target_matching'};DEBUG > 2 and print STDERR " But the leading ! means that this is a NON-match!\n"}else {$dont_ignore=1;$para->[1]{'target_matching'}='!';DEBUG > 2 and print STDERR " But the leading ! means that this IS a match!\n"}}$para->[0]='=for';$para->[1]{'~really'}||= '=begin';$para->[1]{'~ignore'}=(!$dont_ignore)|| 0;$para->[1]{'~resolve'}=$to_resolve || 0;DEBUG > 1 and print STDERR " Making note to ",$dont_ignore ? 'not ' : '',"ignore contents of this region\n";DEBUG > 1 and $dont_ignore and print STDERR " Making note to treat contents as ",($to_resolve ? 'verbatim/plain' : 'data')," paragraphs\n";DEBUG > 1 and print STDERR " (Stack now: ",$self->_dump_curr_open(),")\n";push @$curr_open,$para;if(!$dont_ignore or scalar grep $_->[1]{'~ignore'},@$curr_open){DEBUG > 1 and print STDERR "Ignoring ignorable =begin\n"}else {$self->{'content_seen'}||= 1 unless$self->{'~tried_gen_errata'};$self->_handle_element_start((my$scratch='for'),$para->[1])}return 1}sub _ponder_end {my ($self,$para,$curr_open,$paras)=@_;my$content=join ' ',splice @$para,2;$content =~ s/^\s+//s;$content =~ s/\s+$//s;DEBUG and print STDERR "Ogling '=end $content' directive\n";unless(length($content)){$self->whine($para->[1]{'start_line'},"'=end' without a target?" .((@$curr_open and $curr_open->[-1][0]eq '=for')? (" (Should be \"=end " .$curr_open->[-1][1]{'target'}.'")'): ''));DEBUG and print STDERR "Ignoring targetless =end\n";return 1}unless($content =~ m/^\S+$/){$self->whine($para->[1]{'start_line'},"'=end $content' is invalid.  (Stack: " .$self->_dump_curr_open().')');DEBUG and print STDERR "Ignoring mistargetted =end $content\n";return 1}unless(@$curr_open and $curr_open->[-1][0]eq '=for'){$self->whine($para->[1]{'start_line'},"=end $content without matching =begin.  (Stack: " .$self->_dump_curr_open().')');DEBUG and print STDERR "Ignoring mistargetted =end $content\n";return 1}unless($content eq $curr_open->[-1][1]{'target'}){$self->whine($para->[1]{'start_line'},"=end $content doesn't match =begin " .$curr_open->[-1][1]{'target'}.".  (Stack: " .$self->_dump_curr_open().')');DEBUG and print STDERR "Ignoring mistargetted =end $content at line $para->[1]{'start_line'}\n";return 1}if(grep $_->[1]{'~ignore'},@$curr_open){DEBUG > 1 and print STDERR "Not firing any event for this =end $content because in an ignored region\n"}else {$curr_open->[-1][1]{'start_line'}=$para->[1]{'start_line'};$self->{'content_seen'}||= 1 unless$self->{'~tried_gen_errata'};$self->_handle_element_end(my$scratch='for',$para->[1])}DEBUG > 1 and print STDERR "Popping $curr_open->[-1][0] $curr_open->[-1][1]{'target'} because of =end $content\n";pop @$curr_open;return 1}sub _ponder_doc_end {my ($self,$para,$curr_open,$paras)=@_;if(@$curr_open){DEBUG and print STDERR "Stack is nonempty at end-document: (",$self->_dump_curr_open(),")\n";DEBUG > 9 and print STDERR "Stack: ",pretty($curr_open),"\n";unshift @$paras,$self->_closers_for_all_curr_open;@$paras=grep $_->[0]ne '~end',@$paras;push @$paras,$para,$para;return 1}else {DEBUG and print STDERR "Okay, stack is empty now.\n"}unless($self->{'~tried_gen_errata'}){$self->{'~tried_gen_errata'}=1;my@extras=$self->_gen_errata();if(@extras){unshift @$paras,@extras;DEBUG and print STDERR "Generated errata... relooping...\n";return 1}}splice @$paras;DEBUG and print STDERR "Throwing end-document event.\n";$self->_handle_element_end(my$scratch='Document');return 1}sub _ponder_pod {my ($self,$para,$curr_open,$paras)=@_;$self->whine($para->[1]{'start_line'},"=pod directives shouldn't be over one line long!  Ignoring all " .(@$para - 2)." lines of content")if @$para > 3;if (my$pod_handler=$self->{'pod_handler'}){my ($line_num,$line)=map $_,$para->[1]{'start_line'},$para->[2];$line=$line eq '' ? "=pod" : "=pod $line";$pod_handler->($line,$line_num,$self)}return}sub _ponder_over {my ($self,$para,$curr_open,$paras)=@_;return 1 unless @$paras;my$list_type;if($paras->[0][0]eq '=item'){$list_type=$self->_get_initial_item_type($paras->[0])}elsif($paras->[0][0]eq '=back'){if ($self->{'parse_empty_lists'}){$list_type='empty'}else {shift @$paras;return 1}}elsif($paras->[0][0]eq '~end'){$self->whine($para->[1]{'start_line'},"=over is the last thing in the document?!");return 1}else {$list_type='block'}$para->[1]{'~type'}=$list_type;push @$curr_open,$para;my$content=join ' ',splice @$para,2;$para->[1]{'~orig_content'}=$content;my$overness;if($content =~ m/^\s*$/s){$para->[1]{'indent'}=4}elsif($content =~ m/^\s*((?:\d*\.)?\d+)\s*$/s){no integer;$para->[1]{'indent'}=$1;if($1==0){$self->whine($para->[1]{'start_line'},"Can't have a 0 in =over $content");$para->[1]{'indent'}=4}}else {$self->whine($para->[1]{'start_line'},"=over should be: '=over' or '=over positive_number'");$para->[1]{'indent'}=4}DEBUG > 1 and print STDERR "=over found of type $list_type\n";$self->{'content_seen'}||= 1 unless$self->{'~tried_gen_errata'};$self->_handle_element_start((my$scratch='over-' .$list_type),$para->[1]);return}sub _ponder_back {my ($self,$para,$curr_open,$paras)=@_;my$content=join ' ',splice @$para,2;if($content =~ m/\S/){$self->whine($para->[1]{'start_line'},"=back doesn't take any parameters, but you said =back $content")}if(@$curr_open and $curr_open->[-1][0]eq '=over'){DEBUG > 1 and print STDERR "=back happily closes matching =over\n";$self->{'content_seen'}||= 1 unless$self->{'~tried_gen_errata'};$self->_handle_element_end(my$scratch='over-' .((pop @$curr_open)->[1]{'~type'}),$para->[1])}else {DEBUG > 1 and print STDERR "=back found without a matching =over.  Stack: (",join(', ',map $_->[0],@$curr_open),").\n";$self->whine($para->[1]{'start_line'},'=back without =over');return 1}}sub _ponder_item {my ($self,$para,$curr_open,$paras)=@_;my$over;unless(@$curr_open and $over=(grep {$_->[0]eq '=over'}@$curr_open)[-1]){$self->whine($para->[1]{'start_line'},"'=item' outside of any '=over'");unshift @$paras,['=over',{'start_line'=>$para->[1]{'start_line'}},''],$para ;return 1}my$over_type=$over->[1]{'~type'};if(!$over_type){die "Typeless over in stack, starting at line " .$over->[1]{'start_line'}}elsif($over_type eq 'block'){unless($curr_open->[-1][1]{'~bitched_about'}){$curr_open->[-1][1]{'~bitched_about'}=1;$self->whine($curr_open->[-1][1]{'start_line'},"You can't have =items (as at line " .$para->[1]{'start_line'}.") unless the first thing after the =over is an =item")}$para->[0]='~Para';unshift @$paras,$para;return 1}elsif($over_type eq 'text'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";if($item_type eq 'text'){}elsif($item_type eq 'number' or $item_type eq 'bullet'){$self->whine($para->[1]{'start_line'},"Expected text after =item, not a $item_type");push @$para,$para->[1]{'~orig_content'};delete$para->[1]{'number'}}else {die "Unhandled item type $item_type"}}elsif($over_type eq 'number'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";my$expected_value=++ $curr_open->[-1][1]{'~counter'};if($item_type eq 'bullet'){$para->[1]{'number'}=$expected_value;$self->whine($para->[1]{'start_line'},"Expected '=item $expected_value'");push @$para,$para->[1]{'~orig_content'}}elsif($item_type eq 'text'){$para->[1]{'number'}=$expected_value;$self->whine($para->[1]{'start_line'},"Expected '=item $expected_value'")}elsif($item_type ne 'number'){die "Unknown item type $item_type"}elsif($expected_value==$para->[1]{'number'}){DEBUG > 1 and print STDERR " Numeric item has the expected value of $expected_value\n"}else {DEBUG > 1 and print STDERR " Numeric item has ",$para->[1]{'number'}," instead of the expected value of $expected_value\n";$self->whine($para->[1]{'start_line'},"You have '=item " .$para->[1]{'number'}."' instead of the expected '=item $expected_value'");$para->[1]{'number'}=$expected_value}if(@$para==2){if($paras->[0][0]eq '~Para'){DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";push @$para,splice @{shift @$paras},2}else {DEBUG and print STDERR "Can't assimilate following ",$paras->[0][0],"\n";push @$para,''}}}elsif($over_type eq 'bullet'){my$item_type=$self->_get_item_type($para);DEBUG and print STDERR " Item is of type ",$para->[0]," under $over_type\n";if($item_type eq 'bullet'){if($para->[1]{'~_freaky_para_hack'}){DEBUG and print STDERR "Accomodating '=item * Foo' tolerance hack.\n";push @$para,$para->[1]{'~_freaky_para_hack'}}}elsif($item_type eq 'number'){$self->whine($para->[1]{'start_line'},"Expected '=item *'");push @$para,$para->[1]{'~orig_content'};delete$para->[1]{'number'}}elsif($item_type eq 'text'){$self->whine($para->[1]{'start_line'},"Expected '=item *'")}else {die "Unhandled item type $item_type"}if(@$para==2){if($paras->[0][0]eq '~Para'){DEBUG and print STDERR "Assimilating following ~Para content into $over_type item\n";push @$para,splice @{shift @$paras},2}else {DEBUG and print STDERR "Can't assimilate following ",$paras->[0][0],"\n";push @$para,''}}}else {die "Unhandled =over type \"$over_type\"?"}$para->[0].= '-' .$over_type;return}sub _ponder_Plain {my ($self,$para)=@_;DEBUG and print STDERR " giving plain treatment...\n";unless(@$para==2 or (@$para==3 and $para->[2]eq '')or $para->[1]{'~cooked'}){push @$para,@{$self->_make_treelet(join("\n",splice(@$para,2)),$para->[1]{'start_line'})}}return}sub _ponder_Verbatim {my ($self,$para)=@_;DEBUG and print STDERR " giving verbatim treatment...\n";$para->[1]{'xml:space'}='preserve';unless ($self->{'_output_is_for_JustPod'}){$self->expand_verbatim_tabs(8)if!defined$self->expand_verbatim_tabs()|| $self->expand_verbatim_tabs()=~ /\D/;my$indent=$self->strip_verbatim_indent;if ($indent && ref$indent eq 'CODE'){my@shifted=(shift @{$para},shift @{$para});$indent=$indent->($para);unshift @{$para},@shifted}for(my$i=2;$i < @$para;$i++){for my$line ($para->[$i]){$line =~ s/^\Q$indent// if$indent;next unless$self->expand_verbatim_tabs;while($line =~ s/^([^\t]*)(\t+)/$1.(" " x ((length($2)
                                         * $self->expand_verbatim_tabs)
                                         -(length($1)&7)))/e){}}}}if($self->{'accept_codes'}and $self->{'accept_codes'}{'VerbatimFormatted'}){while(@$para > 3 and $para->[-1]!~ m/\S/){pop @$para}$self->_verbatim_format($para)}elsif ($self->{'codes_in_verbatim'}){push @$para,@{$self->_make_treelet(join("\n",splice(@$para,2)),$para->[1]{'start_line'},$para->[1]{'xml:space'})};$para->[-1]=~ s/\n+$//s}else {push @$para,join "\n",splice(@$para,2)if @$para > 3;$para->[-1]=~ s/\n+$//s}return}sub _ponder_Data {my ($self,$para)=@_;DEBUG and print STDERR " giving data treatment...\n";$para->[1]{'xml:space'}='preserve';push @$para,join "\n",splice(@$para,2)if @$para > 3;return}sub _traverse_treelet_bit {my($self,$name)=splice @_,0,2;my$scratch;$self->_handle_element_start(($scratch=$name),shift @_);while (@_){my$x=shift;if (ref($x)){&_traverse_treelet_bit($self,@$x)}else {$x .= shift while @_ &&!ref($_[0]);$self->_handle_text($x)}}$self->_handle_element_end($scratch=$name);return}sub _closers_for_all_curr_open {my$self=$_[0];my@closers;for my$still_open (@{$self->{'curr_open'}|| return}){my@copy=@$still_open;$copy[1]={%{$copy[1]}};if($copy[0]eq '=for'){$copy[0]='=end'}elsif($copy[0]eq '=over'){$self->whine($still_open->[1]{start_line},"=over without closing =back");$copy[0]='=back'}else {die "I don't know how to auto-close an open $copy[0] region"}unless(@copy > 2){push@copy,$copy[1]{'target'};$copy[-1]='' unless defined$copy[-1]}$copy[1]{'fake-closer'}=1;DEBUG and print STDERR "Queuing up fake-o event: ",pretty(\@copy),"\n";unshift@closers,\@copy}return@closers}sub _verbatim_format {my($it,$p)=@_;my$formatting;for(my$i=2;$i < @$p;$i++){DEBUG and print STDERR "_verbatim_format appends a newline to $i: $p->[$i]\n";$p->[$i].= "\n"}if(DEBUG > 4){print STDERR "<<\n";for(my$i=$#$p;$i >= 2;$i--){print STDERR "_verbatim_format $i: $p->[$i]"}print STDERR ">>\n"}for(my$i=$#$p;$i > 2;$i--){DEBUG > 5 and print STDERR "Scrutinizing line $i: $$p[$i]\n";if($p->[$i]=~ m{^#:([ \^\/\%]*)\n?$}s){DEBUG > 5 and print STDERR "  It's a formatty line.  ","Peeking at previous line ",$i-1,": $$p[$i-1]: \n";if($p->[$i-1]=~ m{^#:[ \^\/\%]*\n?$}s){DEBUG > 5 and print STDERR "  Previous line is formatty!  Skipping this one.\n";next}else {DEBUG > 5 and print STDERR "  Previous line is non-formatty!  Yay!\n"}}else {DEBUG > 5 and print STDERR "  It's not a formatty line.  Ignoring\n";next}DEBUG > 4 and print STDERR "_verbatim_format considers:\n<$p->[$i-1]>\n<$p->[$i]>\n";$formatting='  ' .$1;$formatting =~ s/\s+$//s;unless(length$formatting and $p->[$i-1]=~ m/\S/){splice @$p,$i,1;$i--;next}if(length($formatting)>= length($p->[$i-1])){$formatting=substr($formatting,0,length($p->[$i-1])- 1).' '}else {$formatting .= ' ' x (length($p->[$i-1])- length($formatting))}DEBUG > 4 and print STDERR "Formatting <$formatting>    on <",$p->[$i-1],">\n";my@new_line;while($formatting =~ m{\G(( +)|(\^+)|(\/+)|(\%+))}g){if($2){push@new_line,substr($p->[$i-1],pos($formatting)-length($1),length($1))}else {push@new_line,[($3 ? 'VerbatimB' : $4 ? 'VerbatimI' : $5 ? 'VerbatimBI' : die("Should never get called")),{},substr($p->[$i-1],pos($formatting)-length($1),length($1))]}}my@nixed=splice @$p,$i-1,2,@new_line;DEBUG > 10 and print STDERR "Nixed count: ",scalar(@nixed),"\n";DEBUG > 6 and print STDERR "New version of the above line is these tokens (",scalar(@new_line),"):",map(ref($_)?"<@$_> ":"<$_>",@new_line),"\n";$i--}$p->[0]='VerbatimFormatted';for(my$i=2;$i > $#$p;$i++ ){if(!ref($p->[$i])and!ref($p->[$i + 1])){DEBUG > 5 and print STDERR "_verbatim_format merges {$p->[$i]} and {$p->[$i+1]}\n";$p->[$i].= splice @$p,$i+1,1;--$i}}for(my$i=$#$p;$i >= 2;$i-- ){if(!ref($p->[$i])){if($p->[$i]=~ s/\n$//s){DEBUG > 5 and print STDERR "_verbatim_format killed the terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]}\n"}else {DEBUG > 5 and print STDERR "No terminal newline on #$i: {$p->[$i]}, after {$p->[$i-1]} !?\n"}last}}return}sub _treelet_from_formatting_codes {my($self,$para,$start_line,$preserve_space)=@_;my$treelet=['~Top',{'start_line'=>$start_line},];unless ($preserve_space || $self->{'preserve_whitespace'}){$para =~ s/\s+/ /g;$para =~ s/ $//;$para =~ s/^ //}my@stack;my@lineage=($treelet);my$raw='';my$inL=0;DEBUG > 4 and print STDERR "Paragraph:\n$para\n\n";while($para =~ m/\G
        (?:
          # Match starting codes, including the whitespace following a
          # multiple-delimiter start code.  $1 gets the whole start code and
          # $2 gets all but one of the <s in the multiple-bracket case.
          ([A-Z]<(?:(<+)\s+)?)
          |
          # Match multiple-bracket end codes.  $3 gets the whitespace that
          # should be discarded before an end bracket but kept in other cases
          # and $4 gets the end brackets themselves.  ($3 can be empty if the
          # construct is empty, like C<<  >>, and all the white-space has been
          # gobbled up already, considered to be space after the opening
          # bracket.  In this case we use look-behind to verify that there are
          # at least 2 spaces in a row before the ">".)
          (\s+|(?<=\s\s))(>{2,})
          |
          (\s?>)          # $5: simple end-codes
          |
          (               # $6: stuff containing no start-codes or end-codes
            (?:
              [^A-Z\s>]
              |
              (?:
                [A-Z](?!<)
              )
              |
              # whitespace is ok, but we don't want to eat the whitespace before
              # a multiple-bracket end code.
              # NOTE: we may still have problems with e.g. S<<    >>
              (?:
                \s(?!\s*>{2,})
              )
            )+
          )
        )
      /xgo){DEBUG > 4 and print STDERR "\nParagraphic tokenstack = (@stack)\n";if(defined $1){my$bracket_count;if(defined $2){DEBUG > 3 and print STDERR "Found complex start-text code \"$1\"\n";$bracket_count=length($2)+ 1;push@stack,$bracket_count}else {DEBUG > 3 and print STDERR "Found simple start-text code \"$1\"\n";push@stack,0;$bracket_count=1}my$code=substr($1,0,1);if ('L' eq $code){if ($inL){$raw .= $1;$self->scream($start_line,'Nested L<> are illegal.  Pretending inner one is ' .'X<...> so can continue looking for other errors.');$code="X"}else {$raw="";$inL=@stack}}else {$raw .= $1 if$inL}push@lineage,[$code,{},];if ($self->{'_output_is_for_JustPod'}&& $bracket_count > 1){$lineage[-1][1]{'~bracket_count'}=$bracket_count;my$lspacer=substr($1,1 + $bracket_count);$lineage[-1][1]{'~lspacer'}=$lspacer if$lspacer ne " "}push @{$lineage[-2]},$lineage[-1]}elsif(defined $4){DEBUG > 3 and print STDERR "Found apparent complex end-text code \"$3$4\"\n";if(!@stack){DEBUG > 4 and print STDERR " But it's really just stuff.\n";push @{$lineage[-1]},$3,$4;next}elsif(!$stack[-1]){DEBUG > 4 and print STDERR " And that's more than we needed to close simple.\n";push @{$lineage[-1]},$3;pos($para)=pos($para)- length($4)+ 1}elsif($stack[-1]==length($4)){DEBUG > 4 and print STDERR " And that's exactly what we needed to close complex.\n"}elsif($stack[-1]< length($4)){DEBUG > 4 and print STDERR " And that's more than we needed to close complex.\n";pos($para)=pos($para)- length($4)+ $stack[-1]}else {DEBUG > 4 and print STDERR " But it's really just stuff, because we needed more.\n";push @{$lineage[-1]},$3,$4;next}if ($3 ne " " && $self->{'_output_is_for_JustPod'}){if ($3 ne ""){$lineage[-1][1]{'~rspacer'}=$3}elsif ($lineage[-1][1]{'~lspacer'}eq "  "){delete$lineage[-1][1]{'~lspacer'}}else {$lineage[-1][1]{'~rspacer'}=substr($lineage[-1][1]{'~lspacer'},-1,1);chop$lineage[-1][1]{'~lspacer'}}}push @{$lineage[-1]},'' if 2==@{$lineage[-1]};if ($inL==@stack){$lineage[-1][1]{'raw'}=$raw;$inL=0}pop@stack;pop@lineage;$raw .= $3.$4 if$inL}elsif(defined $5){DEBUG > 3 and print STDERR "Found apparent simple end-text code \"$5\"\n";if(@stack and!$stack[-1]){DEBUG > 4 and print STDERR " It's indeed an end-code.\n";if(length($5)==2){push @{$lineage[-1]},' '}elsif(2==@{$lineage[-1]}){push @{$lineage[-1]},''}if ($inL==@stack){$lineage[-1][1]{'raw'}=$raw;$inL=0}pop@stack;pop@lineage}else {DEBUG > 4 and print STDERR " It's just stuff.\n";push @{$lineage[-1]},$5}$raw .= $5 if$inL}elsif(defined $6){DEBUG > 3 and print STDERR "Found stuff \"$6\"\n";push @{$lineage[-1]},$6;$raw .= $6 if$inL}else {DEBUG and print STDERR "AYYAYAAAAA at line ",__LINE__,"\n";die "SPORK 512512!"}}if(@stack){my$x="...";while(@stack){push @{$lineage[-1]},'' if 2==@{$lineage[-1]};my$code=(pop@lineage)->[0];my$ender_length=pop@stack;if($ender_length){--$ender_length;$x=$code .("<" x $ender_length)." $x " .(">" x $ender_length)}else {$x=$code ."<$x>"}}DEBUG > 1 and print STDERR "Unterminated $x sequence\n";$self->whine($start_line,"Unterminated $x sequence",)}return$treelet}sub text_content_of_treelet {return stringify_lol($_[1])}sub stringify_lol {my$string_form='';_stringify_lol($_[0]=>\$string_form);return$string_form}sub _stringify_lol {my($lol,$to)=@_;for(my$i=2;$i < @$lol;++$i){if(ref($lol->[$i]|| '')and UNIVERSAL::isa($lol->[$i],'ARRAY')){_stringify_lol($lol->[$i],$to)}else {$$to .= $lol->[$i]}}return}sub _dump_curr_open {my$curr_open=$_[0]{'curr_open'};return '[empty]' unless @$curr_open;return join '; ',map {;($_->[0]eq '=for')? (($_->[1]{'~really'}|| '=over').' ' .$_->[1]{'target'}): $_->[0]}@$curr_open }my%pretty_form=("\a"=>'\a',"\b"=>'\b',"\e"=>'\e',"\f"=>'\f',"\t"=>'\t',"\cm"=>'\cm',"\cj"=>'\cj',"\n"=>'\n','"'=>'\"','\\'=>'\\\\','$'=>'\\$','@'=>'\\@','%'=>'\\%','#'=>'\\#',);sub pretty {my@stuff=@_;my$x;my$out=join ", ",map {;if(!defined($_)){"undef"}elsif(ref($_)eq 'ARRAY' or ref($_)eq 'Pod::Simple::LinkSection'){$x="[ " .pretty(@$_)." ]" ;$x}elsif(ref($_)eq 'SCALAR'){$x="\\" .pretty($$_);$x}elsif(ref($_)eq 'HASH'){my$hr=$_;$x="{" .join(", ",map(pretty($_).'=>' .pretty($hr->{$_}),sort keys %$hr))."}" ;$x}elsif(!length($_)){q{''}}elsif($_ eq '0' or(m/^-?(?:[123456789]\d*|0)(?:\.\d+)?$/s and $_ ne '-0')){$_}else {s<([^ !"#'()*+,\-./0123456789:;\<=\>?ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\]^_`abcdefghijklmnopqrstuvwxyz{|}~])>
           <$pretty_form{$1} || '\\x{'.sprintf("%x", ord($1)).'}'>eg;qq{"$_"}}}@stuff;return$out}sub reinit {my$self=shift;for (qw(source_dead source_filename doc_has_started start_of_pod_block content_seen last_was_blank paras curr_open line_count pod_para_count in_pod ~tried_gen_errata all_errata errata errors_seen Title)){delete$self->{$_}}}1;
POD_SIMPLE_BLACKBOX

$fatpacked{"Pod/Simple/Checker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_CHECKER';
  require 5;package Pod::Simple::Checker;use strict;use Carp ();use Pod::Simple::Methody ();use Pod::Simple ();use vars qw(@ISA $VERSION);$VERSION='3.40';@ISA=('Pod::Simple::Methody');BEGIN {*DEBUG=defined(&Pod::Simple::DEBUG)? \&Pod::Simple::DEBUG : sub() {0}}use Text::Wrap 98.112902 ();$Text::Wrap::wrap='overflow';sub any_errata_seen {return $_[1]->{'Errata_seen'}}sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->nix_X_codes(1);$new->nbsp_for_S(1);$new->{'Thispara'}='';$new->{'Indent'}=0;$new->{'Indentstring'}='   ';$new->{'Errata_seen'}=0;return$new}sub handle_text {$_[0]{'Errata_seen'}and $_[0]{'Thispara'}.= $_[1]}sub start_Para {$_[0]{'Thispara'}=''}sub start_head1 {if($_[0]{'Errata_seen'}){$_[0]{'Thispara'}=''}else {if($_[1]{'errata'}){$_[0]{'Errata_seen'}=1;$_[0]{'Thispara'}=$_[0]{'source_filename'}? "$_[0]{'source_filename'} -- " : ''}}}sub start_head2 {$_[0]{'Thispara'}=''}sub start_head3 {$_[0]{'Thispara'}=''}sub start_head4 {$_[0]{'Thispara'}=''}sub start_Verbatim {$_[0]{'Thispara'}=''}sub start_item_bullet {$_[0]{'Thispara'}='* '}sub start_item_number {$_[0]{'Thispara'}="$_[1]{'number'}. "}sub start_item_text {$_[0]{'Thispara'}=''}sub start_over_bullet {++$_[0]{'Indent'}}sub start_over_number {++$_[0]{'Indent'}}sub start_over_text {++$_[0]{'Indent'}}sub start_over_block {++$_[0]{'Indent'}}sub end_over_bullet {--$_[0]{'Indent'}}sub end_over_number {--$_[0]{'Indent'}}sub end_over_text {--$_[0]{'Indent'}}sub end_over_block {--$_[0]{'Indent'}}sub end_head1 {$_[0]->emit_par(-4)}sub end_head2 {$_[0]->emit_par(-3)}sub end_head3 {$_[0]->emit_par(-2)}sub end_head4 {$_[0]->emit_par(-1)}sub end_Para {$_[0]->emit_par(0)}sub end_item_bullet {$_[0]->emit_par(0)}sub end_item_number {$_[0]->emit_par(0)}sub end_item_text {$_[0]->emit_par(-2)}sub emit_par {return unless $_[0]{'Errata_seen'};my($self,$tweak_indent)=splice(@_,0,2);my$length=2 * $self->{'Indent'}+ ($tweak_indent||0);my$indent=' ' x ($length > 0 ? $length : 0);$self->{'Thispara'}=~ s/$Pod::Simple::shy//g;my$out=Text::Wrap::wrap($indent,$indent,$self->{'Thispara'}.= "\n");$out =~ s/$Pod::Simple::nbsp/ /g;print {$self->{'output_fh'}}$out,;$self->{'Thispara'}='';return}sub end_Verbatim {return unless $_[0]{'Errata_seen'};my$self=shift;$self->{'Thispara'}=~ s/$Pod::Simple::nbsp/ /g;$self->{'Thispara'}=~ s/$Pod::Simple::shy//g;my$i=' ' x (2 * $self->{'Indent'}+ 4);$self->{'Thispara'}=~ s/^/$i/mg;print {$self->{'output_fh'}}'',$self->{'Thispara'},"\n\n" ;$self->{'Thispara'}='';return}1;
POD_SIMPLE_CHECKER

$fatpacked{"Pod/Simple/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DEBUG';
  require 5;package Pod::Simple::Debug;use strict;use vars qw($VERSION);$VERSION='3.40';sub import {my($value,$variable);if(@_==2){$value=$_[1]}elsif(@_==3){($variable,$value)=@_[1,2];($variable,$value)=($value,$variable)if defined$value and ref($value)eq 'SCALAR' and not(defined$variable and ref($variable)eq 'SCALAR');unless(defined$variable and ref($variable)eq 'SCALAR'){require Carp;Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor" ."\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting")}}else {require Carp;Carp::croak("Usage:\n use Pod::Simple::Debug (NUMVAL)\nor" ."\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting")}if(defined&Pod::Simple::DEBUG){require Carp;Carp::croak("It's too late to call Pod::Simple::Debug -- " ."Pod::Simple has already loaded\nAborting")}$value=0 unless defined$value;unless($value =~ m/^-?\d+$/){require Carp;Carp::croak("$value isn't a numeric value." ."\nUsage:\n use Pod::Simple::Debug (NUMVAL)\nor" ."\n use Pod::Simple::Debug (\\\$var, STARTNUMVAL)\nAborting")}if(defined$variable){*Pod::Simple::DEBUG=sub () {$$variable};$$variable=$value;print STDERR "# Starting Pod::Simple::DEBUG = non-constant $variable with val $value\n"}else {*Pod::Simple::DEBUG=eval " sub () { $value } ";print STDERR "# Starting Pod::Simple::DEBUG = $value\n"}require Pod::Simple;return}1;
POD_SIMPLE_DEBUG

$fatpacked{"Pod/Simple/DumpAsText.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASTEXT';
  require 5;package Pod::Simple::DumpAsText;$VERSION='3.40';use Pod::Simple ();BEGIN {@ISA=('Pod::Simple')}use strict;use Carp ();BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->accept_codes('VerbatimFormatted');$new->keep_encoding_directive(1);return$new}sub _handle_element_start {my$fh=$_[0]{'output_fh'};my($key,$value);DEBUG and print STDERR "++ $_[1]\n";print$fh '  ' x ($_[0]{'indent'}|| 0),"++",$_[1],"\n";$_[0]{'indent'}++;while(($key,$value)=each %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_perly_escape($key);_perly_escape($value);printf$fh qq{%s \\ "%s" => "%s"\n},'  ' x ($_[0]{'indent'}|| 0),$key,$value}}return}sub _handle_text {DEBUG and print STDERR "== \"$_[1]\"\n";if(length $_[1]){my$indent='  ' x $_[0]{'indent'};my$text=$_[1];_perly_escape($text);$text =~ s/(
           [^\n]{55}         # Snare some characters from a line
           [^\n\ ]{0,50}     #  and finish any current word
          )
          \ {1,10}(?!\n)     # capture some spaces not at line-end
         /$1"\n$indent . "/gx ;print {$_[0]{'output_fh'}}$indent,'* "',$text,"\"\n"}return}sub _handle_element_end {DEBUG and print STDERR "-- $_[1]\n";print {$_[0]{'output_fh'}}'  ' x --$_[0]{'indent'},"--",$_[1],"\n";return}sub _perly_escape {for my$x (@_){$x =~ s/([^\x00-\xFF])/sprintf'\x{%X}',ord($1)/eg;$x =~ s/([^-\n\t \&\<\>\'!\#\%\(\)\*\+,\.\/\:\;=\?\~\[\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf'\x%02X',ord($1)/eg}return}1;
POD_SIMPLE_DUMPASTEXT

$fatpacked{"Pod/Simple/DumpAsXML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_DUMPASXML';
  require 5;package Pod::Simple::DumpAsXML;$VERSION='3.40';use Pod::Simple ();BEGIN {@ISA=('Pod::Simple')}use strict;use Carp ();use Text::Wrap qw(wrap);BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->accept_codes('VerbatimFormatted');$new->keep_encoding_directive(1);return$new}sub _handle_element_start {my$fh=$_[0]{'output_fh'};my($key,$value);DEBUG and print STDERR "++ $_[1]\n";print$fh '  ' x ($_[0]{'indent'}|| 0),"<",$_[1];for my$key (sort keys %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_xml_escape($value=$_[2]{$key});print$fh ' ',$key,'="',$value,'"'}}print$fh ">\n";$_[0]{'indent'}++;return}sub _handle_text {DEBUG and print STDERR "== \"$_[1]\"\n";if(length $_[1]){my$indent='  ' x $_[0]{'indent'};my$text=$_[1];_xml_escape($text);local$Text::Wrap::huge='overflow';$text=wrap('',$indent,$text);print {$_[0]{'output_fh'}}$indent,$text,"\n"}return}sub _handle_element_end {DEBUG and print STDERR "-- $_[1]\n";print {$_[0]{'output_fh'}}'  ' x --$_[0]{'indent'},"</",$_[1],">\n";return}sub _xml_escape {for my$x (@_){if ($] ge 5.007_003){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg}else {$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}}return}1;
POD_SIMPLE_DUMPASXML

$fatpacked{"Pod/Simple/HTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTML';
  require 5;package Pod::Simple::HTML;use strict;use Pod::Simple::PullParser ();use vars qw(@ISA %Tagmap $Computerese $LamePad $Linearization_Limit $VERSION $Perldoc_URL_Prefix $Perldoc_URL_Postfix $Man_URL_Prefix $Man_URL_Postfix $Title_Prefix $Title_Postfix $HTML_EXTENSION %ToIndex $Doctype_decl $Content_decl);@ISA=('Pod::Simple::PullParser');$VERSION='3.40';BEGIN {if(defined&DEBUG){}elsif(defined&Pod::Simple::DEBUG){*DEBUG=\&Pod::Simple::DEBUG}else {*DEBUG=sub () {0}}}$Doctype_decl ||= '';$Content_decl ||= q{<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >};$HTML_EXTENSION='.html' unless defined$HTML_EXTENSION;$Computerese="" unless defined$Computerese;$LamePad='' unless defined$LamePad;$Linearization_Limit=120 unless defined$Linearization_Limit;$Perldoc_URL_Prefix='https://metacpan.org/pod/' unless defined$Perldoc_URL_Prefix;$Perldoc_URL_Postfix='' unless defined$Perldoc_URL_Postfix;$Man_URL_Prefix='http://man.he.net/man';$Man_URL_Postfix='';$Title_Prefix='' unless defined$Title_Prefix;$Title_Postfix='' unless defined$Title_Postfix;%ToIndex=map {;$_=>1}qw(head1 head2 head3 head4);__PACKAGE__->_accessorize('perldoc_url_prefix','perldoc_url_postfix','man_url_prefix','man_url_postfix','batch_mode','batch_mode_current_level','title_prefix','title_postfix','html_h_level','html_header_before_title','html_header_after_title','html_footer','top_anchor','index','html_css','html_javascript','force_title','default_title',);my@_to_accept;%Tagmap=('Verbatim'=>"\n<pre$Computerese>",'/Verbatim'=>"</pre>\n",'VerbatimFormatted'=>"\n<pre$Computerese>",'/VerbatimFormatted'=>"</pre>\n",'VerbatimB'=>"<b>",'/VerbatimB'=>"</b>",'VerbatimI'=>"<i>",'/VerbatimI'=>"</i>",'VerbatimBI'=>"<b><i>",'/VerbatimBI'=>"</i></b>",'Data'=>"\n",'/Data'=>"\n",'head1'=>"\n<h1>",'head2'=>"\n<h2>",'head3'=>"\n<h3>",'head4'=>"\n<h4>",'/head1'=>"</a></h1>\n",'/head2'=>"</a></h2>\n",'/head3'=>"</a></h3>\n",'/head4'=>"</a></h4>\n",'X'=>"<!--\n\tINDEX: ",'/X'=>"\n-->",changes(qw(Para=p B=b I=i over-bullet=ul over-number=ol over-text=dl over-block=blockquote item-bullet=li item-number=li item-text=dt)),changes2(map {;m/^([-a-z]+)/s && push@_to_accept,$1;$_}qw[sample=samp definition=dfn keyboard=kbd variable=var citation=cite abbreviation=abbr acronym=acronym subscript=sub superscript=sup big=big small=small underline=u strikethrough=s preformat=pre teletype=tt]),'/item-bullet'=>"</li>$LamePad\n",'/item-number'=>"</li>$LamePad\n",'/item-text'=>"</a></dt>$LamePad\n",'item-body'=>"\n<dd>",'/item-body'=>"</dd>\n",'B'=>"<b>",'/B'=>"</b>",'I'=>"<i>",'/I'=>"</i>",'F'=>"<em$Computerese>",'/F'=>"</em>",'C'=>"<code$Computerese>",'/C'=>"</code>",'L'=>"<a href='YOU_SHOULD_NEVER_SEE_THIS'>",'/L'=>"</a>",);sub changes {return map {;m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s ? ($1,=>"\n<$2>","/$1",=>"</$2>\n"): die "Funky $_"}@_}sub changes2 {return map {;m/^([-_:0-9a-zA-Z]+)=([-_:0-9a-zA-Z]+)$/s ? ($1,=>"<$2>","/$1",=>"</$2>"): die "Funky $_"}@_}sub go {Pod::Simple::HTML->parse_from_file(@ARGV);exit 0}sub new {my$new=shift->SUPER::new(@_);$new->nbsp_for_S(1);$new->accept_targets('html','HTML');$new->accept_codes('VerbatimFormatted');$new->accept_codes(@_to_accept);DEBUG > 2 and print STDERR "To accept: ",join(' ',@_to_accept),"\n";$new->perldoc_url_prefix($Perldoc_URL_Prefix);$new->perldoc_url_postfix($Perldoc_URL_Postfix);$new->man_url_prefix($Man_URL_Prefix);$new->man_url_postfix($Man_URL_Postfix);$new->title_prefix($Title_Prefix);$new->title_postfix($Title_Postfix);$new->html_header_before_title(qq[$Doctype_decl<html><head><title>]);$new->html_header_after_title(join "\n"=>"</title>",$Content_decl,"</head>\n<body class='pod'>",$new->version_tag_comment,"<!-- start doc -->\n",);$new->html_footer(qq[\n<!-- end doc -->\n\n</body></html>\n]);$new->top_anchor("<a name='___top' class='dummyTopAnchor' ></a>\n");$new->{'Tagmap'}={%Tagmap};return$new}sub __adjust_html_h_levels {my ($self)=@_;my$Tagmap=$self->{'Tagmap'};my$add=$self->html_h_level;return unless defined$add;return if ($self->{'Adjusted_html_h_levels'}||0)==$add;$add -= 1;for (1 .. 4){$Tagmap->{"head$_"}=~ s/$_/$_ + $add/e;$Tagmap->{"/head$_"}=~ s/$_/$_ + $add/e}}sub batch_mode_page_object_init {my($self,$batchconvobj,$module,$infile,$outfile,$depth)=@_;DEBUG and print STDERR "Initting $self\n  for $module\n","  in $infile\n  out $outfile\n  depth $depth\n";$self->batch_mode(1);$self->batch_mode_current_level($depth);return$self}sub run {my$self=$_[0];return$self->do_middle if$self->bare_output;return $self->do_beginning && $self->do_middle && $self->do_end}sub do_beginning {my$self=$_[0];my$title;if(defined$self->force_title){$title=$self->force_title;DEBUG and print STDERR "Forcing title to be $title\n"}else {$title=$self->get_short_title();unless($self->content_seen){DEBUG and print STDERR "No content seen in search for title.\n";return}$self->{'Title'}=$title;if(defined$title and $title =~ m/\S/){$title=$self->title_prefix .esc($title).$self->title_postfix}else {$title=$self->default_title;$title='' unless defined$title;DEBUG and print STDERR "Title defaults to $title\n"}}my$after=$self->html_header_after_title || '';if($self->html_css){my$link=$self->html_css =~ m/</ ? $self->html_css : sprintf(qq[<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="%s">\n],$self->html_css,);$after =~ s{(</head>)}{$link\n$1}i}$self->_add_top_anchor(\$after);if($self->html_javascript){my$link=$self->html_javascript =~ m/</ ? $self->html_javascript : sprintf(qq[<script type="text/javascript" src="%s"></script>\n],$self->html_javascript,);$after =~ s{(</head>)}{$link\n$1}i}print {$self->{'output_fh'}}$self->html_header_before_title || '',$title,$after,;DEBUG and print STDERR "Returning from do_beginning...\n";return 1}sub _add_top_anchor {my($self,$text_r)=@_;unless($$text_r and $$text_r =~ m/name=['"]___top['"]/){$$text_r .= $self->top_anchor || ''}return}sub version_tag_comment {my$self=shift;return sprintf "<!--\n  generated by %s v%s,\n  using %s v%s,\n  under Perl v%s at %s GMT.\n\n %s\n\n-->\n",esc(ref($self),$self->VERSION(),$ISA[0],$ISA[0]->VERSION(),$],scalar(gmtime),),$self->_modnote(),}sub _modnote {my$class=ref($_[0])|| $_[0];return join "\n   "=>grep m/\S/,split "\n",qq{
  If you want to change this HTML document, you probably shouldn't do that
  by changing it directly.  Instead, see about changing the calling options
  to $class, and/or subclassing $class,
  then reconverting this document from the Pod source.
  When in doubt, email the author of $class for advice.
  See 'perldoc $class' for more info.
  }}sub do_end {my$self=$_[0];print {$self->{'output_fh'}}$self->html_footer || '';return 1}sub do_middle {my$self=$_[0];return$self->_do_middle_main_loop unless$self->index;if($self->output_string){my$out=$self->output_string;my$sneakytag="\f\f\e\e\b\bIndex Here\e\e\b\b\f\f\n";$$out .= $sneakytag;$self->_do_middle_main_loop;$sneakytag=quotemeta($sneakytag);my$index=$self->index_as_html();if($$out =~ s/$sneakytag/$index/s){DEBUG and print STDERR "Inserted ",length($index)," bytes of index HTML into $out.\n"}else {DEBUG and print STDERR "Odd, couldn't find where to insert the index in the output!\n"}return 1}unless($self->output_fh){require Carp;Carp::confess("Parser object \$p doesn't seem to have any output object!  I don't know how to deal with that.")}my$fh=$self->output_fh;my$content='';{$self->output_string(\$content);$self->_do_middle_main_loop;$self->abandon_output_string();$self->output_fh($fh)}print$fh $self->index_as_html();print$fh $content;return 1}sub index_as_html {my$self=$_[0];my$points=$self->{'PSHTML_index_points'}|| [];@$points > 1 or return qq[<div class='indexgroupEmpty'></div>\n];my(@out)=qq{\n<div class='indexgroup'>};my$level=0;my($target_level,$previous_tagname,$tagname,$text,$anchorname,$indent);for my$p (@$points,['head0','(end)']){($tagname,$text)=@$p;$anchorname=$self->section_escape($text);if($tagname =~ m{^head(\d+)$}){$target_level=0 + $1}else {if($previous_tagname =~ m{^head\d+$}){$target_level=$level + 1}else {$target_level=$level}}while($level > $target_level){--$level;push@out,("  " x $level)."</ul>"}while($level < $target_level){++$level;push@out,("  " x ($level-1))."<ul   class='indexList indexList$level'>"}$previous_tagname=$tagname;next unless$level;$indent='  ' x $level;push@out,sprintf "%s<li class='indexItem indexItem%s'><a href='#%s'>%s</a>",$indent,$level,esc($anchorname),esc($text)}push@out,"</div>\n";return join "\n",@out}sub _do_middle_main_loop {my$self=$_[0];my$fh=$self->{'output_fh'};my$tagmap=$self->{'Tagmap'};$self->__adjust_html_h_levels;my($token,$type,$tagname,$linkto,$linktype);my@stack;my$dont_wrap=0;while($token=$self->get_token){if(($type=$token->type)eq 'start'){if(($tagname=$token->tagname)eq 'L'){$linktype=$token->attr('type')|| 'insane';$linkto=$self->do_link($token);if(defined$linkto and length$linkto){esc($linkto);print$fh qq{<a href="$linkto" class="podlink$linktype"\n>}}else {print$fh "<a>"}}elsif ($tagname eq 'item-text' or $tagname =~ m/^head\d$/s){print$fh $tagmap->{$tagname}|| next;my@to_unget;while(1){push@to_unget,$self->get_token;last if$to_unget[-1]->is_end and $to_unget[-1]->tagname eq $tagname}my$name=$self->linearize_tokens(@to_unget);$name=$self->do_section($name,$token)if defined$name;print$fh "<a ";if ($tagname =~ m/^head\d$/s){print$fh "class='u'",$self->index ? " href='#___top' title='click to go to top of document'\n" : "\n"}if(defined$name){my$esc=esc($self->section_name_tidy($name));print$fh qq[name="$esc"];DEBUG and print STDERR "Linearized ",scalar(@to_unget)," tokens as \"$name\".\n";push @{$self->{'PSHTML_index_points'}},[$tagname,$name]if$ToIndex{$tagname }}else {DEBUG and print STDERR "Linearized ",scalar(@to_unget)," tokens, but it was too long, so nevermind.\n"}print$fh "\n>";$self->unget_token(@to_unget)}elsif ($tagname eq 'Data'){my$next=$self->get_token;next unless defined$next;unless($next->type eq 'text'){$self->unget_token($next);next}DEBUG and print STDERR "    raw text ",$next->text,"\n";(my$text=$next->text)=~ s/\n\z//;print$fh $text,"\n";next}else {if($tagname =~ m/^over-/s){push@stack,''}elsif($tagname =~ m/^item-/s and @stack and $stack[-1]){print$fh $stack[-1];$stack[-1]=''}print$fh $tagmap->{$tagname}|| next;++$dont_wrap if$tagname eq 'Verbatim' or $tagname eq "VerbatimFormatted" or $tagname eq 'X'}}elsif($type eq 'end'){if(($tagname=$token->tagname)=~ m/^over-/s){if(my$end=pop@stack){print$fh $end}}elsif($tagname =~ m/^item-/s and @stack){$stack[-1]=$tagmap->{"/$tagname"};if($tagname eq 'item-text' and defined(my$next=$self->get_token)){$self->unget_token($next);if($next->type eq 'start'){print$fh $tagmap->{"/item-text"},$tagmap->{"item-body"};$stack[-1]=$tagmap->{"/item-body"}}}next}print$fh $tagmap->{"/$tagname"}|| next;--$dont_wrap if$tagname eq 'Verbatim' or $tagname eq 'X'}elsif($type eq 'text'){esc($type=$token->text);$type =~ s/([\?\!\"\'\.\,]) /$1\n/g unless$dont_wrap;print$fh $type}}return 1}sub do_section {my($self,$name,$token)=@_;return$name}sub do_link {my($self,$token)=@_;my$type=$token->attr('type');if(!defined$type){$self->whine("Typeless L!?",$token->attr('start_line'))}elsif($type eq 'pod'){return$self->do_pod_link($token)}elsif($type eq 'url'){return$self->do_url_link($token)}elsif($type eq 'man'){return$self->do_man_link($token)}else {$self->whine("L of unknown type $type!?",$token->attr('start_line'))}return 'FNORG'}sub do_url_link {return $_[1]->attr('to')}sub do_man_link {my ($self,$link)=@_;my$to=$link->attr('to');my$frag=$link->attr('section');return undef unless defined$to and length$to;$frag=$self->section_escape($frag)if defined$frag and length($frag .= '');DEBUG and print STDERR "Resolving \"$to/$frag\"\n\n";return$self->resolve_man_page_link($to,$frag)}sub do_pod_link {my($self,$link)=@_;my$to=$link->attr('to');my$section=$link->attr('section');return undef unless((defined$to and length$to)or (defined$section and length$section));$section=$self->section_escape($section)if defined$section and length($section .= '');DEBUG and printf STDERR "Resolving \"%s\" \"%s\"...\n",$to || "(nil)",$section || "(nil)";{my$complete_url=$self->resolve_pod_link_by_table($to,$section);if($complete_url){DEBUG > 1 and print STDERR "resolve_pod_link_by_table(T,S) gives ",$complete_url,"\n  (Returning that.)\n";return$complete_url}else {DEBUG > 4 and print STDERR " resolve_pod_link_by_table(T,S)"," didn't return anything interesting.\n"}}if(defined$to and length$to){my$there=$self->resolve_pod_link_by_table($to);if(defined$there and length$there){DEBUG > 1 and print STDERR "resolve_pod_link_by_table(T) gives $there\n"}else {$there=$self->resolve_pod_page_link($to,$section);DEBUG > 1 and print STDERR "resolve_pod_page_link gives ",$there || "(nil)","\n";unless(defined$there and length$there){DEBUG and print STDERR "Can't resolve $to\n";return undef}}$to=$there}my$out=(defined$to and length$to)? $to : '';$out .= "#" .$section if defined$section and length$section;unless(length$out){DEBUG and printf STDERR "Oddly, couldn't resolve \"%s\" \"%s\"...\n",$to || "(nil)",$section || "(nil)";return undef}DEBUG and print STDERR "Resolved to $out\n";return$out}sub section_escape {my($self,$section)=@_;return$self->section_url_escape($self->section_name_tidy($section))}sub section_name_tidy {my($self,$section)=@_;$section =~ s/^\s+//;$section =~ s/\s+$//;$section =~ tr/ /_/;if ($] ge 5.006){$section =~ s/[[:cntrl:][:^ascii:]]//g}elsif ('A' eq chr(65)){$section =~ tr/\x00-\x1F\x80-\x9F//d}$section=$self->unicode_escape_url($section);$section='_' unless length$section;return$section}sub section_url_escape {shift->general_url_escape(@_)}sub pagepath_url_escape {shift->general_url_escape(@_)}sub manpage_url_escape {shift->general_url_escape(@_)}sub general_url_escape {my($self,$string)=@_;$string =~ s/([^\x00-\xFF])/join '', map sprintf('%%%02X',$_), unpack 'C*', $1/eg;if ($] ge 5.007_003){$string =~ s/([^-_\.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf('%%%02X',utf8::native_to_unicode(ord($1)))/eg}else {$string =~ s/([^-_\.!~*()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/sprintf('%%%02X',ord($1))/eg}return$string}sub resolve_pod_page_link {my$self=shift;return$self->batch_mode()? $self->resolve_pod_page_link_batch_mode(@_): $self->resolve_pod_page_link_singleton_mode(@_)}sub resolve_pod_page_link_singleton_mode {my($self,$it)=@_;return undef unless defined$it and length$it;my$url=$self->pagepath_url_escape($it);$url =~ s{::$}{}s;$url =~ s{::}{/}g unless$self->perldoc_url_prefix =~ m/\?/s;return undef unless length$url;return$self->perldoc_url_prefix .$url .$self->perldoc_url_postfix}sub resolve_pod_page_link_batch_mode {my($self,$to)=@_;DEBUG > 1 and print STDERR " During batch mode, resolving $to ...\n";my@path=grep length($_),split m/::/s,$to,-1;unless(@path){DEBUG and print STDERR "Very odd!  Splitting $to gives (nil)!\n";return undef}$self->batch_mode_rectify_path(\@path);my$out=join('/',map$self->pagepath_url_escape($_),@path).$HTML_EXTENSION;DEBUG > 1 and print STDERR " => $out\n";return$out}sub batch_mode_rectify_path {my($self,$pathbits)=@_;my$level=$self->batch_mode_current_level;$level--;if($level < 1){unshift @$pathbits,'.'}else {unshift @$pathbits,('..')x $level}return}sub resolve_man_page_link {my ($self,$to,$frag)=@_;my ($page,$section)=$to =~ /^([^(]+)(?:[(](\d+)[)])?$/;return undef unless defined$page and length$page;$section ||= 1;return$self->man_url_prefix ."$section/" .$self->manpage_url_escape($page).$self->man_url_postfix}sub resolve_pod_link_by_table {return unless $_[0]->{'podhtml_LOT'};my($self,$to,$section)=@_;if(defined$section){$to='' unless defined$to and length$to;return$self->{'podhtml_LOT'}{"$to#$section"}}else {return$self->{'podhtml_LOT'}{$to}}return}sub linearize_tokens {my$self=shift;my$out='';my$t;while($t=shift @_){if(!ref$t or!UNIVERSAL::can($t,'is_text')){$out .= $t}elsif($t->is_text){$out .= $t->text}elsif($t->is_start and $t->tag eq 'X'){my$x_open=1;while($x_open){next if(($t=shift @_)->is_text);if($t->is_start and $t->tag eq 'X'){++$x_open}elsif($t->is_end and $t->tag eq 'X'){--$x_open}}}}return undef if length$out > $Linearization_Limit;return$out}sub unicode_escape_url {my($self,$string)=@_;$string =~ s/([^\x00-\xFF])/'('.ord($1).')'/eg;return$string}sub esc {if(defined wantarray){if(wantarray){@_=splice @_}else {my$x=shift;if ($] ge 5.007_003){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg}else {$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}return$x}}for my$x (@_){if (defined$x){if ($] ge 5.007_003){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg}else {$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}}}return @_}1;
POD_SIMPLE_HTML

$fatpacked{"Pod/Simple/HTMLBatch.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLBATCH';
  require 5;package Pod::Simple::HTMLBatch;use strict;use vars qw($VERSION $HTML_RENDER_CLASS $HTML_EXTENSION $CSS $JAVASCRIPT $SLEEPY $SEARCH_CLASS @ISA);$VERSION='3.40';@ISA=();use Pod::Simple::HTML ();BEGIN {*esc=\&Pod::Simple::HTML::esc}use File::Spec ();use Pod::Simple::Search;$SEARCH_CLASS ||= 'Pod::Simple::Search';BEGIN {if(defined&DEBUG){}elsif(defined&Pod::Simple::DEBUG){*DEBUG=\&Pod::Simple::DEBUG}else {*DEBUG=sub () {0}}}$SLEEPY=1 if!defined$SLEEPY and $^O =~ /mswin|mac/i;$HTML_RENDER_CLASS ||= "Pod::Simple::HTML";Pod::Simple::_accessorize(__PACKAGE__,'verbose','html_render_class','search_class','contents_file','index','progress','contents_page_start','contents_page_end','css_flurry','_css_wad','javascript_flurry','_javascript_wad','no_contents_links','_contents',);sub go {@ARGV==2 or die sprintf("Usage: perl -M%s -e %s:go indirs outdir\n  (or use \"\@INC\" for indirs)\n",__PACKAGE__,__PACKAGE__,);if(defined($ARGV[1])and length($ARGV[1])){my$d=$ARGV[1];-e $d or die "I see no output directory named \"$d\"\nAborting";-d $d or die "But \"$d\" isn't a directory!\nAborting";-w $d or die "Directory \"$d\" isn't writeable!\nAborting"}__PACKAGE__->batch_convert(@ARGV)}sub new {my$new=bless {},ref($_[0])|| $_[0];$new->html_render_class($HTML_RENDER_CLASS);$new->search_class($SEARCH_CLASS);$new->verbose(1 + DEBUG);$new->_contents([]);$new->index(1);$new-> _css_wad([]);$new->css_flurry(1);$new->_javascript_wad([]);$new->javascript_flurry(1);$new->contents_file('index' .($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION));$new->contents_page_start(join "\n",grep $_,$Pod::Simple::HTML::Doctype_decl,"<html><head>","<title>Perl Documentation</title>",$Pod::Simple::HTML::Content_decl,"</head>","\n<body class='contentspage'>\n<h1>Perl Documentation</h1>\n");$new->contents_page_end(sprintf("\n\n<p class='contentsfooty'>Generated by %s v%s under Perl v%s\n<br >At %s GMT, which is %s local time.</p>\n\n</body></html>\n",esc(ref($new),eval {$new->VERSION}|| $VERSION,$],scalar(gmtime),scalar(localtime),)));return$new}sub muse {my$self=shift;if($self->verbose){print 'T+',int(time()- $self->{'_batch_start_time'}),"s: ",@_,"\n"}return 1}sub batch_convert {my($self,$dirs,$outdir)=@_;$self ||= __PACKAGE__;$self=$self->new unless ref$self;if(!defined($dirs)or $dirs eq '' or $dirs eq '@INC'){$dirs=''}elsif(ref$dirs){}else {require Config;my$ps=quotemeta($Config::Config{'path_sep'}|| ":");$dirs=[grep length($_),split qr/$ps/,$dirs ]}$outdir=$self->filespecsys->curdir unless defined$outdir and length$outdir;$self->_batch_convert_main($dirs,$outdir)}sub _batch_convert_main {my($self,$dirs,$outdir)=@_;$self->{'_batch_start_time'}||= time();$self->muse("= ",scalar(localtime));$self->muse("Starting batch conversion to \"$outdir\"");my$progress=$self->progress;if(!$progress and $self->verbose > 0 and $self->verbose()<= 5){require Pod::Simple::Progress;$progress=Pod::Simple::Progress->new(($self->verbose < 2)? (): ($self->verbose==2)? 1 : 0);$self->progress($progress)}if($dirs){$self->muse(scalar(@$dirs)," dirs to scan: @$dirs")}else {$self->muse("Scanning \@INC.  This could take a minute or two.")}my$mod2path=$self->find_all_pods($dirs ? $dirs : ());$self->muse("Done scanning.");my$total=keys %$mod2path;unless($total){$self->muse("No pod found.  Aborting batch conversion.\n");return$self}$progress and $progress->goal($total);$self->muse("Now converting pod files to HTML.",($total > 25)? "  This will take a while more." : ());$self->_spray_css($outdir);$self->_spray_javascript($outdir);$self->_do_all_batch_conversions($mod2path,$outdir);$progress and $progress->done(sprintf ("Done converting %d files.",$self->{"__batch_conv_page_count"}));return$self->_batch_convert_finish($outdir);return$self}sub _do_all_batch_conversions {my($self,$mod2path,$outdir)=@_;$self->{"__batch_conv_page_count"}=0;for my$module (sort {lc($a)cmp lc($b)}keys %$mod2path){$self->_do_one_batch_conversion($module,$mod2path,$outdir);sleep($SLEEPY - 1)if$SLEEPY}return}sub _batch_convert_finish {my($self,$outdir)=@_;$self->write_contents_file($outdir);$self->muse("Done with batch conversion.  $$self{'__batch_conv_page_count'} files done.");$self->muse("= ",scalar(localtime));$self->progress and $self->progress->done("All done!");return}sub _do_one_batch_conversion {my($self,$module,$mod2path,$outdir,$outfile)=@_;my$retval;my$total=scalar keys %$mod2path;my$infile=$mod2path->{$module};my@namelets=grep m/\S/,split "::",$module;my$depth=scalar@namelets;die "Contentless thingie?! $module $infile" unless@namelets;$outfile ||= do {my@n=@namelets;$n[-1].= $HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION;$self->filespecsys->catfile($outdir,@n)};my$progress=$self->progress;my$page=$self->html_render_class->new;if(DEBUG > 5){$self->muse($self->{"__batch_conv_page_count"}+ 1,"/$total: ",ref($page)," render ($depth) $module => $outfile")}elsif(DEBUG > 2){$self->muse($self->{"__batch_conv_page_count"}+ 1,"/$total: $module => $outfile")}$page->batch_mode_page_object_init($self,$module,$infile,$outfile,$depth)if$page->can('batch_mode_page_object_init');$self->batch_mode_page_object_init($page,$module,$infile,$outfile,$depth)if$self->can('batch_mode_page_object_init');$self->makepath($outdir=>\@namelets);$progress and $progress->reach($self->{"__batch_conv_page_count"},"Rendering $module");if($retval=$page->parse_from_file($infile,$outfile)){++ $self->{"__batch_conv_page_count"};$self->note_for_contents_file(\@namelets,$infile,$outfile)}else {$self->muse("Odd, parse_from_file(\"$infile\", \"$outfile\") returned false.")}$page->batch_mode_page_object_kill($self,$module,$infile,$outfile,$depth)if$page->can('batch_mode_page_object_kill');$self->batch_mode_page_object_kill($page,$module,$infile,$outfile,$depth)if$self->can('batch_mode_page_object_kill');DEBUG > 4 and printf STDERR "%s %sb < $infile %s %sb\n",$outfile,-s $outfile,$infile,-s $infile ;undef($page);return$retval}sub filespecsys {$_[0]{'_filespecsys'}|| 'File::Spec'}sub note_for_contents_file {my($self,$namelets,$infile,$outfile)=@_;if($self->contents_file){my$c=$self->_contents();push @$c,[join("::",@$namelets),$infile,$outfile,$namelets ];DEBUG > 3 and print STDERR "Noting @$c[-1]\n"}return}sub write_contents_file {my($self,$outdir)=@_;my$outfile=$self->_contents_filespec($outdir)|| return;$self->muse("Preparing list of modules for ToC");my($toplevel,$toplevel_form_freq,)=$self->_prep_contents_breakdown;my$Contents=eval {$self->_wopen($outfile)};if($Contents){$self->muse("Writing contents file $outfile")}else {warn "Couldn't write-open contents file $outfile: $!\nAbort writing to $outfile at all";return}$self->_write_contents_start($Contents,$outfile,);$self->_write_contents_middle($Contents,$outfile,$toplevel,$toplevel_form_freq);$self->_write_contents_end($Contents,$outfile,);return$outfile}sub _write_contents_start {my($self,$Contents,$outfile)=@_;my$starter=$self->contents_page_start || '';{my$css_wad=$self->_css_wad_to_markup(1);if($css_wad){$starter =~ s{(</head>)}{\n$css_wad\n$1}i}my$javascript_wad=$self->_javascript_wad_to_markup(1);if($javascript_wad){$starter =~ s{(</head>)}{\n$javascript_wad\n$1}i}}unless(print$Contents $starter,"<dl class='superindex'>\n"){warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";close($Contents);return 0}return 1}sub _write_contents_middle {my($self,$Contents,$outfile,$toplevel2submodules,$toplevel_form_freq)=@_;for my$t (sort keys %$toplevel2submodules){my@downlines=sort {$a->[-1]cmp $b->[-1]}@{$toplevel2submodules->{$t}};printf$Contents qq[<dt><a name="%s">%s</a></dt>\n<dd>\n],esc($t,$toplevel_form_freq->{$t});my($path,$name);for my$e (@downlines){$name=$e->[0];$path=join("/",'.',esc(@{$e->[3]})).($HTML_EXTENSION || $Pod::Simple::HTML::HTML_EXTENSION);print$Contents qq{  <a href="$path">},esc($name),"</a>&nbsp;&nbsp;\n"}print$Contents "</dd>\n\n"}return 1}sub _write_contents_end {my($self,$Contents,$outfile)=@_;unless(print$Contents "</dl>\n",$self->contents_page_end || '',){warn "Couldn't write to $outfile: $!"}close($Contents)or warn "Couldn't close $outfile: $!";return 1}sub _prep_contents_breakdown {my($self)=@_;my$contents=$self->_contents;my%toplevel;my%toplevel_form_freq;for my$entry (@$contents){my$toplevel=$entry->[0]=~ m/^perl\w*$/ ? 'perl_core_docs' : $entry->[3][0];++$toplevel_form_freq{lc$toplevel }{$toplevel };push @{$toplevel{lc$toplevel }},$entry;push @$entry,lc($entry->[0])}for my$toplevel (sort keys%toplevel){my$fgroup=$toplevel_form_freq{$toplevel};$toplevel_form_freq{$toplevel}=(sort {$fgroup->{$b}<=> $fgroup->{$a}or $a cmp $b}keys %$fgroup)[0]}return(\%toplevel,\%toplevel_form_freq)if wantarray;return \%toplevel}sub _contents_filespec {my($self,$outdir)=@_;my$outfile=$self->contents_file;return unless$outfile;return$self->filespecsys->catfile($outdir,$outfile)}sub makepath {my($self,$outdir,$namelets)=@_;return unless @$namelets > 1;for my$i (0 .. ($#$namelets - 1)){my$dir=$self->filespecsys->catdir($outdir,@$namelets[0 .. $i]);if(-e $dir){die "$dir exists but not as a directory!?" unless -d $dir;next}DEBUG > 3 and print STDERR "  Making $dir\n";mkdir$dir,0777 or die "Can't mkdir $dir: $!\nAborting" }return}sub batch_mode_page_object_init {my$self=shift;my($page,$module,$infile,$outfile,$depth)=@_;$page->default_title($module);$page->index($self->index);$page->html_css($self-> _css_wad_to_markup($depth));$page->html_javascript($self->_javascript_wad_to_markup($depth));$self->add_header_backlink($page,$module,$infile,$outfile,$depth);$self->add_footer_backlink($page,$module,$infile,$outfile,$depth);return$self}sub add_header_backlink {my$self=shift;return if$self->no_contents_links;my($page,$module,$infile,$outfile,$depth)=@_;$page->html_header_after_title(join '',$page->html_header_after_title || '',qq[<p class="backlinktop"><b><a name="___top" href="],$self->url_up_to_contents($depth),qq[" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>\n],)if$self->contents_file ;return}sub add_footer_backlink {my$self=shift;return if$self->no_contents_links;my($page,$module,$infile,$outfile,$depth)=@_;$page->html_footer(join '',qq[<p class="backlinkbottom"><b><a name="___bottom" href="],$self->url_up_to_contents($depth),qq[" title="All Documents">&lt;&lt;</a></b></p>\n],$page->html_footer || '',)if$self->contents_file ;return}sub url_up_to_contents {my($self,$depth)=@_;--$depth;return join '/',('..')x $depth,esc($self->contents_file)}sub find_all_pods {my($self,$dirs)=@_;return$self->modnames2paths($dirs)}sub modnames2paths {my($self,$dirs)=@_;my$m2p;{my$search=$self->search_class->new;DEBUG and print STDERR "Searching via $search\n";$search->verbose(1)if DEBUG > 10;$search->progress($self->progress->copy->goal(0))if$self->progress;$search->shadows(0);$search->inc($dirs ? 0 : 1);$search->survey($dirs ? @$dirs : ());$m2p=$search->name2path;die "What, no name2path?!" unless$m2p}$self->muse("That's odd... no modules found!")unless keys %$m2p;if(DEBUG > 4){print STDERR "Modules found (name => path):\n";for my$m (sort {lc($a)cmp lc($b)}keys %$m2p){print STDERR "  $m  $$m2p{$m}\n"}print STDERR "(total ",scalar(keys %$m2p),")\n\n"}elsif(DEBUG){print STDERR "Found ",scalar(keys %$m2p)," modules.\n"}$self->muse("Found ",scalar(keys %$m2p)," modules.");return$m2p}sub _wopen {my($self,$outpath)=@_;require Symbol;my$out_fh=Symbol::gensym();DEBUG > 5 and print STDERR "Write-opening to $outpath\n";return$out_fh if open($out_fh,"> $outpath");require Carp;Carp::croak("Can't write-open $outpath: $!")}sub add_css {my($self,$url,$is_default,$name,$content_type,$media,$_code)=@_;return unless$url;unless($name){$name=$url;if($name !~ m/\?/ and $name =~ m{([^/]+)$}s){$name=$1;$name =~ s/\.css//i}}$media ||= 'all';$content_type ||= 'text/css';my$bunch=[$url,$name,$content_type,$media,$_code];if($is_default){unshift @{$self->_css_wad},$bunch}else {push @{$self->_css_wad},$bunch}return}sub _spray_css {my($self,$outdir)=@_;return unless$self->css_flurry();$self->_gen_css_wad();my$lol=$self->_css_wad;for my$chunk (@$lol){my$url=$chunk->[0];my$outfile;if(ref($chunk->[-1])and $url =~ m{^(_[-a-z0-9_]+\.css$)}){$outfile=$self->filespecsys->catfile($outdir,"$1");DEBUG > 5 and print STDERR "Noting $$chunk[0] as a file I'll create.\n"}else {DEBUG > 5 and print STDERR "OK, noting $$chunk[0] as an external CSS.\n";next}my$Cssout=$self->_wopen($outfile);print$Cssout ${$chunk->[-1]}or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";close($Cssout);DEBUG > 5 and print STDERR "Wrote $outfile\n"}return}sub _css_wad_to_markup {my($self,$depth)=@_;my@css=@{$self->_css_wad || return ''};return '' unless@css;my$rel='stylesheet';my$out='';--$depth;my$uplink=$depth ? ('../' x $depth): '';for my$chunk (@css){next unless$chunk and @$chunk;my($url1,$url2,$title,$type,$media)=($self->_maybe_uplink($chunk->[0],$uplink),esc(grep!ref($_),@$chunk));$out .= qq{<link rel="$rel" title="$title" type="$type" href="$url1$url2" media="$media" >\n};$rel='alternate stylesheet'}return$out}sub _maybe_uplink {my($self,$url,$uplink)=@_;($url =~ m{^\./} or $url !~ m{[/\:]})? $uplink : ''}sub _gen_css_wad {my$self=$_[0];my$css_template=$self->_css_template;for my$variation ('110n=blkbluw','010n=blkmagw','100n=blkcynw','101=whtprpk','001=whtnavk','010a=grygrnk','010b=whtgrng','101an=blkgrng','101bn=grygrnw',){my$outname=$variation;my($flipmode,@swap)=(($4 || ''),$1,$2,$3)if$outname =~ s/^([012])([012])([[012])([a-z]*)=?//s;@swap=()if '010' eq join '',@swap;my$this_css="/* This file is autogenerated.  Do not edit.  $variation */\n\n" .$css_template;if($flipmode =~ m/n/){$this_css =~ s/(#[0-9a-fA-F]{3})\b/_color_negate($1)/eg;$this_css =~ s/\bthin\b/medium/g}$this_css =~ s<#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])\b>
                    < join '', '#', ($1,$2,$3)[@swap] >eg if@swap;if($flipmode =~ m/a/){$this_css =~ s/#fff\b/#999/gi}elsif($flipmode =~ m/b/){$this_css =~ s/#000\b/#666/gi}my$name=$outname;$name =~ tr/-_/  /;$self->add_css("_$outname.css",0,$name,0,0,\$this_css)}for (my ($outfile,$variation)=each %{{blkbluw=>'black_with_blue_on_white',whtpurk=>'white_with_purple_on_black',whtgrng=>'white_with_green_on_grey',grygrnw=>'grey_with_green_on_white',}}){my$this_css=join "\n","/* This file is autogenerated.  Do not edit.  $outfile */\n","\@import url(\"./_$variation.css\");",".indexgroup { display: none; }","\n",;my$name=$outfile;$name =~ tr/-_/  /;$self->add_css("_$outfile.css",0,$name,0,0,\$this_css)}return}sub _color_negate {my$x=lc $_[0];$x =~ tr[0123456789abcdef]
            [fedcba9876543210];return$x}sub add_javascript {my($self,$url,$content_type,$_code)=@_;return unless$url;push @{$self->_javascript_wad},[$url,$content_type || 'text/javascript',$_code ];return}sub _spray_javascript {my($self,$outdir)=@_;return unless$self->javascript_flurry();$self->_gen_javascript_wad();my$lol=$self->_javascript_wad;for my$script (@$lol){my$url=$script->[0];my$outfile;if(ref($script->[-1])and $url =~ m{^(_[-a-z0-9_]+\.js$)}){$outfile=$self->filespecsys->catfile($outdir,"$1");DEBUG > 5 and print STDERR "Noting $$script[0] as a file I'll create.\n"}else {DEBUG > 5 and print STDERR "OK, noting $$script[0] as an external JavaScript.\n";next}my$Jsout=$self->_wopen($outfile);print$Jsout ${$script->[-1]}or warn "Couldn't print to $outfile: $!\nAbort writing to $outfile at all";close($Jsout);DEBUG > 5 and print STDERR "Wrote $outfile\n"}return}sub _gen_javascript_wad {my$self=$_[0];my$js_code=$self->_javascript || return;$self->add_javascript("_podly.js",0,\$js_code);return}sub _javascript_wad_to_markup {my($self,$depth)=@_;my@scripts=@{$self->_javascript_wad || return ''};return '' unless@scripts;my$out='';--$depth;my$uplink=$depth ? ('../' x $depth): '';for my$s (@scripts){next unless$s and @$s;my($url1,$url2,$type,$media)=($self->_maybe_uplink($s->[0],$uplink),esc(grep!ref($_),@$s));$out .= qq{<script type="$type" src="$url1$url2"></script>\n}}return$out}sub _css_template {return$CSS}sub _javascript {return$JAVASCRIPT}$CSS=<<'EOCSS';$JAVASCRIPT=<<'EOJAVASCRIPT';1;
  /* For accessibility reasons, never specify text sizes in px/pt/pc/in/cm/mm */
  
  @media all { .hide { display: none; } }
  
  @media print {
    .noprint, div.indexgroup, .backlinktop, .backlinkbottom { display: none }
  
    * {
      border-color: black !important;
      color: black !important;
      background-color: transparent !important;
      background-image: none !important;
    }
  
    dl.superindex > dd  {
      word-spacing: .6em;
    }
  }
  
  @media aural, braille, embossed {
    div.indexgroup  { display: none; }  /* Too noisy, don't you think? */
    dl.superindex > dt:before { content: "Group ";  }
    dl.superindex > dt:after  { content: " contains:"; }
    .backlinktop    a:before  { content: "Back to contents"; }
    .backlinkbottom a:before  { content: "Back to contents"; }
  }
  
  @media aural {
    dl.superindex > dt  { pause-before: 600ms; }
  }
  
  @media screen, tty, tv, projection {
    .noscreen { display: none; }
  
    a:link    { color: #7070ff; text-decoration: underline; }
    a:visited { color: #e030ff; text-decoration: underline; }
    a:active  { color: #800000; text-decoration: underline; }
    body.contentspage a            { text-decoration: none; }
    a.u { color: #fff !important; text-decoration: none; }
  
    body.pod {
      margin: 0 5px;
      color:            #fff;
      background-color: #000;
    }
  
    body.pod h1, body.pod h2, body.pod h3, body.pod h4  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      margin-top: 1.2em;
      margin-bottom: .1em;
      border-top: thin solid transparent;
      /* margin-left: -5px;  border-left: 2px #7070ff solid;  padding-left: 3px; */
    }
    
    body.pod h1  { border-top-color: #0a0; }
    body.pod h2  { border-top-color: #080; }
    body.pod h3  { border-top-color: #040; }
    body.pod h4  { border-top-color: #010; }
  
    p.backlinktop + h1 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h2 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h3 { border-top: none; margin-top: 0em;  }
    p.backlinktop + h4 { border-top: none; margin-top: 0em;  }
  
    body.pod dt {
      font-size: 105%; /* just a wee bit more than normal */
    }
  
    .indexgroup { font-size: 80%; }
  
    .backlinktop,   .backlinkbottom    {
      margin-left:  -5px;
      margin-right: -5px;
      background-color:         #040;
      border-top:    thin solid #050;
      border-bottom: thin solid #050;
    }
    
    .backlinktop a, .backlinkbottom a  {
      text-decoration: none;
      color: #080;
      background-color:  #000;
      border: thin solid #0d0;
    }
    .backlinkbottom { margin-bottom: 0; padding-bottom: 0; }
    .backlinktop    { margin-top:    0; padding-top:    0; }
  
    body.contentspage {
      color:            #fff;
      background-color: #000;
    }
    
    body.contentspage h1  {
      color:            #0d0;
      margin-left: 1em;
      margin-right: 1em;
      text-indent: -.9em;
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      border-top:    thin solid #fff;
      border-bottom: thin solid #fff;
      text-align: center;
    }
  
    dl.superindex > dt  {
      font-family: Tahoma, Verdana, Helvetica, Arial, sans-serif;
      font-weight: normal;
      font-size: 90%;
      margin-top: .45em;
      /* margin-bottom: -.15em; */
    }
    dl.superindex > dd  {
      word-spacing: .6em;    /* most important rule here! */
    }
    dl.superindex > a:link  {
      text-decoration: none;
      color: #fff;
    }
  
    .contentsfooty {
      border-top: thin solid #999;
      font-size: 90%;
    }
    
  }
  
  /* The End */
  
  EOCSS
  
  // From http://www.alistapart.com/articles/alternate/
  
  function setActiveStyleSheet(title) {
    var i, a, main;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(a.getAttribute("rel").indexOf("style") != -1 && a.getAttribute("title")) {
        a.disabled = true;
        if(a.getAttribute("title") == title) a.disabled = false;
      }
    }
  }
  
  function getActiveStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("title")
         && !a.disabled
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function getPreferredStyleSheet() {
    var i, a;
    for(i=0  ;  (a = document.getElementsByTagName("link")[i])  ;  i++) {
      if(   a.getAttribute("rel").indexOf("style") != -1
         && a.getAttribute("rel").indexOf("alt") == -1
         && a.getAttribute("title")
         ) return a.getAttribute("title");
    }
    return null;
  }
  
  function createCookie(name,value,days) {
    if (days) {
      var date = new Date();
      date.setTime(date.getTime()+(days*24*60*60*1000));
      var expires = "; expires="+date.toGMTString();
    }
    else expires = "";
    document.cookie = name+"="+value+expires+"; path=/";
  }
  
  function readCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for(var i=0  ;  i < ca.length  ;  i++) {
      var c = ca[i];
      while (c.charAt(0)==' ') c = c.substring(1,c.length);
      if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
    }
    return null;
  }
  
  window.onload = function(e) {
    var cookie = readCookie("style");
    var title = cookie ? cookie : getPreferredStyleSheet();
    setActiveStyleSheet(title);
  }
  
  window.onunload = function(e) {
    var title = getActiveStyleSheet();
    createCookie("style", title, 365);
  }
  
  var cookie = readCookie("style");
  var title = cookie ? cookie : getPreferredStyleSheet();
  setActiveStyleSheet(title);
  
  // The End
  
  EOJAVASCRIPT
POD_SIMPLE_HTMLBATCH

$fatpacked{"Pod/Simple/HTMLLegacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_HTMLLEGACY';
  require 5;package Pod::Simple::HTMLLegacy;use strict;use vars qw($VERSION);use Getopt::Long;$VERSION="5.01";sub pod2html {my@args=(@_);my($verbose,$infile,$outfile,$title);my$index=1;{my($help);my($netscape);local@ARGV=@args;GetOptions("help"=>\$help,"verbose!"=>\$verbose,"infile=s"=>\$infile,"outfile=s"=>\$outfile,"title=s"=>\$title,"index!"=>\$index,"netscape!"=>\$netscape,)or return bad_opts(@args);bad_opts(@args)if@ARGV;return help_message()if$help}for($infile,$outfile){$_=undef unless defined and length}if($verbose){warn sprintf "%s version %s\n",__PACKAGE__,$VERSION;warn "OK, processed args [@args] ...\n";warn sprintf " Verbose: %s\n Index: %s\n Infile: %s\n Outfile: %s\n Title: %s\n",map defined($_)? $_ : "(nil)",$verbose,$index,$infile,$outfile,$title,;*Pod::Simple::HTML::DEBUG=sub(){1}}require Pod::Simple::HTML;Pod::Simple::HTML->VERSION(3);die "No such input file as $infile\n" if defined$infile and!-e $infile;my$pod=Pod::Simple::HTML->new;$pod->force_title($title)if defined$title;$pod->index($index);return$pod->parse_from_file($infile,$outfile)}sub bad_opts {die _help_message()}sub help_message {print STDOUT _help_message()}sub _help_message {join '',"[",__PACKAGE__," version ",$VERSION,qq~]
  Usage:  pod2html --help --infile=<name> --outfile=<name>
     --verbose --index --noindex
  
  Options:
    --help         - prints this message.
    --[no]index    - generate an index at the top of the resulting html
                     (default behavior).
    --infile       - filename for the pod to convert (input taken from stdin
                     by default).
    --outfile      - filename for the resulting html file (output sent to
                     stdout by default).
    --title        - title that will appear in resulting html file.
    --[no]verbose  - self-explanatory (off by default).
  
  Note that pod2html is DEPRECATED, and this version implements only
   some of the options known to older versions.
  For more information, see 'perldoc pod2html'.
  ~}1;
POD_SIMPLE_HTMLLEGACY

$fatpacked{"Pod/Simple/JustPod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_JUSTPOD';
  use 5;package Pod::Simple::JustPod;use strict;use warnings;use Pod::Simple::Methody ();our@ISA=('Pod::Simple::Methody');sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->accept_targets('*');$new->keep_encoding_directive(1);$new->preserve_whitespace(1);$new->complain_stderr(1);$new->_output_is_for_JustPod(1);return$new}sub check_that_all_is_closed {my$self=shift;while ($self->{inL}){$self->end_L(@_)}while ($self->{fcode_end}&& @{$self->{fcode_end}}){$self->_end_fcode(@_)}}sub handle_text {$_[0]{buffer}.= $_[1]unless $_[0]{inL}}sub spacer {my ($self,$arg)=@_;return unless$arg;my$spacer=($arg->{'~orig_spacer'})? $arg->{'~orig_spacer'}: " ";$self->handle_text($spacer)}sub _generic_start {my ($self,$text,$arg)=@_;$self->check_that_all_is_closed();$self->handle_text($text);$self->spacer($arg)}sub start_Document {shift->_generic_start("=pod\n\n")}sub start_head1 {shift->_generic_start('=head1',@_)}sub start_head2 {shift->_generic_start('=head2',@_)}sub start_head3 {shift->_generic_start('=head3',@_)}sub start_head4 {shift->_generic_start('=head4',@_)}sub start_encoding {shift->_generic_start('=encoding',@_)}sub start_item_bullet {my ($self,$arg)=@_;$self->check_that_all_is_closed();$self->handle_text('=item');if (!$arg->{'~orig_content'}){$self->handle_text("\n\n")}else {$self->spacer($arg);if ($arg->{'~_freaky_para_hack'}){my$item_text=$arg->{'~orig_content'};my$trailing=quotemeta$arg->{'~_freaky_para_hack'};$item_text =~ s/$trailing$//;$self->handle_text($item_text)}else {$self->handle_text("*\n\n")}}}sub start_item_number {my ($self,$arg)=@_;$self->check_that_all_is_closed();$self->handle_text("=item");$self->spacer($arg);$self->handle_text("$arg->{'~orig_content'}\n\n")}sub start_item_text {my ($self,$arg)=@_;$self->check_that_all_is_closed();$self->handle_text('=item');$self->spacer($arg)}sub _end_item {my$self=shift;$self->check_that_all_is_closed();$self->emit}*end_item_bullet=*_end_item;*end_item_number=*_end_item;*end_item_text=*_end_item;sub _start_over {my ($self,$arg)=@_;$self->check_that_all_is_closed();$self->handle_text("=over");if ($arg->{'~orig_content'}){$self->spacer($arg);$self->handle_text("$arg->{'~orig_content'}")}$self->handle_text("\n\n")}*start_over_bullet=*_start_over;*start_over_number=*_start_over;*start_over_text=*_start_over;*start_over_block=*_start_over;sub _end_over {my$self=shift;$self->check_that_all_is_closed();$self->handle_text('=back');$self->emit}*end_over_bullet=*_end_over;*end_over_number=*_end_over;*end_over_text=*_end_over;*end_over_block=*_end_over;sub end_Document {my$self=shift;$self->emit;print {$self->{'output_fh'}}"=cut\n"}sub _end_generic {my$self=shift;$self->check_that_all_is_closed();$self->emit}*end_head1=*_end_generic;*end_head2=*_end_generic;*end_head3=*_end_generic;*end_head4=*_end_generic;*end_encoding=*_end_generic;*end_Para=*_end_generic;*end_Verbatim=*_end_generic;sub _start_fcode {my ($type,$self,$flags)=@_;my$bracket_count=(exists$flags->{'~bracket_count'})? $flags->{'~bracket_count'}: 1;$self->handle_text($type .("<" x $bracket_count));my$rspacer="";if ($bracket_count > 1){my$lspacer=(exists$flags->{'~lspacer'})? $flags->{'~lspacer'}: " ";$self->handle_text($lspacer);$rspacer=(exists$flags->{'~rspacer'})? $flags->{'~rspacer'}: " "}push @{$self->{'fcode_end'}},[$bracket_count,$rspacer ]}sub start_B {_start_fcode('B',@_)}sub start_C {_start_fcode('C',@_)}sub start_E {_start_fcode('E',@_)}sub start_F {_start_fcode('F',@_)}sub start_I {_start_fcode('I',@_)}sub start_S {_start_fcode('S',@_)}sub start_X {_start_fcode('X',@_)}sub start_Z {_start_fcode('Z',@_)}sub _end_fcode {my$self=shift;my$fcode_end=pop @{$self->{'fcode_end'}};my$bracket_count=1;my$rspacer="";if (!defined$fcode_end){$self->whine($self->{line_count},"Extra '>'")}else {$bracket_count=$fcode_end->[0];$rspacer=$fcode_end->[1]}$self->handle_text($rspacer)if$bracket_count > 1;$self->handle_text(">" x $bracket_count)}*end_B=*_end_fcode;*end_C=*_end_fcode;*end_E=*_end_fcode;*end_F=*_end_fcode;*end_I=*_end_fcode;*end_S=*_end_fcode;*end_X=*_end_fcode;*end_Z=*_end_fcode;sub start_L {_start_fcode('L',@_);$_[0]->handle_text($_[1]->{raw});$_[0]->{inL}++}sub end_L {my$self=shift;$self->{inL}--;if ($self->{inL}< 0){$self->whine($self->{line_count},"Extra '>' ending L<>");$self->{inL}=0}$self->_end_fcode(@_)}sub emit {my$self=shift;if ($self->{buffer}ne ""){print {$self->{'output_fh'}}"",$self->{buffer},"\n\n";$self->{buffer}=""}return}1;
POD_SIMPLE_JUSTPOD

$fatpacked{"Pod/Simple/LinkSection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_LINKSECTION';
  require 5;package Pod::Simple::LinkSection;use strict;use Pod::Simple::BlackBox;use vars qw($VERSION);$VERSION='3.40';use overload('""'=>\&Pod::Simple::BlackBox::stringify_lol,'bool'=>\&Pod::Simple::BlackBox::stringify_lol,'fallback'=>1,);sub tack_on {$_[0]=['',{},"$_[0]" ];return $_[0][2].= $_[1]}sub as_string {goto&Pod::Simple::BlackBox::stringify_lol}sub stringify {goto&Pod::Simple::BlackBox::stringify_lol}sub new {my$class=shift;$class=ref($class)|| $class;my$new;if(@_==1){if (!ref($_[0]|| '')){return bless ['',{},$_[0]],$class}elsif(ref($_[0]|| '')eq 'ARRAY'){$new=[@{$_[0]}]}else {Carp::croak("$class new() doesn't know to clone $new")}}else {$new=['',{},@_ ]}for my$x (@$new){if(ref($x || '')eq 'ARRAY'){$x=$class->new($x)}elsif(ref($x || '')eq 'HASH'){$x={%$x }}}return bless$new,$class}1;
POD_SIMPLE_LINKSECTION

$fatpacked{"Pod/Simple/Methody.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_METHODY';
  require 5;package Pod::Simple::Methody;use strict;use Pod::Simple ();use vars qw(@ISA $VERSION);$VERSION='3.40';@ISA=('Pod::Simple');sub _handle_element_start {$_[1]=~ tr/-:./__/;($_[0]->can('start_' .$_[1])|| return)->($_[0],$_[2])}sub _handle_text {($_[0]->can('handle_text')|| return)->(@_)}sub _handle_element_end {$_[1]=~ tr/-:./__/;($_[0]->can('end_' .$_[1])|| return)->($_[0],$_[2])}1;
POD_SIMPLE_METHODY

$fatpacked{"Pod/Simple/Progress.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PROGRESS';
  require 5;package Pod::Simple::Progress;$VERSION='3.40';use strict;sub new {my($class,$delay)=@_;my$self=bless {'quiet_until'=>1},ref($class)|| $class;$self->to(*STDOUT{IO});$self->delay(defined($delay)? $delay : 5);return$self}sub copy {my$orig=shift;bless {%$orig,'quiet_until'=>1},ref($orig)}sub reach {my($self,$point,$note)=@_;if((my$now=time)>= $self->{'quiet_until'}){my$goal;my$to=$self->{'to'};print$to join('',($self->{'quiet_until'}==1)? (): '... ',(defined$point)? ('#',($goal=$self->{'goal'})? (' ' x (length($goal)- length($point)),$point,'/',$goal,): $point,$note ? ': ' : (),): (),$note || '',"\n");$self->{'quiet_until'}=$now + $self->{'delay'}}return$self}sub done {my($self,$note)=@_;$self->{'quiet_until'}=1;return$self->reach(undef,$note)}sub delay {return $_[0]{'delay'}if @_==1;$_[0]{'delay'}=$_[1];return $_[0]}sub goal {return $_[0]{'goal' }if @_==1;$_[0]{'goal' }=$_[1];return $_[0]}sub to {return $_[0]{'to' }if @_==1;$_[0]{'to' }=$_[1];return $_[0]}unless(caller){my$p=__PACKAGE__->new->goal(5);$p->reach(1,"Primus!");sleep 1;$p->reach(2,"Secundus!");sleep 3;$p->reach(3,"Tertius!");sleep 5;$p->reach(4);$p->reach(5,"Quintus!");sleep 1;$p->done("All done")}1;
POD_SIMPLE_PROGRESS

$fatpacked{"Pod/Simple/PullParser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSER';
  require 5;package Pod::Simple::PullParser;$VERSION='3.40';use Pod::Simple ();BEGIN {@ISA=('Pod::Simple')}use strict;use Carp ();use Pod::Simple::PullParserStartToken;use Pod::Simple::PullParserEndToken;use Pod::Simple::PullParserTextToken;BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}__PACKAGE__->_accessorize('source_fh','source_scalar_ref','source_arrayref',);sub filter {my($self,$source)=@_;$self=$self->new unless ref$self;$source=*STDIN{IO}unless defined$source;$self->set_source($source);$self->output_fh(*STDOUT{IO});$self->run;return$self}sub parse_string_document {my$this=shift;$this->set_source(\ $_[0]);$this->run}sub parse_file {my($this,$filename)=@_;$this->set_source($filename);$this->run}sub run {use Carp ();if(__PACKAGE__ eq ref($_[0])|| $_[0]){Carp::croak "You can call run() only on subclasses of " .__PACKAGE__}else {Carp::croak join '',"You can't call run() because ",ref($_[0])|| $_[0]," didn't define a run() method"}}sub parse_lines {use Carp ();Carp::croak "Use set_source with ",__PACKAGE__," and subclasses, not parse_lines"}sub parse_line {use Carp ();Carp::croak "Use set_source with ",__PACKAGE__," and subclasses, not parse_line"}sub new {my$class=shift;my$self=$class->SUPER::new(@_);die "Couldn't construct for $class" unless$self;$self->{'token_buffer'}||= [];$self->{'start_token_class'}||= 'Pod::Simple::PullParserStartToken';$self->{'text_token_class'}||= 'Pod::Simple::PullParserTextToken';$self->{'end_token_class'}||= 'Pod::Simple::PullParserEndToken';DEBUG > 1 and print STDERR "New pullparser object: $self\n";return$self}sub get_token {my$self=shift;DEBUG > 1 and print STDERR "\nget_token starting up on $self.\n";DEBUG > 2 and print STDERR " Items in token-buffer (",scalar(@{$self->{'token_buffer'}}),") :\n",map("    " .$_->dump ."\n",@{$self->{'token_buffer'}}),@{$self->{'token_buffer'}}? '' : '       (no tokens)',"\n" ;until(@{$self->{'token_buffer'}}){DEBUG > 3 and print STDERR "I need to get something into my empty token buffer...\n";if($self->{'source_dead'}){DEBUG and print STDERR "$self 's source is dead.\n";push @{$self->{'token_buffer'}},undef}elsif(exists$self->{'source_fh'}){my@lines;my$fh=$self->{'source_fh'}|| Carp::croak('You have to call set_source before you can call get_token');DEBUG and print STDERR "$self 's source is filehandle $fh.\n";for(my$i=Pod::Simple::MANY_LINES;$i--;){DEBUG > 3 and print STDERR " Fetching a line from source filehandle $fh...\n";local $/=$Pod::Simple::NL;push@lines,scalar(<$fh>);DEBUG > 3 and print STDERR "  Line is: ",defined($lines[-1])? $lines[-1]: "<undef>\n";unless(defined$lines[-1]){DEBUG and print STDERR "That's it for that source fh!  Killing.\n";delete$self->{'source_fh'};last}}if(DEBUG > 8){print STDERR "* I've gotten ",scalar(@lines)," lines:\n";for my$l (@lines){if(defined$l){print STDERR "  line {$l}\n"}else {print STDERR "  line undef\n"}}print STDERR "* end of ",scalar(@lines)," lines\n"}$self->SUPER::parse_lines(@lines)}elsif(exists$self->{'source_arrayref'}){DEBUG and print STDERR "$self 's source is arrayref $self->{'source_arrayref'}, with ",scalar(@{$self->{'source_arrayref'}})," items left in it.\n";DEBUG > 3 and print STDERR "  Fetching ",Pod::Simple::MANY_LINES," lines.\n";$self->SUPER::parse_lines(splice @{$self->{'source_arrayref'}},0,Pod::Simple::MANY_LINES);unless(@{$self->{'source_arrayref'}}){DEBUG and print STDERR "That's it for that source arrayref!  Killing.\n";$self->SUPER::parse_lines(undef);delete$self->{'source_arrayref'}}}elsif(exists$self->{'source_scalar_ref'}){DEBUG and print STDERR "$self 's source is scalarref $self->{'source_scalar_ref'}, with ",length(${$self->{'source_scalar_ref'}})- (pos(${$self->{'source_scalar_ref'}})|| 0)," characters left to parse.\n";DEBUG > 3 and print STDERR " Fetching a line from source-string...\n";if(${$self->{'source_scalar_ref'}}=~ m/([^\n\r]*)((?:\r?\n)?)/g){$self->SUPER::parse_lines($1)if length($1)or length($2)or pos(${$self->{'source_scalar_ref'}})!=length(${$self->{'source_scalar_ref'}})}else {$self->SUPER::parse_lines(undef);delete$self->{'source_scalar_ref'};DEBUG and print STDERR "That's it for that source scalarref!  Killing.\n"}}else {die "What source??"}}DEBUG and print STDERR "get_token about to return ",Pod::Simple::pretty(@{$self->{'token_buffer'}}? $self->{'token_buffer'}[-1]: undef),"\n";return shift @{$self->{'token_buffer'}}}sub unget_token {my$self=shift;DEBUG and print STDERR "Ungetting ",scalar(@_)," tokens: ",@_ ? "@_\n" : "().\n";for my$t (@_){Carp::croak "Can't unget that, because it's not a token -- it's undef!" unless defined$t;Carp::croak "Can't unget $t, because it's not a token -- it's a string!" unless ref$t;Carp::croak "Can't unget $t, because it's not a token object!" unless UNIVERSAL::can($t,'type')}unshift @{$self->{'token_buffer'}},@_;DEBUG > 1 and print STDERR "Token buffer now has ",scalar(@{$self->{'token_buffer'}})," items in it.\n";return}sub set_source {my$self=shift @_;return$self->{'source_fh'}unless @_;Carp::croak("Cannot assign new source to pull parser; create a new instance, instead")if$self->{'source_fh'}|| $self->{'source_scalar_ref'}|| $self->{'source_arrayref'};my$handle;if(!defined $_[0]){Carp::croak("Can't use empty-string as a source for set_source")}elsif(ref(\($_[0]))eq 'GLOB'){$self->{'source_filename'}='' .($handle=$_[0]);DEBUG and print STDERR "$self 's source is glob $_[0]\n"}elsif(ref($_[0])eq 'SCALAR'){$self->{'source_scalar_ref'}=$_[0];DEBUG and print STDERR "$self 's source is scalar ref $_[0]\n";return}elsif(ref($_[0])eq 'ARRAY'){$self->{'source_arrayref'}=$_[0];DEBUG and print STDERR "$self 's source is array ref $_[0]\n";return}elsif(ref $_[0]){$self->{'source_filename'}='' .($handle=$_[0]);DEBUG and print STDERR "$self 's source is fh-obj $_[0]\n"}elsif(!length $_[0]){Carp::croak("Can't use empty-string as a source for set_source")}else {DEBUG and print STDERR "$self 's source is filename $_[0]\n";{local*PODSOURCE;open(PODSOURCE,"<$_[0]")|| Carp::croak "Can't open $_[0]: $!";$handle=*PODSOURCE{IO}}$self->{'source_filename'}=$_[0];DEBUG and print STDERR "  Its name is $_[0].\n"}$self->{'source_fh'}=$handle;DEBUG and print STDERR "  Its handle is $handle\n";return 1}sub get_title_short {shift->get_short_title(@_)}sub get_short_title {my$title=shift->get_title(@_);$title=$1 if$title =~ m/^(\S{1,60})\s+--?\s+./s;return$title}sub get_title {shift->_get_titled_section('NAME',max_token=>50,desperate=>1,@_)}sub get_version {shift->_get_titled_section('VERSION',max_token=>400,accept_verbatim=>1,max_content_length=>3_000,@_,)}sub get_description {shift->_get_titled_section('DESCRIPTION',max_token=>400,max_content_length=>3_000,@_,)}sub get_authors {shift->get_author(@_)}sub get_author {my$this=shift;$this->_get_titled_section('AUTHOR',max_token=>10_000,@_)|| $this->_get_titled_section('AUTHORS',max_token=>10_000,@_)}sub _get_titled_section {my($self,$titlename,%options)=(@_);my$max_token=delete$options{'max_token'};my$desperate_for_title=delete$options{'desperate'};my$accept_verbatim=delete$options{'accept_verbatim'};my$max_content_length=delete$options{'max_content_length'};my$nocase=delete$options{'nocase'};$max_content_length=120 unless defined$max_content_length;Carp::croak("Unknown " .((1==keys%options)? "option: " : "options: ").join " ",map "[$_]",sort keys%options)if keys%options;my%content_containers;$content_containers{'Para'}=1;if($accept_verbatim){$content_containers{'Verbatim'}=1;$content_containers{'VerbatimFormatted'}=1}my$token_count=0;my$title;my@to_unget;my$state=0;my$depth=0;Carp::croak "What kind of titlename is \"$titlename\"?!" unless defined$titlename and $titlename =~ m/^[A-Z ]{1,60}$/s;my$titlename_re=quotemeta($titlename);my$head1_text_content;my$para_text_content;my$skipX;while(++$token_count <= ($max_token || 1_000_000)and defined(my$token=$self->get_token)){push@to_unget,$token;if ($state==0){if($token->is_start and $token->tagname eq 'head1'){DEBUG and print STDERR "  Found head1.  Seeking content...\n";++$state;$head1_text_content=''}}elsif($state==1){if($token->is_text){unless ($skipX){DEBUG and print STDERR "   Adding \"",$token->text,"\" to head1-content.\n";$head1_text_content .= $token->text}}elsif($token->is_tagname('X')){$skipX=$token->is_start;DEBUG and print STDERR +($skipX ? 'Start' : 'End'),'ing ignoring of X<> tag'}elsif($token->is_end and $token->tagname eq 'head1'){DEBUG and print STDERR "  Found end of head1.  Considering content...\n";$head1_text_content=uc$head1_text_content if$nocase;if($head1_text_content eq $titlename or $head1_text_content =~ m/\($titlename_re\)/s){DEBUG and print STDERR "  Yup, it was $titlename.  Seeking next para-content...\n";++$state}elsif($desperate_for_title and $head1_text_content =~ m/\S/ and $head1_text_content !~ m/^[ A-Z]+$/s and $head1_text_content !~ m/\((?:
               NAME | TITLE | VERSION | AUTHORS? | DESCRIPTION | SYNOPSIS
               | COPYRIGHT | LICENSE | NOTES? | FUNCTIONS? | METHODS?
               | CAVEATS? | BUGS? | SEE\ ALSO | SWITCHES | ENVIRONMENT
              )\)/sx and ($max_content_length ? (length($head1_text_content)<= $max_content_length): 1)){($title=$head1_text_content)=~ s/\s+$//;DEBUG and print STDERR "  It looks titular: \"$title\".\n\n  Using that.\n";last}else {--$state;DEBUG and print STDERR "  Didn't look titular ($head1_text_content).\n","\n  Dropping back to seeking-head1-content mode...\n"}}}elsif($state==2){if($token->is_start and $content_containers{$token->tagname }){DEBUG and print STDERR "  Found start of Para.  Accumulating content...\n";$para_text_content='';++$state}else {DEBUG and print "  Didn't see an immediately subsequent start-Para.  Reseeking H1\n";$state=0}}elsif($state==3){if($token->is_text){DEBUG and print STDERR "   Adding \"",$token->text,"\" to para-content.\n";$para_text_content .= $token->text}elsif($token->is_end and $content_containers{$token->tagname }){DEBUG and print STDERR "  Found end of Para.  Considering content: ",$para_text_content,"\n";if($para_text_content =~ m/\S/ and ($max_content_length ? (length($para_text_content)<= $max_content_length): 1)){DEBUG and print STDERR "  It looks contentworthy, I guess.  Using it.\n";$title=$para_text_content;last}else {DEBUG and print STDERR "  Doesn't look at all contentworthy!\n  Giving up.\n";undef$title;last}}}else {die "IMPOSSIBLE STATE $state!\n"}}$self->unget_token(@to_unget);if(DEBUG){if(defined$title){print STDERR "  Returning title <$title>\n"}else {print STDERR "Returning title <>\n"}}return '' unless defined$title;$title =~ s/^\s+//;return$title}sub _handle_element_start {my$self=shift;DEBUG > 2 and print STDERR "++ $_[0] (",map("<$_> ",%{$_[1]}),")\n";push @{$self->{'token_buffer'}},$self->{'start_token_class'}->new(@_);return}sub _handle_text {my$self=shift;DEBUG > 2 and print STDERR "== $_[0]\n";push @{$self->{'token_buffer'}},$self->{'text_token_class'}->new(@_);return}sub _handle_element_end {my$self=shift;DEBUG > 2 and print STDERR "-- $_[0]\n";push @{$self->{'token_buffer'}},$self->{'end_token_class'}->new(@_);return}1;
POD_SIMPLE_PULLPARSER

$fatpacked{"Pod/Simple/PullParserEndToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERENDTOKEN';
  require 5;package Pod::Simple::PullParserEndToken;use Pod::Simple::PullParserToken ();use strict;use vars qw(@ISA $VERSION);@ISA=('Pod::Simple::PullParserToken');$VERSION='3.40';sub new {my$class=shift;return bless ['end',@_],ref($class)|| $class}sub tagname {(@_==2)? ($_[0][1]=$_[1]): $_[0][1]}sub tag {shift->tagname(@_)}sub is_tagname {$_[0][1]eq $_[1]}sub is_tag {shift->is_tagname(@_)}1;
POD_SIMPLE_PULLPARSERENDTOKEN

$fatpacked{"Pod/Simple/PullParserStartToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERSTARTTOKEN';
  require 5;package Pod::Simple::PullParserStartToken;use Pod::Simple::PullParserToken ();use strict;use vars qw(@ISA $VERSION);@ISA=('Pod::Simple::PullParserToken');$VERSION='3.40';sub new {my$class=shift;return bless ['start',@_],ref($class)|| $class}sub tagname {(@_==2)? ($_[0][1]=$_[1]): $_[0][1]}sub tag {shift->tagname(@_)}sub is_tagname {$_[0][1]eq $_[1]}sub is_tag {shift->is_tagname(@_)}sub attr_hash {$_[0][2]||= {}}sub attr {if(@_==2){${$_[0][2]|| return undef}{$_[1]}}elsif(@_ > 2){${$_[0][2]||= {}}{$_[1]}=$_[2]}else {require Carp;Carp::croak('usage: $object->attr("val") or $object->attr("key", "newval")');return undef}}1;
POD_SIMPLE_PULLPARSERSTARTTOKEN

$fatpacked{"Pod/Simple/PullParserTextToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTEXTTOKEN';
  require 5;package Pod::Simple::PullParserTextToken;use Pod::Simple::PullParserToken ();use strict;use vars qw(@ISA $VERSION);@ISA=('Pod::Simple::PullParserToken');$VERSION='3.40';sub new {my$class=shift;return bless ['text',@_],ref($class)|| $class}sub text {(@_==2)? ($_[0][1]=$_[1]): $_[0][1]}sub text_r {\ $_[0][1]}1;
POD_SIMPLE_PULLPARSERTEXTTOKEN

$fatpacked{"Pod/Simple/PullParserToken.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_PULLPARSERTOKEN';
  require 5;package Pod::Simple::PullParserToken;@ISA=();$VERSION='3.40';use strict;sub new {my$class=shift;return bless [@_],ref($class)|| $class}sub type {$_[0][0]}sub dump {Pod::Simple::pretty([@{$_[0]}])}sub is_start {$_[0][0]eq 'start'}sub is_end {$_[0][0]eq 'end'}sub is_text {$_[0][0]eq 'text'}1;
POD_SIMPLE_PULLPARSERTOKEN

$fatpacked{"Pod/Simple/RTF.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_RTF';
  require 5;package Pod::Simple::RTF;use strict;use vars qw($VERSION @ISA %Escape $WRAP %Tagmap);$VERSION='3.40';use Pod::Simple::PullParser ();BEGIN {@ISA=('Pod::Simple::PullParser')}use Carp ();BEGIN {*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}sub to_uni ($) {my$x=shift;$x=chr utf8::native_to_unicode(ord$x)if $] ge 5.007_003 && ord("A")!=65;return$x}my$map_to_self=' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEGHIJKLMNOPQRSTUVWXYZ[]^`abcdefghijklmnopqrstuvwxyz|~';$WRAP=1 unless defined$WRAP;%Escape=(map((chr($_)=>sprintf("\\'%02x",$_)),0 .. 0xFF),map((substr($map_to_self,$_,1)=>to_uni(substr($map_to_self,$_,1))),0 .. length($map_to_self)- 1),"\r"=>"\n","\cj"=>"\n","\n"=>"\n\\line ","\t"=>"\\tab ","\f"=>"\n\\page\n","-"=>"\\_",$Pod::Simple::nbsp=>"\\~",$Pod::Simple::shy=>"\\-","\n"=>"\\line\n","\r"=>"\n","\cb"=>"{\n\\cs21\\lang1024\\noproof ","\cc"=>"}",);my$escaped_sans_hyphen="";$escaped_sans_hyphen .= $_ for grep {$_ ne $Escape{$_}&& $_ ne '-'}sort keys%Escape;my$escaped="-$escaped_sans_hyphen";$escaped_sans_hyphen=qr/[\Q$escaped_sans_hyphen \E]/;$escaped=qr/[\Q$escaped\E]/;sub _openclose {return map {;m/^([-A-Za-z]+)=(\w[^\=]*)$/s or die "what's <$_>?";($1,"{\\$2\n","/$1","}")}@_}my@_to_accept;%Tagmap=(_openclose('B=cs18\b','I=cs16\i','C=cs19\f1\lang1024\noproof','F=cs17\i\lang1024\noproof','VerbatimI=cs26\i','VerbatimB=cs27\b','VerbatimBI=cs28\b\i',map {;m/^([-a-z]+)/s && push@_to_accept,$1;$_}qw[underline=ul smallcaps=scaps shadow=shad superscript=super subscript=sub strikethrough=strike outline=outl emboss=embo engrave=impr dotted-underline=uld dash-underline=uldash dot-dash-underline=uldashd dot-dot-dash-underline=uldashdd double-underline=uldb thick-underline=ulth word-underline=ulw wave-underline=ulwave]),'L=pod'=>'{\cs22\i'."\n",'L=url'=>'{\cs23\i'."\n",'L=man'=>'{\cs24\i'."\n",'/L'=>'}','Data'=>"\n",'/Data'=>"\n",'Verbatim'=>"\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",'/Verbatim'=>"\n\\par}\n",'VerbatimFormatted'=>"\n{\\pard\\li#rtfindent##rtfkeep#\\plain\\s20\\sa180\\f1\\fs18\\lang1024\\noproof\n",'/VerbatimFormatted'=>"\n\\par}\n",'Para'=>"\n{\\pard\\li#rtfindent#\\sa180\n",'/Para'=>"\n\\par}\n",'head1'=>"\n{\\pard\\li#rtfindent#\\s31\\keepn\\sb90\\sa180\\f2\\fs#head1_halfpoint_size#\\ul{\n",'/head1'=>"\n}\\par}\n",'head2'=>"\n{\\pard\\li#rtfindent#\\s32\\keepn\\sb90\\sa180\\f2\\fs#head2_halfpoint_size#\\ul{\n",'/head2'=>"\n}\\par}\n",'head3'=>"\n{\\pard\\li#rtfindent#\\s33\\keepn\\sb90\\sa180\\f2\\fs#head3_halfpoint_size#\\ul{\n",'/head3'=>"\n}\\par}\n",'head4'=>"\n{\\pard\\li#rtfindent#\\s34\\keepn\\sb90\\sa180\\f2\\fs#head4_halfpoint_size#\\ul{\n",'/head4'=>"\n}\\par}\n",'item-bullet'=>"\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",'/item-bullet'=>"\n\\par}\n",'item-number'=>"\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",'/item-number'=>"\n\\par}\n",'item-text'=>"\n{\\pard\\li#rtfindent##rtfitemkeepn#\\sb60\\sa150\\fi-120\n",'/item-text'=>"\n\\par}\n",);sub new {my$new=shift->SUPER::new(@_);$new->nix_X_codes(1);$new->nbsp_for_S(1);$new->accept_targets('rtf','RTF');$new->{'Tagmap'}={%Tagmap};$new->accept_codes(@_to_accept);$new->accept_codes('VerbatimFormatted');DEBUG > 2 and print STDERR "To accept: ",join(' ',@_to_accept),"\n";$new->doc_lang(($ENV{'RTFDEFLANG'}|| '')=~ m/^(\d{1,10})$/s ? $1 : ($ENV{'RTFDEFLANG'}|| '')=~ m/^0?x([a-fA-F0-9]{1,10})$/s ? hex($1): ($ENV{'RTFDEFLANG'}|| '')=~ m/^([a-fA-F0-9]{4})$/s ? hex($1): '1033');$new->head1_halfpoint_size(32);$new->head2_halfpoint_size(28);$new->head3_halfpoint_size(25);$new->head4_halfpoint_size(22);$new->codeblock_halfpoint_size(18);$new->header_halfpoint_size(17);$new->normal_halfpoint_size(25);return$new}__PACKAGE__->_accessorize('doc_lang','head1_halfpoint_size','head2_halfpoint_size','head3_halfpoint_size','head4_halfpoint_size','codeblock_halfpoint_size','header_halfpoint_size','normal_halfpoint_size','no_proofing_exemptions',);sub run {my$self=$_[0];return$self->do_middle if$self->bare_output;return $self->do_beginning && $self->do_middle && $self->do_end}my$id_re=Pod::Simple::BlackBox::my_qr('[\'_\p{XIDS}][\'\p{XIDC}]+',"ab");$id_re=Pod::Simple::BlackBox::my_qr('[\'_\p{IDS}][\'\p{IDC}]+',"ab")unless$id_re;$id_re=qr/['_a-zA-Z]['a-zA-Z0-9_]+/ unless$id_re;sub do_middle {my$self=$_[0];my$fh=$self->{'output_fh'};my($token,$type,$tagname,$scratch);my@stack;my@indent_stack;$self->{'rtfindent'}=0 unless defined$self->{'rtfindent'};while($token=$self->get_token){if(($type=$token->type)eq 'text'){if($self->{'rtfverbatim'}){DEBUG > 1 and print STDERR "  $type ",$token->text," in verbatim!\n";rtf_esc(0,$scratch=$token->text);print$fh $scratch;next}DEBUG > 1 and print STDERR "  $type ",$token->text,"\n";$scratch=$token->text;$scratch =~ tr/\t\cb\cc/ /d;$self->{'no_proofing_exemptions'}or $scratch =~ s/(?:
             ^
             |
             (?<=[\r\n\t "\[\<\(])
           )   # start on whitespace, sequence-start, or quote
           ( # something looking like a Perl token:
            (?:
             [\$\@\:\<\*\\_]\S+  # either starting with a sigil, etc.
            )
            |
            # or starting alpha, but containing anything strange:
            (?:
             ${id_re}[\$\@\:_<>\(\\\*]\S+
            )
           )
          /\cb$1\cc/xsg ;rtf_esc(1,$scratch);$scratch =~ s/(
              [^\r\n]{65}        # Snare 65 characters from a line
              [^\r\n ]{0,50}     #  and finish any current word
             )
             (\ {1,10})(?![\r\n]) # capture some spaces not at line-end
            /$1$2\n/gx if$WRAP;print$fh $scratch}elsif($type eq 'start'){DEBUG > 1 and print STDERR "  +$type ",$token->tagname," (",map("<$_> ",%{$token->attr_hash}),")\n";if(($tagname=$token->tagname)eq 'Verbatim' or $tagname eq 'VerbatimFormatted'){++$self->{'rtfverbatim'};my$next=$self->get_token;next unless defined$next;my$line_count=1;if($next->type eq 'text'){my$t=$next->text_r;while($$t =~ m/$/mg){last if ++$line_count > 15}DEBUG > 3 and print STDERR "    verbatim line count: $line_count\n"}$self->unget_token($next);$self->{'rtfkeep'}=($line_count > 15)? '' : '\keepn' }elsif($tagname =~ m/^item-/s){my@to_unget;my$text_count_here=0;$self->{'rtfitemkeepn'}='';while(1){push@to_unget,$self->get_token;pop(@to_unget),last unless defined$to_unget[-1];if($to_unget[-1]->type eq 'text'){if(($text_count_here += length ${$to_unget[-1]->text_r})> 150){DEBUG > 1 and print STDERR "    item-* is too long to be keepn'd.\n";last}}elsif (@to_unget > 1 and $to_unget[-2]->type eq 'end' and $to_unget[-2]->tagname =~ m/^item-/s){$self->{'rtfitemkeepn'}='\keepn' if $to_unget[-1]->type eq 'start' and $to_unget[-1]->tagname eq 'Para';DEBUG > 1 and printf STDERR "    item-* before %s(%s) %s keepn'd.\n",$to_unget[-1]->type,$to_unget[-1]->can('tagname')? $to_unget[-1]->tagname : '',$self->{'rtfitemkeepn'}? "gets" : "doesn't get";last}elsif (@to_unget > 40){DEBUG > 1 and print STDERR "    item-* now has too many tokens (",scalar(@to_unget),(DEBUG > 4)? (q<: >,map($_->dump,@to_unget)): (),") to be keepn'd.\n";last}}$self->unget_token(@to_unget)}elsif($tagname =~ m/^over-/s){push@stack,$1;push@indent_stack,int($token->attr('indent')* 4 * $self->normal_halfpoint_size);DEBUG and print STDERR "Indenting over $indent_stack[-1] twips.\n";$self->{'rtfindent'}+= $indent_stack[-1]}elsif ($tagname eq 'L'){$tagname .= '=' .($token->attr('type')|| 'pod')}elsif ($tagname eq 'Data'){my$next=$self->get_token;next unless defined$next;unless($next->type eq 'text'){$self->unget_token($next);next}DEBUG and print STDERR "    raw text ",$next->text,"\n";printf$fh "\n" .$next->text ."\n";next}defined($scratch=$self->{'Tagmap'}{$tagname})or next;$scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g;print$fh $scratch;if ($tagname eq 'item-number'){print$fh $token->attr('number'),". \n"}elsif ($tagname eq 'item-bullet'){print$fh "\\'",ord("_"),"\n"}}elsif($type eq 'end'){DEBUG > 1 and print STDERR "  -$type ",$token->tagname,"\n";if(($tagname=$token->tagname)=~ m/^over-/s){DEBUG and print STDERR "Indenting back $indent_stack[-1] twips.\n";$self->{'rtfindent'}-= pop@indent_stack;pop@stack}elsif($tagname eq 'Verbatim' or $tagname eq 'VerbatimFormatted'){--$self->{'rtfverbatim'}}defined($scratch=$self->{'Tagmap'}{"/$tagname"})or next;$scratch =~ s/\#([^\#]+)\#/${$self}{$1}/g;print$fh $scratch}}return 1}sub do_beginning {my$self=$_[0];my$fh=$self->{'output_fh'};return print$fh join '',$self->doc_init,$self->font_table,$self->stylesheet,$self->color_table,$self->doc_info,$self->doc_start,"\n" }sub do_end {my$self=$_[0];my$fh=$self->{'output_fh'};return print$fh '}'}sub stylesheet {return sprintf <<'END',$_[0]->codeblock_halfpoint_size(),$_[0]->head1_halfpoint_size(),$_[0]->head2_halfpoint_size(),$_[0]->head3_halfpoint_size(),$_[0]->head4_halfpoint_size(),}sub font_table {return <<'END'}sub doc_init {return <<'END'}sub color_table {return <<'END'}sub doc_info {my$self=$_[0];my$class=ref($self)|| $self;my$tag=__PACKAGE__ .' ' .$VERSION;unless($class eq __PACKAGE__){$tag=" ($tag)";$tag=" v" .$self->VERSION .$tag if defined$self->VERSION;$tag=$class .$tag}return sprintf <<'END',$tag,$ISA[0],$ISA[0]->VERSION(),$],scalar(gmtime),}sub doc_start {my$self=$_[0];my$title=$self->get_short_title();DEBUG and print STDERR "Short Title: <$title>\n";$title .= ' ' if length$title;$title =~ s/ *$/ /s;$title =~ s/^ //s;$title =~ s/ $/, /s;my$is_obviously_module_name;$is_obviously_module_name=1 if$title =~ m/^\S+$/s and $title =~ m/::/s;DEBUG and print STDERR "Title0: <$title>\n";$title=rtf_esc(1,$title);DEBUG and print STDERR "Title1: <$title>\n";$title='\lang1024\noproof ' .$title if$is_obviously_module_name;return sprintf <<'END',($self->doc_lang)x 2,$self->header_halfpoint_size,$title,$self->normal_halfpoint_size,}use integer;my$question_mark_code_points=Pod::Simple::BlackBox::my_qr('([^\x00-\x{D7FF}\x{E000}-\x{10FFFF}])',"\x{110000}");my$plane0=Pod::Simple::BlackBox::my_qr('([\x{100}-\x{FFFF}])',"\x{100}");my$other_unicode=Pod::Simple::BlackBox::my_qr('([\x{10000}-\x{10FFFF}])',"\x{10000}");sub esc_uni($) {use if $] le 5.006002,'utf8';my$x=shift;$x =~ s/$question_mark_code_points/?/g if$question_mark_code_points;$x =~ s/$plane0/'\\uc1\\u'.((ord($1)<32768)?ord($1):(ord($1)-65536)).'?'/eg if$plane0;$x =~ s/$other_unicode/'\\uc1\\u' . ((ord($1) >> 10) + 0xD7C0 - 65536) . '\\u' . (((ord$1) & 0x03FF) + 0xDC00 - 65536) . '?'/eg if$other_unicode;return$x}sub rtf_esc ($$) {my$escape_re=((shift)? $escaped : $escaped_sans_hyphen);my$x;if(!defined wantarray){for(@_){s/($escape_re)/$Escape{$1}/g;$_=esc_uni($_)}return}elsif(wantarray){return map {;($x=$_)=~ s/($escape_re)/$Escape{$1}/g;$x=esc_uni($x);$x}@_}else {($x=((@_==1)? $_[0]: join '',@_))=~ s/($escape_re)/$Escape{$1}/g;$x=esc_uni($x);return$x}}1;
  {\stylesheet
  {\snext0 Normal;}
  {\*\cs10 \additive Default Paragraph Font;}
  {\*\cs16 \additive \i \sbasedon10 pod-I;}
  {\*\cs17 \additive \i\lang1024\noproof \sbasedon10 pod-F;}
  {\*\cs18 \additive \b \sbasedon10 pod-B;}
  {\*\cs19 \additive \f1\lang1024\noproof\sbasedon10 pod-C;}
  {\s20\ql \li0\ri0\sa180\widctlpar\f1\fs%s\lang1024\noproof\sbasedon0 \snext0 pod-codeblock;}
  {\*\cs21 \additive \lang1024\noproof \sbasedon10 pod-computerese;}
  {\*\cs22 \additive \i\lang1024\noproof\sbasedon10 pod-L-pod;}
  {\*\cs23 \additive \i\lang1024\noproof\sbasedon10 pod-L-url;}
  {\*\cs24 \additive \i\lang1024\noproof\sbasedon10 pod-L-man;}
  
  {\*\cs25 \additive \f1\lang1024\noproof\sbasedon0 pod-codelbock-plain;}
  {\*\cs26 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-ital;}
  {\*\cs27 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold;}
  {\*\cs28 \additive \f1\lang1024\noproof\sbasedon25 pod-codelbock-bold-ital;}
  
  {\s31\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head1;}
  {\s32\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head2;}
  {\s33\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head3;}
  {\s34\ql \keepn\sb90\sa180\f2\fs%s\ul\sbasedon0 \snext0 pod-head4;}
  }
  
  END
  {\fonttbl
  {\f0\froman Times New Roman;}
  {\f1\fmodern Courier New;}
  {\f2\fswiss Arial;}
  }
  
  END
  {\rtf1\ansi\deff0
  
  END
  {\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
  END
  {\info{\doccomm
  %s
   using %s v%s
   under Perl v%s at %s GMT}
  {\author [see doc]}{\company [see doc]}{\operator [see doc]}
  }
  
  END
  \deflang%s\plain\lang%s\widowctrl
  {\header\pard\qr\plain\f2\fs%s
  %s
  p.\chpgn\par}
  \fs%s
  
  END
POD_SIMPLE_RTF

$fatpacked{"Pod/Simple/Search.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SEARCH';
  require 5.005;package Pod::Simple::Search;use strict;use vars qw($VERSION $MAX_VERSION_WITHIN $SLEEPY);$VERSION='3.40';BEGIN {*DEBUG=sub () {0}unless defined&DEBUG}use Carp ();$SLEEPY=1 if!defined$SLEEPY and $^O =~ /mswin|mac/i;$MAX_VERSION_WITHIN ||= 60;use File::Spec ();use File::Basename qw(basename dirname);use Config ();use Cwd qw(cwd);__PACKAGE__->_accessorize('callback','progress','dir_prefix','inc','laborious','limit_glob','limit_re','shadows','verbose','name2path','path2name','recurse','ciseen','is_case_insensitive');sub new {my$class=shift;my$self=bless {},ref($class)|| $class;$self->init;return$self}sub init {my$self=shift;$self->inc(1);$self->recurse(1);$self->verbose(DEBUG);$self->is_case_insensitive(-e uc __FILE__ && -e lc __FILE__);return$self}sub survey {my($self,@search_dirs)=@_;$self=$self->new unless ref$self;$self->_expand_inc(\@search_dirs);$self->{'_scan_count'}=0;$self->{'_dirs_visited'}={};$self->path2name({});$self->name2path({});$self->ciseen({});$self->limit_re($self->_limit_glob_to_limit_re)if$self->{'limit_glob'};my$cwd=cwd();my$verbose=$self->verbose;local $_;for my$try (@search_dirs){unless(File::Spec->file_name_is_absolute($try)){$try=File::Spec->catfile($cwd,$try)}$try=File::Spec->canonpath($try);my$start_in;my$modname_prefix;if($self->{'dir_prefix'}){$start_in=File::Spec->catdir($try,grep length($_),split '[\\/:]+',$self->{'dir_prefix'});$modname_prefix=[grep length($_),split m{[:/\\]},$self->{'dir_prefix'}];$verbose and print "Appending \"$self->{'dir_prefix'}\" to $try, ","giving $start_in (= @$modname_prefix)\n"}else {$start_in=$try}if($self->{'_dirs_visited'}{$start_in}){$verbose and print "Directory '$start_in' already seen, skipping.\n";next}else {$self->{'_dirs_visited'}{$start_in}=1}unless(-e $start_in){$verbose and print "Skipping non-existent $start_in\n";next}my$closure=$self->_make_search_callback;if(-d $start_in){$verbose and print "Beginning excursion under $start_in\n";$self->_recurse_dir($start_in,$closure,$modname_prefix);$verbose and print "Back from excursion under $start_in\n\n"}elsif(-f _){$_=basename($start_in);$verbose and print "Pondering $start_in ($_)\n";$closure->($start_in,$_,0,[])}else {$verbose and print "Skipping mysterious $start_in\n"}}$self->progress and $self->progress->done("Noted $$self{'_scan_count'} Pod files total");$self->ciseen({});return unless defined wantarray;return$self->name2path unless wantarray;return$self->name2path,$self->path2name}sub _make_search_callback {my$self=$_[0];my($laborious,$verbose,$shadows,$limit_re,$callback,$progress,$path2name,$name2path,$recurse,$ciseen,$is_case_insensitive)=map scalar($self->$_()),qw(laborious verbose shadows limit_re callback progress path2name name2path recurse ciseen is_case_insensitive);my ($seen,$remember,$files_for);if ($is_case_insensitive){$seen=sub {$ciseen->{lc $_[0]}};$remember=sub {$name2path->{$_[0]}=$ciseen->{lc $_[0]}=$_[1]};$files_for=sub {my$n=lc $_[0];grep {lc$path2name->{$_}eq $n}%{$path2name}}}else {$seen=sub {$name2path->{$_[0]}};$remember=sub {$name2path->{$_[0]}=$_[1]};$files_for=sub {my$n=$_[0];grep {$path2name->{$_}eq $n}%{$path2name}}}my($file,$shortname,$isdir,$modname_bits);return sub {($file,$shortname,$isdir,$modname_bits)=@_;if($isdir){unless($recurse){$verbose and print "Not recursing into '$file' as per requested.\n";return 'PRUNE'}if($self->{'_dirs_visited'}{$file}){$verbose and print "Directory '$file' already seen, skipping.\n";return 'PRUNE'}print "Looking in dir $file\n" if$verbose;unless ($laborious){if(m/^(\d+\.[\d_]{3,})\z/s and do {my$x=$1;$x =~ tr/_//d;$x!=$]}){$verbose and print "Perl $] version mismatch on $_, skipping.\n";return 'PRUNE'}if(m/^([A-Za-z][a-zA-Z0-9_]*)\z/s){$verbose and print "$_ is a well-named module subdir.  Looking....\n"}else {$verbose and print "$_ is a fishy directory name.  Skipping.\n";return 'PRUNE'}}$self->{'_dirs_visited'}{$file}=1;return}if($laborious){unless(m/\.(pod|pm|plx?)\z/i || -x _ and -T _){$verbose > 1 and print " Brushing off uninteresting $file\n";return}}else {unless(m/^[-_a-zA-Z0-9]+\.(?:pod|pm|plx?)\z/is){$verbose > 1 and print " Brushing off oddly-named $file\n";return}}$verbose and print "Considering item $file\n";my$name=$self->_path2modname($file,$shortname,$modname_bits);$verbose > 0.01 and print " Nominating $file as $name\n";if($limit_re and $name !~ m/$limit_re/i){$verbose and print "Shunning $name as not matching $limit_re\n";return}if(!$shadows and $seen->($name)){$verbose and print "Not worth considering $file ","-- already saw $name as ",join(' ',$files_for->($name)),"\n";return}$progress and $progress->reach($self->{'_scan_count'},"Scanning $file");return unless$self->contains_pod($file);++ $self->{'_scan_count'};if (my$prev=$seen->($name)){$verbose and print "Duplicate POD found (shadowing?): $name ($file)\n","    Already seen in ",join(' ',$files_for->($name)),"\n"}else {$remember->($name,$file)}$verbose and print "  Noting $name = $file\n";if($callback){local $_=$_;$callback->($file,$name)}$path2name->{$file}=$name;return}}sub _path2modname {my($self,$file,$shortname,$modname_bits)=@_;my@m=@$modname_bits;my$x;my$verbose=$self->verbose;while(@m and defined($x=lc($m[0]))and($x eq 'site_perl' or($x =~ m/^pods?$/ and @m==1 and $shortname =~ m{^perl.*\.pod$}s)or $x =~ m{\\d+\\.z\\d+([_.]?\\d+)?} or $x eq lc($Config::Config{'archname'}))){shift@m}my$name=join '::',@m,$shortname;$self->_simplify_base($name);if ($^O eq 'VMS' && ($name eq lc($name)|| $name eq uc($name))){open PODFILE,"<$file" or die "_path2modname: Can't open $file: $!";my$in_pod=0;my$in_name=0;my$line;while ($line=<PODFILE>){chomp$line;$in_pod=1 if ($line =~ m/^=\w/);$in_pod=0 if ($line =~ m/^=cut/);next unless$in_pod;next if ($line =~ m/^\s*\z/);next if ($in_pod && ($line =~ m/^X</));if ($in_name){if ($line =~ m/(\w+::)?(\w+)/){my$podname=$2;my$prefix=$1 || '';$verbose and print "Attempting case restore of '$name' from '$prefix$podname'\n";unless ($name =~ s/$prefix$podname/$prefix$podname/i){$verbose and print "Attempting case restore of '$name' from '$podname'\n";$name =~ s/$podname/$podname/i}last}}$in_name=1 if ($line =~ m/^=head1 NAME/)}close PODFILE}return$name}sub _recurse_dir {my($self,$startdir,$callback,$modname_bits)=@_;my$maxdepth=$self->{'fs_recursion_maxdepth'}|| 10;my$verbose=$self->verbose;my$here_string=File::Spec->curdir;my$up_string=File::Spec->updir;$modname_bits ||= [];my$recursor;$recursor=sub {my($dir_long,$dir_bare)=@_;if(@$modname_bits >= 10){$verbose and print "Too deep! [@$modname_bits]\n";return}unless(-d $dir_long){$verbose > 2 and print "But it's not a dir! $dir_long\n";return}unless(opendir(INDIR,$dir_long)){$verbose > 2 and print "Can't opendir $dir_long : $!\n";closedir(INDIR);return}my@items=map {$_->[0]}sort {$a->[1]cmp $b->[1]|| $b->[2]cmp $a->[2]}map {(my$t=$_)=~ s/[.]p(m|lx?|od)\z//;[$_,$t,lc($1 || 'z')]}readdir(INDIR);closedir(INDIR);push @$modname_bits,$dir_bare unless$dir_bare eq '';my$i_full;for my$i (@items){next if$i eq $here_string or $i eq $up_string or $i eq '';$i_full=File::Spec->catfile($dir_long,$i);if(!-r $i_full){$verbose and print "Skipping unreadable $i_full\n"}elsif(-f $i_full){$_=$i;$callback->($i_full,$i,0,$modname_bits)}elsif(-d _){$i =~ s/\.DIR\z//i if $^O eq 'VMS';$_=$i;my$rv=$callback->($i_full,$i,1,$modname_bits)|| '';if($rv eq 'PRUNE'){$verbose > 1 and print "OK, pruning"}else {$recursor->(File::Spec->catdir($dir_long,$i),$i)}}else {$verbose > 1 and print "Skipping oddity $i_full\n"}}pop @$modname_bits;return};;local $_;$recursor->($startdir,'');undef$recursor;return}sub run {my$self=__PACKAGE__->new;$self->limit_glob($ARGV[0])if@ARGV;$self->callback(sub {my($file,$name)=@_;my$version='';if($file =~ m/\.pod$/i){DEBUG and print "Not looking for \$VERSION in .pod $file\n"}elsif(!open(INPOD,$file)){DEBUG and print "Couldn't open $file: $!\n";close(INPOD)}else {my$lines=0;while(<INPOD>){last if$lines++ > $MAX_VERSION_WITHIN;if(s/^\s*\$VERSION\s*=\s*//s and m/\d/){DEBUG and print "Found version line (#$lines): $_";s/\s*\#.*//s;s/\;\s*$//s;s/\s+$//s;s/\t+/ /s;$_="v$1" if m{^v?["']?([0-9_]+(\.[0-9_]+)*)["']?$}s or m{\$Revision:\s*([0-9_]+(?:\.[0-9_]+)*)\s*\$}s ;$_=sprintf("v%d.%s",map {s/_//g;$_}$1 =~ m/-(\d+)_([\d_]+)/)if m{\$Name:\s*([^\$]+)\$}s ;$version=$_;DEBUG and print "Noting $version as version\n";last}}close(INPOD)}print "$name\t$version\t$file\n";return});$self->survey}sub simplify_name {my($self,$str)=@_;if ($^O eq 'MacOS'){$str =~ s{^.*:+}{}s}else {$str =~ s{^.*/+}{}s}$self->_simplify_base($str);return$str}sub _simplify_base {$_[1]=~ s/\.(pod|pm|plx?)\z//i;$_[1]=~ s/\.(bat|exe|cmd)\z//i if $^O =~ /mswin|os2/i;$_[1]=~ s/\.(com)\z//i if $^O eq 'VMS';return}sub _expand_inc {my($self,$search_dirs)=@_;return unless$self->{'inc'};my%seen=map {File::Spec->rel2abs($_)=>1}@{$search_dirs};if ($^O eq 'MacOS'){push @$search_dirs,grep {!$seen{File::Spec->rel2abs($_)}++}$self->_mac_whammy(@INC)}else {push @$search_dirs,grep {!$seen{File::Spec->rel2abs($_)}++}@INC}$self->{'laborious'}=0;return}sub _mac_whammy {my@them;(undef,@them)=@_;for $_ (@them){if ($_ eq '.'){$_=':'}elsif ($_ =~ s|^((?:\.\./)+)|':' x (length($1)/3)|e){$_=':'.$_}else {$_ =~ s|^\./|:|}}return@them}sub _limit_glob_to_limit_re {my$self=$_[0];my$limit_glob=$self->{'limit_glob'}|| return;my$limit_re='^' .quotemeta($limit_glob).'$';$limit_re =~ s/\\\?/./g;$limit_re =~ s/\\\*/.*?/g;$limit_re =~ s/\.\*\?\$$//s;$self->{'verbose'}and print "Turning limit_glob $limit_glob into re $limit_re\n";if(!exists($self->{'dir_prefix'})and $limit_glob =~ m/^(?:\w+\:\:)+/s){$self->{'dir_prefix'}=join "::",$limit_glob =~ m/^(?:\w+::)+/sg;$self->{'verbose'}and print " and setting dir_prefix to $self->{'dir_prefix'}\n"}return$limit_re}sub _actual_filenames {my$dir=shift;my$fn=lc shift;opendir my ($dh),$dir or return;return map {File::Spec->catdir($dir,$_)}grep {lc $_ eq $fn}readdir$dh}sub find {my($self,$pod,@search_dirs)=@_;$self=$self->new unless ref$self;Carp::carp 'Usage: \$self->find($podname, ...)' unless defined$pod and length$pod;my$verbose=$self->verbose;my@parts=split /::/,$pod;$verbose and print "Chomping {$pod} => {@parts}\n";$self->_expand_inc(\@search_dirs);push@search_dirs,$Config::Config{'scriptdir'}if$self->inc;my%seen_dir;while (my$dir=shift@search_dirs){next unless defined$dir and length$dir;next if$seen_dir{$dir};$seen_dir{$dir}=1;unless(-d $dir){print "Directory $dir does not exist\n" if$verbose}print "Looking in directory $dir\n" if$verbose;my$fullname=File::Spec->catfile($dir,@parts);print "Filename is now $fullname\n" if$verbose;for my$ext ('','.pod','.pm','.pl'){my$fullext=$fullname .$ext;if (-f $fullext and $self->contains_pod($fullext)){print "FOUND: $fullext\n" if$verbose;if (@parts > 1 && lc$parts[0]eq 'pod' && $self->is_case_insensitive()&& $ext eq '.pod'){my$subdir=dirname$fullext;unless (grep {$fullext eq $_}_actual_filenames$subdir,"$parts[-1].pod"){print "# Looking for alternate spelling in $subdir\n" if$verbose;my$pm=$fullname .'.pm';if (-f $pm and $self->contains_pod($pm)){if (grep {$pm eq $_}_actual_filenames$subdir,"$parts[-1].pm"){print "FOUND: $fullext\n" if$verbose;return$pm}}}}return$fullext}}for my$subdir (_actual_filenames($dir,'pods'),_actual_filenames($dir,'pod')){if (-d $subdir){$verbose and print "Noticing $subdir and looking there...\n";unshift@search_dirs,$subdir}}}return undef}sub contains_pod {my($self,$file)=@_;my$verbose=$self->{'verbose'};$verbose > 1 and print " Scanning $file for pod...\n";unless(open(MAYBEPOD,"<$file")){print "Error: $file is unreadable: $!\n";return undef}sleep($SLEEPY - 1)if$SLEEPY;local $_;while(<MAYBEPOD>){if(m/^=(head\d|pod|over|item)\b/s){close(MAYBEPOD)|| die "Bizarre error closing $file: $!\nAborting";chomp;$verbose > 1 and print "  Found some pod ($_) in $file\n";return 1}}close(MAYBEPOD)|| die "Bizarre error closing $file: $!\nAborting";$verbose > 1 and print "  No POD in $file, skipping.\n";return 0}sub _accessorize {shift;no strict 'refs';for my$attrname (@_){*{caller().'::' .$attrname}=sub {use strict;$Carp::CarpLevel=1,Carp::croak("Accessor usage: \$obj->$attrname() or \$obj->$attrname(\$new_value)")unless (@_==1 or @_==2)and ref $_[0];return $_[0]->{$attrname}if @_==1;$_[0]->{$attrname}=$_[1];return $_[0]}}return}sub _state_as_string {my$self=$_[0];return '' unless ref$self;my@out="{\n  # State of $self ...\n";for my$k (sort keys %$self){push@out,"  ",_esc($k)," => ",_esc($self->{$k}),",\n"}push@out,"}\n";my$x=join '',@out;$x =~ s/^/#/mg;return$x}sub _esc {my$in=$_[0];return 'undef' unless defined$in;$in =~ s<([^\x20\x21\x23\x27-\x3F\x41-\x5B\x5D-\x7E])>
       <'\\x'.(unpack("H2",$1))>eg;return qq{"$in"}}run()unless caller;1;
POD_SIMPLE_SEARCH

$fatpacked{"Pod/Simple/SimpleTree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_SIMPLETREE';
  require 5;package Pod::Simple::SimpleTree;use strict;use Carp ();use Pod::Simple ();use vars qw($ATTR_PAD @ISA $VERSION $SORT_ATTRS);$VERSION='3.40';BEGIN {@ISA=('Pod::Simple');*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}__PACKAGE__->_accessorize('root',);sub _handle_element_start {DEBUG > 2 and print STDERR "Handling $_[1] start-event\n";my$x=[$_[1],$_[2]];if($_[0]{'_currpos'}){push @{$_[0]{'_currpos'}[0]},$x;unshift @{$_[0]{'_currpos'}},$x}else {DEBUG and print STDERR " And oo, it gets to be root!\n";$_[0]{'_currpos'}=[$_[0]{'root'}=$x ]}DEBUG > 3 and print STDERR "Stack is now: ",join(">",map $_->[0],@{$_[0]{'_currpos'}}),"\n";return}sub _handle_element_end {DEBUG > 2 and print STDERR "Handling $_[1] end-event\n";shift @{$_[0]{'_currpos'}};DEBUG > 3 and print STDERR "Stack is now: ",join(">",map $_->[0],@{$_[0]{'_currpos'}}),"\n";return}sub _handle_text {DEBUG > 2 and print STDERR "Handling $_[1] text-event\n";push @{$_[0]{'_currpos'}[0]},$_[1];return}sub _traverse_treelet_bit {DEBUG > 2 and print STDERR "Handling $_[1] paragraph event\n";my$self=shift;push @{$self->{'_currpos'}[0]},[@_];return}1;
POD_SIMPLE_SIMPLETREE

$fatpacked{"Pod/Simple/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXT';
  require 5;package Pod::Simple::Text;use strict;use Carp ();use Pod::Simple::Methody ();use Pod::Simple ();use vars qw(@ISA $VERSION $FREAKYMODE);$VERSION='3.40';@ISA=('Pod::Simple::Methody');BEGIN {*DEBUG=defined(&Pod::Simple::DEBUG)? \&Pod::Simple::DEBUG : sub() {0}}use Text::Wrap 98.112902 ();$Text::Wrap::huge='overflow';sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->accept_target_as_text(qw(text plaintext plain));$new->nix_X_codes(1);$new->nbsp_for_S(1);$new->{'Thispara'}='';$new->{'Indent'}=0;$new->{'Indentstring'}='   ';return$new}sub handle_text {$_[0]{'Thispara'}.= $_[1]}sub start_Para {$_[0]{'Thispara'}=''}sub start_head1 {$_[0]{'Thispara'}=''}sub start_head2 {$_[0]{'Thispara'}=''}sub start_head3 {$_[0]{'Thispara'}=''}sub start_head4 {$_[0]{'Thispara'}=''}sub start_Verbatim {$_[0]{'Thispara'}=''}sub start_item_bullet {$_[0]{'Thispara'}=$FREAKYMODE ? '' : '* '}sub start_item_number {$_[0]{'Thispara'}=$FREAKYMODE ? '' : "$_[1]{'number'}. "}sub start_item_text {$_[0]{'Thispara'}=''}sub start_over_bullet {++$_[0]{'Indent'}}sub start_over_number {++$_[0]{'Indent'}}sub start_over_text {++$_[0]{'Indent'}}sub start_over_block {++$_[0]{'Indent'}}sub end_over_bullet {--$_[0]{'Indent'}}sub end_over_number {--$_[0]{'Indent'}}sub end_over_text {--$_[0]{'Indent'}}sub end_over_block {--$_[0]{'Indent'}}sub end_head1 {$_[0]->emit_par(-4)}sub end_head2 {$_[0]->emit_par(-3)}sub end_head3 {$_[0]->emit_par(-2)}sub end_head4 {$_[0]->emit_par(-1)}sub end_Para {$_[0]->emit_par(0)}sub end_item_bullet {$_[0]->emit_par(0)}sub end_item_number {$_[0]->emit_par(0)}sub end_item_text {$_[0]->emit_par(-2)}sub start_L {$_[0]{'Link'}=$_[1]if $_[1]->{type}eq 'url'}sub end_L {if (my$link=delete $_[0]{'Link'}){$_[0]{'Thispara'}.= " <$link->{to}>" unless $_[0]{'Thispara'}=~ /\b\Q$link->{to}/}}sub emit_par {my($self,$tweak_indent)=splice(@_,0,2);my$indent=' ' x (2 * $self->{'Indent'}+ 4 + ($tweak_indent||0));$self->{'Thispara'}=~ s/$Pod::Simple::shy//g;my$out=Text::Wrap::wrap($indent,$indent,$self->{'Thispara'}.= "\n");$out =~ s/$Pod::Simple::nbsp/ /g;print {$self->{'output_fh'}}$out,"\n";$self->{'Thispara'}='';return}sub end_Verbatim {my$self=shift;$self->{'Thispara'}=~ s/$Pod::Simple::nbsp/ /g;$self->{'Thispara'}=~ s/$Pod::Simple::shy//g;my$i=' ' x (2 * $self->{'Indent'}+ 4);$self->{'Thispara'}=~ s/^/$i/mg;print {$self->{'output_fh'}}'',$self->{'Thispara'},"\n\n" ;$self->{'Thispara'}='';return}1;
POD_SIMPLE_TEXT

$fatpacked{"Pod/Simple/TextContent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TEXTCONTENT';
  require 5;package Pod::Simple::TextContent;use strict;use Carp ();use Pod::Simple ();use vars qw(@ISA $VERSION);$VERSION='3.40';@ISA=('Pod::Simple');sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->nix_X_codes(1);return$new}sub _handle_element_start {print {$_[0]{'output_fh'}}"\n" unless $_[1]=~ m/^[A-Z]$/s;return}sub _handle_text {$_[1]=~ s/$Pod::Simple::shy//g;$_[1]=~ s/$Pod::Simple::nbsp/ /g;print {$_[0]{'output_fh'}}$_[1];return}sub _handle_element_end {print {$_[0]{'output_fh'}}"\n" unless $_[1]=~ m/^[A-Z]$/s;return}1;
POD_SIMPLE_TEXTCONTENT

$fatpacked{"Pod/Simple/TiedOutFH.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TIEDOUTFH';
  use strict;package Pod::Simple::TiedOutFH;use Symbol ('gensym');use Carp ();use vars qw($VERSION);$VERSION='3.40';sub handle_on {my$class=shift;$class=ref($class)|| $class;Carp::croak "Usage: ${class}->handle_on(\$somescalar)" unless @_;my$x=(defined($_[0])and ref($_[0]))? $_[0]: (\($_[0]))[0];$$x='' unless defined $$x;my$new=gensym();tie *$new,$class,$x;return$new}sub TIEHANDLE {my($class,$scalar_ref)=@_;$$scalar_ref='' unless defined $$scalar_ref;return bless \$scalar_ref,ref($class)|| $class}sub PRINT {my$it=shift;for my$x (@_){$$$it .= $x}return 1}sub FETCH {return ${$_[0]}}sub PRINTF {my$it=shift;my$format=shift;$$$it .= sprintf$format,@_;return 1}sub FILENO {${$_[0]}+ 100}sub CLOSE {1}1;
POD_SIMPLE_TIEDOUTFH

$fatpacked{"Pod/Simple/Transcode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODE';
  require 5;package Pod::Simple::Transcode;use strict;use vars qw($VERSION @ISA);$VERSION='3.40';BEGIN {if(defined&DEBUG){}elsif(defined&Pod::Simple::DEBUG){*DEBUG=\&Pod::Simple::DEBUG}else {*DEBUG=sub () {0}}}for my$class ('Pod::Simple::TranscodeSmart','Pod::Simple::TranscodeDumb','',){$class or die "Couldn't load any encoding classes";DEBUG and print STDERR "About to try loading $class...\n";eval "require $class;";if($@){DEBUG and print STDERR "Couldn't load $class: $@\n"}else {DEBUG and print STDERR "OK, loaded $class.\n";@ISA=($class);last}}sub _blorp {return}1;
POD_SIMPLE_TRANSCODE

$fatpacked{"Pod/Simple/TranscodeDumb.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODEDUMB';
  require 5;package Pod::Simple::TranscodeDumb;use strict;use vars qw($VERSION %Supported);$VERSION='3.40';%Supported=('ascii'=>1,'ascii-ctrl'=>1,'iso-8859-1'=>1,'cp1252'=>1,'null'=>1,'latin1'=>1,'latin-1'=>1,%Supported,);sub is_dumb {1}sub is_smart {0}sub all_encodings {return sort keys%Supported}sub encoding_is_available {return exists$Supported{lc $_[1]}}sub encmodver {return __PACKAGE__ ." v" .($VERSION || '?')}sub make_transcoder {my ($e)=$_[1];die "WHAT ENCODING!?!?" unless$e;return sub {}if$e !~ /^cp-?1252$/i;return sub {my%ascii_for=("\x80"=>'e',"\x82"=>',',"\x83"=>'f',"\x84"=>',,',"\x85"=>'...',"\x86"=>'+',"\x87"=>'++',"\x88"=>'^',"\x89"=>'%',"\x8a"=>'S',"\x8b"=>'<',"\x8c"=>'OE',"\x8e"=>'Z',"\x91"=>"'","\x92"=>"'","\x93"=>'"',"\x94"=>'"',"\x95"=>'*',"\x96"=>'-',"\x97"=>'--',"\x98"=>'~',"\x99"=>'(tm)',"\x9a"=>'s',"\x9b"=>'>',"\x9c"=>'oe',"\x9e"=>'z',"\x9f"=>'Y',);s{([\x80-\x9f])}{$ascii_for{$1} || $1}emxsg for @_}}1;
POD_SIMPLE_TRANSCODEDUMB

$fatpacked{"Pod/Simple/TranscodeSmart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_TRANSCODESMART';
  require 5;use 5.008;package Pod::Simple::TranscodeSmart;use strict;use Pod::Simple;require Encode;use vars qw($VERSION);$VERSION='3.40';sub is_dumb {0}sub is_smart {1}sub all_encodings {return Encode::->encodings(':all')}sub encoding_is_available {return Encode::resolve_alias($_[1])}sub encmodver {return "Encode.pm v" .($Encode::VERSION || '?')}sub make_transcoder {my$e=Encode::find_encoding($_[1]);die "WHAT ENCODING!?!?" unless$e;my$x;return sub {for$x (@_){$x=$e->decode($x)unless Encode::is_utf8($x)}return}}1;
POD_SIMPLE_TRANSCODESMART

$fatpacked{"Pod/Simple/XHTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XHTML';
  package Pod::Simple::XHTML;use strict;use vars qw($VERSION @ISA $HAS_HTML_ENTITIES);$VERSION='3.40';use Pod::Simple::Methody ();@ISA=('Pod::Simple::Methody');BEGIN {$HAS_HTML_ENTITIES=eval "require HTML::Entities; 1"}my%entities=(q{>}=>'gt',q{<}=>'lt',q{'}=>'#39',q{"}=>'quot',q{&}=>'amp',);sub encode_entities {my$self=shift;my$ents=$self->html_encode_chars;return HTML::Entities::encode_entities($_[0],$ents)if$HAS_HTML_ENTITIES;if (defined$ents){$ents =~ s,(?<!\\)([]/]),\\$1,g;$ents =~ s,(?<!\\)\\\z,\\\\,}else {$ents=join '',keys%entities}my$str=$_[0];$str =~ s/([$ents])/'&' . ($entities{$1} || sprintf '#x%X', ord $1) . ';'/ge;return$str}__PACKAGE__->_accessorize('perldoc_url_prefix','perldoc_url_postfix','man_url_prefix','man_url_postfix','title_prefix','title_postfix','html_css','html_javascript','html_doctype','html_charset','html_encode_chars','html_h_level','title','default_title','force_title','html_header','html_footer','index','anchor_items','backlink','batch_mode','batch_mode_current_level',);sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->perldoc_url_prefix('https://metacpan.org/pod/');$new->man_url_prefix('http://man.he.net/man');$new->html_charset('ISO-8859-1');$new->nix_X_codes(1);$new->{'scratch'}='';$new->{'to_index'}=[];$new->{'output'}=[];$new->{'saved'}=[];$new->{'ids'}={'_podtop_'=>1 };$new->{'in_li'}=[];$new->{'__region_targets'}=[];$new->{'__literal_targets'}={};$new->accept_targets_as_html('html','HTML');return$new}sub html_header_tags {my$self=shift;return$self->{html_header_tags}=shift if @_;return$self->{html_header_tags}||= '<meta http-equiv="Content-Type" content="text/html; charset=' .$self->html_charset .'" />'}sub __in_literal_xhtml_region {return unless @{$_[0]{__region_targets}};my$target=$_[0]{__region_targets}[-1];return $_[0]{__literal_targets}{$target }}sub accept_targets_as_html {my ($self,@targets)=@_;$self->accept_targets(@targets);$self->{__literal_targets}{$_}=1 for@targets}sub handle_text {my$text=$_[0]->__in_literal_xhtml_region ? $_[1]: $_[0]->encode_entities($_[1]);if ($_[0]{'in_code'}&& @{$_[0]{'in_code'}}){$_[0]->handle_code($_[1],$_[0]{'in_code'}[-1])}else {if ($_[0]->{in_for}){my$newlines=$_[0]->__in_literal_xhtml_region ? "\n\n" : '';if ($_[0]->{started_for}){if ($text =~ /\S/){delete $_[0]->{started_for};$_[0]{'scratch'}.= $text .$newlines}}else {$text =~ s/\n\z//;$_[0]{'scratch'}.= $text .$newlines}}else {$_[0]{'scratch'}.= $text}}$_[0]{htext}.= $text if $_[0]{'in_head'}}sub start_code {$_[0]{'scratch'}.= '<code>'}sub end_code {$_[0]{'scratch'}.= '</code>'}sub handle_code {$_[0]{'scratch'}.= $_[0]->encode_entities($_[1])}sub start_Para {$_[0]{'scratch'}.= '<p>'}sub start_Verbatim {$_[0]{'scratch'}='<pre>';push(@{$_[0]{'in_code'}},'Verbatim');$_[0]->start_code($_[0]{'in_code'}[-1])}sub start_head1 {$_[0]{'in_head'}=1;$_[0]{htext}=''}sub start_head2 {$_[0]{'in_head'}=2;$_[0]{htext}=''}sub start_head3 {$_[0]{'in_head'}=3;$_[0]{htext}=''}sub start_head4 {$_[0]{'in_head'}=4;$_[0]{htext}=''}sub start_item_number {$_[0]{'scratch'}="</li>\n" if ($_[0]{'in_li'}->[-1]&& pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '<li><p>';push @{$_[0]{'in_li'}},1}sub start_item_bullet {$_[0]{'scratch'}="</li>\n" if ($_[0]{'in_li'}->[-1]&& pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '<li><p>';push @{$_[0]{'in_li'}},1}sub start_item_text {}sub start_over_bullet {$_[0]{'scratch'}='<ul>';push @{$_[0]{'in_li'}},0;$_[0]->emit}sub start_over_block {$_[0]{'scratch'}='<ul>';$_[0]->emit}sub start_over_number {$_[0]{'scratch'}='<ol>';push @{$_[0]{'in_li'}},0;$_[0]->emit}sub start_over_text {$_[0]{'scratch'}='<dl>';$_[0]{'dl_level'}++;$_[0]{'in_dd'}||= [];$_[0]->emit}sub end_over_block {$_[0]{'scratch'}.= '</ul>';$_[0]->emit}sub end_over_number {$_[0]{'scratch'}="</li>\n" if (pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '</ol>';pop @{$_[0]{'in_li'}};$_[0]->emit}sub end_over_bullet {$_[0]{'scratch'}="</li>\n" if (pop @{$_[0]{'in_li'}});$_[0]{'scratch'}.= '</ul>';pop @{$_[0]{'in_li'}};$_[0]->emit}sub end_over_text {if ($_[0]{'in_dd'}[$_[0]{'dl_level'}]){$_[0]{'scratch'}="</dd>\n";$_[0]{'in_dd'}[$_[0]{'dl_level'}]=0}$_[0]{'scratch'}.= '</dl>';$_[0]{'dl_level'}--;$_[0]->emit}sub end_Para {$_[0]{'scratch'}.= '</p>';$_[0]->emit}sub end_Verbatim {$_[0]->end_code(pop(@{$_[0]->{'in_code'}}));$_[0]{'scratch'}.= '</pre>';$_[0]->emit}sub _end_head {my$h=delete $_[0]{in_head};my$add=$_[0]->html_h_level;$add=1 unless defined$add;$h += $add - 1;my$id=$_[0]->idify($_[0]{htext});my$text=$_[0]{scratch};$_[0]{'scratch'}=$_[0]->backlink && ($h - $add==0)? qq{<a href="#_podtop_"><h$h id="$id">$text</h$h></a>} : qq{<h$h id="$id">$text</h$h>};$_[0]->emit;push @{$_[0]{'to_index'}},[$h,$id,delete $_[0]{'htext'}]}sub end_head1 {shift->_end_head(@_)}sub end_head2 {shift->_end_head(@_)}sub end_head3 {shift->_end_head(@_)}sub end_head4 {shift->_end_head(@_)}sub end_item_bullet {$_[0]{'scratch'}.= '</p>';$_[0]->emit}sub end_item_number {$_[0]{'scratch'}.= '</p>';$_[0]->emit}sub end_item_text {my$dt_id=$_[0]{'anchor_items'}? ' id="'.$_[0]->idify($_[0]{'scratch'}).'"' : '';my$text=$_[0]{scratch};$_[0]{'scratch'}='';if ($_[0]{'in_dd'}[$_[0]{'dl_level'}]){$_[0]{'scratch'}="</dd>\n";$_[0]{'in_dd'}[$_[0]{'dl_level'}]=0}$_[0]{'scratch'}.= qq{<dt$dt_id>$text</dt>\n<dd>};$_[0]{'in_dd'}[$_[0]{'dl_level'}]=1;$_[0]->emit}sub start_for {my ($self,$flags)=@_;push @{$self->{__region_targets}},$flags->{target_matching};$self->{started_for}=1;$self->{in_for}=1;unless ($self->__in_literal_xhtml_region){$self->{scratch}.= '<div';$self->{scratch}.= qq( class="$flags->{target}") if$flags->{target};$self->{scratch}.= ">\n\n"}}sub end_for {my ($self)=@_;delete$self->{started_for};delete$self->{in_for};if ($self->__in_literal_xhtml_region){$self->{'scratch'}=~ s/\s+\z//s}else {$self->{'scratch'}.= '</div>'}pop @{$self->{__region_targets}};$self->emit}sub start_Document {my ($self)=@_;if (defined$self->html_header){$self->{'scratch'}.= $self->html_header;$self->emit unless$self->html_header eq ""}else {my ($doctype,$title,$metatags,$bodyid);$doctype=$self->html_doctype || '';$title=$self->force_title || $self->title || $self->default_title || '';$metatags=$self->html_header_tags || '';if (my$css=$self->html_css){if ($css !~ /<link/){$metatags .= '<link rel="stylesheet" href="' .$self->encode_entities($css).'" type="text/css" />'}else {$metatags .= $css}}if ($self->html_javascript){$metatags .= qq{\n<script type="text/javascript" src="} .$self->html_javascript .'"></script>'}$bodyid=$self->backlink ? ' id="_podtop_"' : '';$self->{'scratch'}.= <<"HTML";$self->emit}}sub end_Document {my ($self)=@_;my$to_index=$self->{'to_index'};if ($self->index && @{$to_index}){my@out;my$level=0;my$indent=-1;my$space='';my$id=' id="index"';for my$h (@{$to_index},[0]){my$target_level=$h->[0];if ($level==$target_level){$out[-1].= '</li>'}elsif ($level > $target_level){$out[-1].= '</li>' if$out[-1]=~ /^\s+<li>/;while ($level > $target_level){--$level;push@out,('  ' x --$indent).'</li>' if@out && $out[-1]=~ m{^\s+<\/ul};push@out,('  ' x --$indent).'</ul>'}push@out,('  ' x --$indent).'</li>' if$level}else {while ($level < $target_level){++$level;push@out,('  ' x ++$indent).'<li>' if@out && $out[-1]=~ /^\s*<ul/;push@out,('  ' x ++$indent)."<ul$id>";$id=''}++$indent}next unless$level;$space='  ' x $indent;push@out,sprintf '%s<li><a href="#%s">%s</a>',$space,$h->[1],$h->[2]}my$offset=defined$self->html_header ? $self->html_header eq '' ? 0 : 1 : 1;splice @{$self->{'output'}},$offset,0,join "\n",@out}if (defined$self->html_footer){$self->{'scratch'}.= $self->html_footer;$self->emit unless$self->html_footer eq ""}else {$self->{'scratch'}.= "</body>\n</html>";$self->emit}if ($self->index){print {$self->{'output_fh'}}join ("\n\n",@{$self->{'output'}}),"\n\n";@{$self->{'output'}}=()}}sub start_B {$_[0]{'scratch'}.= '<b>'}sub end_B {$_[0]{'scratch'}.= '</b>'}sub start_C {push(@{$_[0]{'in_code'}},'C');$_[0]->start_code($_[0]{'in_code'}[-1])}sub end_C {$_[0]->end_code(pop(@{$_[0]{'in_code'}}))}sub start_F {$_[0]{'scratch'}.= '<i>'}sub end_F {$_[0]{'scratch'}.= '</i>'}sub start_I {$_[0]{'scratch'}.= '<i>'}sub end_I {$_[0]{'scratch'}.= '</i>'}sub start_L {my ($self,$flags)=@_;my ($type,$to,$section)=@{$flags}{'type','to','section'};my$url=$self->encode_entities($type eq 'url' ? $to : $type eq 'pod' ? $self->resolve_pod_page_link($to,$section): $type eq 'man' ? $self->resolve_man_page_link($to,$section): undef);$self->{'scratch'}.= '<a' .($url ? ' href="'.$url .'">' : '>')}sub end_L {$_[0]{'scratch'}.= '</a>'}sub start_S {$_[0]{'scratch'}.= '<span style="white-space: nowrap;">'}sub end_S {$_[0]{'scratch'}.= '</span>'}sub emit {my($self)=@_;if ($self->index){push @{$self->{'output'}},$self->{'scratch'}}else {print {$self->{'output_fh'}}$self->{'scratch'},"\n\n"}$self->{'scratch'}='';return}sub resolve_pod_page_link {my ($self,$to,$section)=@_;return undef unless defined$to || defined$section;if (defined$section){$section='#' .$self->idify($self->encode_entities($section),1);return$section unless defined$to}else {$section=''}return ($self->perldoc_url_prefix || '').$self->encode_entities($to).$section .($self->perldoc_url_postfix || '')}sub resolve_man_page_link {my ($self,$to,$section)=@_;return undef unless defined$to;my ($page,$part)=$to =~ /^([^(]+)(?:[(](\d+)[)])?$/;return undef unless$page;return ($self->man_url_prefix || '').($part || 1)."/" .$self->encode_entities($page).($self->man_url_postfix || '')}sub idify {my ($self,$t,$not_unique)=@_;for ($t){s/<[^>]+>//g;s/&[^;]+;//g;s/^\s+//;s/\s+$//;s/^([^a-zA-Z]+)$/pod$1/;s/^[^a-zA-Z]+//;s/[^-a-zA-Z0-9_:.]+/-/g;s/[-:.]+$//}return$t if$not_unique;my$i='';$i++ while$self->{ids}{"$t$i"}++;return "$t$i"}sub batch_mode_page_object_init {my ($self,$batchconvobj,$module,$infile,$outfile,$depth)=@_;$self->batch_mode(1);$self->batch_mode_current_level($depth);return$self}sub html_header_after_title {}1;
  $doctype
  <html>
  <head>
  <title>$title</title>
  $metatags
  </head>
  <body$bodyid>
  HTML
POD_SIMPLE_XHTML

$fatpacked{"Pod/Simple/XMLOutStream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SIMPLE_XMLOUTSTREAM';
  require 5;package Pod::Simple::XMLOutStream;use strict;use Carp ();use Pod::Simple ();use vars qw($ATTR_PAD @ISA $VERSION $SORT_ATTRS);$VERSION='3.40';BEGIN {@ISA=('Pod::Simple');*DEBUG=\&Pod::Simple::DEBUG unless defined&DEBUG}$ATTR_PAD="\n" unless defined$ATTR_PAD;$SORT_ATTRS=0 unless defined$SORT_ATTRS;sub new {my$self=shift;my$new=$self->SUPER::new(@_);$new->{'output_fh'}||= *STDOUT{IO};$new->keep_encoding_directive(1);return$new}sub _handle_element_start {my$fh=$_[0]{'output_fh'};my($key,$value);DEBUG and print STDERR "++ $_[1]\n";print$fh "<",$_[1];if($SORT_ATTRS){for my$key (sort keys %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_xml_escape($value=$_[2]{$key});print$fh $ATTR_PAD,$key,'="',$value,'"'}}}else {while(($key,$value)=each %{$_[2]}){unless($key =~ m/^~/s){next if$key eq 'start_line' and $_[0]{'hide_line_numbers'};_xml_escape($value);print$fh $ATTR_PAD,$key,'="',$value,'"'}}}print$fh ">";return}sub _handle_text {DEBUG and print STDERR "== \"$_[1]\"\n";if(length $_[1]){my$text=$_[1];_xml_escape($text);print {$_[0]{'output_fh'}}$text}return}sub _handle_element_end {DEBUG and print STDERR "-- $_[1]\n";print {$_[0]{'output_fh'}}"</",$_[1],">";return}sub _xml_escape {for my$x (@_){if ($] ge 5.007_003){$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(utf8::native_to_unicode(ord($1))).';'/eg}else {$x =~ s/([^-\n\t !\#\$\%\(\)\*\+,\.\~\/\:\;=\?\@\[\\\]\^_\`\{\|\}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789])/'&#'.(ord($1)).';'/eg}}return}1;
POD_SIMPLE_XMLOUTSTREAM

$fatpacked{"Pod/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT';
  package Pod::Text;use 5.006;use strict;use warnings;use vars qw(@ISA @EXPORT %ESCAPES $VERSION);use Carp qw(carp croak);use Encode qw(encode);use Exporter ();use Pod::Simple ();@ISA=qw(Pod::Simple Exporter);@EXPORT=qw(pod2text);$VERSION='4.12';my ($NBSP,$SHY);if ($Pod::Simple::VERSION ge 3.30){$NBSP=$Pod::Simple::nbsp;$SHY=$Pod::Simple::shy}else {if ($] ge 5.007_003){$NBSP=chr utf8::unicode_to_native(0xA0);$SHY=chr utf8::unicode_to_native(0xAD)}elsif (Pod::Simple::ASCII){$NBSP="\xA0";$SHY="\xAD"}else {$NBSP="\x41";$SHY="\xCA"}}sub handle_code {my ($line,$number,$parser)=@_;$parser->output_code ($line ."\n")}sub new {my$class=shift;my$self=$class->SUPER::new;$self->nbsp_for_S (1);if ($self->can ('preserve_whitespace')){$self->preserve_whitespace (1)}else {$self->fullstop_space_harden (1)}$self->accept_targets (qw/text TEXT/);$self->merge_text (1);my%opts=@_;my@opts=map {("opt_$_",$opts{$_})}keys%opts;%$self=(%$self,@opts);if ($$self{opt_stderr}and not $$self{opt_errors}){$$self{opt_errors}='stderr'}delete $$self{opt_stderr};if (not defined $$self{opt_errors}){$$self{opt_errors}='pod'}if ($$self{opt_errors}eq 'stderr' || $$self{opt_errors}eq 'die'){$self->no_errata_section (1);$self->complain_stderr (1);if ($$self{opt_errors}eq 'die'){$$self{complain_die}=1}}elsif ($$self{opt_errors}eq 'pod'){$self->no_errata_section (0);$self->complain_stderr (0)}elsif ($$self{opt_errors}eq 'none'){$self->no_errata_section (1);$self->no_whining (1)}else {croak (qq(Invalid errors setting: "$$self{errors}"))}delete $$self{errors};$$self{opt_alt}=0 unless defined $$self{opt_alt};$$self{opt_indent}=4 unless defined $$self{opt_indent};$$self{opt_margin}=0 unless defined $$self{opt_margin};$$self{opt_loose}=0 unless defined $$self{opt_loose};$$self{opt_sentence}=0 unless defined $$self{opt_sentence};$$self{opt_width}=76 unless defined $$self{opt_width};$$self{opt_quotes}||= '"';if ($$self{opt_quotes}eq 'none'){$$self{LQUOTE}=$$self{RQUOTE}=''}elsif (length ($$self{opt_quotes})==1){$$self{LQUOTE}=$$self{RQUOTE}=$$self{opt_quotes}}elsif (length ($$self{opt_quotes})% 2==0){my$length=length ($$self{opt_quotes})/ 2;$$self{LQUOTE}=substr ($$self{opt_quotes},0,$length);$$self{RQUOTE}=substr ($$self{opt_quotes},$length)}else {croak qq(Invalid quote specification "$$self{opt_quotes}")}$self->code_handler (\&handle_code)if $$self{opt_code};return$self}sub _handle_text {my ($self,$text)=@_;my$tag=$$self{PENDING}[-1];$$tag[1].= $text}sub method_for_element {my ($self,$element)=@_;$element =~ tr/-/_/;$element =~ tr/A-Z/a-z/;$element =~ tr/_a-z0-9//cd;return$element}sub _handle_element_start {my ($self,$element,$attrs)=@_;my$method=$self->method_for_element ($element);if ($self->can ("cmd_$method")){push (@{$$self{PENDING}},[$attrs,'' ])}elsif ($self->can ("start_$method")){my$method='start_' .$method;$self->$method ($attrs,'')}}sub _handle_element_end {my ($self,$element)=@_;my$method=$self->method_for_element ($element);if ($self->can ("cmd_$method")){my$tag=pop @{$$self{PENDING}};my$method='cmd_' .$method;my$text=$self->$method (@$tag);if (defined$text){if (@{$$self{PENDING}}> 1){$$self{PENDING}[-1][1].= $text}else {$self->output ($text)}}}elsif ($self->can ("end_$method")){my$method='end_' .$method;$self->$method ()}}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};while (length > $width){if (s/^([^\n]{0,$width})\s+// || s/^([^\n]{$width})//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;return$output}sub reformat {my$self=shift;local $_=shift;if ($$self{opt_sentence}){s/ +$//mg;s/\.\n/. \n/g;s/\n/ /g;s/   +/  /g}else {s/\s+/ /g}return$self->wrap ($_)}sub output {my ($self,@text)=@_;my$text=join ('',@text);if ($NBSP){$text =~ s/$NBSP/ /g}if ($SHY){$text =~ s/$SHY//g}unless ($$self{opt_utf8}){my$encoding=$$self{encoding}|| '';if ($encoding && $encoding ne $$self{ENCODING}){$$self{ENCODING}=$encoding;eval {binmode ($$self{output_fh},":encoding($encoding)")}}}if ($$self{ENCODE}){print {$$self{output_fh}}encode ('UTF-8',$text)}else {print {$$self{output_fh}}$text}}sub output_code {$_[0]->output ($_[1])}sub start_document {my ($self,$attrs)=@_;if ($$attrs{contentless}&&!$$self{ALWAYS_EMIT_SOMETHING}){$$self{CONTENTLESS}=1}else {delete $$self{CONTENTLESS}}my$margin=$$self{opt_indent}+ $$self{opt_margin};$$self{INDENTS}=[];$$self{MARGIN}=$margin;$$self{PENDING}=[[]];$$self{ENCODING}='';$$self{ENCODE}=0;if ($$self{opt_utf8}){$$self{ENCODE}=1;eval {my@options=(output=>1,details=>1);my$flag=(PerlIO::get_layers ($$self{output_fh},@options))[-1];if ($flag & PerlIO::F_UTF8 ()){$$self{ENCODE}=0;$$self{ENCODING}='UTF-8'}}}return ''}sub end_document {my ($self)=@_;if ($$self{complain_die}&& $self->errors_seen){croak ("POD document had syntax errors")}}sub strip_format {my ($self,$string)=@_;return$string}sub item {my ($self,$text)=@_;my$tag=$$self{ITEM};unless (defined$tag){carp "Item called without tag";return}undef $$self{ITEM};my$indent=$$self{INDENTS}[-1];$indent=$$self{opt_indent}unless defined$indent;my$margin=' ' x $$self{opt_margin};my$tag_length=length ($self->strip_format ($tag));my$fits=($$self{MARGIN}- $indent >= $tag_length + 1);if (!$text || $text =~ /^\s+$/ ||!$fits){my$realindent=$$self{MARGIN};$$self{MARGIN}=$indent;my$output=$self->reformat ($tag);$output =~ s/^$margin /$margin:/ if ($$self{opt_alt}&& $indent > 0);$output =~ s/\n*$/\n/;$output .= "\n" if$text && $text =~ /^\s*$/;$self->output ($output);$$self{MARGIN}=$realindent;$self->output ($self->reformat ($text))if ($text && $text =~ /\S/)}else {my$space=' ' x $indent;$space =~ s/^$margin /$margin:/ if $$self{opt_alt};$text=$self->reformat ($text);$text =~ s/^$margin /$margin:/ if ($$self{opt_alt}&& $indent > 0);my$tagspace=' ' x $tag_length;$text =~ s/^($space)$tagspace/$1$tag/ or warn "Bizarre space in item";$self->output ($text)}}sub cmd_para {my ($self,$attrs,$text)=@_;$text =~ s/\s+$/\n/;if (defined $$self{ITEM}){$self->item ($text ."\n")}else {$self->output ($self->reformat ($text ."\n"))}return ''}sub cmd_verbatim {my ($self,$attrs,$text)=@_;$self->item if defined $$self{ITEM};return if$text =~ /^\s*$/;$text =~ s/^(\n*)([ \t]*\S+)/$1 . (' ' x $$self{MARGIN}) . $2/gme;$text =~ s/\s*$/\n\n/;$self->output ($text);return ''}sub cmd_data {my ($self,$attrs,$text)=@_;$text =~ s/^\n+//;$text =~ s/\n{0,2}$/\n/;$self->output ($text);return ''}sub heading {my ($self,$text,$indent,$marker)=@_;$self->item ("\n\n")if defined $$self{ITEM};$text =~ s/\s+$//;if ($$self{opt_alt}){my$closemark=reverse (split (//,$marker));my$margin=' ' x $$self{opt_margin};$self->output ("\n" ."$margin$marker $text $closemark" ."\n\n")}else {$text .= "\n" if $$self{opt_loose};my$margin=' ' x ($$self{opt_margin}+ $indent);$self->output ($margin .$text ."\n")}return ''}sub cmd_head1 {my ($self,$attrs,$text)=@_;$self->heading ($text,0,'====')}sub cmd_head2 {my ($self,$attrs,$text)=@_;$self->heading ($text,$$self{opt_indent}/ 2,'==  ')}sub cmd_head3 {my ($self,$attrs,$text)=@_;$self->heading ($text,$$self{opt_indent}* 2 / 3 + 0.5,'=   ')}sub cmd_head4 {my ($self,$attrs,$text)=@_;$self->heading ($text,$$self{opt_indent}* 3 / 4 + 0.5,'-   ')}sub over_common_start {my ($self,$attrs)=@_;$self->item ("\n\n")if defined $$self{ITEM};my$indent=$$attrs{indent};unless (defined ($indent)&& $indent =~ /^\s*[-+]?\d{1,4}\s*$/){$indent=$$self{opt_indent}}push (@{$$self{INDENTS}},$$self{MARGIN});$$self{MARGIN}+= ($indent + 0);return ''}sub over_common_end {my ($self)=@_;$self->item ("\n\n")if defined $$self{ITEM};$$self{MARGIN}=pop @{$$self{INDENTS}};return ''}sub start_over_bullet {$_[0]->over_common_start ($_[1])}sub start_over_number {$_[0]->over_common_start ($_[1])}sub start_over_text {$_[0]->over_common_start ($_[1])}sub start_over_block {$_[0]->over_common_start ($_[1])}sub end_over_bullet {$_[0]->over_common_end}sub end_over_number {$_[0]->over_common_end}sub end_over_text {$_[0]->over_common_end}sub end_over_block {$_[0]->over_common_end}sub item_common {my ($self,$type,$attrs,$text)=@_;$self->item if defined $$self{ITEM};$text =~ s/\s+$//;my ($item,$index);if ($type eq 'bullet'){$item='*'}elsif ($type eq 'number'){$item=$$attrs{'~orig_content'}}else {$item=$text;$item =~ s/\s*\n\s*/ /g;$text=''}$$self{ITEM}=$item;if ($text){$text =~ s/\s*$/\n/;$self->item ($text)}return ''}sub cmd_item_bullet {my$self=shift;$self->item_common ('bullet',@_)}sub cmd_item_number {my$self=shift;$self->item_common ('number',@_)}sub cmd_item_text {my$self=shift;$self->item_common ('text',@_)}sub cmd_item_block {my$self=shift;$self->item_common ('block',@_)}sub cmd_b {return $_[0]{alt}? "``$_[2]''" : $_[2]}sub cmd_f {return $_[0]{alt}? "\"$_[2]\"" : $_[2]}sub cmd_i {return '*' .$_[2].'*'}sub cmd_x {return ''}sub cmd_c {my ($self,$attrs,$text)=@_;my$index='(?: \[.*\] | \{.*\} )?';$text =~ m{
        ^\s*
        (?:
           ( [\'\`\"] ) .* \1                             # already quoted
         | \` .* \'                                       # `quoted'
         | \$+ [\#^]? \S $index                           # special ($^Foo, $")
         | [\$\@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
         | [\$\@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
         | [+-]? ( \d[\d.]* | \.\d+ ) (?: [eE][+-]?\d+ )? # a number
         | 0x [a-fA-F\d]+                                 # a hex constant
        )
        \s*\z
       }xo && return$text;return $$self{opt_alt}? "``$text''" : "$$self{LQUOTE}$text$$self{RQUOTE}"}sub cmd_l {my ($self,$attrs,$text)=@_;if ($$attrs{type}eq 'url'){if (not defined($$attrs{to})or $$attrs{to}eq $text){return "<$text>"}elsif ($$self{opt_nourls}){return$text}else {return "$text <$$attrs{to}>"}}else {return$text}}sub pod2text {my@args;while ($_[0]=~ /^-/){my$flag=shift;if ($flag eq '-a'){push (@args,alt=>1)}elsif ($flag =~ /^-(\d+)$/){push (@args,width=>$1)}else {unshift (@_,$flag);last}}my$parser=Pod::Text->new (@args);if (defined $_[1]){my@fhs=@_;local*IN;unless (open (IN,$fhs[0])){croak ("Can't open $fhs[0] for reading: $!\n");return}$fhs[0]=\*IN;$parser->output_fh ($fhs[1]);my$retval=$parser->parse_file ($fhs[0]);my$fh=$parser->output_fh ();close$fh;return$retval}else {$parser->output_fh (\*STDOUT);return$parser->parse_file (@_)}}sub parse_from_file {my$self=shift;$self->reinit;if (ref ($_[0])eq 'HASH'){my$opts=shift @_;if (defined ($$opts{-cutting})&&!$$opts{-cutting}){$$self{in_pod}=1;$$self{last_was_blank}=1}}my$retval=$self->Pod::Simple::parse_from_file (@_);my$fh=$self->output_fh ();my$oldfh=select$fh;my$oldflush=$|;$|=1;print$fh '';$|=$oldflush;select$oldfh;return$retval}sub parse_from_filehandle {my$self=shift;$self->parse_from_file (@_)}sub parse_file {my ($self,$in)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_file ($in)}sub parse_lines {my ($self,@lines)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_lines (@lines)}sub parse_string_document {my ($self,$doc)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_string_document ($doc)}1;
POD_TEXT

$fatpacked{"Pod/Text/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_COLOR';
  package Pod::Text::Color;use 5.006;use strict;use warnings;use Pod::Text ();use Term::ANSIColor qw(color colored);use vars qw(@ISA $VERSION);@ISA=qw(Pod::Text);$VERSION='4.12';sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;local$Term::ANSIColor::EACHLINE="\n";$self->SUPER::cmd_head1 ($attrs,colored ($text,'bold'))}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head2 ($attrs,colored ($text,'bold'))}sub cmd_b {return colored ($_[2],'bold')}sub cmd_f {return colored ($_[2],'cyan')}sub cmd_i {return colored ($_[2],'yellow')}sub end_format {my ($self,$line)=@_;my$reset=color ('reset');my$current;while ($line =~ /(\e\[[\d;]+m)/g){my$code=$1;if ($code eq $reset){undef$current}else {$current .= $code}}return$current}sub output_code {my ($self,$code)=@_;local$Term::ANSIColor::EACHLINE="\n";$code=colored ($code,'green');$self->output ($code)}sub strip_format {my ($self,$text)=@_;$text =~ s/\e\[[\d;]*m//g;return$text}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};my$code='(?:\e\[[\d;]+m)';my$char="(?>$code*[^\\n])";my$shortchar='^(' .$char ."{0,$width}(?>$code*)" .')(?:\s+|\z)';my$longchar='^(' .$char ."{$width})";while (length > $width){if (s/$shortchar// || s/$longchar//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;if ($output =~ /\n/){my@lines=split (/\n/,$output);my$start_format;for my$line (@lines){if ($start_format && $line =~ /\S/){$line =~ s/^(\s*)(\S)/$1$start_format$2/}$start_format=$self->end_format ($line);if ($start_format){$line .= color ('reset')}}$output=join ("\n",@lines)}$output =~ s/\s+$/\n\n/;$output}1;
POD_TEXT_COLOR

$fatpacked{"Pod/Text/Overstrike.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_OVERSTRIKE';
  package Pod::Text::Overstrike;use 5.006;use strict;use warnings;use vars qw(@ISA $VERSION);use Pod::Text ();@ISA=qw(Pod::Text);$VERSION='4.12';sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/$1\b$1/g;return$self->SUPER::cmd_head1 ($attrs,$text)}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/$1\b$1/g;return$self->SUPER::cmd_head2 ($attrs,$text)}sub cmd_head3 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/_\b$1/g;return$self->SUPER::cmd_head3 ($attrs,$text)}sub cmd_head4 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/_\b$1/g;return$self->SUPER::cmd_head4 ($attrs,$text)}sub heading {my ($self,$text,$indent,$marker)=@_;$self->item ("\n\n")if defined $$self{ITEM};$text .= "\n" if $$self{opt_loose};my$margin=' ' x ($$self{opt_margin}+ $indent);$self->output ($margin .$text ."\n");return ''}sub cmd_b {local $_=$_[0]->strip_format ($_[2]);s/(.)/$1\b$1/g;$_}sub cmd_f {local $_=$_[0]->strip_format ($_[2]);s/(.)/_\b$1/g;$_}sub cmd_i {local $_=$_[0]->strip_format ($_[2]);s/(.)/_\b$1/g;$_}sub output_code {my ($self,$code)=@_;$code =~ s/(.)/$1\b$1/g;$self->output ($code)}sub strip_format {my ($self,$text)=@_;$text =~ s/(.)[\b]\1/$1/g;$text =~ s/_[\b]//g;return$text}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};while (length > $width){my$char='(?:[^\n][\b])?[^\n]';if (s/^((?>$char){0,$width})(?:\Z|\s+)//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;return$output}1;
POD_TEXT_OVERSTRIKE

$fatpacked{"Pod/Text/Termcap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_TERMCAP';
  package Pod::Text::Termcap;use 5.006;use strict;use warnings;use Pod::Text ();use POSIX ();use Term::Cap;use vars qw(@ISA $VERSION);@ISA=qw(Pod::Text);$VERSION='4.12';sub new {my ($self,%args)=@_;my ($ospeed,$term,$termios);unless (exists$ENV{TERMPATH}){my$home=exists$ENV{HOME}? "$ENV{HOME}/.termcap:" : '';$ENV{TERMPATH}="${home}/etc/termcap:/usr/share/misc/termcap:/usr/share/lib/termcap"}eval {$termios=POSIX::Termios->new};if ($@){$ospeed=9600}else {$termios->getattr;$ospeed=$termios->getospeed || 9600}my ($bold,$undl,$norm,$width);eval {my$term=Tgetent Term::Cap {TERM=>undef,OSPEED=>$ospeed};$bold=$term->Tputs('md');$undl=$term->Tputs('us');$norm=$term->Tputs('me');if (defined $$term{_co}){$width=$$term{_co};$width =~ s/^\#//}};unless (defined$args{width}){$args{width}=$ENV{COLUMNS}|| $width || 80;$args{width}-= 2}$self=$self->SUPER::new (%args);$$self{BOLD}=$bold || "\e[1m";$$self{UNDL}=$undl || "\e[4m";$$self{NORM}=$norm || "\e[m";return$self}sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head1 ($attrs,"$$self{BOLD}$text$$self{NORM}")}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head2 ($attrs,"$$self{BOLD}$text$$self{NORM}")}sub cmd_b {my$self=shift;return "$$self{BOLD}$_[1]$$self{NORM}"}sub cmd_i {my$self=shift;return "$$self{UNDL}$_[1]$$self{NORM}"}sub end_format {my ($self,$line)=@_;my$pattern="(\Q$$self{BOLD}\E|\Q$$self{UNDL}\E|\Q$$self{NORM}\E)";my$current;while ($line =~ /$pattern/g){my$code=$1;if ($code eq $$self{NORM}){undef$current}else {$current .= $code}}return$current}sub output_code {my ($self,$code)=@_;$self->output ($$self{BOLD}.$code .$$self{NORM})}sub strip_format {my ($self,$text)=@_;$text =~ s/\Q$$self{BOLD}//g;$text =~ s/\Q$$self{UNDL}//g;$text =~ s/\Q$$self{NORM}//g;return$text}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};my$code="(?:\Q$$self{BOLD}\E|\Q$$self{UNDL}\E|\Q$$self{NORM}\E)";my$char="(?>$code*[^\\n])";my$shortchar='^(' .$char ."{0,$width}(?>$code*)" .')(?:\s+|\z)';my$longchar='^(' .$char ."{$width})";while (length > $width){if (s/$shortchar// || s/$longchar//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;if ($output =~ /\n/){my@lines=split (/\n/,$output);my$start_format;for my$line (@lines){if ($start_format && $line =~ /\S/){$line =~ s/^(\s*)(\S)/$1$start_format$2/}$start_format=$self->end_format ($line);if ($start_format){$line .= $$self{NORM}}}$output=join ("\n",@lines)}$output =~ s/\s+$/\n\n/;return$output}1;
POD_TEXT_TERMCAP

$fatpacked{"String/ShellQuote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRING_SHELLQUOTE';
  package String::ShellQuote;use strict;use vars qw($VERSION @ISA @EXPORT);require Exporter;$VERSION='1.04';@ISA=qw(Exporter);@EXPORT=qw(shell_quote shell_quote_best_effort shell_comment_quote);sub croak {require Carp;goto&Carp::croak}sub _shell_quote_backend {my@in=@_;my@err=();if (0){require RS::Handy;print RS::Handy::data_dump(\@in)}return \@err,'' unless@in;my$ret='';my$saw_non_equal=0;for (@in){if (!defined $_ or $_ eq ''){$_="''";next}if (s/\x00//g){push@err,"No way to quote string containing null (\\000) bytes"}my$escape=0;if (/=/){if (!$saw_non_equal){$escape=1}}else {$saw_non_equal=1}if (m|[^\w!%+,\-./:=@^]|){$escape=1}if ($escape || (!$saw_non_equal && /=/)){s/'/'\\''/g;s|((?:'\\''){2,})|q{'"} . (q{'} x (length($1) / 4)) . q{"'}|ge;$_="'$_'";s/^''//;s/''$//}}continue {$ret .= "$_ "}chop$ret;return \@err,$ret}sub shell_quote {my ($rerr,$s)=_shell_quote_backend @_;if (@$rerr){my%seen;@$rerr=grep {!$seen{$_}++}@$rerr;my$s=join '',map {"shell_quote(): $_\n"}@$rerr;chomp$s;croak$s}return$s}sub shell_quote_best_effort {my ($rerr,$s)=_shell_quote_backend @_;return$s}sub shell_comment_quote {return '' unless @_;unless (@_==1){croak "Too many arguments to shell_comment_quote " ."(got " .@_ ." expected 1)"}local $_=shift;s/\n/\n#/g;return $_}1;
STRING_SHELLQUOTE

$fatpacked{"Tie/Handle/Offset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIE_HANDLE_OFFSET';
  use strict;BEGIN{if (not $] < 5.006){require warnings;warnings->import}}package Tie::Handle::Offset;our$VERSION='0.004';use Tie::Handle;our@ISA=qw/Tie::Handle/;sub offset {my$self=shift;if (@_){return ${*$self}{offset}=shift}else {return ${*$self}{offset}}}sub TIEHANDLE {my$class=shift;my$params;$params=pop if ref $_[-1]eq 'HASH';my$self=\do {no warnings 'once';local*HANDLE};bless$self,$class;$self->OPEN(@_)if (@_);if ($params->{offset}){seek($self,$self->offset($params->{offset}),0)}return$self}sub TELL {my$cur=tell($_[0])- $_[0]->offset;return$cur > 0 ? $cur : 0}sub SEEK {my ($self,$pos,$whence)=@_;my$rc;if ($whence==0 || $whence==1){$rc=seek($self,$pos + $self->offset,$whence)}elsif (_size($self)+ $pos < $self->offset){$rc=''}else {$rc=seek($self,$pos,$whence)}return$rc}sub OPEN {$_[0]->offset(0);$_[0]->CLOSE if defined($_[0]->FILENO);@_==2 ? open($_[0],$_[1]): open($_[0],$_[1],$_[2])}sub _size {my ($self)=@_;my$cur=tell($self);seek($self,0,2);my$size=tell($self);seek($self,$cur,0);return$size}sub EOF {eof($_[0])}sub FILENO {fileno($_[0])}sub CLOSE {close($_[0])}sub BINMODE {binmode($_[0])}sub READ {read($_[0],$_[1],$_[2])}sub READLINE {my$fh=$_[0];<$fh>}sub GETC {getc($_[0])}sub WRITE {my$fh=$_[0];print$fh substr($_[1],0,$_[2])}1;
TIE_HANDLE_OFFSET

$fatpacked{"Tie/Handle/SkipHeader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIE_HANDLE_SKIPHEADER';
  use strict;BEGIN{if (not $] < 5.006){require warnings;warnings->import}}package Tie::Handle::SkipHeader;our$VERSION='0.004';use Tie::Handle::Offset;our@ISA=qw/Tie::Handle::Offset/;sub TIEHANDLE {my$class=shift;pop if ref $_[-1]eq 'HASH';return$class->SUPER::TIEHANDLE(@_)}sub OPEN {my$self=shift;my$rc=$self->SUPER::OPEN(@_);while (my$line=<$self>){last if$line =~ /\A\s*\Z/}$self->offset(tell($self));return$rc}1;
TIE_HANDLE_SKIPHEADER

$fatpacked{"URI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI';
  package URI;use strict;use warnings;our$VERSION='1.76';our ($ABS_REMOTE_LEADING_DOTS,$ABS_ALLOW_RELATIVE_SCHEME,$DEFAULT_QUERY_FORM_DELIMITER);my%implements;our$reserved=q(;/?:@&=+$,[]);our$mark=q(-_.!~*'());our$unreserved="A-Za-z0-9\Q$mark\E";our$uric=quotemeta($reserved).$unreserved ."%";our$scheme_re='[a-zA-Z][a-zA-Z0-9.+\-]*';use Carp ();use URI::Escape ();use overload ('""'=>sub {${$_[0]}},'=='=>sub {_obj_eq(@_)},'!='=>sub {!_obj_eq(@_)},fallback=>1,);sub _obj_eq {return overload::StrVal($_[0])eq overload::StrVal($_[1])}sub new {my($class,$uri,$scheme)=@_;$uri=defined ($uri)? "$uri" : "";$uri =~ s/^<(?:URL:)?(.*)>$/$1/;$uri =~ s/^"(.*)"$/$1/;$uri =~ s/^\s+//;$uri =~ s/\s+$//;my$impclass;if ($uri =~ m/^($scheme_re):/so){$scheme=$1}else {if (($impclass=ref($scheme))){$scheme=$scheme->scheme}elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o){$scheme=$1}}$impclass ||= implementor($scheme)|| do {require URI::_foreign;$impclass='URI::_foreign'};return$impclass->_init($uri,$scheme)}sub new_abs {my($class,$uri,$base)=@_;$uri=$class->new($uri,$base);$uri->abs($base)}sub _init {my$class=shift;my($str,$scheme)=@_;$str=$class->_uric_escape($str);$str="$scheme:$str" unless$str =~ /^$scheme_re:/o || $class->_no_scheme_ok;my$self=bless \$str,$class;$self}sub _uric_escape {my($class,$str)=@_;$str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;utf8::downgrade($str);return$str}my%require_attempted;sub implementor {my($scheme,$impclass)=@_;if (!$scheme || $scheme !~ /\A$scheme_re\z/o){require URI::_generic;return "URI::_generic"}$scheme=lc($scheme);if ($impclass){my$old=$implements{$scheme};$impclass->_init_implementor($scheme);$implements{$scheme}=$impclass;return$old}my$ic=$implements{$scheme};return$ic if$ic;$ic="URI::$scheme";$ic =~ s/\+/_P/g;$ic =~ s/\./_O/g;$ic =~ s/\-/_/g;no strict 'refs';unless (@{"${ic}::ISA"}){if (not exists$require_attempted{$ic}){my$_old_error=$@;eval "require $ic";die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;$@=$_old_error}return undef unless @{"${ic}::ISA"}}$ic->_init_implementor($scheme);$implements{$scheme}=$ic;$ic}sub _init_implementor {my($class,$scheme)=@_}sub clone {my$self=shift;my$other=$$self;bless \$other,ref$self}sub TO_JSON {${$_[0]}}sub _no_scheme_ok {0}sub _scheme {my$self=shift;unless (@_){return undef unless $$self =~ /^($scheme_re):/o;return $1}my$old;my$new=shift;if (defined($new)&& length($new)){Carp::croak("Bad scheme '$new'")unless$new =~ /^$scheme_re$/o;$old=$1 if $$self =~ s/^($scheme_re)://o;my$newself=URI->new("$new:$$self");$$self=$$newself;bless$self,ref($newself)}else {if ($self->_no_scheme_ok){$old=$1 if $$self =~ s/^($scheme_re)://o;Carp::carp("Oops, opaque part now look like scheme")if $^W && $$self =~ m/^$scheme_re:/o}else {$old=$1 if $$self =~ m/^($scheme_re):/o}}return$old}sub scheme {my$scheme=shift->_scheme(@_);return undef unless defined$scheme;lc($scheme)}sub has_recognized_scheme {my$self=shift;return ref($self)!~ /^URI::_(?:foreign|generic)\z/}sub opaque {my$self=shift;unless (@_){$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;return $1}$$self =~ /^($scheme_re:)?    # optional scheme
  	        ([^\#]*)          # opaque
                  (\#.*)?           # optional fragment
                $/sx or die;my$old_scheme=$1;my$old_opaque=$2;my$old_frag=$3;my$new_opaque=shift;$new_opaque="" unless defined$new_opaque;$new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($new_opaque);$$self=defined($old_scheme)? $old_scheme : "";$$self .= $new_opaque;$$self .= $old_frag if defined$old_frag;$old_opaque}sub path {goto&opaque}sub fragment {my$self=shift;unless (@_){return undef unless $$self =~ /\#(.*)/s;return $1}my$old;$old=$1 if $$self =~ s/\#(.*)//s;my$new_frag=shift;if (defined$new_frag){$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;utf8::downgrade($new_frag);$$self .= "#$new_frag"}$old}sub as_string {my$self=shift;$$self}sub as_iri {my$self=shift;my$str=$$self;if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg){require Encode;my$enc=Encode::find_encoding("UTF-8");my$u="";while (length$str){$u .= $enc->decode($str,Encode::FB_QUIET());if (length$str){$u .= URI::Escape::escape_char(substr($str,0,1,""))}}$str=$u}return$str}sub canonical {my$self=shift;my$scheme=$self->_scheme || "";my$uc_scheme=$scheme =~ /[A-Z]/;my$esc=$$self =~ /%[a-fA-F0-9]{2}/;return$self unless$uc_scheme || $esc;my$other=$self->clone;if ($uc_scheme){$other->_scheme(lc$scheme)}if ($esc){$$other =~ s{%([0-9a-fA-F]{2})}
  	            { my $a = chr(hex($1));
                        $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                      }ge}return$other}sub eq {my($self,$other)=@_;$self=URI->new($self,$other)unless ref$self;$other=URI->new($other,$self)unless ref$other;ref($self)eq ref($other)&& $self->canonical->as_string eq $other->canonical->as_string}sub abs {$_[0]}sub rel {$_[0]}sub secure {0}sub STORABLE_freeze {my($self,$cloning)=@_;return $$self}sub STORABLE_thaw {my($self,$cloning,$str)=@_;$$self=$str}1;
URI

$fatpacked{"URI/Escape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_ESCAPE';
  package URI::Escape;use strict;use warnings;use Exporter 5.57 'import';our%escapes;our@EXPORT=qw(uri_escape uri_unescape uri_escape_utf8);our@EXPORT_OK=qw(%escapes);our$VERSION="3.31";use Carp ();for (0..255){$escapes{chr($_)}=sprintf("%%%02X",$_)}my%subst;my%Unsafe=(RFC2732=>qr/[^A-Za-z0-9\-_.!~*'()]/,RFC3986=>qr/[^A-Za-z0-9\-\._~]/,);sub uri_escape {my($text,$patn)=@_;return undef unless defined$text;if (defined$patn){unless (exists$subst{$patn}){(my$tmp=$patn)=~ s,/,\\/,g;eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";Carp::croak("uri_escape: $@")if $@}&{$subst{$patn}}($text)}else {$text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge}$text}sub _fail_hi {my$chr=shift;Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead",ord($chr))}sub uri_escape_utf8 {my$text=shift;return undef unless defined$text;utf8::encode($text);return uri_escape($text,@_)}sub uri_unescape {my$str=shift;if (@_ && wantarray){my@str=($str,@_);for (@str){s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg}return@str}$str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined$str;$str}sub escape_char {my$dummy=substr($_[0],0,0);if (utf8::is_utf8($_[0])){my$s=shift;utf8::encode($s);unshift(@_,$s)}return join '',@URI::Escape::escapes{split //,$_[0]}}1;
URI_ESCAPE

$fatpacked{"URI/Heuristic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HEURISTIC';
  package URI::Heuristic;use strict;use warnings;use Exporter 5.57 'import';our@EXPORT_OK=qw(uf_uri uf_uristr uf_url uf_urlstr);our$VERSION="4.20";our ($MY_COUNTRY,$DEBUG);sub MY_COUNTRY() {for ($MY_COUNTRY){return $_ if defined;$_=$ENV{COUNTRY};return $_ if defined;my@srcs=($ENV{LC_ALL},$ENV{LANG});if (my$httplang=$ENV{HTTP_ACCEPT_LANGUAGE}){for$httplang (split(/\s*,\s*/,$httplang)){if ($httplang =~ /^\s*([a-zA-Z]+)[_-]([a-zA-Z]{2})\s*$/){unshift(@srcs,"${1}_${2}");last}}}for (@srcs){next unless defined;return lc($1)if /^[a-zA-Z]+_([a-zA-Z]{2})(?:[.@]|$)/}require Net::Domain;my$fqdn=Net::Domain::hostfqdn();$_=lc($1)if$fqdn =~ /\.([a-zA-Z]{2})$/;return $_ if defined;return ($_=0)}}our%LOCAL_GUESSING=('us'=>[qw(www.ACME.gov www.ACME.mil)],'gb'=>[qw(www.ACME.co.uk www.ACME.org.uk www.ACME.ac.uk)],'au'=>[qw(www.ACME.com.au www.ACME.org.au www.ACME.edu.au)],'il'=>[qw(www.ACME.co.il www.ACME.org.il www.ACME.net.il)],);$LOCAL_GUESSING{uk}=$LOCAL_GUESSING{gb};sub uf_uristr ($) {local($_)=@_;print STDERR "uf_uristr: resolving $_\n" if$DEBUG;return unless defined;s/^\s+//;s/\s+$//;if (/^(www|web|home)[a-z0-9-]*(?:\.|$)/i){$_="http://$_"}elsif (/^(ftp|gopher|news|wais|https|http)[a-z0-9-]*(?:\.|$)/i){$_=lc($1)."://$_"}elsif ($^O ne "MacOS" && (m,^/, || m,^\.\.?/, || m,^[a-zA-Z]:[/\\],)){$_="file:$_"}elsif ($^O eq "MacOS" && m/:/){unless (m/^(ftp|gopher|news|wais|http|https|mailto):/){require URI::file;my$a=URI::file->new($_)->as_string;$_=($a =~ m/^file:/)? $a : "file:$a"}}elsif (/^\w+([\.\-]\w+)*\@(\w+\.)+\w{2,3}$/){$_="mailto:$_"}elsif (!/^[a-zA-Z][a-zA-Z0-9.+\-]*:/){if (s/^([-\w]+(?:\.[-\w]+)*)([\/:\?\#]|$)/$2/){my$host=$1;my$scheme="http";if (/^:(\d+)\b/){if ($1 =~ /^[56789]?443$/){$scheme="https"}elsif ($1 eq "21"){$scheme="ftp"}}if ($host !~ /\./ && $host ne "localhost"){my@guess;if (exists$ENV{URL_GUESS_PATTERN}){@guess=map {s/\bACME\b/$host/;$_}split(' ',$ENV{URL_GUESS_PATTERN})}else {if (MY_COUNTRY()){my$special=$LOCAL_GUESSING{MY_COUNTRY()};if ($special){my@special=@$special;push(@guess,map {s/\bACME\b/$host/;$_}@special)}else {push(@guess,"www.$host." .MY_COUNTRY())}}push(@guess,map "www.$host.$_","com","org","net","edu","int")}my$guess;for$guess (@guess){print STDERR "uf_uristr: gethostbyname('$guess.')..." if$DEBUG;if (gethostbyname("$guess.")){print STDERR "yes\n" if$DEBUG;$host=$guess;last}print STDERR "no\n" if$DEBUG}}$_="$scheme://$host$_"}else {}}print STDERR "uf_uristr: ==> $_\n" if$DEBUG;$_}sub uf_uri ($) {require URI;URI->new(uf_uristr($_[0]))}*uf_urlstr=\*uf_uristr;sub uf_url ($) {require URI::URL;URI::URL->new(uf_uristr($_[0]))}1;
URI_HEURISTIC

$fatpacked{"URI/IRI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_IRI';
  package URI::IRI;use strict;use warnings;use URI ();use overload '""'=>sub {shift->as_string};our$VERSION='1.76';sub new {my($class,$uri,$scheme)=@_;utf8::upgrade($uri);return bless {uri=>URI->new($uri,$scheme),},$class}sub clone {my$self=shift;return bless {uri=>$self->{uri}->clone,},ref($self)}sub as_string {my$self=shift;return$self->{uri}->as_iri}our$AUTOLOAD;sub AUTOLOAD {my$method=substr($AUTOLOAD,rindex($AUTOLOAD,'::')+2);no strict 'refs';*$method=sub {shift->{uri}->$method(@_)};goto &$method}sub DESTROY {}1;
URI_IRI

$fatpacked{"URI/QueryParam.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_QUERYPARAM';
  package URI::QueryParam;use strict;use warnings;our$VERSION='1.76';sub URI::_query::query_param {my$self=shift;my@old=$self->query_form;if (@_==0){my (%seen,$i);return grep!($i++ % 2 || $seen{$_}++),@old}my$key=shift;my@i=grep $_ % 2==0 && $old[$_]eq $key,0 .. $#old;if (@_){my@new=@old;my@new_i=@i;my@vals=map {ref($_)eq 'ARRAY' ? @$_ : $_}@_;while (@new_i > @vals){splice@new,pop@new_i,2}if (@vals > @new_i){my$i=@new_i ? $new_i[-1]+ 2 : @new;my@splice=splice@vals,@new_i,@vals - @new_i;splice@new,$i,0,map {$key=>$_}@splice}if (@vals){@new[map $_ + 1,@new_i ]=@vals}$self->query_form(\@new)}return wantarray ? @old[map $_+1,@i]: @i ? $old[$i[0]+1]: undef}sub URI::_query::query_param_append {my$self=shift;my$key=shift;my@vals=map {ref $_ eq 'ARRAY' ? @$_ : $_}@_;$self->query_form($self->query_form,$key=>\@vals);return}sub URI::_query::query_param_delete {my$self=shift;my$key=shift;my@old=$self->query_form;my@vals;for (my$i=@old - 2;$i >= 0;$i -= 2){next if$old[$i]ne $key;push(@vals,(splice(@old,$i,2))[1])}$self->query_form(\@old)if@vals;return wantarray ? reverse@vals : $vals[-1]}sub URI::_query::query_form_hash {my$self=shift;my@old=$self->query_form;if (@_){$self->query_form(@_==1 ? %{shift(@_)}: @_)}my%hash;while (my($k,$v)=splice(@old,0,2)){if (exists$hash{$k}){for ($hash{$k}){$_=[$_]unless ref($_)eq "ARRAY";push(@$_,$v)}}else {$hash{$k}=$v}}return \%hash}1;
URI_QUERYPARAM

$fatpacked{"URI/Split.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SPLIT';
  package URI::Split;use strict;use warnings;our$VERSION='1.76';use Exporter 5.57 'import';our@EXPORT_OK=qw(uri_split uri_join);use URI::Escape ();sub uri_split {return $_[0]=~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,}sub uri_join {my($scheme,$auth,$path,$query,$frag)=@_;my$uri=defined($scheme)? "$scheme:" : "";$path="" unless defined$path;if (defined$auth){$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;$uri .= "//$auth";$path="/$path" if length($path)&& $path !~ m,^/,}elsif ($path =~ m,^//,){$uri .= "//"}unless (length$uri){$path =~ s,(:), URI::Escape::escape_char($1),e while$path =~ m,^[^:/?\#]+:,}$path =~ s,([?\#]), URI::Escape::escape_char($1),eg;$uri .= $path;if (defined$query){$query =~ s,(\#), URI::Escape::escape_char($1),eg;$uri .= "?$query"}$uri .= "#$frag" if defined$frag;$uri}1;
URI_SPLIT

$fatpacked{"URI/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URL';
  package URI::URL;use strict;use warnings;use parent 'URI::WithBase';our$VERSION="5.04";use Exporter 5.57 'import';our@EXPORT=qw(url);sub url ($;$) {URI::URL->new(@_)}use URI::Escape qw(uri_unescape);sub new {my$class=shift;my$self=$class->SUPER::new(@_);$self->[0]=$self->[0]->canonical;$self}sub newlocal {my$class=shift;require URI::file;bless [URI::file->new_abs(shift)],$class}{package URI::_foreign;sub _init {my$class=shift;die "Unknown URI::URL scheme $_[1]:" if$URI::URL::STRICT;$class->SUPER::_init(@_)}}sub strict {my$old=$URI::URL::STRICT;$URI::URL::STRICT=shift if @_;$old}sub print_on {my$self=shift;require Data::Dumper;print STDERR Data::Dumper::Dumper($self)}sub _try {my$self=shift;my$method=shift;scalar(eval {$self->$method(@_)})}sub crack {my$self=shift;(scalar($self->scheme),$self->_try("user"),$self->_try("password"),$self->_try("host"),$self->_try("port"),$self->_try("path"),$self->_try("params"),$self->_try("query"),scalar($self->fragment),)}sub full_path {my$self=shift;my$path=$self->path_query;$path="/" unless length$path;$path}sub netloc {shift->authority(@_)}sub epath {my$path=shift->SUPER::path(@_);$path =~ s/;.*//;$path}sub eparams {my$self=shift;my@p=$self->path_segments;return undef unless ref($p[-1]);@p=@{$p[-1]};shift@p;join(";",@p)}sub params {shift->eparams(@_)}sub path {my$self=shift;my$old=$self->epath(@_);return unless defined wantarray;return '/' if!defined($old)||!length($old);Carp::croak("Path components contain '/' (you must call epath)")if$old =~ /%2[fF]/ and!@_;$old="/$old" if$old !~ m|^/| && defined$self->netloc;return uri_unescape($old)}sub path_components {shift->path_segments(@_)}sub query {my$self=shift;my$old=$self->equery(@_);if (defined(wantarray)&& defined($old)){if ($old =~ /%(?:26|2[bB]|3[dD])/){my$mess;for ($old){$mess="Query contains both '+' and '%2B'" if /\+/ && /%2[bB]/;$mess="Form query contains escaped '=' or '&'" if /=/ && /%(?:3[dD]|26)/}if ($mess){Carp::croak("$mess (you must call equery)")}}return uri_unescape($old)}undef}sub abs {my$self=shift;my$base=shift;my$allow_scheme=shift;$allow_scheme=$URI::URL::ABS_ALLOW_RELATIVE_SCHEME unless defined$allow_scheme;local$URI::ABS_ALLOW_RELATIVE_SCHEME=$allow_scheme;local$URI::ABS_REMOTE_LEADING_DOTS=$URI::URL::ABS_REMOTE_LEADING_DOTS;$self->SUPER::abs($base)}sub frag {shift->fragment(@_)}sub keywords {shift->query_keywords(@_)}sub local_path {shift->file}sub unix_path {shift->file("unix")}sub dos_path {shift->file("dos")}sub mac_path {shift->file("mac")}sub vms_path {shift->file("vms")}sub address {shift->to(@_)}sub encoded822addr {shift->to(@_)}sub URI::mailto::authority {shift->to(@_)}sub groupart {shift->_group(@_)}sub article {shift->message(@_)}1;
URI_URL

$fatpacked{"URI/WithBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_WITHBASE';
  package URI::WithBase;use strict;use warnings;use URI;use Scalar::Util 'blessed';our$VERSION="2.20";use overload '""'=>"as_string",fallback=>1;sub as_string;sub new {my($class,$uri,$base)=@_;my$ibase=$base;if ($base && blessed($base)&& $base->isa(__PACKAGE__)){$base=$base->abs;$ibase=$base->[0]}bless [URI->new($uri,$ibase),$base],$class}sub new_abs {my$class=shift;my$self=$class->new(@_);$self->abs}sub _init {my$class=shift;my($str,$scheme)=@_;bless [URI->new($str,$scheme),undef],$class}sub eq {my($self,$other)=@_;$other=$other->[0]if blessed($other)and $other->isa(__PACKAGE__);$self->[0]->eq($other)}our$AUTOLOAD;sub AUTOLOAD {my$self=shift;my$method=substr($AUTOLOAD,rindex($AUTOLOAD,'::')+2);return if$method eq "DESTROY";$self->[0]->$method(@_)}sub can {my$self=shift;$self->SUPER::can(@_)|| (ref($self)? $self->[0]->can(@_): undef)}sub base {my$self=shift;my$base=$self->[1];if (@_){my$new_base=shift;$new_base=$new_base->abs if ref($new_base)&& $new_base->isa(__PACKAGE__);$self->[1]=$new_base}return unless defined wantarray;if (defined($base)&&!ref($base)){$base=ref($self)->new($base);$self->[1]=$base unless @_}$base}sub clone {my$self=shift;my$base=$self->[1];$base=$base->clone if ref($base);bless [$self->[0]->clone,$base],ref($self)}sub abs {my$self=shift;my$base=shift || $self->base || return$self->clone;$base=$base->as_string if ref($base);bless [$self->[0]->abs($base,@_),$base],ref($self)}sub rel {my$self=shift;my$base=shift || $self->base || return$self->clone;$base=$base->as_string if ref($base);bless [$self->[0]->rel($base,@_),$base],ref($self)}1;
URI_WITHBASE

$fatpacked{"URI/_foreign.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__FOREIGN';
  package URI::_foreign;use strict;use warnings;use parent 'URI::_generic';our$VERSION='1.76';1;
URI__FOREIGN

$fatpacked{"URI/_generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__GENERIC';
  package URI::_generic;use strict;use warnings;use parent qw(URI URI::_query);use URI::Escape qw(uri_unescape);use Carp ();our$VERSION='1.76';my$ACHAR=$URI::uric;$ACHAR =~ s,\\[/?],,g;my$PCHAR=$URI::uric;$PCHAR =~ s,\\[?],,g;sub _no_scheme_ok {1}sub authority {my$self=shift;$$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\#]*))?(.*)$,os or die;if (@_){my$auth=shift;$$self=$1;my$rest=$3;if (defined$auth){$auth =~ s/([^$ACHAR])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($auth);$$self .= "//$auth"}_check_path($rest,$$self);$$self .= $rest}$2}sub path {my$self=shift;$$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^?\#]*)(.*)$,s or die;if (@_){$$self=$1;my$rest=$3;my$new_path=shift;$new_path="" unless defined$new_path;$new_path =~ s/([^$PCHAR])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($new_path);_check_path($new_path,$$self);$$self .= $new_path .$rest}$2}sub path_query {my$self=shift;$$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^\#]*)(.*)$,s or die;if (@_){$$self=$1;my$rest=$3;my$new_path=shift;$new_path="" unless defined$new_path;$new_path =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($new_path);_check_path($new_path,$$self);$$self .= $new_path .$rest}$2}sub _check_path {my($path,$pre)=@_;my$prefix;if ($pre =~ m,/,){$prefix="/" if length($path)&& $path !~ m,^[/?\#],}else {if ($path =~ m,^//,){Carp::carp("Path starting with double slash is confusing")if $^W}elsif (!length($pre)&& $path =~ m,^[^:/?\#]+:,){Carp::carp("Path might look like scheme, './' prepended")if $^W;$prefix="./"}}substr($_[0],0,0)=$prefix if defined$prefix}sub path_segments {my$self=shift;my$path=$self->path;if (@_){my@arg=@_;for (@arg){if (ref($_)){my@seg=@$_;$seg[0]=~ s/%/%25/g;for (@seg){s/;/%3B/g}$_=join(";",@seg)}else {s/%/%25/g;s/;/%3B/g}s,/,%2F,g}$self->path(join("/",@arg))}return$path unless wantarray;map {/;/ ? $self->_split_segment($_): uri_unescape($_)}split('/',$path,-1)}sub _split_segment {my$self=shift;require URI::_segment;URI::_segment->new(@_)}sub abs {my$self=shift;my$base=shift || Carp::croak("Missing base argument");if (my$scheme=$self->scheme){return$self unless$URI::ABS_ALLOW_RELATIVE_SCHEME;$base=URI->new($base)unless ref$base;return$self unless$scheme eq $base->scheme}$base=URI->new($base)unless ref$base;my$abs=$self->clone;$abs->scheme($base->scheme);return$abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;$abs->authority($base->authority);my$path=$self->path;return$abs if$path =~ m,^/,;if (!length($path)){my$abs=$base->clone;my$query=$self->query;$abs->query($query)if defined$query;my$fragment=$self->fragment;$abs->fragment($fragment)if defined$fragment;return$abs}my$p=$base->path;$p =~ s,[^/]+$,,;$p .= $path;my@p=split('/',$p,-1);shift(@p)if@p &&!length($p[0]);my$i=1;while ($i < @p){if ($p[$i-1]eq "."){splice(@p,$i-1,1);$i-- if$i > 1}elsif ($p[$i]eq ".." && $p[$i-1]ne ".."){splice(@p,$i-1,2);if ($i > 1){$i--;push(@p,"")if$i==@p}}else {$i++}}$p[-1]="" if@p && $p[-1]eq ".";if ($URI::ABS_REMOTE_LEADING_DOTS){shift@p while@p && $p[0]=~ /^\.\.?$/}$abs->path("/" .join("/",@p));$abs}sub rel {my$self=shift;my$base=shift || Carp::croak("Missing base argument");my$rel=$self->clone;$base=URI->new($base)unless ref$base;my$scheme=$rel->scheme;my$auth=$rel->canonical->authority;my$path=$rel->path;if (!defined($scheme)&&!defined($auth)){return$rel}my$bscheme=$base->scheme;my$bauth=$base->canonical->authority;my$bpath=$base->path;for ($bscheme,$bauth,$auth){$_='' unless defined}unless ($scheme eq $bscheme && $auth eq $bauth){return$rel}for ($path,$bpath){$_="/$_" unless m,^/,}$rel->scheme(undef);$rel->authority(undef);my$li=1;while (1){my$i=index($path,'/',$li);last if$i < 0 || $i!=index($bpath,'/',$li)|| substr($path,$li,$i-$li)ne substr($bpath,$li,$i-$li);$li=$i+1}substr($path,0,$li)='';substr($bpath,0,$li)='';if ($path eq $bpath && defined($rel->fragment)&& !defined($rel->query)){$rel->path("")}else {$path=('../' x $bpath =~ tr|/|/|).$path;$path="./" if$path eq "";$rel->path($path)}$rel}1;
URI__GENERIC

$fatpacked{"URI/_idna.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__IDNA';
  package URI::_idna;use strict;use warnings;use URI::_punycode qw(encode_punycode decode_punycode);use Carp qw(croak);our$VERSION='1.76';BEGIN {*URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS="$]" < 5.008_003 ? sub () {1}: sub () {0}}my$ASCII=qr/^[\x00-\x7F]*\z/;sub encode {my$idomain=shift;my@labels=split(/\./,$idomain,-1);my@last_empty;push(@last_empty,pop@labels)if@labels > 1 && $labels[-1]eq "";for (@labels){$_=ToASCII($_)}return eval 'join(".", @labels, @last_empty)' if URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS;return join(".",@labels,@last_empty)}sub decode {my$domain=shift;return join(".",map ToUnicode($_),split(/\./,$domain,-1))}sub nameprep {my$label=shift;$label=lc($label);return$label}sub check_size {my$label=shift;croak "Label empty" if$label eq "";croak "Label too long" if length($label)> 63;return$label}sub ToASCII {my$label=shift;return check_size($label)if$label =~ $ASCII;$label=nameprep($label);return check_size($label)if$label =~ $ASCII;if ($label =~ /^xn--/){croak "Label starts with ACE prefix"}$label=encode_punycode($label);$label="xn--$label";return check_size($label)}sub ToUnicode {my$label=shift;$label=nameprep($label)unless$label =~ $ASCII;return$label unless$label =~ /^xn--/;my$result=decode_punycode(substr($label,4));my$label2=ToASCII($result);if (lc($label)ne $label2){croak "IDNA does not round-trip: '\L$label\E' vs '$label2'"}return$result}1;
URI__IDNA

$fatpacked{"URI/_ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LDAP';
  package URI::_ldap;use strict;use warnings;our$VERSION='1.76';use URI::Escape qw(uri_unescape);sub _ldap_elem {my$self=shift;my$elem=shift;my$query=$self->query;my@bits=(split(/\?/,defined($query)? $query : ""),("")x4);my$old=$bits[$elem];if (@_){my$new=shift;$new =~ s/\?/%3F/g;$bits[$elem]=$new;$query=join("?",@bits);$query =~ s/\?+$//;$query=undef unless length($query);$self->query($query)}$old}sub dn {my$old=shift->path(@_);$old =~ s:^/::;uri_unescape($old)}sub attributes {my$self=shift;my$old=_ldap_elem($self,0,@_ ? join(",",map {my$tmp=$_;$tmp =~ s/,/%2C/g;$tmp}@_): ());return$old unless wantarray;map {uri_unescape($_)}split(/,/,$old)}sub _scope {my$self=shift;my$old=_ldap_elem($self,1,@_);return undef unless defined wantarray && defined$old;uri_unescape($old)}sub scope {my$old=&_scope;$old="base" unless length$old;$old}sub _filter {my$self=shift;my$old=_ldap_elem($self,2,@_);return undef unless defined wantarray && defined$old;uri_unescape($old)}sub filter {my$old=&_filter;$old="(objectClass=*)" unless length$old;$old}sub extensions {my$self=shift;my@ext;while (@_){my$key=shift;my$value=shift;push(@ext,join("=",map {$_="" unless defined;s/,/%2C/g;$_}$key,$value))}@ext=join(",",@ext)if@ext;my$old=_ldap_elem($self,3,@ext);return$old unless wantarray;map {uri_unescape($_)}map {/^([^=]+)=(.*)$/}split(/,/,$old)}sub canonical {my$self=shift;my$other=$self->_nonldap_canonical;$other=$other->clone if$other==$self;$other->dn(_normalize_dn($other->dn));$other->attributes(map lc,$other->attributes);my$old_scope=$other->scope;my$new_scope=lc($old_scope);$new_scope="" if$new_scope eq "base";$other->scope($new_scope)if$new_scope ne $old_scope;my$old_filter=$other->filter;$other->filter("")if lc($old_filter)eq "(objectclass=*)" || lc($old_filter)eq "objectclass=*";my@ext=$other->extensions;for (my$i=0;$i < @ext;$i += 2){my$etype=$ext[$i]=lc($ext[$i]);if ($etype =~ /^!?bindname$/){$ext[$i+1]=_normalize_dn($ext[$i+1])}}$other->extensions(@ext)if@ext;$other}sub _normalize_dn {my$dn=shift;return$dn;my@dn=split(/([+,])/,$dn);for (@dn){s/^([a-zA-Z]+=)/lc($1)/e}join("",@dn)}1;
URI__LDAP

$fatpacked{"URI/_login.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LOGIN';
  package URI::_login;use strict;use warnings;use parent qw(URI::_server URI::_userpass);our$VERSION='1.76';1;
URI__LOGIN

$fatpacked{"URI/_punycode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__PUNYCODE';
  package URI::_punycode;use strict;use warnings;our$VERSION='1.76';use Exporter 'import';our@EXPORT=qw(encode_punycode decode_punycode);use integer;our$DEBUG=0;use constant BASE=>36;use constant TMIN=>1;use constant TMAX=>26;use constant SKEW=>38;use constant DAMP=>700;use constant INITIAL_BIAS=>72;use constant INITIAL_N=>128;my$Delimiter=chr 0x2D;my$BasicRE=qr/[\x00-\x7f]/;sub _croak {require Carp;Carp::croak(@_)}sub digit_value {my$code=shift;return ord($code)- ord("A")if$code =~ /[A-Z]/;return ord($code)- ord("a")if$code =~ /[a-z]/;return ord($code)- ord("0")+ 26 if$code =~ /[0-9]/;return}sub code_point {my$digit=shift;return$digit + ord('a')if 0 <= $digit && $digit <= 25;return$digit + ord('0')- 26 if 26 <= $digit && $digit <= 36;die 'NOT COME HERE'}sub adapt {my($delta,$numpoints,$firsttime)=@_;$delta=$firsttime ? $delta / DAMP : $delta / 2;$delta += $delta / $numpoints;my$k=0;while ($delta > ((BASE - TMIN)* TMAX)/ 2){$delta /= BASE - TMIN;$k += BASE}return$k + (((BASE - TMIN + 1)* $delta)/ ($delta + SKEW))}sub decode_punycode {my$code=shift;my$n=INITIAL_N;my$i=0;my$bias=INITIAL_BIAS;my@output;if ($code =~ s/(.*)$Delimiter//o){push@output,map ord,split //,$1;return _croak('non-basic code point')unless $1 =~ /^$BasicRE*$/o}while ($code){my$oldi=$i;my$w=1;LOOP: for (my$k=BASE;1;$k += BASE){my$cp=substr($code,0,1,'');my$digit=digit_value($cp);defined$digit or return _croak("invalid punycode input");$i += $digit * $w;my$t=($k <= $bias)? TMIN : ($k >= $bias + TMAX)? TMAX : $k - $bias;last LOOP if$digit < $t;$w *= (BASE - $t)}$bias=adapt($i - $oldi,@output + 1,$oldi==0);warn "bias becomes $bias" if$DEBUG;$n += $i / (@output + 1);$i=$i % (@output + 1);splice(@output,$i,0,$n);warn join " ",map sprintf('%04x',$_),@output if$DEBUG;$i++}return join '',map chr,@output}sub encode_punycode {my$input=shift;my@input=split //,$input;my$n=INITIAL_N;my$delta=0;my$bias=INITIAL_BIAS;my@output;my@basic=grep /$BasicRE/,@input;my$h=my$b=@basic;push@output,@basic;push@output,$Delimiter if$b && $h < @input;warn "basic codepoints: (@output)" if$DEBUG;while ($h < @input){my$m=min(grep {$_ >= $n}map ord,@input);warn sprintf "next code point to insert is %04x",$m if$DEBUG;$delta += ($m - $n)* ($h + 1);$n=$m;for my$i (@input){my$c=ord($i);$delta++ if$c < $n;if ($c==$n){my$q=$delta;LOOP: for (my$k=BASE;1;$k += BASE){my$t=($k <= $bias)? TMIN : ($k >= $bias + TMAX)? TMAX : $k - $bias;last LOOP if$q < $t;my$cp=code_point($t + (($q - $t)% (BASE - $t)));push@output,chr($cp);$q=($q - $t)/ (BASE - $t)}push@output,chr(code_point($q));$bias=adapt($delta,$h + 1,$h==$b);warn "bias becomes $bias" if$DEBUG;$delta=0;$h++}}$delta++;$n++}return join '',@output}sub min {my$min=shift;for (@_){$min=$_ if $_ <= $min}return$min}1;
URI__PUNYCODE

$fatpacked{"URI/_query.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__QUERY';
  package URI::_query;use strict;use warnings;use URI ();use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub query {my$self=shift;$$self =~ m,^([^?\#]*)(?:\?([^\#]*))?(.*)$,s or die;if (@_){my$q=shift;$$self=$1;if (defined$q){$q =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($q);$$self .= "?$q"}$$self .= $3}$2}sub query_form {my$self=shift;my$old=$self->query;if (@_){my$delim;my$r=$_[0];if (ref($r)eq "ARRAY"){$delim=$_[1];@_=@$r}elsif (ref($r)eq "HASH"){$delim=$_[1];@_=map {$_=>$r->{$_}}sort keys %$r}$delim=pop if @_ % 2;my@query;while (my($key,$vals)=splice(@_,0,2)){$key='' unless defined$key;$key =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;$key =~ s/ /+/g;$vals=[ref($vals)eq "ARRAY" ? @$vals : $vals];for my$val (@$vals){$val='' unless defined$val;$val =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;$val =~ s/ /+/g;push(@query,"$key=$val")}}if (@query){unless ($delim){$delim=$1 if$old && $old =~ /([&;])/;$delim ||= $URI::DEFAULT_QUERY_FORM_DELIMITER || "&"}$self->query(join($delim,@query))}else {$self->query(undef)}}return if!defined($old)||!length($old)||!defined(wantarray);return unless$old =~ /=/;map {s/\+/ /g;uri_unescape($_)}map {/=/ ? split(/=/,$_,2): ($_=>'')}split(/[&;]/,$old)}sub query_keywords {my$self=shift;my$old=$self->query;if (@_){my@copy=@_;@copy=@{$copy[0]}if@copy==1 && ref($copy[0])eq "ARRAY";for (@copy){s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg}$self->query(@copy ? join('+',@copy): undef)}return if!defined($old)||!defined(wantarray);return if$old =~ /=/;map {uri_unescape($_)}split(/\+/,$old,-1)}sub equery {goto&query}1;
URI__QUERY

$fatpacked{"URI/_segment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SEGMENT';
  package URI::_segment;use strict;use warnings;use URI::Escape qw(uri_unescape);use overload '""'=>sub {$_[0]->[0]},fallback=>1;our$VERSION='1.76';sub new {my$class=shift;my@segment=split(';',shift,-1);$segment[0]=uri_unescape($segment[0]);bless \@segment,$class}1;
URI__SEGMENT

$fatpacked{"URI/_server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SERVER';
  package URI::_server;use strict;use warnings;use parent 'URI::_generic';use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub _uric_escape {my($class,$str)=@_;if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os){my($scheme,$host,$rest)=($1,$2,$3);my$ui=$host =~ s/(.*@)// ? $1 : "";my$port=$host =~ s/(:\d+)\z// ? $1 : "";if (_host_escape($host)){$str="$scheme//$ui$host$port$rest"}}return$class->SUPER::_uric_escape($str)}sub _host_escape {return unless $_[0]=~ /[^$URI::uric]/;eval {require URI::_idna;$_[0]=URI::_idna::encode($_[0])};return 0 if $@;return 1}sub as_iri {my$self=shift;my$str=$self->SUPER::as_iri;if ($str =~ /\bxn--/){if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os){my($scheme,$host,$rest)=($1,$2,$3);my$ui=$host =~ s/(.*@)// ? $1 : "";my$port=$host =~ s/(:\d+)\z// ? $1 : "";require URI::_idna;$host=URI::_idna::decode($host);$str="$scheme//$ui$host$port$rest"}}return$str}sub userinfo {my$self=shift;my$old=$self->authority;if (@_){my$new=$old;$new="" unless defined$new;$new =~ s/.*@//;my$ui=shift;if (defined$ui){$ui =~ s/@/%40/g;$new="$ui\@$new"}$self->authority($new)}return undef if!defined($old)|| $old !~ /(.*)@/;return $1}sub host {my$self=shift;my$old=$self->authority;if (@_){my$tmp=$old;$tmp="" unless defined$tmp;my$ui=($tmp =~ /(.*@)/)? $1 : "";my$port=($tmp =~ /(:\d+)$/)? $1 : "";my$new=shift;$new="" unless defined$new;if (length$new){$new =~ s/[@]/%40/g;if ($new =~ /^[^:]*:\d*\z/ || $new =~ /]:\d*\z/){$new =~ s/(:\d*)\z// || die "Assert";$port=$1}$new="[$new]" if$new =~ /:/ && $new !~ /^\[/;_host_escape($new)}$self->authority("$ui$new$port")}return undef unless defined$old;$old =~ s/.*@//;$old =~ s/:\d+$//;$old =~ s{^\[(.*)\]$}{$1};return uri_unescape($old)}sub ihost {my$self=shift;my$old=$self->host(@_);if ($old =~ /(^|\.)xn--/){require URI::_idna;$old=URI::_idna::decode($old)}return$old}sub _port {my$self=shift;my$old=$self->authority;if (@_){my$new=$old;$new =~ s/:\d*$//;my$port=shift;$new .= ":$port" if defined$port;$self->authority($new)}return $1 if defined($old)&& $old =~ /:(\d*)$/;return}sub port {my$self=shift;my$port=$self->_port(@_);$port=$self->default_port if!defined($port)|| $port eq "";$port}sub host_port {my$self=shift;my$old=$self->authority;$self->host(shift)if @_;return undef unless defined$old;$old =~ s/.*@//;$old =~ s/:$//;$old .= ":" .$self->port unless$old =~ /:\d+$/;$old}sub default_port {undef}sub canonical {my$self=shift;my$other=$self->SUPER::canonical;my$host=$other->host || "";my$port=$other->_port;my$uc_host=$host =~ /[A-Z]/;my$def_port=defined($port)&& ($port eq "" || $port==$self->default_port);if ($uc_host || $def_port){$other=$other->clone if$other==$self;$other->host(lc$host)if$uc_host;$other->port(undef)if$def_port}$other}1;
URI__SERVER

$fatpacked{"URI/_userpass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__USERPASS';
  package URI::_userpass;use strict;use warnings;use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub user {my$self=shift;my$info=$self->userinfo;if (@_){my$new=shift;my$pass=defined($info)? $info : "";$pass =~ s/^[^:]*//;if (!defined($new)&&!length($pass)){$self->userinfo(undef)}else {$new="" unless defined($new);$new =~ s/%/%25/g;$new =~ s/:/%3A/g;$self->userinfo("$new$pass")}}return undef unless defined$info;$info =~ s/:.*//;uri_unescape($info)}sub password {my$self=shift;my$info=$self->userinfo;if (@_){my$new=shift;my$user=defined($info)? $info : "";$user =~ s/:.*//;if (!defined($new)&&!length($user)){$self->userinfo(undef)}else {$new="" unless defined($new);$new =~ s/%/%25/g;$self->userinfo("$user:$new")}}return undef unless defined$info;return undef unless$info =~ s/^[^:]*://;uri_unescape($info)}1;
URI__USERPASS

$fatpacked{"URI/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_DATA';
  package URI::data;use strict;use warnings;use parent 'URI';our$VERSION='1.76';use MIME::Base64 qw(encode_base64 decode_base64);use URI::Escape qw(uri_unescape);sub media_type {my$self=shift;my$opaque=$self->opaque;$opaque =~ /^([^,]*),?/ or die;my$old=$1;my$base64;$base64=$1 if$old =~ s/(;base64)$//i;if (@_){my$new=shift;$new="" unless defined$new;$new =~ s/%/%25/g;$new =~ s/,/%2C/g;$base64="" unless defined$base64;$opaque =~ s/^[^,]*,?/$new$base64,/;$self->opaque($opaque)}return uri_unescape($old)if$old;"text/plain;charset=US-ASCII"}sub data {my$self=shift;my($enc,$data)=split(",",$self->opaque,2);unless (defined$data){$data="";$enc="" unless defined$enc}my$base64=($enc =~ /;base64$/i);if (@_){$enc =~ s/;base64$//i if$base64;my$new=shift;$new="" unless defined$new;my$uric_count=_uric_count($new);my$urienc_len=$uric_count + (length($new)- $uric_count)* 3;my$base64_len=int((length($new)+2)/ 3)* 4;$base64_len += 7;if ($base64_len < $urienc_len || $_[0]){$enc .= ";base64";$new=encode_base64($new,"")}else {$new =~ s/%/%25/g}$self->opaque("$enc,$new")}return unless defined wantarray;$data=uri_unescape($data);return$base64 ? decode_base64($data): $data}my$ENC=$URI::uric;$ENC =~ s/%//;eval <<EOT;die $@ if $@;1;
  sub _uric_count
  {
      \$_[0] =~ tr/$ENC//;
  }
  EOT
URI_DATA

$fatpacked{"URI/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE';
  package URI::file;use strict;use warnings;use parent 'URI::_generic';our$VERSION="4.21";use URI::Escape qw(uri_unescape);our$DEFAULT_AUTHORITY="";our%OS_CLASS=(os2=>"OS2",mac=>"Mac",MacOS=>"Mac",MSWin32=>"Win32",win32=>"Win32",msdos=>"FAT",dos=>"FAT",qnx=>"QNX",);sub os_class {my($OS)=shift || $^O;my$class="URI::file::" .($OS_CLASS{$OS}|| "Unix");no strict 'refs';unless (%{"$class\::"}){eval "require $class";die $@ if $@}$class}sub host {uri_unescape(shift->authority(@_))}sub new {my($class,$path,$os)=@_;os_class($os)->new($path)}sub new_abs {my$class=shift;my$file=$class->new(@_);return$file->abs($class->cwd)unless $$file =~ /^file:/;$file}sub cwd {my$class=shift;require Cwd;my$cwd=Cwd::cwd();$cwd=VMS::Filespec::unixpath($cwd)if $^O eq 'VMS';$cwd=$class->new($cwd);$cwd .= "/" unless substr($cwd,-1,1)eq "/";$cwd}sub canonical {my$self=shift;my$other=$self->SUPER::canonical;my$scheme=$other->scheme;my$auth=$other->authority;return$other if!defined($scheme)&&!defined($auth);if (!defined($auth)|| $auth eq "" || lc($auth)eq "localhost" || (defined($DEFAULT_AUTHORITY)&& lc($auth)eq lc($DEFAULT_AUTHORITY))){if ((defined($auth)|| defined($DEFAULT_AUTHORITY))&& (!defined($auth)||!defined($DEFAULT_AUTHORITY)|| $auth ne $DEFAULT_AUTHORITY)){$other=$other->clone if$self==$other;$other->authority($DEFAULT_AUTHORITY)}}$other}sub file {my($self,$os)=@_;os_class($os)->file($self)}sub dir {my($self,$os)=@_;os_class($os)->dir($self)}1;
URI_FILE

$fatpacked{"URI/file/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_BASE';
  package URI::file::Base;use strict;use warnings;use URI::Escape qw();our$VERSION='1.76';sub new {my$class=shift;my$path=shift;$path="" unless defined$path;my($auth,$escaped_auth,$escaped_path);($auth,$escaped_auth)=$class->_file_extract_authority($path);($path,$escaped_path)=$class->_file_extract_path($path);if (defined$auth){$auth =~ s,%,%25,g unless$escaped_auth;$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;$auth="//$auth";if (defined$path){$path="/$path" unless substr($path,0,1)eq "/"}else {$path=""}}else {return undef unless defined$path;$auth=""}$path =~ s,([%;?]), URI::Escape::escape_char($1),eg unless$escaped_path;$path =~ s/\#/%23/g;my$uri=$auth .$path;$uri="file:$uri" if substr($uri,0,1)eq "/";URI->new($uri,"file")}sub _file_extract_authority {my($class,$path)=@_;return undef unless$class->_file_is_absolute($path);return$URI::file::DEFAULT_AUTHORITY}sub _file_extract_path {return undef}sub _file_is_absolute {return 0}sub _file_is_localhost {shift;my$host=lc(shift);return 1 if$host eq "localhost";eval {require Net::Domain;lc(Net::Domain::hostfqdn()|| '')eq $host || lc(Net::Domain::hostname()|| '')eq $host}}sub file {undef}sub dir {my$self=shift;$self->file(@_)}1;
URI_FILE_BASE

$fatpacked{"URI/file/FAT.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_FAT';
  package URI::file::FAT;use strict;use warnings;use parent 'URI::file::Win32';our$VERSION='1.76';sub fix_path {shift;for (@_){my@p=map uc,split(/\./,$_,-1);return if@p > 2;@p=("")unless@p;$_=substr($p[0],0,8);if (@p > 1){my$ext=substr($p[1],0,3);$_ .= ".$ext" if length$ext}}1}1;
URI_FILE_FAT

$fatpacked{"URI/file/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_MAC';
  package URI::file::Mac;use strict;use warnings;use parent 'URI::file::Base';use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub _file_extract_path {my$class=shift;my$path=shift;my@pre;if ($path =~ s/^(:+)//){if (length($1)==1){@pre=(".")unless length($path)}else {@pre=("..")x (length($1)- 1)}}else {$pre[0]=""}my$isdir=($path =~ s/:$//);$path =~ s,([%/;]), URI::Escape::escape_char($1),eg;my@path=split(/:/,$path,-1);for (@path){if ($_ eq "." || $_ eq ".."){$_="%2E" x length($_)}$_=".." unless length($_)}push (@path,"")if$isdir;(join("/",@pre,@path),1)}sub file {my$class=shift;my$uri=shift;my@path;my$auth=$uri->authority;if (defined$auth){if (lc($auth)ne "localhost" && $auth ne ""){my$u_auth=uri_unescape($auth);if (!$class->_file_is_localhost($u_auth)){@path=("",$auth)}}}my@ps=split("/",$uri->path,-1);shift@ps if@path;push(@path,@ps);my$pre="";if (!@path){return}elsif ($path[0]eq ""){shift(@path);if (@path==1){return if$path[0]eq "";push(@path,"")}@ps=@path;@path=();my$part;for (@ps){next if $_ eq ".";$part=$_ eq ".." ? "" : $_;push(@path,$part)}if ($ps[-1]eq ".."){push(@path,"")}}else {$pre=":";@ps=@path;@path=();my$part;for (@ps){next if $_ eq ".";$part=$_ eq ".." ? "" : $_;push(@path,$part)}if ($ps[-1]eq ".."){push(@path,"")}}return unless$pre || @path;for (@path){s/;.*//;$_=uri_unescape($_);return if /\0/;return if /:/}$pre .join(":",@path)}sub dir {my$class=shift;my$path=$class->file(@_);return unless defined$path;$path .= ":" unless$path =~ /:$/;$path}1;
URI_FILE_MAC

$fatpacked{"URI/file/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_OS2';
  package URI::file::OS2;use strict;use warnings;use parent 'URI::file::Win32';our$VERSION='1.76';sub _file_extract_authority {my$class=shift;return $1 if $_[0]=~ s,^\\\\([^\\]+),,;return $1 if $_[0]=~ s,^//([^/]+),,;if ($_[0]=~ m#^[a-zA-Z]{1,2}:#){return ""}return}sub file {my$p=&URI::file::Win32::file;return unless defined$p;$p =~ s,\\,/,g;$p}1;
URI_FILE_OS2

$fatpacked{"URI/file/QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_QNX';
  package URI::file::QNX;use strict;use warnings;use parent 'URI::file::Unix';our$VERSION='1.76';sub _file_extract_path {my($class,$path)=@_;$path =~ s,(.)//+,$1/,g;$path =~ s,(/\.)+/,/,g;$path="./$path" if$path =~ m,^[^:/]+:,,;$path}1;
URI_FILE_QNX

$fatpacked{"URI/file/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_UNIX';
  package URI::file::Unix;use strict;use warnings;use parent 'URI::file::Base';use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub _file_extract_path {my($class,$path)=@_;$path =~ s,//+,/,g;$path =~ s,(/\.)+/,/,g;$path="./$path" if$path =~ m,^[^:/]+:,,;return$path}sub _file_is_absolute {my($class,$path)=@_;return$path =~ m,^/,}sub file {my$class=shift;my$uri=shift;my@path;my$auth=$uri->authority;if (defined($auth)){if (lc($auth)ne "localhost" && $auth ne ""){$auth=uri_unescape($auth);unless ($class->_file_is_localhost($auth)){push(@path,"","",$auth)}}}my@ps=$uri->path_segments;shift@ps if@path;push(@path,@ps);for (@path){return undef if /\0/;return undef if /\//}return join("/",@path)}1;
URI_FILE_UNIX

$fatpacked{"URI/file/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_WIN32';
  package URI::file::Win32;use strict;use warnings;use parent 'URI::file::Base';use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub _file_extract_authority {my$class=shift;return$class->SUPER::_file_extract_authority($_[0])if defined$URI::file::DEFAULT_AUTHORITY;return $1 if $_[0]=~ s,^\\\\([^\\]+),,;return $1 if $_[0]=~ s,^//([^/]+),,;if ($_[0]=~ s,^([a-zA-Z]:),,){my$auth=$1;$auth .= "relative" if $_[0]!~ m,^[\\/],;return$auth}return undef}sub _file_extract_path {my($class,$path)=@_;$path =~ s,\\,/,g;$path =~ s,(/\.)+/,/,g;if (defined$URI::file::DEFAULT_AUTHORITY){$path =~ s,^([a-zA-Z]:),/$1,}return$path}sub _file_is_absolute {my($class,$path)=@_;return$path =~ m,^[a-zA-Z]:, || $path =~ m,^[/\\],}sub file {my$class=shift;my$uri=shift;my$auth=$uri->authority;my$rel;if (defined$auth){$auth=uri_unescape($auth);if ($auth =~ /^([a-zA-Z])[:|](relative)?/){$auth=uc($1).":";$rel++ if $2}elsif (lc($auth)eq "localhost"){$auth=""}elsif (length$auth){$auth="\\\\" .$auth}}else {$auth=""}my@path=$uri->path_segments;for (@path){return undef if /\0/;return undef if /\//}return undef unless$class->fix_path(@path);my$path=join("\\",@path);$path =~ s/^\\// if$rel;$path=$auth .$path;$path =~ s,^\\([a-zA-Z])[:|],\u$1:,;return$path}sub fix_path {1}1;
URI_FILE_WIN32

$fatpacked{"URI/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FTP';
  package URI::ftp;use strict;use warnings;our$VERSION='1.76';use parent qw(URI::_server URI::_userpass);sub default_port {21}sub path {shift->path_query(@_)}sub _user {shift->SUPER::user(@_)}sub _password {shift->SUPER::password(@_)}sub user {my$self=shift;my$user=$self->_user(@_);$user="anonymous" unless defined$user;$user}sub password {my$self=shift;my$pass=$self->_password(@_);unless (defined$pass){my$user=$self->user;if ($user eq 'anonymous' || $user eq 'ftp'){$pass='anonymous@'}}$pass}1;
URI_FTP

$fatpacked{"URI/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_GOPHER';
  package URI::gopher;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_server';use URI::Escape qw(uri_unescape);sub default_port {70}sub _gopher_type {my$self=shift;my$path=$self->path_query;$path =~ s,^/,,;my$gtype=$1 if$path =~ s/^(.)//s;if (@_){my$new_type=shift;if (defined($new_type)){Carp::croak("Bad gopher type '$new_type'")unless length($new_type)==1;substr($path,0,0)=$new_type;$self->path_query($path)}else {Carp::croak("Can't delete gopher type when selector is present")if length($path);$self->path_query(undef)}}return$gtype}sub gopher_type {my$self=shift;my$gtype=$self->_gopher_type(@_);$gtype="1" unless defined$gtype;$gtype}sub gtype {goto&gopher_type}sub selector {shift->_gfield(0,@_)}sub search {shift->_gfield(1,@_)}sub string {shift->_gfield(2,@_)}sub _gfield {my$self=shift;my$fno=shift;my$path=$self->path_query;$path =~ s/\?/\t/;$path=uri_unescape($path);$path =~ s,^/,,;my$gtype=$1 if$path =~ s,^(.),,s;my@path=split(/\t/,$path,3);if (@_){my$new=shift;$path[$fno]=$new;pop(@path)while@path &&!defined($path[-1]);for (@path){$_="" unless defined}$path=$gtype;$path="1" unless defined$path;$path .= join("\t",@path);$self->path_query($path)}$path[$fno]}1;
URI_GOPHER

$fatpacked{"URI/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTP';
  package URI::http;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_server';sub default_port {80}sub canonical {my$self=shift;my$other=$self->SUPER::canonical;my$slash_path=defined($other->authority)&& !length($other->path)&&!defined($other->query);if ($slash_path){$other=$other->clone if$other==$self;$other->path("/")}$other}1;
URI_HTTP

$fatpacked{"URI/https.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTPS';
  package URI::https;use strict;use warnings;our$VERSION='1.76';use parent 'URI::http';sub default_port {443}sub secure {1}1;
URI_HTTPS

$fatpacked{"URI/ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAP';
  package URI::ldap;use strict;use warnings;our$VERSION='1.76';use parent qw(URI::_ldap URI::_server);sub default_port {389}sub _nonldap_canonical {my$self=shift;$self->URI::_server::canonical(@_)}1;
URI_LDAP

$fatpacked{"URI/ldapi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPI';
  package URI::ldapi;use strict;use warnings;our$VERSION='1.76';use parent qw(URI::_ldap URI::_generic);require URI::Escape;sub un_path {my$self=shift;my$old=URI::Escape::uri_unescape($self->authority);if (@_){my$p=shift;$p =~ s/:/%3A/g;$p =~ s/\@/%40/g;$self->authority($p)}return$old}sub _nonldap_canonical {my$self=shift;$self->URI::_generic::canonical(@_)}1;
URI_LDAPI

$fatpacked{"URI/ldaps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPS';
  package URI::ldaps;use strict;use warnings;our$VERSION='1.76';use parent 'URI::ldap';sub default_port {636}sub secure {1}1;
URI_LDAPS

$fatpacked{"URI/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MAILTO';
  package URI::mailto;use strict;use warnings;our$VERSION='1.76';use parent qw(URI URI::_query);sub to {my$self=shift;my@old=$self->headers;if (@_){my@new=@old;for (my$i=0;$i < @new;$i += 2){if (lc($new[$i]|| '')eq "to"){splice(@new,$i,2);redo}}my$to=shift;$to="" unless defined$to;unshift(@new,"to"=>$to);$self->headers(@new)}return unless defined wantarray;my@to;while (@old){my$h=shift@old;my$v=shift@old;push(@to,$v)if lc($h)eq "to"}join(",",@to)}sub headers {my$self=shift;my$opaque="to=" .$self->opaque;$opaque =~ s/\?/&/;if (@_){my@new=@_;my@to;for (my$i=0;$i < @new;$i += 2){if (lc($new[$i]|| '')eq "to"){push(@to,(splice(@new,$i,2))[1]);redo}}my$new=join(",",@to);$new =~ s/%/%25/g;$new =~ s/\?/%3F/g;$self->opaque($new);$self->query_form(@new)if@new}return unless defined wantarray;URI->new("mailto:?$opaque")->query_form}1;
URI_MAILTO

$fatpacked{"URI/mms.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MMS';
  package URI::mms;use strict;use warnings;our$VERSION='1.76';use parent 'URI::http';sub default_port {1755}1;
URI_MMS

$fatpacked{"URI/news.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NEWS';
  package URI::news;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_server';use URI::Escape qw(uri_unescape);use Carp ();sub default_port {119}sub _group {my$self=shift;my$old=$self->path;if (@_){my($group,$from,$to)=@_;if ($group =~ /\@/){$group =~ s/^<(.*)>$/$1/}$group =~ s,%,%25,g;$group =~ s,/,%2F,g;my$path=$group;if (defined$from){$path .= "/$from";$path .= "-$to" if defined$to}$self->path($path)}$old =~ s,^/,,;if ($old !~ /\@/ && $old =~ s,/(.*),, && wantarray){my$extra=$1;return (uri_unescape($old),split(/-/,$extra))}uri_unescape($old)}sub group {my$self=shift;if (@_){Carp::croak("Group name can't contain '\@'")if $_[0]=~ /\@/}my@old=$self->_group(@_);return if$old[0]=~ /\@/;wantarray ? @old : $old[0]}sub message {my$self=shift;if (@_){Carp::croak("Message must contain '\@'")unless $_[0]=~ /\@/}my$old=$self->_group(@_);return undef unless$old =~ /\@/;return$old}1;
URI_NEWS

$fatpacked{"URI/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NNTP';
  package URI::nntp;use strict;use warnings;our$VERSION='1.76';use parent 'URI::news';1;
URI_NNTP

$fatpacked{"URI/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_POP';
  package URI::pop;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_server';use URI::Escape qw(uri_unescape);sub default_port {110}sub user {my$self=shift;my$old=$self->userinfo;if (@_){my$new_info=$old;$new_info="" unless defined$new_info;$new_info =~ s/^[^;]*//;my$new=shift;if (!defined($new)&&!length($new_info)){$self->userinfo(undef)}else {$new="" unless defined$new;$new =~ s/%/%25/g;$new =~ s/;/%3B/g;$self->userinfo("$new$new_info")}}return undef unless defined$old;$old =~ s/;.*//;return uri_unescape($old)}sub auth {my$self=shift;my$old=$self->userinfo;if (@_){my$new=$old;$new="" unless defined$new;$new =~ s/(^[^;]*)//;my$user=$1;$new =~ s/;auth=[^;]*//i;my$auth=shift;if (defined$auth){$auth =~ s/%/%25/g;$auth =~ s/;/%3B/g;$new=";AUTH=$auth$new"}$self->userinfo("$user$new")}return undef unless defined$old;$old =~ s/^[^;]*//;return uri_unescape($1)if$old =~ /;auth=(.*)/i;return}1;
URI_POP

$fatpacked{"URI/rlogin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RLOGIN';
  package URI::rlogin;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_login';sub default_port {513}1;
URI_RLOGIN

$fatpacked{"URI/rsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RSYNC';
  package URI::rsync;use strict;use warnings;our$VERSION='1.76';use parent qw(URI::_server URI::_userpass);sub default_port {873}1;
URI_RSYNC

$fatpacked{"URI/rtsp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSP';
  package URI::rtsp;use strict;use warnings;our$VERSION='1.76';use parent 'URI::http';sub default_port {554}1;
URI_RTSP

$fatpacked{"URI/rtspu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSPU';
  package URI::rtspu;use strict;use warnings;our$VERSION='1.76';use parent 'URI::rtsp';sub default_port {554}1;
URI_RTSPU

$fatpacked{"URI/sftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SFTP';
  package URI::sftp;use strict;use warnings;use parent 'URI::ssh';our$VERSION='1.76';1;
URI_SFTP

$fatpacked{"URI/sip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIP';
  package URI::sip;use strict;use warnings;use parent qw(URI::_server URI::_userpass);use URI::Escape qw(uri_unescape);our$VERSION='1.76';sub default_port {5060}sub authority {my$self=shift;$$self =~ m,^($URI::scheme_re:)?([^;?]*)(.*)$,os or die;my$old=$2;if (@_){my$auth=shift;$$self=defined($1)? $1 : "";my$rest=$3;if (defined$auth){$auth =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;$$self .= "$auth"}$$self .= $rest}$old}sub params_form {my$self=shift;$$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;my$paramstr=$3;if (@_){my@args=@_;$$self=$1 .$2;my$rest=$4;my@new;for (my$i=0;$i < @args;$i += 2){push(@new,"$args[$i]=$args[$i+1]")}$paramstr=join(";",@new);$$self .= ";" .$paramstr .$rest}$paramstr =~ s/^;//o;return split(/[;=]/,$paramstr)}sub params {my$self=shift;$$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;my$paramstr=$3;if (@_){my$new=shift;$$self=$1 .$2;my$rest=$4;$$self .= $paramstr .$rest}$paramstr =~ s/^;//o;return$paramstr}sub path {}sub path_query {}sub path_segments {}sub abs {shift}sub rel {shift}sub query_keywords {}1;
URI_SIP

$fatpacked{"URI/sips.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIPS';
  package URI::sips;use strict;use warnings;our$VERSION='1.76';use parent 'URI::sip';sub default_port {5061}sub secure {1}1;
URI_SIPS

$fatpacked{"URI/snews.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SNEWS';
  package URI::snews;use strict;use warnings;our$VERSION='1.76';use parent 'URI::news';sub default_port {563}sub secure {1}1;
URI_SNEWS

$fatpacked{"URI/ssh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SSH';
  package URI::ssh;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_login';sub default_port {22}sub secure {1}1;
URI_SSH

$fatpacked{"URI/telnet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TELNET';
  package URI::telnet;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_login';sub default_port {23}1;
URI_TELNET

$fatpacked{"URI/tn3270.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TN3270';
  package URI::tn3270;use strict;use warnings;our$VERSION='1.76';use parent 'URI::_login';sub default_port {23}1;
URI_TN3270

$fatpacked{"URI/urn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN';
  package URI::urn;use strict;use warnings;our$VERSION='1.76';use parent 'URI';use Carp qw(carp);my%implementor;my%require_attempted;sub _init {my$class=shift;my$self=$class->SUPER::_init(@_);my$nid=$self->nid;my$impclass=$implementor{$nid};return$impclass->_urn_init($self,$nid)if$impclass;$impclass="URI::urn";if ($nid =~ /^[A-Za-z\d][A-Za-z\d\-]*\z/){my$id=$nid;$id =~ s/-/_/g;$id="_$id" if$id =~ /^\d/;$impclass="URI::urn::$id";no strict 'refs';unless (@{"${impclass}::ISA"}){if (not exists$require_attempted{$impclass}){my$_old_error=$@;eval "require $impclass";die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;$@=$_old_error}$impclass="URI::urn" unless @{"${impclass}::ISA"}}}else {carp("Illegal namespace identifier '$nid' for URN '$self'")if $^W}$implementor{$nid}=$impclass;return$impclass->_urn_init($self,$nid)}sub _urn_init {my($class,$self,$nid)=@_;bless$self,$class}sub _nid {my$self=shift;my$opaque=$self->opaque;if (@_){my$v=$opaque;my$new=shift;$v =~ s/[^:]*/$new/;$self->opaque($v)}$opaque =~ s/:.*//s;return$opaque}sub nid {my$self=shift;my$nid=$self->_nid(@_);$nid=lc($nid)if defined($nid);return$nid}sub nss {my$self=shift;my$opaque=$self->opaque;if (@_){my$v=$opaque;my$new=shift;if (defined$new){$v =~ s/(:|\z).*/:$new/}else {$v =~ s/:.*//s}$self->opaque($v)}return undef unless$opaque =~ s/^[^:]*://;return$opaque}sub canonical {my$self=shift;my$nid=$self->_nid;my$new=$self->SUPER::canonical;return$new if$nid !~ /[A-Z]/ || $nid =~ /%/;$new=$new->clone if$new==$self;$new->nid(lc($nid));return$new}1;
URI_URN

$fatpacked{"URI/urn/isbn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_ISBN';
  package URI::urn::isbn;use strict;use warnings;our$VERSION='1.76';use parent 'URI::urn';use Carp qw(carp);BEGIN {require Business::ISBN;local $^W=0;warn "Using Business::ISBN version " .Business::ISBN->VERSION ." which is deprecated.\nUpgrade to Business::ISBN version 2\n" if Business::ISBN->VERSION < 2}sub _isbn {my$nss=shift;$nss=$nss->nss if ref($nss);my$isbn=Business::ISBN->new($nss);$isbn=undef if$isbn &&!$isbn->is_valid;return$isbn}sub _nss_isbn {my$self=shift;my$nss=$self->nss(@_);my$isbn=_isbn($nss);$isbn=$isbn->as_string if$isbn;return($nss,$isbn)}sub isbn {my$self=shift;my$isbn;(undef,$isbn)=$self->_nss_isbn(@_);return$isbn}sub isbn_publisher_code {my$isbn=shift->_isbn || return undef;return$isbn->publisher_code}BEGIN {my$group_method=do {local $^W=0;Business::ISBN->VERSION >= 2 ? 'group_code' : 'country_code'};sub isbn_group_code {my$isbn=shift->_isbn || return undef;return$isbn->$group_method}}sub isbn_country_code {my$name=(caller(0))[3];$name =~ s/.*:://;carp "$name is DEPRECATED. Use isbn_group_code instead";no strict 'refs';&isbn_group_code}BEGIN {my$isbn13_method=do {local $^W=0;Business::ISBN->VERSION >= 2 ? 'as_isbn13' : 'as_ean'};sub isbn13 {my$isbn=shift->_isbn || return undef;my$thingy=$isbn->$isbn13_method;return eval {$thingy->can('as_string')}? $thingy->as_string([]): $thingy}}sub isbn_as_ean {my$name=(caller(0))[3];$name =~ s/.*:://;carp "$name is DEPRECATED. Use isbn13 instead";no strict 'refs';&isbn13}sub canonical {my$self=shift;my($nss,$isbn)=$self->_nss_isbn;my$new=$self->SUPER::canonical;return$new unless$nss && $isbn && $nss ne $isbn;$new=$new->clone if$new==$self;$new->nss($isbn);return$new}1;
URI_URN_ISBN

$fatpacked{"URI/urn/oid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_OID';
  package URI::urn::oid;use strict;use warnings;our$VERSION='1.76';use parent 'URI::urn';sub oid {my$self=shift;my$old=$self->nss;if (@_){$self->nss(join(".",@_))}return split(/\./,$old)if wantarray;return$old}1;
URI_URN_OID

$fatpacked{"Win32/ShellQuote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WIN32_SHELLQUOTE';
  package Win32::ShellQuote;use strict;use warnings FATAL=>'all';use base 'Exporter';use Carp;our$VERSION='0.003001';$VERSION=eval$VERSION;our@EXPORT_OK=qw(quote_native quote_cmd quote_system_list quote_system_string quote_system quote_system_cmd quote_literal cmd_escape unquote_native cmd_unescape);our%EXPORT_TAGS=(all=>[@EXPORT_OK]);sub quote_native {return join q{ },quote_system_list(@_)}sub quote_cmd {return cmd_escape(quote_native(@_))}sub quote_system_list {return map {quote_literal($_,1)}@_}sub quote_system_string {my$args=quote_native(@_);if (_has_shell_metachars($args)){$args=cmd_escape($args)}return$args}sub quote_system {if (@_ > 1){return quote_system_list(@_)}else {return quote_system_string(@_)}}sub quote_system_cmd {my$args=quote_native(@_);if (!_has_shell_metachars($args)){return '%PATH:~0,0%' .cmd_escape($args)}return cmd_escape($args)}sub cmd_escape {my$string=shift;if ($string =~ /[\r\n\0]/){croak "can't quote newlines to pass through cmd.exe"}$string =~ s/([()%!^"<>&|])/^$1/g;return$string}sub quote_literal {my ($text,$force)=@_;if (!$force && $text ne '' && $text !~ /[ \t\n\x0b"]/){}else {$text =~ s{(\\*)(?="|\z)}{$1$1}g;$text =~ s{"}{\\"}g;$text=qq{"$text"}}return$text}sub _has_shell_metachars {my$string=shift;return 1 if$string =~ /%/;$string =~ s/(['"]).*?(\1|\z)//sg;return$string =~ /[<>|]/}sub unquote_native {local ($_)=@_;my@argv;my$length=length or return@argv;m/\G\s*/gc;ARGS: until (pos==$length){my$quote_mode;my$arg='';CHARS: until (pos==$length){if (m/\G((?:\\\\)+)(?=\\?(")?)/gc){if (defined $2){$arg .= '\\' x (length($1)/ 2)}else {$arg .= $1}}elsif (m/\G\\"/gc){$arg .= '"'}elsif (m/\G"/gc){if ($quote_mode && m/\G"/gc){$arg .= '"'}$quote_mode=!$quote_mode}elsif (!$quote_mode && m/\G\s+/gc){last}elsif (m/\G(.)/sgc){$arg .= $1}}push@argv,$arg}return@argv}sub cmd_unescape {my ($string)=@_;no warnings 'uninitialized';$string =~ s/\^(.?)|([^^"]+)|("[^"]*(?:"|\z))/$1$2$3/gs;return$string}1;
WIN32_SHELLQUOTE

$fatpacked{"lib/core/only.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIB_CORE_ONLY';
  package lib::core::only;use strict;use warnings FATAL=>'all';use Config;sub import {@INC=@Config{qw(privlibexp archlibexp)};return}1;
LIB_CORE_ONLY

$fatpacked{"local/lib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCAL_LIB';
  package local::lib;use 5.006;BEGIN {if ($ENV{RELEASE_TESTING}){require strict;strict->import;require warnings;warnings->import}}use Config ();our$VERSION='2.000024';$VERSION=eval$VERSION;BEGIN {*_WIN32=($^O eq 'MSWin32' || $^O eq 'NetWare' || $^O eq 'symbian')? sub(){1}: sub(){0};*_USE_FSPEC=($^O eq 'MacOS' || $^O eq 'VMS' || $INC{'File/Spec.pm'})? sub(){1}: sub(){0}}my$_archname=$Config::Config{archname};my$_version=$Config::Config{version};my@_inc_version_list=reverse split / /,$Config::Config{inc_version_list};my$_path_sep=$Config::Config{path_sep};our$_DIR_JOIN=_WIN32 ? '\\' : '/';our$_DIR_SPLIT=(_WIN32 || $^O eq 'cygwin')? qr{[\\/]} : qr{/};our$_ROOT=_WIN32 ? do {my$UNC=qr{[\\/]{2}[^\\/]+[\\/][^\\/]+};qr{^(?:$UNC|[A-Za-z]:|)$_DIR_SPLIT}}: qr{^/};our$_PERL;sub _perl {if (!$_PERL){($_PERL,my$exe)=$^X =~ /((?:.*$_DIR_SPLIT)?(.+))/;$_PERL='perl' if$exe !~ /perl/;if (_is_abs($_PERL)){}elsif (-x $Config::Config{perlpath}){$_PERL=$Config::Config{perlpath}}elsif ($_PERL =~ $_DIR_SPLIT && -x $_PERL){$_PERL=_rel2abs($_PERL)}else {($_PERL)=map {/(.*)/}grep {-x $_}map {($_,_WIN32 ? ("$_.exe"): ())}map {join($_DIR_JOIN,$_,$_PERL)}split /\Q$_path_sep\E/,$ENV{PATH}}}$_PERL}sub _cwd {if (my$cwd =defined&Cwd::sys_cwd ? \&Cwd::sys_cwd : defined&Cwd::cwd ? \&Cwd::cwd : undef){no warnings 'redefine';*_cwd=$cwd;goto &$cwd}my$drive=shift;return Win32::Cwd()if _WIN32 && defined&Win32::Cwd &&!$drive;local@ENV{qw(PATH IFS CDPATH ENV BASH_ENV)};my$cmd=$drive ? "eval { Cwd::getdcwd(q($drive)) }" : 'getcwd';my$perl=_perl;my$cwd=`"$perl" -MCwd -le "print $cmd"`;chomp$cwd;if (!length$cwd && $drive){$cwd=$drive}$cwd =~ s/$_DIR_SPLIT?$/$_DIR_JOIN/;$cwd}sub _catdir {if (_USE_FSPEC){require File::Spec;File::Spec->catdir(@_)}else {my$dir=join($_DIR_JOIN,@_);$dir =~ s{($_DIR_SPLIT)(?:\.?$_DIR_SPLIT)+}{$1}g;$dir}}sub _is_abs {if (_USE_FSPEC){require File::Spec;File::Spec->file_name_is_absolute($_[0])}else {$_[0]=~ $_ROOT}}sub _rel2abs {my ($dir,$base)=@_;return$dir if _is_abs($dir);$base=_WIN32 && $dir =~ s/^([A-Za-z]:)// ? _cwd("$1"): $base ? _rel2abs($base): _cwd;return _catdir($base,$dir)}our$_DEVNULL;sub _devnull {return$_DEVNULL ||= _USE_FSPEC ? (require File::Spec,File::Spec->devnull): _WIN32 ? 'nul' : $^O eq 'os2' ? '/dev/nul' : '/dev/null'}sub import {my ($class,@args)=@_;if ($0 eq '-'){push@args,@ARGV;require Cwd}my@steps;my%opts;my%attr;my$shelltype;while (@args){my$arg=shift@args;if ($arg =~ /\xE2\x88\x92/){die <<'DEATH'}elsif ($arg eq '--self-contained'){die <<'DEATH'}elsif($arg =~ /^--deactivate(?:=(.*))?$/){my$path=defined $1 ? $1 : shift@args;push@steps,['deactivate',$path]}elsif ($arg eq '--deactivate-all'){push@steps,['deactivate_all']}elsif ($arg =~ /^--shelltype(?:=(.*))?$/){$shelltype=defined $1 ? $1 : shift@args}elsif ($arg eq '--no-create'){$opts{no_create}=1}elsif ($arg eq '--quiet'){$attr{quiet}=1}elsif ($arg =~ /^--/){die "Unknown import argument: $arg"}else {push@steps,['activate',$arg,\%opts]}}if (!@steps){push@steps,['activate',undef,\%opts]}my$self=$class->new(%attr);for (@steps){my ($method,@args)=@$_;$self=$self->$method(@args)}if ($0 eq '-'){print$self->environment_vars_string($shelltype);exit 0}else {$self->setup_local_lib}}sub new {my$class=shift;bless {@_},$class}sub clone {my$self=shift;bless {%$self,@_},ref$self}sub inc {$_[0]->{inc}||= \@INC}sub libs {$_[0]->{libs}||= [\'PERL5LIB' ]}sub bins {$_[0]->{bins}||= [\'PATH' ]}sub roots {$_[0]->{roots}||= [\'PERL_LOCAL_LIB_ROOT' ]}sub extra {$_[0]->{extra}||= {}}sub quiet {$_[0]->{quiet}}sub _as_list {my$list=shift;grep length,map {!(ref $_ && ref $_ eq 'SCALAR')? $_ : (defined$ENV{$$_}? split(/\Q$_path_sep/,$ENV{$$_}): ())}ref$list ? @$list : $list}sub _remove_from {my ($list,@remove)=@_;return @$list if!@remove;my%remove=map {$_=>1}@remove;grep!$remove{$_},_as_list($list)}my@_lib_subdirs=([$_version,$_archname],[$_version],[$_archname],(map [$_],@_inc_version_list),[],);sub install_base_bin_path {my ($class,$path)=@_;return _catdir($path,'bin')}sub install_base_perl_path {my ($class,$path)=@_;return _catdir($path,'lib','perl5')}sub install_base_arch_path {my ($class,$path)=@_;_catdir($class->install_base_perl_path($path),$_archname)}sub lib_paths_for {my ($class,$path)=@_;my$base=$class->install_base_perl_path($path);return map {_catdir($base,@$_)}@_lib_subdirs}sub _mm_escape_path {my$path=shift;$path =~ s/\\/\\\\/g;if ($path =~ s/ /\\ /g){$path=qq{"$path"}}return$path}sub _mb_escape_path {my$path=shift;$path =~ s/\\/\\\\/g;return qq{"$path"}}sub installer_options_for {my ($class,$path)=@_;return (PERL_MM_OPT=>defined$path ? "INSTALL_BASE="._mm_escape_path($path): undef,PERL_MB_OPT=>defined$path ? "--install_base "._mb_escape_path($path): undef,)}sub active_paths {my ($self)=@_;$self=ref$self ? $self : $self->new;return grep {my$active_ll=$self->install_base_perl_path($_);grep {$_ eq $active_ll}@{$self->inc}}_as_list($self->roots)}sub deactivate {my ($self,$path)=@_;$self=$self->new unless ref$self;$path=$self->resolve_path($path);$path=$self->normalize_path($path);my@active_lls=$self->active_paths;if (!grep {$_ eq $path}@active_lls){warn "Tried to deactivate inactive local::lib '$path'\n";return$self}my%args=(bins=>[_remove_from($self->bins,$self->install_base_bin_path($path))],libs=>[_remove_from($self->libs,$self->install_base_perl_path($path))],inc=>[_remove_from($self->inc,$self->lib_paths_for($path))],roots=>[_remove_from($self->roots,$path)],);$args{extra}={$self->installer_options_for($args{roots}[0])};$self->clone(%args)}sub deactivate_all {my ($self)=@_;$self=$self->new unless ref$self;my@active_lls=$self->active_paths;my%args;if (@active_lls){%args=(bins=>[_remove_from($self->bins,map$self->install_base_bin_path($_),@active_lls)],libs=>[_remove_from($self->libs,map$self->install_base_perl_path($_),@active_lls)],inc=>[_remove_from($self->inc,map$self->lib_paths_for($_),@active_lls)],roots=>[_remove_from($self->roots,@active_lls)],)}$args{extra}={$self->installer_options_for(undef)};$self->clone(%args)}sub activate {my ($self,$path,$opts)=@_;$opts ||= {};$self=$self->new unless ref$self;$path=$self->resolve_path($path);$self->ensure_dir_structure_for($path,{quiet=>$self->quiet })unless$opts->{no_create};$path=$self->normalize_path($path);my@active_lls=$self->active_paths;if (grep {$_ eq $path}@active_lls[1 .. $#active_lls]){$self=$self->deactivate($path)}my%args;if ($opts->{always}||!@active_lls || $active_lls[0]ne $path){%args=(bins=>[$self->install_base_bin_path($path),@{$self->bins}],libs=>[$self->install_base_perl_path($path),@{$self->libs}],inc=>[$self->lib_paths_for($path),@{$self->inc}],roots=>[$path,@{$self->roots}],)}$args{extra}={$self->installer_options_for($path)};$self->clone(%args)}sub normalize_path {my ($self,$path)=@_;$path=(Win32::GetShortPathName($path)|| $path)if $^O eq 'MSWin32';return$path}sub build_environment_vars_for {my$self=$_[0]->new->activate($_[1],{always=>1 });$self->build_environment_vars}sub build_activate_environment_vars_for {my$self=$_[0]->new->activate($_[1],{always=>1 });$self->build_environment_vars}sub build_deactivate_environment_vars_for {my$self=$_[0]->new->deactivate($_[1]);$self->build_environment_vars}sub build_deact_all_environment_vars_for {my$self=$_[0]->new->deactivate_all;$self->build_environment_vars}sub build_environment_vars {my$self=shift;(PATH=>join($_path_sep,_as_list($self->bins)),PERL5LIB=>join($_path_sep,_as_list($self->libs)),PERL_LOCAL_LIB_ROOT=>join($_path_sep,_as_list($self->roots)),%{$self->extra},)}sub setup_local_lib_for {my$self=$_[0]->new->activate($_[1]);$self->setup_local_lib}sub setup_local_lib {my$self=shift;require Carp::Heavy if$INC{'Carp.pm'};$self->setup_env_hash;@INC=@{$self->inc}}sub setup_env_hash_for {my$self=$_[0]->new->activate($_[1]);$self->setup_env_hash}sub setup_env_hash {my$self=shift;my%env=$self->build_environment_vars;for my$key (keys%env){if (defined$env{$key}){$ENV{$key}=$env{$key}}else {delete$ENV{$key}}}}sub print_environment_vars_for {print $_[0]->environment_vars_string_for(@_[1..$#_])}sub environment_vars_string_for {my$self=$_[0]->new->activate($_[1],{always=>1});$self->environment_vars_string}sub environment_vars_string {my ($self,$shelltype)=@_;$shelltype ||= $self->guess_shelltype;my$extra=$self->extra;my@envs=(PATH=>$self->bins,PERL5LIB=>$self->libs,PERL_LOCAL_LIB_ROOT=>$self->roots,map {$_=>$extra->{$_}}sort keys %$extra,);$self->_build_env_string($shelltype,\@envs)}sub _build_env_string {my ($self,$shelltype,$envs)=@_;my@envs=@$envs;my$build_method="build_${shelltype}_env_declaration";my$out='';while (@envs){my ($name,$value)=(shift(@envs),shift(@envs));if (ref$value && @$value==1 && ref$value->[0]&& ref$value->[0]eq 'SCALAR' && ${$value->[0]}eq $name){next}$out .= $self->$build_method($name,$value)}my$wrap_method="wrap_${shelltype}_output";if ($self->can($wrap_method)){return$self->$wrap_method($out)}return$out}sub build_bourne_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'${%s:-}',qr/["\\\$!`]/,'\\%s');if (!defined$value){return qq{unset $name;\n}}$value =~ s/(^|\G|$_path_sep)\$\{$name:-\}$_path_sep/$1\${$name}\${$name:+$_path_sep}/g;$value =~ s/$_path_sep\$\{$name:-\}$/\${$name:+$_path_sep\${$name}}/;qq{${name}="$value"; export ${name};\n}}sub build_csh_env_declaration {my ($class,$name,$args)=@_;my ($value,@vars)=$class->_interpolate($args,'${%s}',qr/["\$]/,'"\\%s"');if (!defined$value){return qq{unsetenv $name;\n}}my$out='';for my$var (@vars){$out .= qq{if ! \$?$name setenv $name '';\n}}my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)\$\{$name\}(?:$_path_sep|$)//g){$out .= qq{if "\${$name}" != '' setenv $name "$value";\n};$out .= qq{if "\${$name}" == '' }}$out .= qq{setenv $name "$value_without";\n};return$out}sub build_cmd_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'%%%s%%',qr(%),'%s');if (!$value){return qq{\@set $name=\n}}my$out='';my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)%$name%(?:$_path_sep|$)//g){$out .= qq{\@if not "%$name%"=="" set "$name=$value"\n};$out .= qq{\@if "%$name%"=="" }}$out .= qq{\@set "$name=$value_without"\n};return$out}sub build_powershell_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'$env:%s',qr/["\$]/,'`%s');if (!$value){return qq{Remove-Item -ErrorAction 0 Env:\\$name;\n}}my$maybe_path_sep=qq{\$(if("\$env:$name"-eq""){""}else{"$_path_sep"})};$value =~ s/(^|\G|$_path_sep)\$env:$name$_path_sep/$1\$env:$name"+$maybe_path_sep+"/g;$value =~ s/$_path_sep\$env:$name$/"+$maybe_path_sep+\$env:$name+"/;qq{\$env:$name = \$("$value");\n}}sub wrap_powershell_output {my ($class,$out)=@_;return$out || " \n"}sub build_fish_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'$%s',qr/[\\"'$ ]/,'\\%s');if (!defined$value){return qq{set -e $name;\n}}if ($name =~ /^(?:CD|MAN)?PATH$/){$value =~ s/$_path_sep/ /g;my$silent=$name =~ /^(?:CD)?PATH$/ ? " ^"._devnull : '';return qq{set -x $name $value$silent;\n}}my$out='';my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)\$$name(?:$_path_sep|$)//g){$out .= qq{set -q $name; and set -x $name $value;\n};$out .= qq{set -q $name; or }}$out .= qq{set -x $name $value_without;\n};$out}sub _interpolate {my ($class,$args,$var_pat,$escape,$escape_pat)=@_;return unless defined$args;my@args=ref$args ? @$args : $args;return unless@args;my@vars=map {$$_}grep {ref $_ eq 'SCALAR'}@args;my$string=join$_path_sep,map {ref $_ eq 'SCALAR' ? sprintf($var_pat,$$_): do {s/($escape)/sprintf($escape_pat, $1)/ge;$_}}@args;return wantarray ? ($string,\@vars): $string}sub pipeline;sub pipeline {my@methods=@_;my$last=pop(@methods);if (@methods){\sub {my ($obj,@args)=@_;$obj->${pipeline@methods}($obj->$last(@args))}}else {\sub {shift->$last(@_)}}}sub resolve_path {my ($class,$path)=@_;$path=$class->${pipeline qw(resolve_relative_path resolve_home_path resolve_empty_path)}($path);$path}sub resolve_empty_path {my ($class,$path)=@_;if (defined$path){$path}else {'~/perl5'}}sub resolve_home_path {my ($class,$path)=@_;$path =~ /^~([^\/]*)/ or return$path;my$user=$1;my$homedir=do {if (!length($user)&& defined$ENV{HOME}){$ENV{HOME}}else {require File::Glob;File::Glob::bsd_glob("~$user",File::Glob::GLOB_TILDE())}};unless (defined$homedir){require Carp;require Carp::Heavy;Carp::croak("Couldn't resolve homedir for " .(defined$user ? $user : 'current user'))}$path =~ s/^~[^\/]*/$homedir/;$path}sub resolve_relative_path {my ($class,$path)=@_;_rel2abs($path)}sub ensure_dir_structure_for {my ($class,$path,$opts)=@_;$opts ||= {};my@dirs;for my$dir ($class->lib_paths_for($path),$class->install_base_bin_path($path),){my$d=$dir;while (!-d $d){push@dirs,$d;require File::Basename;$d=File::Basename::dirname($d)}}warn "Attempting to create directory ${path}\n" if!$opts->{quiet}&& @dirs;my%seen;for my$dir (reverse@dirs){next if$seen{$dir}++;mkdir$dir or -d $dir or die "Unable to create $dir: $!"}return}sub guess_shelltype {my$shellbin =defined$ENV{SHELL}&& length$ENV{SHELL}? ($ENV{SHELL}=~ /([\w.]+)$/)[-1]: ($^O eq 'MSWin32' && exists$ENV{'!EXITCODE'})? 'bash' : ($^O eq 'MSWin32' && $ENV{PROMPT}&& $ENV{COMSPEC})? ($ENV{COMSPEC}=~ /([\w.]+)$/)[-1]: ($^O eq 'MSWin32' &&!$ENV{PROMPT})? 'powershell.exe' : 'sh';for ($shellbin){return /csh$/ ? 'csh' : /fish$/ ? 'fish' : /command(?:\.com)?$/i ? 'cmd' : /cmd(?:\.exe)?$/i ? 'cmd' : /4nt(?:\.exe)?$/i ? 'cmd' : /powershell(?:\.exe)?$/i ? 'powershell' : 'bourne'}}1;
  WHOA THERE! It looks like you've got some fancy dashes in your commandline!
  These are *not* the traditional -- dashes that software recognizes. You
  probably got these by copy-pasting from the perldoc for this module as
  rendered by a UTF8-capable formatter. This most typically happens on an OS X
  terminal, but can happen elsewhere too. Please try again after replacing the
  dashes with normal minus signs.
  DEATH
  FATAL: The local::lib --self-contained flag has never worked reliably and the
  original author, Mark Stosberg, was unable or unwilling to maintain it. As
  such, this flag has been removed from the local::lib codebase in order to
  prevent misunderstandings and potentially broken builds. The local::lib authors
  recommend that you look at the lib::core::only module shipped with this
  distribution in order to create a more robust environment that is equivalent to
  what --self-contained provided (although quite possibly not what you originally
  thought it provided due to the poor quality of the documentation, for which we
  apologise).
  DEATH
LOCAL_LIB

$fatpacked{"newgetopt.pl"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NEWGETOPT.PL';
  {package newgetopt;$REQUIRE_ORDER=0;$PERMUTE=1;$RETURN_IN_ORDER=2;if (defined$ENV{"POSIXLY_CORRECT"}){$autoabbrev=0;$getopt_compat=0;$option_start="(--|-)";$order=$REQUIRE_ORDER;$bundling=0;$passthrough=0}else {$autoabbrev=1;$getopt_compat=1;$option_start="(--|-|\\+)";$order=$PERMUTE;$bundling=0;$passthrough=0}$debug=0;$ignorecase=1;$argv_end="--"}use Getopt::Long;sub NGetOpt {$Getopt::Long::debug=$newgetopt::debug if defined$newgetopt::debug;$Getopt::Long::autoabbrev=$newgetopt::autoabbrev if defined$newgetopt::autoabbrev;$Getopt::Long::getopt_compat=$newgetopt::getopt_compat if defined$newgetopt::getopt_compat;$Getopt::Long::option_start=$newgetopt::option_start if defined$newgetopt::option_start;$Getopt::Long::order=$newgetopt::order if defined$newgetopt::order;$Getopt::Long::bundling=$newgetopt::bundling if defined$newgetopt::bundling;$Getopt::Long::ignorecase=$newgetopt::ignorecase if defined$newgetopt::ignorecase;$Getopt::Long::ignorecase=$newgetopt::ignorecase if defined$newgetopt::ignorecase;$Getopt::Long::passthrough=$newgetopt::passthrough if defined$newgetopt::passthrough;&GetOptions}1;
NEWGETOPT.PL

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;use strict;our$VERSION='0.237';sub import {my$class=shift;my$inheritor=caller(0);if (@_ and $_[0]eq '-norequire'){shift @_}else {for (my@filename=@_){s{::|'}{/}g;require "$_.pm"}}{no strict 'refs';push @{"$inheritor\::ISA"},@_}};1;
PARENT

$fatpacked{"version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION';
  package version;use 5.006002;use strict;use warnings::register;if ($] >= 5.015){warnings::register_categories(qw/version/)}our$VERSION=0.9924;our$CLASS='version';our (@ISA,$STRICT,$LAX);{local$SIG{'__DIE__'};eval "use version::vxs $VERSION";if ($@){eval "use version::vpp $VERSION";die "$@" if ($@);push@ISA,"version::vpp";local $^W;*version::qv=\&version::vpp::qv;*version::declare=\&version::vpp::declare;*version::_VERSION=\&version::vpp::_VERSION;*version::vcmp=\&version::vpp::vcmp;*version::new=\&version::vpp::new;*version::numify=\&version::vpp::numify;*version::normal=\&version::vpp::normal;if ($] >= 5.009000){no strict 'refs';*version::stringify=\&version::vpp::stringify;*{'version::(""'}=\&version::vpp::stringify;*{'version::(<=>'}=\&version::vpp::vcmp;*{'version::(cmp'}=\&version::vpp::vcmp;*version::parse=\&version::vpp::parse}}else {push@ISA,"version::vxs";local $^W;*version::declare=\&version::vxs::declare;*version::qv=\&version::vxs::qv;*version::_VERSION=\&version::vxs::_VERSION;*version::vcmp=\&version::vxs::VCMP;*version::new=\&version::vxs::new;*version::numify=\&version::vxs::numify;*version::normal=\&version::vxs::normal;if ($] >= 5.009000){no strict 'refs';*version::stringify=\&version::vxs::stringify;*{'version::(""'}=\&version::vxs::stringify;*{'version::(<=>'}=\&version::vxs::VCMP;*{'version::(cmp'}=\&version::vxs::VCMP;*version::parse=\&version::vxs::parse}}}require version::regex;*version::is_lax=\&version::regex::is_lax;*version::is_strict=\&version::regex::is_strict;*LAX=\$version::regex::LAX;*LAX_DECIMAL_VERSION=\$version::regex::LAX_DECIMAL_VERSION;*LAX_DOTTED_DECIMAL_VERSION=\$version::regex::LAX_DOTTED_DECIMAL_VERSION;*STRICT=\$version::regex::STRICT;*STRICT_DECIMAL_VERSION=\$version::regex::STRICT_DECIMAL_VERSION;*STRICT_DOTTED_DECIMAL_VERSION=\$version::regex::STRICT_DOTTED_DECIMAL_VERSION;sub import {no strict 'refs';my ($class)=shift;unless ($class eq $CLASS){local $^W;*{$class.'::declare'}=\&{$CLASS.'::declare'};*{$class.'::qv'}=\&{$CLASS.'::qv'}}my%args;if (@_){map {$args{$_}=1}@_}else {%args=(qv=>1,'UNIVERSAL::VERSION'=>1,)}my$callpkg=caller();if (exists($args{declare})){*{$callpkg.'::declare'}=sub {return$class->declare(shift)}unless defined(&{$callpkg.'::declare'})}if (exists($args{qv})){*{$callpkg.'::qv'}=sub {return$class->qv(shift)}unless defined(&{$callpkg.'::qv'})}if (exists($args{'UNIVERSAL::VERSION'})){local $^W;*UNIVERSAL::VERSION =\&{$CLASS.'::_VERSION'}}if (exists($args{'VERSION'})){*{$callpkg.'::VERSION'}=\&{$CLASS.'::_VERSION'}}if (exists($args{'is_strict'})){*{$callpkg.'::is_strict'}=\&{$CLASS.'::is_strict'}unless defined(&{$callpkg.'::is_strict'})}if (exists($args{'is_lax'})){*{$callpkg.'::is_lax'}=\&{$CLASS.'::is_lax'}unless defined(&{$callpkg.'::is_lax'})}}1;
VERSION

$fatpacked{"version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION_REGEX';
  package version::regex;use strict;our$VERSION=0.9924;my$FRACTION_PART=qr/\.[0-9]+/;my$STRICT_INTEGER_PART=qr/0|[1-9][0-9]*/;my$LAX_INTEGER_PART=qr/[0-9]+/;my$STRICT_DOTTED_DECIMAL_PART=qr/\.[0-9]{1,3}/;my$LAX_DOTTED_DECIMAL_PART=qr/\.[0-9]+/;my$LAX_ALPHA_PART=qr/_[0-9]+/;our$STRICT_DECIMAL_VERSION=qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;our$STRICT_DOTTED_DECIMAL_VERSION=qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;our$STRICT=qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;our$LAX_DECIMAL_VERSION=qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;our$LAX_DOTTED_DECIMAL_VERSION=qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;our$LAX=qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;sub is_strict {defined $_[0]&& $_[0]=~ qr/ \A $STRICT \z /x}sub is_lax {defined $_[0]&& $_[0]=~ qr/ \A $LAX \z /x}1;
VERSION_REGEX

$fatpacked{"version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION_VPP';
  package charstar;use overload ('""'=>\&thischar,'0+'=>\&thischar,'++'=>\&increment,'--'=>\&decrement,'+'=>\&plus,'-'=>\&minus,'*'=>\&multiply,'cmp'=>\&cmp,'<=>'=>\&spaceship,'bool'=>\&thischar,'='=>\&clone,);sub new {my ($self,$string)=@_;my$class=ref($self)|| $self;my$obj={string=>[split(//,$string)],current=>0,};return bless$obj,$class}sub thischar {my ($self)=@_;my$last=$#{$self->{string}};my$curr=$self->{current};if ($curr >= 0 && $curr <= $last){return$self->{string}->[$curr]}else {return ''}}sub increment {my ($self)=@_;$self->{current}++}sub decrement {my ($self)=@_;$self->{current}--}sub plus {my ($self,$offset)=@_;my$rself=$self->clone;$rself->{current}+= $offset;return$rself}sub minus {my ($self,$offset)=@_;my$rself=$self->clone;$rself->{current}-= $offset;return$rself}sub multiply {my ($left,$right,$swapped)=@_;my$char=$left->thischar();return$char * $right}sub spaceship {my ($left,$right,$swapped)=@_;unless (ref($right)){$right=$left->new($right)}return$left->{current}<=> $right->{current}}sub cmp {my ($left,$right,$swapped)=@_;unless (ref($right)){if (length($right)==1){return$left->thischar cmp $right}$right=$left->new($right)}return$left->currstr cmp $right->currstr}sub bool {my ($self)=@_;my$char=$self->thischar;return ($char ne '')}sub clone {my ($left,$right,$swapped)=@_;$right={string=>[@{$left->{string}}],current=>$left->{current},};return bless$right,ref($left)}sub currstr {my ($self,$s)=@_;my$curr=$self->{current};my$last=$#{$self->{string}};if (defined($s)&& $s->{current}< $last){$last=$s->{current}}my$string=join('',@{$self->{string}}[$curr..$last]);return$string}package version::vpp;use 5.006002;use strict;use warnings::register;use Config;our$VERSION=0.9924;our$CLASS='version::vpp';our ($LAX,$STRICT,$WARN_CATEGORY);if ($] > 5.015){warnings::register_categories(qw/version/);$WARN_CATEGORY='version'}else {$WARN_CATEGORY='numeric'}require version::regex;*version::vpp::is_strict=\&version::regex::is_strict;*version::vpp::is_lax=\&version::regex::is_lax;*LAX=\$version::regex::LAX;*STRICT=\$version::regex::STRICT;use overload ('""'=>\&stringify,'0+'=>\&numify,'cmp'=>\&vcmp,'<=>'=>\&vcmp,'bool'=>\&vbool,'+'=>\&vnoop,'-'=>\&vnoop,'*'=>\&vnoop,'/'=>\&vnoop,'+='=>\&vnoop,'-='=>\&vnoop,'*='=>\&vnoop,'/='=>\&vnoop,'abs'=>\&vnoop,);sub import {no strict 'refs';my ($class)=shift;unless ($class eq $CLASS){local $^W;*{$class.'::declare'}=\&{$CLASS.'::declare'};*{$class.'::qv'}=\&{$CLASS.'::qv'}}my%args;if (@_){map {$args{$_}=1}@_}else {%args=(qv=>1,'UNIVERSAL::VERSION'=>1,)}my$callpkg=caller();if (exists($args{declare})){*{$callpkg.'::declare'}=sub {return$class->declare(shift)}unless defined(&{$callpkg.'::declare'})}if (exists($args{qv})){*{$callpkg.'::qv'}=sub {return$class->qv(shift)}unless defined(&{$callpkg.'::qv'})}if (exists($args{'UNIVERSAL::VERSION'})){no warnings qw/redefine/;*UNIVERSAL::VERSION =\&{$CLASS.'::_VERSION'}}if (exists($args{'VERSION'})){*{$callpkg.'::VERSION'}=\&{$CLASS.'::_VERSION'}}if (exists($args{'is_strict'})){*{$callpkg.'::is_strict'}=\&{$CLASS.'::is_strict'}unless defined(&{$callpkg.'::is_strict'})}if (exists($args{'is_lax'})){*{$callpkg.'::is_lax'}=\&{$CLASS.'::is_lax'}unless defined(&{$callpkg.'::is_lax'})}}my$VERSION_MAX=0x7FFFFFFF;use constant TRUE=>1;use constant FALSE=>0;sub isDIGIT {my ($char)=shift->thischar();return ($char =~ /\d/)}sub isALPHA {my ($char)=shift->thischar();return ($char =~ /[a-zA-Z]/)}sub isSPACE {my ($char)=shift->thischar();return ($char =~ /\s/)}sub BADVERSION {my ($s,$errstr,$error)=@_;if ($errstr){$$errstr=$error}return$s}sub prescan_version {my ($s,$strict,$errstr,$sqv,$ssaw_decimal,$swidth,$salpha)=@_;my$qv=defined$sqv ? $$sqv : FALSE;my$saw_decimal=defined$ssaw_decimal ? $$ssaw_decimal : 0;my$width=defined$swidth ? $$swidth : 3;my$alpha=defined$salpha ? $$salpha : FALSE;my$d=$s;if ($qv && isDIGIT($d)){goto dotted_decimal_version}if ($d eq 'v'){$d++;if (isDIGIT($d)){$qv=TRUE}else {return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}dotted_decimal_version: if ($strict && $d eq '0' && isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)")}while (isDIGIT($d)){$d++}if ($d eq '.'){$saw_decimal++;$d++}else {if ($strict){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}else {goto version_prescan_finish}}{my$i=0;my$j=0;while (isDIGIT($d)){$i++;while (isDIGIT($d)){$d++;$j++;if ($strict && $j > 3){return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)")}}if ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)")}$d++;$alpha=TRUE}elsif ($d eq '.'){if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)")}$saw_decimal++;$d++}elsif (!isDIGIT($d)){last}$j=0}if ($strict && $i < 2){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}}}else {my$j=0;if ($strict){if ($d eq '.'){return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)")}if ($d eq '0' && isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)")}}if ($d eq '-'){return BADVERSION($s,$errstr,"Invalid version format (negative version number)")}while (isDIGIT($d)){$d++}if ($d eq '.'){$saw_decimal++;$d++}elsif (!$d || $d eq ';' || isSPACE($d)|| $d eq '}'){if ($d==$s){return BADVERSION($s,$errstr,"Invalid version format (version required)")}goto version_prescan_finish}elsif ($d==$s){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}elsif ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}elsif (isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)")}else {return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)")}}elsif ($d){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}if ($d &&!isDIGIT($d)&& ($strict ||!($d eq ';' || isSPACE($d)|| $d eq '}'))){return BADVERSION($s,$errstr,"Invalid version format (fractional part required)")}while (isDIGIT($d)){$d++;$j++;if ($d eq '.' && isDIGIT($d-1)){if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)")}if ($strict){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')")}$d=$s;$qv=TRUE;goto dotted_decimal_version}if ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)")}if (!isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)")}$width=$j;$d++;$alpha=TRUE}}}version_prescan_finish: while (isSPACE($d)){$d++}if ($d &&!isDIGIT($d)&& (!($d eq ';' || $d eq '}'))){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}if ($saw_decimal > 1 && ($d-1)eq '.'){return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)")}if (defined$sqv){$$sqv=$qv}if (defined$swidth){$$swidth=$width}if (defined$ssaw_decimal){$$ssaw_decimal=$saw_decimal}if (defined$salpha){$$salpha=$alpha}return$d}sub scan_version {my ($s,$rv,$qv)=@_;my$start;my$pos;my$last;my$errstr;my$saw_decimal=0;my$width=3;my$alpha=FALSE;my$vinf=FALSE;my@av;$s=new charstar$s;while (isSPACE($s)){$s++}$last=prescan_version($s,FALSE,\$errstr,\$qv,\$saw_decimal,\$width,\$alpha);if ($errstr){if ($s ne 'undef'){require Carp;Carp::croak($errstr)}}$start=$s;if ($s eq 'v'){$s++}$pos=$s;if ($qv){$$rv->{qv}=$qv}if ($alpha){$$rv->{alpha}=$alpha}if (!$qv && $width < 3){$$rv->{width}=$width}while (isDIGIT($pos)|| $pos eq '_'){$pos++}if (!isALPHA($pos)){my$rev;for (;;){$rev=0;{my$end=$pos;my$mult=1;my$orev;if (!$qv && $s > $start && $saw_decimal==1){$mult *= 100;while ($s < $end){next if$s eq '_';$orev=$rev;$rev += $s * $mult;$mult /= 10;if ((abs($orev)> abs($rev))|| (abs($rev)> $VERSION_MAX)){warn("Integer overflow in version %d",$VERSION_MAX);$s=$end - 1;$rev=$VERSION_MAX;$vinf=1}$s++;if ($s eq '_'){$s++}}}else {while (--$end >= $s){next if$end eq '_';$orev=$rev;$rev += $end * $mult;$mult *= 10;if ((abs($orev)> abs($rev))|| (abs($rev)> $VERSION_MAX)){warn("Integer overflow in version");$end=$s - 1;$rev=$VERSION_MAX;$vinf=1}}}}push@av,$rev;if ($vinf){$s=$last;last}elsif ($pos eq '.'){$s=++$pos}elsif ($pos eq '_' && isDIGIT($pos+1)){$s=++$pos}elsif ($pos eq ',' && isDIGIT($pos+1)){$s=++$pos}elsif (isDIGIT($pos)){$s=$pos}else {$s=$pos;last}if ($qv){while (isDIGIT($pos)|| $pos eq '_'){$pos++}}else {my$digits=0;while ((isDIGIT($pos)|| $pos eq '_')&& $digits < 3){if ($pos ne '_'){$digits++}$pos++}}}}if ($qv){my$len=$#av;$len=2 - $len;while ($len-- > 0){push@av,0}}if ($vinf){$$rv->{original}="v.Inf";$$rv->{vinf}=1}elsif ($s > $start){$$rv->{original}=$start->currstr($s);if ($qv && $saw_decimal==1 && $start ne 'v'){$$rv->{original}='v' .$$rv->{original}}}else {$$rv->{original}='0';push(@av,0)}$$rv->{version}=\@av;if ($s eq 'undef'){$s += 5}return$s}sub new {my$class=shift;unless (defined$class or $#_ > 1){require Carp;Carp::croak('Usage: version::new(class, version)')}my$self=bless ({},ref ($class)|| $class);my$qv=FALSE;if ($#_==1){$qv=TRUE}my$value=pop;if (ref($value)&& eval('$value->isa("version")')){$self->{version}=[@{$value->{version}}];$self->{qv}=1 if$value->{qv};$self->{alpha}=1 if$value->{alpha};$self->{original}=''.$value->{original};return$self}if (not defined$value or $value =~ /^undef$/){push @{$self->{version}},0;$self->{original}="0";return ($self)}if (ref($value)=~ m/ARRAY|HASH/){require Carp;Carp::croak("Invalid version format (non-numeric data)")}$value=_un_vstring($value);if ($Config{d_setlocale}){use POSIX qw/locale_h/;use if$Config{d_setlocale},'locale';my$currlocale=setlocale(LC_ALL);if (localeconv()->{decimal_point}eq ','){$value =~ tr/,/./}}if ($value =~ /\d+.?\d*e[-+]?\d+/){$value=sprintf("%.9f",$value);$value =~ s/(0+)$//}my$s=scan_version($value,\$self,$qv);if ($s){warn(sprintf "Version string '%s' contains invalid data; " ."ignoring: '%s'",$value,$s)}return ($self)}*parse=\&new;sub numify {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}my$alpha=$self->{alpha}|| "";my$len=$#{$self->{version}};my$digit=$self->{version}[0];my$string=sprintf("%d.",$digit);if ($alpha and warnings::enabled()){warnings::warn($WARN_CATEGORY,'alpha->numify() is lossy')}for (my$i=1 ;$i <= $len ;$i++ ){$digit=$self->{version}[$i];$string .= sprintf("%03d",$digit)}if ($len==0){$string .= sprintf("000")}return$string}sub normal {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}my$len=$#{$self->{version}};my$digit=$self->{version}[0];my$string=sprintf("v%d",$digit);for (my$i=1 ;$i <= $len ;$i++ ){$digit=$self->{version}[$i];$string .= sprintf(".%d",$digit)}if ($len <= 2){for ($len=2 - $len;$len!=0;$len-- ){$string .= sprintf(".%0d",0)}}return$string}sub stringify {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}return exists$self->{original}? $self->{original}: exists$self->{qv}? $self->normal : $self->numify}sub vcmp {my ($left,$right,$swap)=@_;my$class=ref($left);unless (UNIVERSAL::isa($right,$class)){$right=$class->new($right)}if ($swap){($left,$right)=($right,$left)}unless (_verify($left)){require Carp;Carp::croak("Invalid version object")}unless (_verify($right)){require Carp;Carp::croak("Invalid version format")}my$l=$#{$left->{version}};my$r=$#{$right->{version}};my$m=$l < $r ? $l : $r;my$lalpha=$left->is_alpha;my$ralpha=$right->is_alpha;my$retval=0;my$i=0;while ($i <= $m && $retval==0){$retval=$left->{version}[$i]<=> $right->{version}[$i];$i++}if ($retval==0 && $l!=$r){if ($l < $r){while ($i <= $r && $retval==0){if ($right->{version}[$i]!=0){$retval=-1}$i++}}else {while ($i <= $l && $retval==0){if ($left->{version}[$i]!=0){$retval=+1}$i++}}}return$retval}sub vbool {my ($self)=@_;return vcmp($self,$self->new("0"),1)}sub vnoop {require Carp;Carp::croak("operation not supported with version object")}sub is_alpha {my ($self)=@_;return (exists$self->{alpha})}sub qv {my$value=shift;my$class=$CLASS;if (@_){$class=ref($value)|| $value;$value=shift}$value=_un_vstring($value);$value='v'.$value unless$value =~ /(^v|\d+\.\d+\.\d)/;my$obj=$CLASS->new($value);return bless$obj,$class}*declare=\&qv;sub is_qv {my ($self)=@_;return (exists$self->{qv})}sub _verify {my ($self)=@_;if (ref($self)&& eval {exists$self->{version}}&& ref($self->{version})eq 'ARRAY'){return 1}else {return 0}}sub _is_non_alphanumeric {my$s=shift;$s=new charstar$s;while ($s){return 0 if isSPACE($s);return 1 unless (isALPHA($s)|| isDIGIT($s)|| $s =~ /[.-]/);$s++}return 0}sub _un_vstring {my$value=shift;if (length($value)>= 1 && $value !~ /[,._]/ && _is_non_alphanumeric($value)){my$tvalue;if ($] >= 5.008_001){$tvalue=_find_magic_vstring($value);$value=$tvalue if length$tvalue}elsif ($] >= 5.006_000){$tvalue=sprintf("v%vd",$value);if ($tvalue =~ /^v\d+(\.\d+)*$/){$value=$tvalue}}}return$value}sub _find_magic_vstring {my$value=shift;my$tvalue='';require B;my$sv=B::svref_2object(\$value);my$magic=ref($sv)eq 'B::PVMG' ? $sv->MAGIC : undef;while ($magic){if ($magic->TYPE eq 'V'){$tvalue=$magic->PTR;$tvalue =~ s/^v?(.+)$/v$1/;last}else {$magic=$magic->MOREMAGIC}}$tvalue =~ tr/_//d;return$tvalue}sub _VERSION {my ($obj,$req)=@_;my$class=ref($obj)|| $obj;no strict 'refs';if (exists$INC{"$class.pm"}and not %{"$class\::"}and $] >= 5.008){require Carp;Carp::croak("$class defines neither package nor VERSION" ."--version check failed")}my$version=eval "\$$class\::VERSION";if (defined$version){local $^W if $] <= 5.008;$version=version::vpp->new($version)}if (defined$req){unless (defined$version){require Carp;my$msg=$] < 5.006 ? "$class version $req required--this is only version " : "$class does not define \$$class\::VERSION" ."--version check failed";if ($ENV{VERSION_DEBUG}){Carp::confess($msg)}else {Carp::croak($msg)}}$req=version::vpp->new($req);if ($req > $version){require Carp;if ($req->is_qv){Carp::croak(sprintf ("%s version %s required--"."this is only version %s",$class,$req->normal,$version->normal))}else {Carp::croak(sprintf ("%s version %s required--"."this is only version %s",$class,$req->stringify,$version->stringify))}}}return defined$version ? $version->stringify : undef}1;
VERSION_VPP

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

#
# This is a pre-compiled source code for the cpanm (cpanminus) program.
# For more details about how to install cpanm, go to the following URL:
#
#   https://github.com/miyagawa/cpanminus
#
# Quickstart: Run the following command and it will install itself for
# you. You might want to run it as a root with sudo if you want to install
# to places like /usr/local/bin.
#
#   % curl -L https://cpanmin.us | perl - App::cpanminus
#
# If you don't have curl but wget, replace `curl -L` with `wget -O -`.

# DO NOT EDIT -- this is an auto generated file

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/cpanminus.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANMINUS';
  package App::cpanminus;our$VERSION="1.7044";1;
APP_CPANMINUS

$fatpacked{"App/cpanminus/Dependency.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANMINUS_DEPENDENCY';
  package App::cpanminus::Dependency;use strict;use CPAN::Meta::Requirements;sub from_prereqs {my($class,$prereqs,$phases,$types)=@_;my@deps;for my$type (@$types){push@deps,$class->from_versions($prereqs->merged_requirements($phases,[$type])->as_string_hash,$type,)}return@deps}sub from_versions {my($class,$versions,$type)=@_;my@deps;while (my($module,$version)=each %$versions){push@deps,$class->new($module,$version,$type)}@deps}sub merge_with {my($self,$requirements)=@_;$self->{original_version}=$self->version;eval {$requirements->add_string_requirement($self->module,$self->version)};if ($@ =~ /illegal requirements/){warn sprintf("Can't merge requirements for %s: '%s' and '%s'",$self->module,$self->version,$requirements->requirements_for_module($self->module))}$self->{version}=$requirements->requirements_for_module($self->module)}sub new {my($class,$module,$version,$type)=@_;bless {module=>$module,version=>$version,type=>$type || 'requires',},$class}sub module {$_[0]->{module}}sub version {$_[0]->{version}}sub type {$_[0]->{type}}sub requires_version {my$self=shift;if (defined$self->{original_version}){return$self->{original_version}}$self->version}sub is_requirement {$_[0]->{type}eq 'requires'}1;
APP_CPANMINUS_DEPENDENCY

$fatpacked{"App/cpanminus/script.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANMINUS_SCRIPT';
  package App::cpanminus::script;use strict;use Config;use Cwd ();use App::cpanminus;use App::cpanminus::Dependency;use File::Basename ();use File::Find ();use File::Path ();use File::Spec ();use File::Copy ();use File::Temp ();use Getopt::Long ();use Symbol ();use String::ShellQuote ();use version ();use constant WIN32=>$^O eq 'MSWin32';use constant BAD_TAR=>($^O eq 'solaris' || $^O eq 'hpux');use constant CAN_SYMLINK=>eval {symlink("","");1};our$VERSION=$App::cpanminus::VERSION;if ($INC{"App/FatPacker/Trace.pm"}){require version::vpp}my$quote=WIN32 ? q/"/ : q/'/;sub agent {my$self=shift;my$agent="cpanminus/$VERSION";$agent .= " perl/$]" if$self->{report_perl_version};$agent}sub determine_home {my$class=shift;my$homedir=$ENV{HOME}|| eval {require File::HomeDir;File::HomeDir->my_home}|| join('',@ENV{qw(HOMEDRIVE HOMEPATH)});if (WIN32){require Win32;$homedir=Win32::GetShortPathName($homedir)}return "$homedir/.cpanm"}sub new {my$class=shift;bless {home=>$class->determine_home,cmd=>'install',seen=>{},notest=>undef,test_only=>undef,installdeps=>undef,force=>undef,sudo=>undef,make=>undef,verbose=>undef,quiet=>undef,interactive=>undef,log=>undef,mirrors=>[],mirror_only=>undef,mirror_index=>undef,cpanmetadb=>"http://cpanmetadb.plackperl.org/v1.0/",perl=>$^X,argv=>[],local_lib=>undef,self_contained=>undef,exclude_vendor=>undef,prompt_timeout=>0,prompt=>undef,configure_timeout=>60,build_timeout=>3600,test_timeout=>1800,try_lwp=>1,try_wget=>1,try_curl=>1,uninstall_shadows=>($] < 5.012),skip_installed=>1,skip_satisfied=>0,auto_cleanup=>7,pod2man=>1,installed_dists=>0,install_types=>['requires'],with_develop=>0,with_configure=>0,showdeps=>0,scandeps=>0,scandeps_tree=>[],format=>'tree',save_dists=>undef,skip_configure=>0,verify=>0,report_perl_version=>!$class->maybe_ci,build_args=>{},features=>{},pure_perl=>0,cpanfile_path=>'cpanfile',@_,},$class}sub env {my($self,$key)=@_;$ENV{"PERL_CPANM_" .$key}}sub maybe_ci {my$class=shift;grep$ENV{$_},qw(TRAVIS CI AUTOMATED_TESTING AUTHOR_TESTING)}sub install_type_handlers {my$self=shift;my@handlers;for my$type (qw(recommends suggests)){push@handlers,"with-$type"=>sub {my%uniq;$self->{install_types}=[grep!$uniq{$_}++,@{$self->{install_types}},$type ]};push@handlers,"without-$type"=>sub {$self->{install_types}=[grep $_ ne $type,@{$self->{install_types}}]}}@handlers}sub build_args_handlers {my$self=shift;my@handlers;for my$phase (qw(configure build test install)){push@handlers,"$phase-args=s"=>\($self->{build_args}{$phase})}@handlers}sub parse_options {my$self=shift;local@ARGV=@{$self->{argv}};push@ARGV,grep length,split /\s+/,$self->env('OPT');push@ARGV,@_;Getopt::Long::Configure("bundling");Getopt::Long::GetOptions('f|force'=>sub {$self->{skip_installed}=0;$self->{force}=1},'n|notest!'=>\$self->{notest},'test-only'=>sub {$self->{notest}=0;$self->{skip_installed}=0;$self->{test_only}=1},'S|sudo!'=>\$self->{sudo},'v|verbose'=>\$self->{verbose},'verify!'=>\$self->{verify},'q|quiet!'=>\$self->{quiet},'h|help'=>sub {$self->{action}='show_help'},'V|version'=>sub {$self->{action}='show_version'},'perl=s'=>sub {$self->diag("--perl is deprecated since it's known to be fragile in figuring out dependencies. Run `$_[1] -S cpanm` instead.\n",1);$self->{perl}=$_[1]},'l|local-lib=s'=>sub {$self->{local_lib}=$self->maybe_abs($_[1])},'L|local-lib-contained=s'=>sub {$self->{local_lib}=$self->maybe_abs($_[1]);$self->{self_contained}=1;$self->{pod2man}=undef},'self-contained!'=>\$self->{self_contained},'exclude-vendor!'=>\$self->{exclude_vendor},'mirror=s@'=>$self->{mirrors},'mirror-only!'=>\$self->{mirror_only},'mirror-index=s'=>sub {$self->{mirror_index}=$self->maybe_abs($_[1])},'M|from=s'=>sub {$self->{mirrors}=[$_[1]];$self->{mirror_only}=1},'cpanmetadb=s'=>\$self->{cpanmetadb},'cascade-search!'=>\$self->{cascade_search},'prompt!'=>\$self->{prompt},'installdeps'=>\$self->{installdeps},'skip-installed!'=>\$self->{skip_installed},'skip-satisfied!'=>\$self->{skip_satisfied},'reinstall'=>sub {$self->{skip_installed}=0},'interactive!'=>\$self->{interactive},'i|install'=>sub {$self->{cmd}='install'},'info'=>sub {$self->{cmd}='info'},'look'=>sub {$self->{cmd}='look';$self->{skip_installed}=0},'U|uninstall'=>sub {$self->{cmd}='uninstall'},'self-upgrade'=>sub {$self->{action}='self_upgrade'},'uninst-shadows!'=>\$self->{uninstall_shadows},'lwp!'=>\$self->{try_lwp},'wget!'=>\$self->{try_wget},'curl!'=>\$self->{try_curl},'auto-cleanup=s'=>\$self->{auto_cleanup},'man-pages!'=>\$self->{pod2man},'scandeps'=>\$self->{scandeps},'showdeps'=>sub {$self->{showdeps}=1;$self->{skip_installed}=0},'format=s'=>\$self->{format},'save-dists=s'=>sub {$self->{save_dists}=$self->maybe_abs($_[1])},'skip-configure!'=>\$self->{skip_configure},'dev!'=>\$self->{dev_release},'metacpan!'=>\$self->{metacpan},'report-perl-version!'=>\$self->{report_perl_version},'configure-timeout=i'=>\$self->{configure_timeout},'build-timeout=i'=>\$self->{build_timeout},'test-timeout=i'=>\$self->{test_timeout},'with-develop'=>\$self->{with_develop},'without-develop'=>sub {$self->{with_develop}=0},'with-configure'=>\$self->{with_configure},'without-configure'=>sub {$self->{with_configure}=0},'with-feature=s'=>sub {$self->{features}{$_[1]}=1},'without-feature=s'=>sub {$self->{features}{$_[1]}=0},'with-all-features'=>sub {$self->{features}{__all}=1},'pp|pureperl!'=>\$self->{pure_perl},"cpanfile=s"=>\$self->{cpanfile_path},$self->install_type_handlers,$self->build_args_handlers,);if (!@ARGV && $0 ne '-' &&!-t STDIN){push@ARGV,$self->load_argv_from_fh(\*STDIN);$self->{load_from_stdin}=1}$self->{argv}=\@ARGV}sub check_upgrade {my$self=shift;my$install_base=$ENV{PERL_LOCAL_LIB_ROOT}? $self->local_lib_target($ENV{PERL_LOCAL_LIB_ROOT}): $Config{installsitebin};if ($0 eq '-'){return}elsif ($0 !~ /^$install_base/){if ($0 =~ m!perlbrew/bin!){die <<DIE}else {die <<DIE}}}sub check_libs {my$self=shift;return if$self->{_checked}++;$self->bootstrap_local_lib}sub setup_verify {my$self=shift;my$has_modules=eval {require Module::Signature;require Digest::SHA;1};$self->{cpansign}=$self->which('cpansign');unless ($has_modules && $self->{cpansign}){warn "WARNING: Module::Signature and Digest::SHA is required for distribution verifications.\n";$self->{verify}=0}}sub parse_module_args {my($self,$module)=@_;$module =~ s/^([A-Za-z0-9_:]+)@([v\d\._]+)$/$1~== $2/;if ($module =~ /\~[v\d\._,\!<>= ]+$/){return split /\~/,$module,2}else {return$module,undef}}sub doit {my$self=shift;my$code;eval {$code=($self->_doit==0)};if (my$e=$@){warn$e;$code=1}return$code}sub _doit {my$self=shift;$self->setup_home;$self->init_tools;$self->setup_verify if$self->{verify};if (my$action=$self->{action}){$self->$action()and return 1}return$self->show_help(1)unless @{$self->{argv}}or $self->{load_from_stdin};$self->configure_mirrors;my$cwd=Cwd::cwd;my@fail;for my$module (@{$self->{argv}}){if ($module =~ s/\.pm$//i){my ($volume,$dirs,$file)=File::Spec->splitpath($module);$module=join '::',grep {$_}File::Spec->splitdir($dirs),$file}($module,my$version)=$self->parse_module_args($module);$self->chdir($cwd);if ($self->{cmd}eq 'uninstall'){$self->uninstall_module($module)or push@fail,$module}else {$self->install_module($module,0,$version)or push@fail,$module}}if ($self->{base}&& $self->{auto_cleanup}){$self->cleanup_workdirs}if ($self->{installed_dists}){my$dists=$self->{installed_dists}> 1 ? "distributions" : "distribution";$self->diag("$self->{installed_dists} $dists installed\n",1)}if ($self->{scandeps}){$self->dump_scandeps()}$self->chdir($cwd);return!@fail}sub setup_home {my$self=shift;$self->{home}=$self->env('HOME')if$self->env('HOME');unless (_writable($self->{home})){die "Can't write to cpanm home '$self->{home}': You should fix it with chown/chmod first.\n"}$self->{base}="$self->{home}/work/" .time .".$$";File::Path::mkpath([$self->{base}],0,0777);$self->{log}=File::Spec->catfile($self->{base},"build.log");my$final_log="$self->{home}/build.log";{open my$out,">$self->{log}" or die "$self->{log}: $!"}if (CAN_SYMLINK){my$build_link="$self->{home}/latest-build";unlink$build_link;symlink$self->{base},$build_link;unlink$final_log;symlink$self->{log},$final_log}else {my$log=$self->{log};my$home=$self->{home};$self->{at_exit}=sub {my$self=shift;my$temp_log="$home/build.log." .time .".$$";File::Copy::copy($log,$temp_log)&& unlink($final_log);rename($temp_log,$final_log)}}$self->chat("cpanm (App::cpanminus) $VERSION on perl $] built for $Config{archname}\n" ."Work directory is $self->{base}\n")}sub package_index_for {my ($self,$mirror)=@_;return$self->source_for($mirror)."/02packages.details.txt"}sub generate_mirror_index {my ($self,$mirror)=@_;my$file=$self->package_index_for($mirror);my$gz_file=$file .'.gz';my$index_mtime=(stat$gz_file)[9];unless (-e $file && (stat$file)[9]>= $index_mtime){$self->chat("Uncompressing index file...\n");if (eval {require Compress::Zlib}){my$gz=Compress::Zlib::gzopen($gz_file,"rb")or do {$self->diag_fail("$Compress::Zlib::gzerrno opening compressed index");return};open my$fh,'>',$file or do {$self->diag_fail("$! opening uncompressed index for write");return};my$buffer;while (my$status=$gz->gzread($buffer)){if ($status < 0){$self->diag_fail($gz->gzerror ." reading compressed index");return}print$fh $buffer}}else {if (system("gunzip -c $gz_file > $file")){$self->diag_fail("Cannot uncompress -- please install gunzip or Compress::Zlib");return}}utime$index_mtime,$index_mtime,$file}return 1}sub search_mirror_index {my ($self,$mirror,$module,$version)=@_;$self->search_mirror_index_file($self->package_index_for($mirror),$module,$version)}sub search_mirror_index_file {my($self,$file,$module,$version)=@_;open my$fh,'<',$file or return;my$found;while (<$fh>){if (m!^\Q$module\E\s+([\w\.]+)\s+(\S*)!m){$found=$self->cpan_module($module,$2,$1);last}}return$found unless$self->{cascade_search};if ($found){if ($self->satisfy_version($module,$found->{module_version},$version)){return$found}else {$self->chat("Found $module $found->{module_version} which doesn't satisfy $version.\n")}}return}sub with_version_range {my($self,$version)=@_;defined($version)&& $version =~ /(?:<|!=|==)/}sub encode_json {my($self,$data)=@_;require JSON::PP;my$json=JSON::PP::encode_json($data);$self->uri_escape($json)}sub decode_json {my($self,$json)=@_;require JSON::PP;JSON::PP::decode_json($json)}sub uri_escape {my($self,$fragment)=@_;$fragment =~ s/([^A-Za-z0-9\-\._~])/uc sprintf("%%%02X", ord($1))/eg;$fragment}sub uri_params {my($self,@params)=@_;my@param_strings;while (my$key=shift@params){my$value=shift@params;push@param_strings,join '=',map$self->uri_escape($_),$key,$value}return join '&',@param_strings}sub numify_ver {my($self,$ver)=@_;eval version->new($ver)->numify}sub search_metacpan {my($self,$module,$version,$dev_release)=@_;my$metacpan_uri='http://fastapi.metacpan.org/v1/download_url/';my$url=$metacpan_uri .$module;my$query=$self->uri_params(($version ? (version=>$version): ()),($dev_release ? (dev=>1): ()),);$url .= '?' .$query if length$query;my$dist_json=$self->get($url);my$dist_meta=eval {$self->decode_json($dist_json)};if ($dist_meta && $dist_meta->{download_url}){(my$distfile=$dist_meta->{download_url})=~ s!.+/authors/id/!!;local$self->{mirrors}=$self->{mirrors};$self->{mirrors}=['http://cpan.metacpan.org' ];return$self->cpan_module($module,$distfile,$dist_meta->{version})}$self->chat("! Could not find a release matching $module".($version?" ($version)":'')." on MetaCPAN.\n");return}sub search_database {my($self,$module,$version)=@_;my$found;if ($self->{dev_release}or $self->{metacpan}){$found=$self->search_metacpan($module,$version,$self->{dev_release})and return$found;$found=$self->search_cpanmetadb($module,$version,$self->{dev_release})and return$found}else {$found=$self->search_cpanmetadb($module,$version)and return$found;$found=$self->search_metacpan($module,$version)and return$found}}sub search_cpanmetadb {my($self,$module,$version,$dev_release)=@_;$self->chat("Searching $module ($version) on cpanmetadb ...\n");if ($self->with_version_range($version)){return$self->search_cpanmetadb_history($module,$version,$dev_release)}else {return$self->search_cpanmetadb_package($module,$version,$dev_release)}}sub search_cpanmetadb_package {my($self,$module,$version,$dev_release)=@_;require CPAN::Meta::YAML;(my$uri=$self->{cpanmetadb})=~ s{/?$}{/package/$module};my$yaml=$self->get($uri);my$meta=eval {CPAN::Meta::YAML::Load($yaml)};if ($meta && $meta->{distfile}){return$self->cpan_module($module,$meta->{distfile},$meta->{version})}$self->diag_fail("Finding $module on cpanmetadb failed.");return}sub search_cpanmetadb_history {my($self,$module,$version)=@_;(my$uri=$self->{cpanmetadb})=~ s{/?$}{/history/$module};my$content=$self->get($uri)or return;my@found;for my$line (split /\r?\n/,$content){if ($line =~ /^$module\s+(\S+)\s+(\S+)$/){push@found,{version=>$1,version_obj=>version::->parse($1),distfile=>$2,}}}return unless@found;$found[-1]->{latest}=1;my$match;for my$try (sort {$b->{version_obj}cmp $a->{version_obj}}@found){if ($self->satisfy_version($module,$try->{version_obj},$version)){local$self->{mirrors}=$self->{mirrors};unshift @{$self->{mirrors}},'http://backpan.perl.org' unless$try->{latest};return$self->cpan_module($module,$try->{distfile},$try->{version})}}$self->diag_fail("Finding $module ($version) on cpanmetadb failed.");return}sub search_module {my($self,$module,$version)=@_;if ($self->{mirror_index}){$self->mask_output(chat=>"Searching $module on mirror index $self->{mirror_index} ...\n");my$pkg=$self->search_mirror_index_file($self->{mirror_index},$module,$version);return$pkg if$pkg;unless ($self->{cascade_search}){$self->mask_output(diag_fail=>"Finding $module ($version) on mirror index $self->{mirror_index} failed.");return}}unless ($self->{mirror_only}){my$found=$self->search_database($module,$version);return$found if$found}MIRROR: for my$mirror (@{$self->{mirrors}}){$self->mask_output(chat=>"Searching $module on mirror $mirror ...\n");my$name='02packages.details.txt.gz';my$uri="$mirror/modules/$name";my$gz_file=$self->package_index_for($mirror).'.gz';unless ($self->{pkgs}{$uri}){$self->mask_output(chat=>"Downloading index file $uri ...\n");$self->mirror($uri,$gz_file);$self->generate_mirror_index($mirror)or next MIRROR;$self->{pkgs}{$uri}="!!retrieved!!"}my$pkg=$self->search_mirror_index($mirror,$module,$version);return$pkg if$pkg;$self->mask_output(diag_fail=>"Finding $module ($version) on mirror $mirror failed.")}return}sub source_for {my($self,$mirror)=@_;$mirror =~ s/[^\w\.\-]+/%/g;my$dir="$self->{home}/sources/$mirror";File::Path::mkpath([$dir ],0,0777);return$dir}sub load_argv_from_fh {my($self,$fh)=@_;my@argv;while(defined(my$line=<$fh>)){chomp$line;$line =~ s/#.+$//;$line =~ s/^\s+//;$line =~ s/\s+$//;push@argv,split ' ',$line if$line}return@argv}sub show_version {my$self=shift;print "cpanm (App::cpanminus) version $VERSION ($0)\n";print "perl version $] ($^X)\n\n";print "  \%Config:\n";for my$key (qw(archname installsitelib installsitebin installman1dir installman3dir sitearchexp sitelibexp vendorarch vendorlibexp archlibexp privlibexp)){print "    $key=$Config{$key}\n" if$Config{$key}}print "  \%ENV:\n";for my$key (grep /^PERL/,sort keys%ENV){print "    $key=$ENV{$key}\n"}print "  \@INC:\n";for my$inc (@INC){print "    $inc\n" unless ref($inc)eq 'CODE'}return 1}sub show_help {my$self=shift;if ($_[0]){print <<USAGE;return}print <<HELP;return 1}sub _writable {my$dir=shift;my@dir=File::Spec->splitdir($dir);while (@dir){$dir=File::Spec->catdir(@dir);if (-e $dir){return -w _}pop@dir}return}sub maybe_abs {my($self,$lib)=@_;if ($lib eq '_' or $lib =~ /^~/ or File::Spec->file_name_is_absolute($lib)){return$lib}else {return File::Spec->canonpath(File::Spec->catdir(Cwd::cwd(),$lib))}}sub local_lib_target {my($self,$root)=@_;(grep {$_ ne ''}split /\Q$Config{path_sep}/,$root)[0]}sub bootstrap_local_lib {my$self=shift;if ($self->{local_lib}){return$self->setup_local_lib($self->{local_lib})}if ($ENV{PERL_LOCAL_LIB_ROOT}&& $ENV{PERL_MM_OPT}){return$self->setup_local_lib($self->local_lib_target($ENV{PERL_LOCAL_LIB_ROOT}),1)}return if$self->{sudo}or (_writable($Config{installsitelib})and _writable($Config{installsitebin}));if ($ENV{PERL_MM_OPT}and ($ENV{MODULEBUILDRC}or $ENV{PERL_MB_OPT})){return}$self->setup_local_lib;$self->diag(<<DIAG,1);sleep 2}sub upgrade_toolchain {my($self,$config_deps)=@_;my%deps=map {$_->module=>$_}@$config_deps;my$reqs=CPAN::Meta::Requirements->from_string_hash({'Module::Build'=>'0.38','ExtUtils::MakeMaker'=>'6.58','ExtUtils::Install'=>'1.46',});if ($deps{"ExtUtils::MakeMaker"}){$deps{"ExtUtils::MakeMaker"}->merge_with($reqs)}elsif ($deps{"Module::Build"}){$deps{"Module::Build"}->merge_with($reqs);$deps{"ExtUtils::Install"}||= App::cpanminus::Dependency->new("ExtUtils::Install",0,'configure');$deps{"ExtUtils::Install"}->merge_with($reqs)}@$config_deps=values%deps}sub _core_only_inc {my($self,$base)=@_;require local::lib;(local::lib->resolve_path(local::lib->install_base_arch_path($base)),local::lib->resolve_path(local::lib->install_base_perl_path($base)),(!$self->{exclude_vendor}? grep {$_}@Config{qw(vendorarch vendorlibexp)}: ()),@Config{qw(archlibexp privlibexp)},)}sub _diff {my($self,$old,$new)=@_;my@diff;my%old=map {$_=>1}@$old;for my$n (@$new){push@diff,$n unless exists$old{$n}}@diff}sub _setup_local_lib_env {my($self,$base)=@_;$self->diag(<<WARN,1)if$base =~ /\s/;local$SIG{__WARN__}=sub {};local::lib->setup_env_hash_for($base,0)}sub setup_local_lib {my($self,$base,$no_env)=@_;$base=undef if$base eq '_';require local::lib;{local $0='cpanm';$base ||= "~/perl5";$base=local::lib->resolve_path($base);if ($self->{self_contained}){my@inc=$self->_core_only_inc($base);$self->{search_inc}=[@inc ]}else {$self->{search_inc}=[local::lib->install_base_arch_path($base),local::lib->install_base_perl_path($base),@INC,]}$self->_setup_local_lib_env($base)unless$no_env;$self->{local_lib}=$base}}sub prompt_bool {my($self,$mess,$def)=@_;my$val=$self->prompt($mess,$def);return lc$val eq 'y'}sub prompt {my($self,$mess,$def)=@_;my$isa_tty=-t STDIN && (-t STDOUT ||!(-f STDOUT || -c STDOUT));my$dispdef=defined$def ? "[$def] " : " ";$def=defined$def ? $def : "";if (!$self->{prompt}|| (!$isa_tty && eof STDIN)){return$def}local $|=1;local $\;my$ans;eval {local$SIG{ALRM}=sub {undef$ans;die "alarm\n"};print STDOUT "$mess $dispdef";alarm$self->{prompt_timeout}if$self->{prompt_timeout};$ans=<STDIN>;alarm 0};if (defined$ans){chomp$ans}else {print STDOUT "\n"}return (!defined$ans || $ans eq '')? $def : $ans}sub diag_ok {my($self,$msg)=@_;chomp$msg;$msg ||= "OK";if ($self->{in_progress}){$self->_diag("$msg\n");$self->{in_progress}=0}$self->log("-> $msg\n")}sub diag_fail {my($self,$msg,$always)=@_;chomp$msg;if ($self->{in_progress}){$self->_diag("FAIL\n");$self->{in_progress}=0}if ($msg){$self->_diag("! $msg\n",$always,1);$self->log("-> FAIL $msg\n")}}sub diag_progress {my($self,$msg)=@_;chomp$msg;$self->{in_progress}=1;$self->_diag("$msg ... ");$self->log("$msg\n")}sub _diag {my($self,$msg,$always,$error)=@_;my$fh=$error ? *STDERR : *STDOUT;print {$fh}$msg if$always or $self->{verbose}or!$self->{quiet}}sub diag {my($self,$msg,$always)=@_;$self->_diag($msg,$always);$self->log($msg)}sub chat {my$self=shift;print STDERR @_ if$self->{verbose};$self->log(@_)}sub mask_output {my$self=shift;my$method=shift;$self->$method($self->mask_uri_passwords(@_))}sub log {my$self=shift;open my$out,">>$self->{log}";print$out @_}sub run {my($self,$cmd)=@_;if (WIN32){$cmd=$self->shell_quote(@$cmd)if ref$cmd eq 'ARRAY';unless ($self->{verbose}){$cmd .= " >> " .$self->shell_quote($self->{log})." 2>&1"}!system$cmd}else {my$pid=fork;if ($pid){waitpid$pid,0;return!$?}else {$self->run_exec($cmd)}}}sub run_exec {my($self,$cmd)=@_;if (ref$cmd eq 'ARRAY'){unless ($self->{verbose}){open my$logfh,">>",$self->{log};open STDERR,'>&',$logfh;open STDOUT,'>&',$logfh;close$logfh}exec @$cmd}else {unless ($self->{verbose}){$cmd .= " >> " .$self->shell_quote($self->{log})." 2>&1"}exec$cmd}}sub run_timeout {my($self,$cmd,$timeout)=@_;return$self->run($cmd)if WIN32 || $self->{verbose}||!$timeout;my$pid=fork;if ($pid){eval {local$SIG{ALRM}=sub {die "alarm\n"};alarm$timeout;waitpid$pid,0;alarm 0};if ($@ && $@ eq "alarm\n"){$self->diag_fail("Timed out (> ${timeout}s). Use --verbose to retry.");local$SIG{TERM}='IGNORE';kill TERM=>0;waitpid$pid,0;return}return!$?}elsif ($pid==0){$self->run_exec($cmd)}else {$self->chat("! fork failed: falling back to system()\n");$self->run($cmd)}}sub append_args {my($self,$cmd,$phase)=@_;if (my$args=$self->{build_args}{$phase}){$cmd=join ' ',$self->shell_quote(@$cmd),$args}$cmd}sub configure {my($self,$cmd,$depth)=@_;local$ENV{PERL5_CPAN_IS_RUNNING}=local$ENV{PERL5_CPANPLUS_IS_RUNNING}=$$;local$ENV{PERL5_CPANM_IS_RUNNING}=$$;my$use_default=!$self->{interactive};local$ENV{PERL_MM_USE_DEFAULT}=$use_default;local$ENV{PERL_MM_OPT}=$ENV{PERL_MM_OPT};local$ENV{PERL_MB_OPT}=$ENV{PERL_MB_OPT};unless ($self->{pod2man}){$ENV{PERL_MM_OPT}.= " INSTALLMAN1DIR=none INSTALLMAN3DIR=none";$ENV{PERL_MB_OPT}.= " --config installman1dir= --config installsiteman1dir= --config installman3dir= --config installsiteman3dir="}if ($self->{pure_perl}){$ENV{PERL_MM_OPT}.= " PUREPERL_ONLY=1";$ENV{PERL_MB_OPT}.= " --pureperl-only"}local$ENV{PERL_USE_UNSAFE_INC}=1 unless exists$ENV{PERL_USE_UNSAFE_INC};$cmd=$self->append_args($cmd,'configure')if$depth==0;local$self->{verbose}=$self->{verbose}|| $self->{interactive};$self->run_timeout($cmd,$self->{configure_timeout})}sub build {my($self,$cmd,$distname,$depth)=@_;local$ENV{PERL_MM_USE_DEFAULT}=!$self->{interactive};local$ENV{PERL_USE_UNSAFE_INC}=1 unless exists$ENV{PERL_USE_UNSAFE_INC};$cmd=$self->append_args($cmd,'build')if$depth==0;return 1 if$self->run_timeout($cmd,$self->{build_timeout});while (1){my$ans=lc$self->prompt("Building $distname failed.\nYou can s)kip, r)etry, e)xamine build log, or l)ook ?","s");return if$ans eq 's';return$self->build($cmd,$distname,$depth)if$ans eq 'r';$self->show_build_log if$ans eq 'e';$self->look if$ans eq 'l'}}sub test {my($self,$cmd,$distname,$depth)=@_;return 1 if$self->{notest};local$ENV{PERL_MM_USE_DEFAULT}=!$self->{interactive};local$ENV{NONINTERACTIVE_TESTING}=!$self->{interactive};$cmd=$self->append_args($cmd,'test')if$depth==0;local$ENV{PERL_USE_UNSAFE_INC}=1 unless exists$ENV{PERL_USE_UNSAFE_INC};return 1 if$self->run_timeout($cmd,$self->{test_timeout});if ($self->{force}){$self->diag_fail("Testing $distname failed but installing it anyway.");return 1}else {$self->diag_fail;while (1){my$ans=lc$self->prompt("Testing $distname failed.\nYou can s)kip, r)etry, f)orce install, e)xamine build log, or l)ook ?","s");return if$ans eq 's';return$self->test($cmd,$distname,$depth)if$ans eq 'r';return 1 if$ans eq 'f';$self->show_build_log if$ans eq 'e';$self->look if$ans eq 'l'}}}sub install {my($self,$cmd,$uninst_opts,$depth)=@_;if ($depth==0 && $self->{test_only}){return 1}local$ENV{PERL_USE_UNSAFE_INC}=1 unless exists$ENV{PERL_USE_UNSAFE_INC};if ($self->{sudo}){unshift @$cmd,"sudo"}if ($self->{uninstall_shadows}&&!$ENV{PERL_MM_OPT}){push @$cmd,@$uninst_opts}$cmd=$self->append_args($cmd,'install')if$depth==0;$self->run($cmd)}sub look {my$self=shift;my$shell=$ENV{SHELL};$shell ||= $ENV{COMSPEC}if WIN32;if ($shell){my$cwd=Cwd::cwd;$self->diag("Entering $cwd with $shell\n");system$shell}else {$self->diag_fail("You don't seem to have a SHELL :/")}}sub show_build_log {my$self=shift;my@pagers=($ENV{PAGER},(WIN32 ? (): ('less')),'more');my$pager;while (@pagers){$pager=shift@pagers;next unless$pager;$pager=$self->which($pager);next unless$pager;last}if ($pager){system("$pager < $self->{log}")}else {$self->diag_fail("You don't seem to have a PAGER :/")}}sub chdir {my$self=shift;Cwd::chdir(File::Spec->canonpath($_[0]))or die "$_[0]: $!"}sub configure_mirrors {my$self=shift;unless (@{$self->{mirrors}}){$self->{mirrors}=['http://www.cpan.org' ]}for (@{$self->{mirrors}}){s!^/!file:///!;s!/$!!}}sub self_upgrade {my$self=shift;$self->check_upgrade;$self->{argv}=['App::cpanminus' ];return}sub install_module {my($self,$module,$depth,$version)=@_;$self->check_libs;if ($self->{seen}{$module}++){$self->chat("Already tried $module. Skipping.\n");return 1}if ($self->{skip_satisfied}){my($ok,$local)=$self->check_module($module,$version || 0);if ($ok){$self->diag("You have $module ($local)\n",1);return 1}}my$dist=$self->resolve_name($module,$version);unless ($dist){my$what=$module .($version ? " ($version)" : "");$self->diag_fail("Couldn't find module or a distribution $what",1);return}if ($dist->{distvname}&& $self->{seen}{$dist->{distvname}}++){$self->chat("Already tried $dist->{distvname}. Skipping.\n");return 1}if ($self->{cmd}eq 'info'){print$self->format_dist($dist),"\n";return 1}$dist->{depth}=$depth;if ($dist->{module}){unless ($self->satisfy_version($dist->{module},$dist->{module_version},$version)){$self->diag("Found $dist->{module} $dist->{module_version} which doesn't satisfy $version.\n",1);return}my$cmp=$version ? "==" : "";my$requirement=$dist->{module_version}? "$cmp$dist->{module_version}" : 0;my($ok,$local)=$self->check_module($dist->{module},$requirement);if ($self->{skip_installed}&& $ok){$self->diag("$dist->{module} is up to date. ($local)\n",1);return 1}}if ($dist->{dist}eq 'perl'){$self->diag("skipping $dist->{pathname}\n");return 1}$self->diag("--> Working on $module\n");$dist->{dir}||= $self->fetch_module($dist);unless ($dist->{dir}){$self->diag_fail("Failed to fetch distribution $dist->{distvname}",1);return}$self->chat("Entering $dist->{dir}\n");$self->chdir($self->{base});$self->chdir($dist->{dir});if ($self->{cmd}eq 'look'){$self->look;return 1}return$self->build_stuff($module,$dist,$depth)}sub uninstall_search_path {my$self=shift;$self->{local_lib}? (local::lib->install_base_arch_path($self->{local_lib}),local::lib->install_base_perl_path($self->{local_lib})): @Config{qw(installsitearch installsitelib)}}sub uninstall_module {my ($self,$module)=@_;$self->check_libs;my@inc=$self->uninstall_search_path;my($metadata,$packlist)=$self->packlists_containing($module,\@inc);unless ($packlist){$self->diag_fail(<<DIAG,1);return}my@uninst_files=$self->uninstall_target($metadata,$packlist);$self->ask_permission($module,\@uninst_files)or return;$self->uninstall_files(@uninst_files,$packlist);$self->diag("Successfully uninstalled $module\n",1);return 1}sub packlists_containing {my($self,$module,$inc)=@_;require Module::Metadata;my$metadata=Module::Metadata->new_from_module($module,inc=>$inc)or return;my$packlist;my$wanted=sub {return unless $_ eq '.packlist' && -f $_;for my$file ($self->unpack_packlist($File::Find::name)){$packlist ||= $File::Find::name if$file eq $metadata->filename}};{require File::pushd;my$pushd=File::pushd::pushd();my@search=grep -d $_,map File::Spec->catdir($_,'auto'),@$inc;File::Find::find($wanted,@search)}return$metadata,$packlist}sub uninstall_target {my($self,$metadata,$packlist)=@_;if ($self->has_shadow_install($metadata)or $self->{local_lib}){grep$self->should_unlink($_),$self->unpack_packlist($packlist)}else {$self->unpack_packlist($packlist)}}sub has_shadow_install {my($self,$metadata)=@_;my@shadow=grep defined,map Module::Metadata->new_from_module($metadata->name,inc=>[$_]),@INC;@shadow >= 2}sub should_unlink {my($self,$file)=@_;if ($self->{local_lib}){$file =~ /^\Q$self->{local_lib}\E/}else {!(grep$file =~ /^\Q$_\E/,@Config{qw(installbin installscript installman1dir installman3dir)})}}sub ask_permission {my ($self,$module,$files)=@_;$self->diag("$module contains the following files:\n\n");for my$file (@$files){$self->diag("  $file\n")}$self->diag("\n");return 'force uninstall' if$self->{force};local$self->{prompt}=1;return$self->prompt_bool("Are you sure you want to uninstall $module?",'y')}sub unpack_packlist {my ($self,$packlist)=@_;open my$fh,'<',$packlist or die "$packlist: $!";map {chomp;$_}<$fh>}sub uninstall_files {my ($self,@files)=@_;$self->diag("\n");for my$file (@files){$self->diag("Unlink: $file\n");unlink$file or $self->diag_fail("$!: $file")}$self->diag("\n");return 1}sub format_dist {my($self,$dist)=@_;return "$dist->{cpanid}/$dist->{filename}"}sub trim {local $_=shift;tr/\n/ /d;s/^\s*|\s*$//g;$_}sub fetch_module {my($self,$dist)=@_;$self->chdir($self->{base});for my$uri (@{$dist->{uris}}){$self->mask_output(diag_progress=>"Fetching $uri");my$filename=$dist->{filename}|| $uri;my$name=File::Basename::basename($filename);my$cancelled;my$fetch=sub {my$file;eval {local$SIG{INT}=sub {$cancelled=1;die "SIGINT\n"};$self->mirror($uri,$name);$file=$name if -e $name};$self->diag("ERROR: " .trim("$@")."\n",1)if $@ && $@ ne "SIGINT\n";return$file};my($try,$file);while ($try++ < 3){$file=$fetch->();last if$cancelled or $file;$self->mask_output(diag_fail=>"Download $uri failed. Retrying ... ")}if ($cancelled){$self->diag_fail("Download cancelled.");return}unless ($file){$self->mask_output(diag_fail=>"Failed to download $uri");next}$self->diag_ok;$dist->{local_path}=File::Spec->rel2abs($name);my$dir=$self->unpack($file,$uri,$dist);next unless$dir;if (my$save=$self->{save_dists}){my$path=$dist->{pathname}? "$save/authors/id/$dist->{pathname}" : "$save/vendor/$file";$self->chat("Copying $name to $path\n");File::Path::mkpath([File::Basename::dirname($path)],0,0777);File::Copy::copy($file,$path)or warn $!}return$dist,$dir}}sub unpack {my($self,$file,$uri,$dist)=@_;if ($self->{verify}){$self->verify_archive($file,$uri,$dist)or return}$self->chat("Unpacking $file\n");my$dir=$file =~ /\.zip/i ? $self->unzip($file): $self->untar($file);unless ($dir){$self->diag_fail("Failed to unpack $file: no directory")}return$dir}sub verify_checksums_signature {my($self,$chk_file)=@_;require Module::Signature;$self->chat("Verifying the signature of CHECKSUMS\n");my$rv=eval {local$SIG{__WARN__}=sub {};my$v=Module::Signature::_verify($chk_file);$v==Module::Signature::SIGNATURE_OK()};if ($rv){$self->chat("Verified OK!\n")}else {$self->diag_fail("Verifying CHECKSUMS signature failed: $rv\n");return}return 1}sub verify_archive {my($self,$file,$uri,$dist)=@_;unless ($dist->{cpanid}){$self->chat("Archive '$file' does not seem to be from PAUSE. Skip verification.\n");return 1}(my$mirror=$uri)=~ s!/authors/id.*$!!;(my$chksum_uri=$uri)=~ s!/[^/]*$!/CHECKSUMS!;my$chk_file=$self->source_for($mirror)."/$dist->{cpanid}.CHECKSUMS";$self->mask_output(diag_progress=>"Fetching $chksum_uri");$self->mirror($chksum_uri,$chk_file);unless (-e $chk_file){$self->diag_fail("Fetching $chksum_uri failed.\n");return}$self->diag_ok;$self->verify_checksums_signature($chk_file)or return;$self->verify_checksum($file,$chk_file)}sub verify_checksum {my($self,$file,$chk_file)=@_;$self->chat("Verifying the SHA1 for $file\n");open my$fh,"<$chk_file" or die "$chk_file: $!";my$data=join '',<$fh>;$data =~ s/\015?\012/\n/g;require Safe;my$chksum=Safe->new->reval($data);if (!ref$chksum or ref$chksum ne 'HASH'){$self->diag_fail("! Checksum file downloaded from $chk_file is broken.\n");return}if (my$sha=$chksum->{$file}{sha256}){my$hex=$self->sha1_for($file);if ($hex eq $sha){$self->chat("Checksum for $file: Verified!\n")}else {$self->diag_fail("Checksum mismatch for $file\n");return}}else {$self->chat("Checksum for $file not found in CHECKSUMS.\n");return}}sub sha1_for {my($self,$file)=@_;require Digest::SHA;open my$fh,"<",$file or die "$file: $!";my$dg=Digest::SHA->new(256);my($data);while (read($fh,$data,4096)){$dg->add($data)}return$dg->hexdigest}sub verify_signature {my($self,$dist)=@_;$self->diag_progress("Verifying the SIGNATURE file");my$out=`$self->{cpansign} -v --skip 2>&1`;$self->log($out);if ($out =~ /Signature verified OK/){$self->diag_ok("Verified OK");return 1}else {$self->diag_fail("SIGNATURE verification for $dist->{filename} failed\n");return}}sub resolve_name {my($self,$module,$version)=@_;if ($module =~ /(?:^git:|\.git(?:@.+)?$)/){return$self->git_uri($module)}if ($module =~ /^(ftp|https?|file):/){if ($module =~ m!authors/id/(.*)!){return$self->cpan_dist($1,$module)}else {return {uris=>[$module ]}}}if ($module =~ m!^[\./]! && -d $module){return {source=>'local',dir=>Cwd::abs_path($module),}}if (-f $module){return {source=>'local',uris=>["file://" .Cwd::abs_path($module)],}}if ($module =~ s!^cpan:///distfile/!!){return$self->cpan_dist($module)}if ($module =~ m!^(?:[A-Z]/[A-Z]{2}/)?([A-Z]{2}[\-A-Z0-9]*/.*)$!){return$self->cpan_dist($1)}return$self->search_module($module,$version)}sub cpan_module {my($self,$module,$dist_file,$version)=@_;my$dist=$self->cpan_dist($dist_file);$dist->{module}=$module;$dist->{module_version}=$version if$version && $version ne 'undef';return$dist}sub cpan_dist {my($self,$dist,$url)=@_;$dist =~ s!^([A-Z]{2})!substr($1,0,1)."/".substr($1,0,2)."/".$1!e;require CPAN::DistnameInfo;my$d=CPAN::DistnameInfo->new($dist);if ($url){$url=[$url ]unless ref$url eq 'ARRAY'}else {my$id=$d->cpanid;my$fn=substr($id,0,1)."/" .substr($id,0,2)."/" .$id ."/" .$d->filename;my@mirrors=@{$self->{mirrors}};my@urls=map "$_/authors/id/$fn",@mirrors;$url=\@urls,}return {$d->properties,source=>'cpan',uris=>$url,}}sub git_uri {my ($self,$uri)=@_;($uri,my$commitish)=split /(?<=\.git)@/i,$uri,2;my$dir=File::Temp::tempdir(CLEANUP=>1);$self->mask_output(diag_progress=>"Cloning $uri");$self->run(['git','clone',$uri,$dir ]);unless (-e "$dir/.git"){$self->diag_fail("Failed cloning git repository $uri",1);return}if ($commitish){require File::pushd;my$dir=File::pushd::pushd($dir);unless ($self->run(['git','checkout',$commitish ])){$self->diag_fail("Failed to checkout '$commitish' in git repository $uri\n");return}}$self->diag_ok;return {source=>'local',dir=>$dir,}}sub setup_module_build_patch {my$self=shift;open my$out,">$self->{base}/ModuleBuildSkipMan.pm" or die $!;print$out <<EOF}sub core_version_for {my($self,$module)=@_;require Module::CoreList;unless (exists$Module::CoreList::version{$]+0}){die sprintf("Module::CoreList %s (loaded from %s) doesn't seem to have entries for perl $]. " ."You're strongly recommended to upgrade Module::CoreList from CPAN.\n",$Module::CoreList::VERSION,$INC{"Module/CoreList.pm"})}unless (exists$Module::CoreList::version{$]+0}{$module}){return -1}return$Module::CoreList::version{$]+0}{$module}}sub search_inc {my$self=shift;$self->{search_inc}||= do {if (defined$::Bin){[grep!/^\Q$::Bin\E\/..\/(?:fat)?lib$/,@INC]}else {[@INC]}}}sub check_module {my($self,$mod,$want_ver)=@_;require Module::Metadata;my$meta=Module::Metadata->new_from_module($mod,inc=>$self->search_inc)or return 0,undef;my$version=$meta->version;if ($self->{self_contained}&& $self->loaded_from_perl_lib($meta)){$version=$self->core_version_for($mod);return 0,undef if$version && $version==-1}$self->{local_versions}{$mod}=$version;if ($self->is_deprecated($meta)){return 0,$version}elsif ($self->satisfy_version($mod,$version,$want_ver)){return 1,($version || 'undef')}else {return 0,$version}}sub satisfy_version {my($self,$mod,$version,$want_ver)=@_;$want_ver='0' unless defined($want_ver)&& length($want_ver);require CPAN::Meta::Requirements;my$requirements=CPAN::Meta::Requirements->new;$requirements->add_string_requirement($mod,$want_ver);$requirements->accepts_module($mod,$version)}sub unsatisfy_how {my($self,$ver,$want_ver)=@_;if ($want_ver =~ /^[v0-9\.\_]+$/){return "$ver < $want_ver"}else {return "$ver doesn't satisfy $want_ver"}}sub is_deprecated {my($self,$meta)=@_;my$deprecated=eval {require Module::CoreList;Module::CoreList::is_deprecated($meta->{module})};return$deprecated && $self->loaded_from_perl_lib($meta)}sub loaded_from_perl_lib {my($self,$meta)=@_;require Config;my@dirs=qw(archlibexp privlibexp);if ($self->{self_contained}&&!$self->{exclude_vendor}&& $Config{vendorarch}){unshift@dirs,qw(vendorarch vendorlibexp)}for my$dir (@dirs){my$confdir=$Config{$dir};if ($confdir eq substr($meta->filename,0,length($confdir))){return 1}}return}sub should_install {my($self,$mod,$ver)=@_;$self->chat("Checking if you have $mod $ver ... ");my($ok,$local)=$self->check_module($mod,$ver);if ($ok){$self->chat("Yes ($local)\n")}elsif ($local){$self->chat("No (" .$self->unsatisfy_how($local,$ver).")\n")}else {$self->chat("No\n")}return$mod unless$ok;return}sub check_perl_version {my($self,$version)=@_;require CPAN::Meta::Requirements;my$req=CPAN::Meta::Requirements->from_string_hash({perl=>$version });$req->accepts_module(perl=>$])}sub install_deps {my($self,$dir,$depth,@deps)=@_;my(@install,%seen,@fail);for my$dep (@deps){next if$seen{$dep->module};if ($dep->module eq 'perl'){if ($dep->is_requirement &&!$self->check_perl_version($dep->version)){$self->diag("Needs perl @{[$dep->version]}, you have $]\n");push@fail,'perl'}}elsif ($self->should_install($dep->module,$dep->version)){push@install,$dep;$seen{$dep->module}=1}}if (@install){$self->diag("==> Found dependencies: " .join(", ",map $_->module,@install)."\n")}for my$dep (@install){$self->install_module($dep->module,$depth + 1,$dep->version)}$self->chdir($self->{base});$self->chdir($dir)if$dir;if ($self->{scandeps}){return 1}my@not_ok=$self->unsatisfied_deps(@deps);if (@not_ok){return 0,\@not_ok}else {return 1}}sub unsatisfied_deps {my($self,@deps)=@_;require CPAN::Meta::Check;require CPAN::Meta::Requirements;my$reqs=CPAN::Meta::Requirements->new;for my$dep (grep $_->is_requirement,@deps){$reqs->add_string_requirement($dep->module=>$dep->requires_version || '0')}my$ret=CPAN::Meta::Check::check_requirements($reqs,'requires',$self->{search_inc});grep defined,values %$ret}sub install_deps_bailout {my($self,$target,$dir,$depth,@deps)=@_;my($ok,$fail)=$self->install_deps($dir,$depth,@deps);if (!$ok){$self->diag_fail("Installing the dependencies failed: " .join(", ",@$fail),1);unless ($self->prompt_bool("Do you want to continue building $target anyway?","n")){$self->diag_fail("Bailing out the installation for $target.",1);return}}return 1}sub build_stuff {my($self,$stuff,$dist,$depth)=@_;if ($self->{verify}&& -e 'SIGNATURE'){$self->verify_signature($dist)or return}require CPAN::Meta;my($meta_file)=grep -f,qw(META.json META.yml);if ($meta_file){$self->chat("Checking configure dependencies from $meta_file\n");$dist->{cpanmeta}=eval {CPAN::Meta->load_file($meta_file)}}elsif ($dist->{dist}&& $dist->{version}){$self->chat("META.yml/json not found. Creating skeleton for it.\n");$dist->{cpanmeta}=CPAN::Meta->new({name=>$dist->{dist},version=>$dist->{version}})}$dist->{meta}=$dist->{cpanmeta}? $dist->{cpanmeta}->as_struct : {};my@config_deps;if ($dist->{cpanmeta}){push@config_deps,App::cpanminus::Dependency->from_prereqs($dist->{cpanmeta}->effective_prereqs,['configure'],$self->{install_types},)}if (-e 'Build.PL' &&!$self->should_use_mm($dist->{dist})&&!@config_deps){push@config_deps,App::cpanminus::Dependency->from_versions({'Module::Build'=>'0.38' },'configure',)}$self->merge_with_cpanfile($dist,\@config_deps);$self->upgrade_toolchain(\@config_deps);my$target=$dist->{meta}{name}? "$dist->{meta}{name}-$dist->{meta}{version}" : $dist->{dir};{$self->install_deps_bailout($target,$dist->{dir},$depth,@config_deps)or return}$self->diag_progress("Configuring $target");my$configure_state=$self->configure_this($dist,$depth);$self->diag_ok($configure_state->{configured_ok}? "OK" : "N/A");if ($dist->{cpanmeta}&& $dist->{source}eq 'cpan'){$dist->{provides}=$dist->{cpanmeta}{provides}|| $self->extract_packages($dist->{cpanmeta},".")}my$root_target=(($self->{installdeps}or $self->{showdeps})and $depth==0);$dist->{want_phases}=$self->{notest}&&!$root_target ? [qw(build runtime)]: [qw(build test runtime)];push @{$dist->{want_phases}},'develop' if$self->{with_develop}&& $depth==0;push @{$dist->{want_phases}},'configure' if$self->{with_configure}&& $depth==0;my@deps=$self->find_prereqs($dist);my$module_name=$self->find_module_name($configure_state)|| $dist->{meta}{name};$module_name =~ s/-/::/g;if ($self->{showdeps}){for my$dep (@config_deps,@deps){print$dep->module,($dep->version ? ("~".$dep->version): ""),"\n"}return 1}my$distname=$dist->{meta}{name}? "$dist->{meta}{name}-$dist->{meta}{version}" : $stuff;my$walkup;if ($self->{scandeps}){$walkup=$self->scandeps_append_child($dist)}$self->install_deps_bailout($distname,$dist->{dir},$depth,@deps)or return;if ($self->{scandeps}){unless ($configure_state->{configured_ok}){my$diag=<<DIAG;if (@config_deps){my@tree=@{$self->{scandeps_tree}};$diag .= "!\n" .join("",map "! * $_->[0]{module}\n",@tree[0..$#tree-1])if@tree}$self->diag("!\n$diag!\n",1)}$walkup->();return 1}if ($self->{installdeps}&& $depth==0){if ($configure_state->{configured_ok}){$self->diag("<== Installed dependencies for $stuff. Finishing.\n");return 1}else {$self->diag("! Configuring $distname failed. See $self->{log} for details.\n",1);return}}my$installed;if ($configure_state->{use_module_build}&& -e 'Build' && -f _){$self->diag_progress("Building " .($self->{notest}? "" : "and testing ").$distname);$self->build([$self->{perl},"./Build" ],$distname,$depth)&& $self->test([$self->{perl},"./Build","test" ],$distname,$depth)&& $self->install([$self->{perl},"./Build","install" ],["--uninst",1 ],$depth)&& $installed++}elsif ($self->{make}&& -e 'Makefile'){$self->diag_progress("Building " .($self->{notest}? "" : "and testing ").$distname);$self->build([$self->{make}],$distname,$depth)&& $self->test([$self->{make},"test" ],$distname,$depth)&& $self->install([$self->{make},"install" ],["UNINST=1" ],$depth)&& $installed++}else {my$why;my$configure_failed=$configure_state->{configured}&&!$configure_state->{configured_ok};if ($configure_failed){$why="Configure failed for $distname."}elsif ($self->{make}){$why="The distribution doesn't have a proper Makefile.PL/Build.PL"}else {$why="Can't configure the distribution. You probably need to have 'make'."}$self->diag_fail("$why See $self->{log} for details.",1);return}if ($installed && $self->{test_only}){$self->diag_ok;$self->diag("Successfully tested $distname\n",1)}elsif ($installed){my$local=$self->{local_versions}{$dist->{module}|| ''};my$version=$dist->{module_version}|| $dist->{meta}{version}|| $dist->{version};my$reinstall=$local && ($local eq $version);my$action=$local &&!$reinstall ? $self->numify_ver($version)< $self->numify_ver($local)? "downgraded" : "upgraded" : undef;my$how=$reinstall ? "reinstalled $distname" : $local ? "installed $distname ($action from $local)" : "installed $distname" ;my$msg="Successfully $how";$self->diag_ok;$self->diag("$msg\n",1);$self->{installed_dists}++;$self->save_meta($stuff,$dist,$module_name,\@config_deps,\@deps);return 1}else {my$what=$self->{test_only}? "Testing" : "Installing";$self->diag_fail("$what $stuff failed. See $self->{log} for details. Retry with --force to force install it.",1);return}}sub perl_requirements {my($self,@requires)=@_;my@perl;for my$requires (grep defined,@requires){if (exists$requires->{perl}){push@perl,App::cpanminus::Dependency->new(perl=>$requires->{perl})}}return@perl}sub should_use_mm {my($self,$dist)=@_;my%should_use_mm=map {$_=>1}qw(version ExtUtils-ParseXS ExtUtils-Install ExtUtils-Manifest);$should_use_mm{$dist}}sub configure_this {my($self,$dist,$depth)=@_;if (-e $self->{cpanfile_path}&& $self->{installdeps}&& $depth==0){require Module::CPANfile;$dist->{cpanfile}=eval {Module::CPANfile->load($self->{cpanfile_path})};$self->diag_fail($@,1)if $@;return {configured=>1,configured_ok=>!!$dist->{cpanfile},use_module_build=>0,}}if ($self->{skip_configure}){my$eumm=-e 'Makefile';my$mb=-e 'Build' && -f _;return {configured=>1,configured_ok=>$eumm || $mb,use_module_build=>$mb,}}my$state={};my$try_eumm=sub {if (-e 'Makefile.PL'){$self->chat("Running Makefile.PL\n");if ($self->configure([$self->{perl},"Makefile.PL" ],$depth)){$state->{configured_ok}=-e 'Makefile'}$state->{configured}++}};my$try_mb=sub {if (-e 'Build.PL'){$self->chat("Running Build.PL\n");if ($self->configure([$self->{perl},"Build.PL" ],$depth)){$state->{configured_ok}=-e 'Build' && -f _}$state->{use_module_build}++;$state->{configured}++}};my@try;if ($dist->{dist}&& $self->should_use_mm($dist->{dist})){@try=($try_eumm,$try_mb)}else {@try=($try_mb,$try_eumm)}for my$try (@try){$try->();last if$state->{configured_ok}}unless ($state->{configured_ok}){while (1){my$ans=lc$self->prompt("Configuring $dist->{dist} failed.\nYou can s)kip, r)etry, e)xamine build log, or l)ook ?","s");last if$ans eq 's';return$self->configure_this($dist,$depth)if$ans eq 'r';$self->show_build_log if$ans eq 'e';$self->look if$ans eq 'l'}}return$state}sub find_module_name {my($self,$state)=@_;return unless$state->{configured_ok};if ($state->{use_module_build}&& -e "_build/build_params"){my$params=do {open my$in,"_build/build_params";$self->safe_eval(join "",<$in>)};return eval {$params->[2]{module_name}}|| undef}elsif (-e "Makefile"){open my$mf,"Makefile";while (<$mf>){if (/^\#\s+NAME\s+=>\s+(.*)/){return$self->safe_eval($1)}}}return}sub list_files {my$self=shift;if (-e 'MANIFEST'){require ExtUtils::Manifest;my$manifest=eval {ExtUtils::Manifest::manifind()}|| {};return sort {lc$a cmp lc$b}keys %$manifest}else {require File::Find;my@files;my$finder=sub {my$name=$File::Find::name;$name =~ s!\.[/\\]!!;push@files,$name};File::Find::find($finder,".");return sort {lc$a cmp lc$b}@files}}sub extract_packages {my($self,$meta,$dir)=@_;my$try=sub {my$file=shift;return 0 if$file =~ m!^(?:x?t|inc|local|perl5|fatlib|_build)/!;return 1 unless$meta->{no_index};return 0 if grep {$file =~ m!^$_/!}@{$meta->{no_index}{directory}|| []};return 0 if grep {$file eq $_}@{$meta->{no_index}{file}|| []};return 1};require Parse::PMFile;my@files=grep {/\.pm(?:\.PL)?$/ && $try->($_)}$self->list_files;my$provides={};for my$file (@files){my$parser=Parse::PMFile->new($meta,{UNSAFE=>1,ALLOW_DEV_VERSION=>1 });my$packages=$parser->parse($file);while (my($package,$meta)=each %$packages){$provides->{$package}||= {file=>$meta->{infile},($meta->{version}eq 'undef')? (): (version=>$meta->{version}),}}}return$provides}sub save_meta {my($self,$module,$dist,$module_name,$config_deps,$build_deps)=@_;return unless$dist->{distvname}&& $dist->{source}eq 'cpan';my$base=($ENV{PERL_MM_OPT}|| '')=~ /INSTALL_BASE=/ ? ($self->install_base($ENV{PERL_MM_OPT})."/lib/perl5"): $Config{sitelibexp};my$provides=$dist->{provides};File::Path::mkpath("blib/meta",0,0777);my$local={name=>$module_name,target=>$module,version=>exists$provides->{$module_name}? ($provides->{$module_name}{version}|| $dist->{version}): $dist->{version},dist=>$dist->{distvname},pathname=>$dist->{pathname},provides=>$provides,};require JSON::PP;open my$fh,">","blib/meta/install.json" or die $!;print$fh JSON::PP::encode_json($local);if (-e "MYMETA.json"){File::Copy::copy("MYMETA.json","blib/meta/MYMETA.json")}my@cmd=(($self->{sudo}? 'sudo' : ()),$^X,'-MExtUtils::Install=install','-e',qq[install({ 'blib/meta' => '$base/$Config{archname}/.meta/$dist->{distvname}' })],);$self->run(\@cmd)}sub _merge_hashref {my($self,@hashrefs)=@_;my%hash;for my$h (@hashrefs){%hash=(%hash,%$h)}return \%hash}sub install_base {my($self,$mm_opt)=@_;$mm_opt =~ /INSTALL_BASE=(\S+)/ and return $1;die "Your PERL_MM_OPT doesn't contain INSTALL_BASE"}sub safe_eval {my($self,$code)=@_;eval$code}sub configure_features {my($self,$dist,@features)=@_;map $_->identifier,grep {$self->effective_feature($dist,$_)}@features}sub effective_feature {my($self,$dist,$feature)=@_;if ($dist->{depth}==0){my$value=$self->{features}{$feature->identifier};return$value if defined$value;return 1 if$self->{features}{__all}}if ($self->{interactive}){require CPAN::Meta::Requirements;$self->diag("[@{[ $feature->description ]}]\n",1);my$req=CPAN::Meta::Requirements->new;for my$phase (@{$dist->{want_phases}}){for my$type (@{$self->{install_types}}){$req->add_requirements($feature->prereqs->requirements_for($phase,$type))}}my$reqs=$req->as_string_hash;my@missing;for my$module (keys %$reqs){if ($self->should_install($module,$req->{$module})){push@missing,$module}}if (@missing){my$howmany=@missing;$self->diag("==> Found missing dependencies: " .join(", ",@missing)."\n",1);local$self->{prompt}=1;return$self->prompt_bool("Install the $howmany optional module(s)?","y")}}return}sub find_prereqs {my($self,$dist)=@_;my@deps=$self->extract_meta_prereqs($dist);if ($dist->{module}=~ /^Bundle::/i){push@deps,$self->bundle_deps($dist)}$self->merge_with_cpanfile($dist,\@deps);return@deps}sub merge_with_cpanfile {my($self,$dist,$deps)=@_;if ($self->{cpanfile_requirements}&&!$dist->{cpanfile}){for my$dep (@$deps){$dep->merge_with($self->{cpanfile_requirements})}}}sub extract_meta_prereqs {my($self,$dist)=@_;if ($dist->{cpanfile}){my@features=$self->configure_features($dist,$dist->{cpanfile}->features);my$prereqs=$dist->{cpanfile}->prereqs_with(@features);$self->{cpanfile_requirements}=$prereqs->merged_requirements($dist->{want_phases},['requires']);return App::cpanminus::Dependency->from_prereqs($prereqs,$dist->{want_phases},$self->{install_types})}require CPAN::Meta;my@deps;my($meta_file)=grep -f,qw(MYMETA.json MYMETA.yml);if ($meta_file){$self->chat("Checking dependencies from $meta_file ...\n");my$mymeta=eval {CPAN::Meta->load_file($meta_file,{lazy_validation=>1 })};if ($mymeta){$dist->{meta}{name}=$mymeta->name;$dist->{meta}{version}=$mymeta->version;return$self->extract_prereqs($mymeta,$dist)}}if (-e '_build/prereqs'){$self->chat("Checking dependencies from _build/prereqs ...\n");my$prereqs=do {open my$in,"_build/prereqs";$self->safe_eval(join "",<$in>)};my$meta=CPAN::Meta->new({name=>$dist->{meta}{name},version=>$dist->{meta}{version},%$prereqs },{lazy_validation=>1 },);@deps=$self->extract_prereqs($meta,$dist)}elsif (-e 'Makefile'){$self->chat("Finding PREREQ from Makefile ...\n");open my$mf,"Makefile";while (<$mf>){if (/^\#\s+PREREQ_PM => \{\s*(.*?)\s*\}/){my@all;my@pairs=split ', ',$1;for (@pairs){my ($pkg,$v)=split '=>',$_;push@all,[$pkg,$v ]}my$list=join ", ",map {"'$_->[0]' => $_->[1]"}@all;my$prereq=$self->safe_eval("no strict; +{ $list }");push@deps,App::cpanminus::Dependency->from_versions($prereq)if$prereq;last}}}return@deps}sub bundle_deps {my($self,$dist)=@_;my$match;if ($dist->{module}){$match=sub {my$meta=Module::Metadata->new_from_file($_[0]);$meta && ($meta->name eq $dist->{module})}}else {$match=sub {1}}my@files;File::Find::find({wanted=>sub {push@files,File::Spec->rel2abs($_)if /\.pm$/i && $match->($_)},no_chdir=>1,},'.');my@deps;for my$file (@files){open my$pod,"<",$file or next;my$in_contents;while (<$pod>){if (/^=head\d\s+CONTENTS/){$in_contents=1}elsif (/^=/){$in_contents=0}elsif ($in_contents){/^(\S+)\s*(\S+)?/ and push@deps,App::cpanminus::Dependency->new($1,$self->maybe_version($2))}}}return@deps}sub maybe_version {my($self,$string)=@_;return$string && $string =~ /^\.?\d/ ? $string : undef}sub extract_prereqs {my($self,$meta,$dist)=@_;my@features=$self->configure_features($dist,$meta->features);my$prereqs=$self->soften_makemaker_prereqs($meta->effective_prereqs(\@features)->clone);return App::cpanminus::Dependency->from_prereqs($prereqs,$dist->{want_phases},$self->{install_types})}sub soften_makemaker_prereqs {my($self,$prereqs)=@_;return$prereqs unless -e "inc/Module/Install.pm";for my$phase (qw(build test runtime)){my$reqs=$prereqs->requirements_for($phase,'requires');if ($reqs->requirements_for_module('ExtUtils::MakeMaker')){$reqs->clear_requirement('ExtUtils::MakeMaker');$reqs->add_minimum('ExtUtils::MakeMaker'=>0)}}$prereqs}sub cleanup_workdirs {my$self=shift;my$expire=time - 24 * 60 * 60 * $self->{auto_cleanup};my@targets;opendir my$dh,"$self->{home}/work";while (my$e=readdir$dh){next if$e !~ /^(\d+)\.\d+$/;my$time=$1;if ($time < $expire){push@targets,"$self->{home}/work/$e"}}if (@targets){if (@targets >= 64){$self->diag("Expiring " .scalar(@targets)." work directories. This might take a while...\n")}else {$self->chat("Expiring " .scalar(@targets)." work directories.\n")}File::Path::rmtree(\@targets,0,0)}}sub scandeps_append_child {my($self,$dist)=@_;my$new_node=[$dist,[]];my$curr_node=$self->{scandeps_current}|| [undef,$self->{scandeps_tree}];push @{$curr_node->[1]},$new_node;$self->{scandeps_current}=$new_node;return sub {$self->{scandeps_current}=$curr_node}}sub dump_scandeps {my$self=shift;if ($self->{format}eq 'tree'){$self->walk_down(sub {my($dist,$depth)=@_;if ($depth==0){print "$dist->{distvname}\n"}else {print " " x ($depth - 1);print "\\_ $dist->{distvname}\n"}},1)}elsif ($self->{format}=~ /^dists?$/){$self->walk_down(sub {my($dist,$depth)=@_;print$self->format_dist($dist),"\n"},0)}elsif ($self->{format}eq 'json'){require JSON::PP;print JSON::PP::encode_json($self->{scandeps_tree})}elsif ($self->{format}eq 'yaml'){require YAML;print YAML::Dump($self->{scandeps_tree})}else {$self->diag("Unknown format: $self->{format}\n")}}sub walk_down {my($self,$cb,$pre)=@_;$self->_do_walk_down($self->{scandeps_tree},$cb,0,$pre)}sub _do_walk_down {my($self,$children,$cb,$depth,$pre)=@_;for my$node (@$children){$cb->($node->[0],$depth)if$pre;$self->_do_walk_down($node->[1],$cb,$depth + 1,$pre);$cb->($node->[0],$depth)unless$pre}}sub DESTROY {my$self=shift;$self->{at_exit}->($self)if$self->{at_exit}}sub shell_quote {my($self,@stuff)=@_;if (WIN32){join ' ',map {/^${quote}.+${quote}$/ ? $_ : ($quote .$_ .$quote)}@stuff}else {String::ShellQuote::shell_quote_best_effort(@stuff)}}sub which {my($self,$name)=@_;if (File::Spec->file_name_is_absolute($name)){if (-x $name &&!-d _){return$name}}my$exe_ext=$Config{_exe};for my$dir (File::Spec->path){my$fullpath=File::Spec->catfile($dir,$name);if ((-x $fullpath || -x ($fullpath .= $exe_ext))&&!-d _){if ($fullpath =~ /\s/){$fullpath=$self->shell_quote($fullpath)}return$fullpath}}return}sub get {my($self,$uri)=@_;if ($uri =~ /^file:/){$self->file_get($uri)}else {$self->{_backends}{get}->(@_)}}sub mirror {my($self,$uri,$local)=@_;if ($uri =~ /^file:/){$self->file_mirror($uri,$local)}else {$self->{_backends}{mirror}->(@_)}}sub untar {$_[0]->{_backends}{untar}->(@_)};sub unzip {$_[0]->{_backends}{unzip}->(@_)};sub uri_to_file {my($self,$uri)=@_;if ($uri =~ s!file:/+!!){$uri="/$uri" unless$uri =~ m![a-zA-Z]:!}return$uri}sub file_get {my($self,$uri)=@_;my$file=$self->uri_to_file($uri);open my$fh,"<$file" or return;join '',<$fh>}sub file_mirror {my($self,$uri,$path)=@_;my$file=$self->uri_to_file($uri);my$source_mtime=(stat$file)[9];return 1 if -e $path && (stat$path)[9]>= $source_mtime;File::Copy::copy($file,$path);utime$source_mtime,$source_mtime,$path}sub has_working_lwp {my($self,$mirrors)=@_;my$https=grep /^https:/,@$mirrors;eval {require LWP::UserAgent;LWP::UserAgent->VERSION(5.802);require LWP::Protocol::https if$https;1}}sub init_tools {my$self=shift;return if$self->{initialized}++;if ($self->{make}=$self->which($Config{make})){$self->chat("You have make $self->{make}\n")}if ($self->{try_lwp}&& $self->has_working_lwp($self->{mirrors})){$self->chat("You have LWP $LWP::VERSION\n");my$ua=sub {LWP::UserAgent->new(parse_head=>0,env_proxy=>1,agent=>$self->agent,timeout=>30,@_,)};$self->{_backends}{get}=sub {my$self=shift;my$res=$ua->()->request(HTTP::Request->new(GET=>$_[0]));return unless$res->is_success;return$res->decoded_content};$self->{_backends}{mirror}=sub {my$self=shift;my$res=$ua->()->mirror(@_);die$res->content if$res->code==501;$res->code}}elsif ($self->{try_wget}and my$wget=$self->which('wget')){$self->chat("You have $wget\n");my@common=('--user-agent',$self->agent,'--retry-connrefused',($self->{verbose}? (): ('-q')),);$self->{_backends}{get}=sub {my($self,$uri)=@_;$self->safeexec(my$fh,$wget,$uri,@common,'-O','-')or die "wget $uri: $!";local $/;<$fh>};$self->{_backends}{mirror}=sub {my($self,$uri,$path)=@_;$self->safeexec(my$fh,$wget,$uri,@common,'-O',$path)or die "wget $uri: $!";local $/;<$fh>}}elsif ($self->{try_curl}and my$curl=$self->which('curl')){$self->chat("You have $curl\n");my@common=('--location','--user-agent',$self->agent,($self->{verbose}? (): '-s'),);$self->{_backends}{get}=sub {my($self,$uri)=@_;$self->safeexec(my$fh,$curl,@common,$uri)or die "curl $uri: $!";local $/;<$fh>};$self->{_backends}{mirror}=sub {my($self,$uri,$path)=@_;$self->safeexec(my$fh,$curl,@common,$uri,'-#','-o',$path)or die "curl $uri: $!";local $/;<$fh>}}else {require HTTP::Tiny;$self->chat("Falling back to HTTP::Tiny $HTTP::Tiny::VERSION\n");my%common=(agent=>$self->agent,);$self->{_backends}{get}=sub {my$self=shift;my$res=HTTP::Tiny->new(%common)->get($_[0]);return unless$res->{success};return$res->{content}};$self->{_backends}{mirror}=sub {my$self=shift;my$res=HTTP::Tiny->new(%common)->mirror(@_);return$res->{status}}}my$tar=$self->which('tar');my$tar_ver;my$maybe_bad_tar=sub {WIN32 || BAD_TAR || (($tar_ver=`$tar --version 2>/dev/null`)=~ /GNU.*1\.13/i)};if ($tar &&!$maybe_bad_tar->()){chomp$tar_ver;$self->chat("You have $tar: $tar_ver\n");$self->{_backends}{untar}=sub {my($self,$tarfile)=@_;my$xf=($self->{verbose}? 'v' : '')."xf";my$ar=$tarfile =~ /bz2$/ ? 'j' : 'z';my($root,@others)=`$tar ${ar}tf $tarfile` or return undef;FILE: {chomp$root;$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}system "$tar $ar$xf $tarfile";return$root if -d $root;$self->diag_fail("Bad archive: $tarfile");return undef}}elsif ($tar and my$gzip=$self->which('gzip')and my$bzip2=$self->which('bzip2')){$self->chat("You have $tar, $gzip and $bzip2\n");$self->{_backends}{untar}=sub {my($self,$tarfile)=@_;my$x="x" .($self->{verbose}? 'v' : '')."f -";my$ar=$tarfile =~ /bz2$/ ? $bzip2 : $gzip;my($root,@others)=`$ar -dc $tarfile | $tar tf -` or return undef;FILE: {chomp$root;$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}system "$ar -dc $tarfile | $tar $x";return$root if -d $root;$self->diag_fail("Bad archive: $tarfile");return undef}}elsif (eval {require Archive::Tar}){$self->chat("Falling back to Archive::Tar $Archive::Tar::VERSION\n");$self->{_backends}{untar}=sub {my$self=shift;my$t=Archive::Tar->new($_[0]);my($root,@others)=$t->list_files;FILE: {$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}$t->extract;return -d $root ? $root : undef}}else {$self->{_backends}{untar}=sub {die "Failed to extract $_[1] - You need to have tar or Archive::Tar installed.\n"}}if (my$unzip=$self->which('unzip')){$self->chat("You have $unzip\n");$self->{_backends}{unzip}=sub {my($self,$zipfile)=@_;my$opt=$self->{verbose}? '' : '-q';my(undef,$root,@others)=`$unzip -t $zipfile` or return undef;FILE: {chomp$root;if ($root !~ s{^\s+testing:\s+([^/]+)/.*?\s+OK$}{$1}){$root=shift(@others);redo FILE if$root}}system "$unzip $opt $zipfile";return$root if -d $root;$self->diag_fail("Bad archive: [$root] $zipfile");return undef}}else {$self->{_backends}{unzip}=sub {eval {require Archive::Zip}or die "Failed to extract $_[1] - You need to have unzip or Archive::Zip installed.\n";my($self,$file)=@_;my$zip=Archive::Zip->new();my$status;$status=$zip->read($file);$self->diag_fail("Read of file[$file] failed")if$status!=Archive::Zip::AZ_OK();my@members=$zip->members();for my$member (@members){my$af=$member->fileName();next if ($af =~ m!^(/|\.\./)!);$status=$member->extractToFileNamed($af);$self->diag_fail("Extracting of file[$af] from zipfile[$file failed")if$status!=Archive::Zip::AZ_OK()}my ($root)=$zip->membersMatching(qr<^[^/]+/$>);$root &&= $root->fileName;return -d $root ? $root : undef}}}sub safeexec {my$self=shift;my$rdr=$_[0]||= Symbol::gensym();if (WIN32){my$cmd=$self->shell_quote(@_[1..$#_]);return open($rdr,"$cmd |")}if (my$pid=open($rdr,'-|')){return$pid}elsif (defined$pid){exec(@_[1 .. $#_ ]);exit 1}else {return}}sub mask_uri_passwords {my($self,@strings)=@_;s{ (https?://) ([^:/]+) : [^@/]+ @ }{$1$2:********@}gx for@strings;return@strings}1;
  It appears your cpanm executable was installed via `perlbrew install-cpanm`.
  cpanm --self-upgrade won't upgrade the version of cpanm you're running.
  
  Run the following command to get it upgraded.
  
    perlbrew install-cpanm
  
  DIE
  You are running cpanm from the path where your current perl won't install executables to.
  Because of that, cpanm --self-upgrade won't upgrade the version of cpanm you're running.
  
    cpanm path   : $0
    Install path : $Config{installsitebin}
  
  It means you either installed cpanm globally with system perl, or use distro packages such
  as rpm or apt-get, and you have to use them again to upgrade cpanm.
  DIE
  Usage: cpanm [options] Module [...]
  
  Try `cpanm --help` or `man cpanm` for more options.
  USAGE
  Usage: cpanm [options] Module [...]
  
  Options:
    -v,--verbose              Turns on chatty output
    -q,--quiet                Turns off the most output
    --interactive             Turns on interactive configure (required for Task:: modules)
    -f,--force                force install
    -n,--notest               Do not run unit tests
    --test-only               Run tests only, do not install
    -S,--sudo                 sudo to run install commands
    --installdeps             Only install dependencies
    --showdeps                Only display direct dependencies
    --reinstall               Reinstall the distribution even if you already have the latest version installed
    --mirror                  Specify the base URL for the mirror (e.g. http://cpan.cpantesters.org/)
    --mirror-only             Use the mirror's index file instead of the CPAN Meta DB
    -M,--from                 Use only this mirror base URL and its index file
    --prompt                  Prompt when configure/build/test fails
    -l,--local-lib            Specify the install base to install modules
    -L,--local-lib-contained  Specify the install base to install all non-core modules
    --self-contained          Install all non-core modules, even if they're already installed.
    --auto-cleanup            Number of days that cpanm's work directories expire in. Defaults to 7
  
  Commands:
    --self-upgrade            upgrades itself
    --info                    Displays distribution info on CPAN
    --look                    Opens the distribution with your SHELL
    -U,--uninstall            Uninstalls the modules (EXPERIMENTAL)
    -V,--version              Displays software version
  
  Examples:
  
    cpanm Test::More                                          # install Test::More
    cpanm MIYAGAWA/Plack-0.99_05.tar.gz                       # full distribution path
    cpanm http://example.org/LDS/CGI.pm-3.20.tar.gz           # install from URL
    cpanm ~/dists/MyCompany-Enterprise-1.00.tar.gz            # install from a local file
    cpanm --interactive Task::Kensho                          # Configure interactively
    cpanm .                                                   # install from local directory
    cpanm --installdeps .                                     # install all the deps for the current directory
    cpanm -L extlib Plack                                     # install Plack and all non-core deps into extlib
    cpanm --mirror http://cpan.cpantesters.org/ DBI           # use the fast-syncing mirror
    cpanm -M https://cpan.metacpan.org App::perlbrew          # use only this secure mirror and its index
  
  You can also specify the default options in PERL_CPANM_OPT environment variable in the shell rc:
  
    export PERL_CPANM_OPT="--prompt --reinstall -l ~/perl --mirror http://cpan.cpantesters.org"
  
  Type `man cpanm` or `perldoc cpanm` for the more detailed explanation of the options.
  
  HELP
  !
  ! Can't write to $Config{installsitelib} and $Config{installsitebin}: Installing modules to $ENV{HOME}/perl5
  ! To turn off this warning, you have to do one of the following:
  !   - run me as a root or with --sudo option (to install to $Config{installsitelib} and $Config{installsitebin})
  !   - Configure local::lib in your existing shell to set PERL_MM_OPT etc.
  !   - Install local::lib by running the following commands
  !
  !         cpanm --local-lib=~/perl5 local::lib && eval \$(perl -I ~/perl5/lib/perl5/ -Mlocal::lib)
  !
  DIAG
  WARNING: Your lib directory name ($base) contains a space in it. It's known to cause issues with perl builder tools such as local::lib and MakeMaker. You're recommended to rename your directory.
  WARN
  $module is not found in the following directories and can't be uninstalled.
  
  @{[ join("  \n", map "  $_", @inc) ]}
  
  DIAG
  package ModuleBuildSkipMan;
  CHECK {
    if (%Module::Build::) {
      no warnings 'redefine';
      *Module::Build::Base::ACTION_manpages = sub {};
      *Module::Build::Base::ACTION_docs     = sub {};
    }
  }
  1;
  EOF
  ! Configuring $distname failed. See $self->{log} for details.
  ! You might have to install the following modules first to get --scandeps working correctly.
  DIAG
APP_CPANMINUS_SCRIPT

$fatpacked{"CPAN/DistnameInfo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_DISTNAMEINFO';
  package CPAN::DistnameInfo;$VERSION="0.12";use strict;sub distname_info {my$file=shift or return;my ($dist,$version)=$file =~ /^
      ((?:[-+.]*(?:[A-Za-z0-9]+|(?<=\D)_|_(?=\D))*
       (?:
  	[A-Za-z](?=[^A-Za-z]|$)
  	|
  	\d(?=-)
       )(?<![._-][vV])
      )+)(.*)
    $/xs or return ($file,undef,undef);if ($dist =~ /-undef\z/ and!length$version){$dist =~ s/-undef\z//}$version =~ s/-withoutworldwriteables$//;if ($version =~ /^(-[Vv].*)-(\d.*)/){$dist .= $1;$version=$2}if ($version =~ /(.+_.*)-(\d.*)/){$dist .= $1;$version=$2}$dist =~ s{\.pm$}{};$version=$1 if!length$version and $dist =~ s/-(\d+\w)$//;$version=$1 .$version if$version =~ /^\d+$/ and $dist =~ s/-(\w+)$//;if ($version =~ /\d\.\d/){$version =~ s/^[-_.]+//}else {$version =~ s/^[-_]+//}my$dev;if (length$version){if ($file =~ /^perl-?\d+\.(\d+)(?:\D(\d+))?(-(?:TRIAL|RC)\d+)?$/){$dev=1 if (($1 > 6 and $1 & 1)or ($2 and $2 >= 50))or $3}elsif ($version =~ /\d\D\d+_\d/ or $version =~ /-TRIAL/){$dev=1}}else {$version=undef}($dist,$version,$dev)}sub new {my$class=shift;my$distfile=shift;$distfile =~ s,//+,/,g;my%info=(pathname=>$distfile);($info{filename}=$distfile)=~ s,^(((.*?/)?authors/)?id/)?([A-Z])/(\4[A-Z])/(\5[-A-Z0-9]*)/,, and $info{cpanid}=$6;if ($distfile =~ m,([^/]+)\.(tar\.(?:g?z|bz2)|zip|tgz)$,i){$info{distvname}=$1;$info{extension}=$2}@info{qw(dist version beta)}=distname_info($info{distvname});$info{maturity}=delete$info{beta}? 'developer' : 'released';return bless \%info,$class}sub dist {shift->{dist}}sub version {shift->{version}}sub maturity {shift->{maturity}}sub filename {shift->{filename}}sub cpanid {shift->{cpanid}}sub distvname {shift->{distvname}}sub extension {shift->{extension}}sub pathname {shift->{pathname}}sub properties {%{$_[0]}}1;
CPAN_DISTNAMEINFO

$fatpacked{"CPAN/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META';
  use 5.006;use strict;use warnings;package CPAN::Meta;our$VERSION='2.150005';use Carp qw(carp croak);use CPAN::Meta::Feature;use CPAN::Meta::Prereqs;use CPAN::Meta::Converter;use CPAN::Meta::Validator;use Parse::CPAN::Meta 1.4414 ();BEGIN {*_dclone=\&CPAN::Meta::Converter::_dclone}BEGIN {my@STRING_READERS=qw(abstract description dynamic_config generated_by name release_status version);no strict 'refs';for my$attr (@STRING_READERS){*$attr=sub {$_[0]{$attr }}}}BEGIN {my@LIST_READERS=qw(author keywords license);no strict 'refs';for my$attr (@LIST_READERS){*$attr=sub {my$value=$_[0]{$attr };croak "$attr must be called in list context" unless wantarray;return @{_dclone($value)}if ref$value;return$value}}}sub authors {$_[0]->author}sub licenses {$_[0]->license}BEGIN {my@MAP_READERS=qw(meta-spec resources provides no_index prereqs optional_features);no strict 'refs';for my$attr (@MAP_READERS){(my$subname=$attr)=~ s/-/_/;*$subname=sub {my$value=$_[0]{$attr };return _dclone($value)if$value;return {}}}}sub custom_keys {return grep {/^x_/i}keys %{$_[0]}}sub custom {my ($self,$attr)=@_;my$value=$self->{$attr};return _dclone($value)if ref$value;return$value}sub _new {my ($class,$struct,$options)=@_;my$self;if ($options->{lazy_validation}){my$cmc=CPAN::Meta::Converter->new($struct);$self=$cmc->convert(version=>2);return bless$self,$class}else {my$cmv=CPAN::Meta::Validator->new($struct);unless ($cmv->is_valid){die "Invalid metadata structure. Errors: " .join(", ",$cmv->errors)."\n"}}my$version=$struct->{'meta-spec'}{version}|| '1.0';if ($version==2){$self=$struct}else {my$cmc=CPAN::Meta::Converter->new($struct);$self=$cmc->convert(version=>2)}return bless$self,$class}sub new {my ($class,$struct,$options)=@_;my$self=eval {$class->_new($struct,$options)};croak($@)if $@;return$self}sub create {my ($class,$struct,$options)=@_;my$version=__PACKAGE__->VERSION || 2;$struct->{generated_by}||= __PACKAGE__ ." version $version" ;$struct->{'meta-spec'}{version}||= int($version);my$self=eval {$class->_new($struct,$options)};croak ($@)if $@;return$self}sub load_file {my ($class,$file,$options)=@_;$options->{lazy_validation}=1 unless exists$options->{lazy_validation};croak "load_file() requires a valid, readable filename" unless -r $file;my$self;eval {my$struct=Parse::CPAN::Meta->load_file($file);$self=$class->_new($struct,$options)};croak($@)if $@;return$self}sub load_yaml_string {my ($class,$yaml,$options)=@_;$options->{lazy_validation}=1 unless exists$options->{lazy_validation};my$self;eval {my ($struct)=Parse::CPAN::Meta->load_yaml_string($yaml);$self=$class->_new($struct,$options)};croak($@)if $@;return$self}sub load_json_string {my ($class,$json,$options)=@_;$options->{lazy_validation}=1 unless exists$options->{lazy_validation};my$self;eval {my$struct=Parse::CPAN::Meta->load_json_string($json);$self=$class->_new($struct,$options)};croak($@)if $@;return$self}sub load_string {my ($class,$string,$options)=@_;$options->{lazy_validation}=1 unless exists$options->{lazy_validation};my$self;eval {my$struct=Parse::CPAN::Meta->load_string($string);$self=$class->_new($struct,$options)};croak($@)if $@;return$self}sub save {my ($self,$file,$options)=@_;my$version=$options->{version}|| '2';my$layer=$] ge '5.008001' ? ':utf8' : '';if ($version ge '2'){carp "'$file' should end in '.json'" unless$file =~ m{\.json$}}else {carp "'$file' should end in '.yml'" unless$file =~ m{\.yml$}}my$data=$self->as_string($options);open my$fh,">$layer",$file or die "Error opening '$file' for writing: $!\n";print {$fh}$data;close$fh or die "Error closing '$file': $!\n";return 1}sub meta_spec_version {my ($self)=@_;return$self->meta_spec->{version}}sub effective_prereqs {my ($self,$features)=@_;$features ||= [];my$prereq=CPAN::Meta::Prereqs->new($self->prereqs);return$prereq unless @$features;my@other=map {;$self->feature($_)->prereqs}@$features;return$prereq->with_merged_prereqs(\@other)}sub should_index_file {my ($self,$filename)=@_;for my$no_index_file (@{$self->no_index->{file}|| []}){return if$filename eq $no_index_file}for my$no_index_dir (@{$self->no_index->{directory}}){$no_index_dir =~ s{$}{/} unless$no_index_dir =~ m{/\z};return if index($filename,$no_index_dir)==0}return 1}sub should_index_package {my ($self,$package)=@_;for my$no_index_pkg (@{$self->no_index->{package}|| []}){return if$package eq $no_index_pkg}for my$no_index_ns (@{$self->no_index->{namespace}}){return if index($package,"${no_index_ns}::")==0}return 1}sub features {my ($self)=@_;my$opt_f=$self->optional_features;my@features=map {;CPAN::Meta::Feature->new($_=>$opt_f->{$_ })}keys %$opt_f;return@features}sub feature {my ($self,$ident)=@_;croak "no feature named $ident" unless my$f=$self->optional_features->{$ident };return CPAN::Meta::Feature->new($ident,$f)}sub as_struct {my ($self,$options)=@_;my$struct=_dclone($self);if ($options->{version}){my$cmc=CPAN::Meta::Converter->new($struct);$struct=$cmc->convert(version=>$options->{version})}return$struct}sub as_string {my ($self,$options)=@_;my$version=$options->{version}|| '2';my$struct;if ($self->meta_spec_version ne $version){my$cmc=CPAN::Meta::Converter->new($self->as_struct);$struct=$cmc->convert(version=>$version)}else {$struct=$self->as_struct}my ($data,$backend);if ($version ge '2'){$backend=Parse::CPAN::Meta->json_backend();local$struct->{x_serialization_backend}=sprintf '%s version %s',$backend,$backend->VERSION;$data=$backend->new->pretty->canonical->encode($struct)}else {$backend=Parse::CPAN::Meta->yaml_backend();local$struct->{x_serialization_backend}=sprintf '%s version %s',$backend,$backend->VERSION;$data=eval {no strict 'refs';&{"$backend\::Dump"}($struct)};if ($@){croak$backend->can('errstr')? $backend->errstr : $@}}return$data}sub TO_JSON {return {%{$_[0]}}}1;
CPAN_META

$fatpacked{"CPAN/Meta/Check.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_CHECK';
  package CPAN::Meta::Check;$CPAN::Meta::Check::VERSION='0.012';use strict;use warnings;use base 'Exporter';our@EXPORT=qw//;our@EXPORT_OK=qw/check_requirements requirements_for verify_dependencies/;our%EXPORT_TAGS=(all=>[@EXPORT,@EXPORT_OK ]);use CPAN::Meta::Prereqs '2.132830';use CPAN::Meta::Requirements 2.121;use Module::Metadata 1.000023;sub _check_dep {my ($reqs,$module,$dirs)=@_;$module eq 'perl' and return ($reqs->accepts_module($module,$])? (): sprintf "Your Perl (%s) is not in the range '%s'",$],$reqs->requirements_for_module($module));my$metadata=Module::Metadata->new_from_module($module,inc=>$dirs);return "Module '$module' is not installed" if not defined$metadata;my$version=eval {$metadata->version};return "Missing version info for module '$module'" if$reqs->requirements_for_module($module)and not $version;return sprintf 'Installed version (%s) of %s is not in range \'%s\'',$version,$module,$reqs->requirements_for_module($module)if not $reqs->accepts_module($module,$version || 0);return}sub _check_conflict {my ($reqs,$module,$dirs)=@_;my$metadata=Module::Metadata->new_from_module($module,inc=>$dirs);return if not defined$metadata;my$version=eval {$metadata->version};return "Missing version info for module '$module'" if not $version;return sprintf 'Installed version (%s) of %s is in range \'%s\'',$version,$module,$reqs->requirements_for_module($module)if$reqs->accepts_module($module,$version);return}sub requirements_for {my ($meta,$phases,$type)=@_;my$prereqs=ref($meta)eq 'CPAN::Meta' ? $meta->effective_prereqs : $meta;return$prereqs->merged_requirements(ref($phases)? $phases : [$phases ],[$type ])}sub check_requirements {my ($reqs,$type,$dirs)=@_;return +{map {$_=>$type ne 'conflicts' ? scalar _check_dep($reqs,$_,$dirs): scalar _check_conflict($reqs,$_,$dirs)}$reqs->required_modules }}sub verify_dependencies {my ($meta,$phases,$type,$dirs)=@_;my$reqs=requirements_for($meta,$phases,$type);my$issues=check_requirements($reqs,$type,$dirs);return grep {defined}values %{$issues}}1;
CPAN_META_CHECK

$fatpacked{"CPAN/Meta/Converter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_CONVERTER';
  use 5.006;use strict;use warnings;package CPAN::Meta::Converter;our$VERSION='2.150005';use CPAN::Meta::Validator;use CPAN::Meta::Requirements;use Parse::CPAN::Meta 1.4400 ();BEGIN {eval "use version ()";if (my$err=$@){eval "use ExtUtils::MakeMaker::version" or die$err}}*_is_qv=version->can('is_qv')? sub {$_[0]->is_qv}: sub {exists $_[0]->{qv}};sub _dclone {my$ref=shift;no warnings 'once';no warnings 'redefine';local*UNIVERSAL::TO_JSON=sub {"$_[0]"};my$json=Parse::CPAN::Meta->json_backend()->new ->utf8 ->allow_blessed ->convert_blessed;$json->decode($json->encode($ref))}my%known_specs=('2'=>'http://search.cpan.org/perldoc?CPAN::Meta::Spec','1.4'=>'http://module-build.sourceforge.net/META-spec-v1.4.html','1.3'=>'http://module-build.sourceforge.net/META-spec-v1.3.html','1.2'=>'http://module-build.sourceforge.net/META-spec-v1.2.html','1.1'=>'http://module-build.sourceforge.net/META-spec-v1.1.html','1.0'=>'http://module-build.sourceforge.net/META-spec-v1.0.html');my@spec_list=sort {$a <=> $b}keys%known_specs;my ($LOWEST,$HIGHEST)=@spec_list[0,-1];sub _keep {$_[0]}sub _keep_or_one {defined($_[0])? $_[0]: 1}sub _keep_or_zero {defined($_[0])? $_[0]: 0}sub _keep_or_unknown {defined($_[0])&& length($_[0])? $_[0]: "unknown"}sub _generated_by {my$gen=shift;my$sig=__PACKAGE__ ." version " .(__PACKAGE__->VERSION || "<dev>");return$sig unless defined$gen and length$gen;return$gen if$gen =~ /\Q$sig/;return "$gen, $sig"}sub _listify {!defined $_[0]? undef : ref $_[0]eq 'ARRAY' ? $_[0]: [$_[0]]}sub _prefix_custom {my$key=shift;$key =~ s/^(?!x_)   # Unless it already starts with x_
               (?:x-?)? # Remove leading x- or x (if present)
             /x_/ix;return$key}sub _ucfirst_custom {my$key=shift;$key=ucfirst$key unless$key =~ /[A-Z]/;return$key}sub _no_prefix_ucfirst_custom {my$key=shift;$key =~ s/^x_//;return _ucfirst_custom($key)}sub _change_meta_spec {my ($element,undef,undef,$version)=@_;return {version=>$version,url=>$known_specs{$version},}}my@open_source=('perl','gpl','apache','artistic','artistic_2','lgpl','bsd','gpl','mit','mozilla','open_source',);my%is_open_source=map {;$_=>1}@open_source;my@valid_licenses_1=(@open_source,'unrestricted','restrictive','unknown',);my%license_map_1=((map {$_=>$_}@valid_licenses_1),artistic2=>'artistic_2',);sub _license_1 {my ($element)=@_;return 'unknown' unless defined$element;if ($license_map_1{lc$element}){return$license_map_1{lc$element}}else {return 'unknown'}}my@valid_licenses_2=qw(agpl_3 apache_1_1 apache_2_0 artistic_1 artistic_2 bsd freebsd gfdl_1_2 gfdl_1_3 gpl_1 gpl_2 gpl_3 lgpl_2_1 lgpl_3_0 mit mozilla_1_0 mozilla_1_1 openssl perl_5 qpl_1_0 ssleay sun zlib open_source restricted unrestricted unknown);my%license_map_2=((map {$_=>$_}@valid_licenses_2),apache=>'apache_2_0',artistic=>'artistic_1',artistic2=>'artistic_2',gpl=>'open_source',lgpl=>'open_source',mozilla=>'open_source',perl=>'perl_5',restrictive=>'restricted',);sub _license_2 {my ($element)=@_;return ['unknown' ]unless defined$element;$element=[$element ]unless ref$element eq 'ARRAY';my@new_list;for my$lic (@$element){next unless defined$lic;if (my$new=$license_map_2{lc$lic}){push@new_list,$new}}return@new_list ? \@new_list : ['unknown' ]}my%license_downgrade_map=qw(agpl_3 open_source apache_1_1 apache apache_2_0 apache artistic_1 artistic artistic_2 artistic_2 bsd bsd freebsd open_source gfdl_1_2 open_source gfdl_1_3 open_source gpl_1 gpl gpl_2 gpl gpl_3 gpl lgpl_2_1 lgpl lgpl_3_0 lgpl mit mit mozilla_1_0 mozilla mozilla_1_1 mozilla openssl open_source perl_5 perl qpl_1_0 open_source ssleay open_source sun open_source zlib open_source open_source open_source restricted restrictive unrestricted unrestricted unknown unknown);sub _downgrade_license {my ($element)=@_;if (!defined$element){return "unknown"}elsif(ref$element eq 'ARRAY'){if (@$element > 1){if (grep {!$is_open_source{$license_downgrade_map{lc $_}|| 'unknown' }}@$element){return 'unknown'}else {return 'open_source'}}elsif (@$element==1){return$license_downgrade_map{lc$element->[0]}|| "unknown"}}elsif (!ref$element){return$license_downgrade_map{lc$element}|| "unknown"}return "unknown"}my$no_index_spec_1_2={'file'=>\&_listify,'dir'=>\&_listify,'package'=>\&_listify,'namespace'=>\&_listify,};my$no_index_spec_1_3={'file'=>\&_listify,'directory'=>\&_listify,'package'=>\&_listify,'namespace'=>\&_listify,};my$no_index_spec_2={'file'=>\&_listify,'directory'=>\&_listify,'package'=>\&_listify,'namespace'=>\&_listify,':custom'=>\&_prefix_custom,};sub _no_index_1_2 {my (undef,undef,$meta)=@_;my$no_index=$meta->{no_index}|| $meta->{private};return unless$no_index;if (!ref$no_index){my$item=$no_index;$no_index={dir=>[$item ],file=>[$item ]}}elsif (ref$no_index eq 'ARRAY'){my$list=$no_index;$no_index={dir=>[@$list ],file=>[@$list ]}}if (exists$no_index->{files}){$no_index->{file}=delete$no_index->{files}}if (exists$no_index->{modules}){$no_index->{module}=delete$no_index->{modules}}return _convert($no_index,$no_index_spec_1_2)}sub _no_index_directory {my ($element,$key,$meta,$version)=@_;return unless$element;if (!ref$element){my$item=$element;$element={directory=>[$item ],file=>[$item ]}}elsif (ref$element eq 'ARRAY'){my$list=$element;$element={directory=>[@$list ],file=>[@$list ]}}if (exists$element->{dir}){$element->{directory}=delete$element->{dir}}if (exists$element->{files}){$element->{file}=delete$element->{files}}if (exists$element->{modules}){$element->{module}=delete$element->{modules}}my$spec=$version==2 ? $no_index_spec_2 : $no_index_spec_1_3;return _convert($element,$spec)}sub _is_module_name {my$mod=shift;return unless defined$mod && length$mod;return$mod =~ m{^[A-Za-z][A-Za-z0-9_]*(?:::[A-Za-z0-9_]+)*$}}sub _clean_version {my ($element)=@_;return 0 if!defined$element;$element =~ s{^\s*}{};$element =~ s{\s*$}{};$element =~ s{^\.}{0.};return 0 if!length$element;return 0 if ($element eq 'undef' || $element eq '<undef>');my$v=eval {version->new($element)};if (defined$v){return _is_qv($v)? $v->normal : $element}else {return 0}}sub _bad_version_hook {my ($v)=@_;$v =~ s{^\s*}{};$v =~ s{\s*$}{};$v =~ s{[a-z]+$}{};my$vobj=eval {version->new($v)};return defined($vobj)? $vobj : version->new(0)}sub _version_map {my ($element)=@_;return unless defined$element;if (ref$element eq 'HASH'){my$new_map=CPAN::Meta::Requirements->new({bad_version_hook=>\&_bad_version_hook });while (my ($k,$v)=each %$element){next unless _is_module_name($k);if (!defined($v)||!length($v)|| $v eq 'undef' || $v eq '<undef>'){$v=0}if (_is_module_name($v)&&!version::is_lax($v)){$new_map->add_minimum($k=>0);$new_map->add_minimum($v=>0)}$new_map->add_string_requirement($k=>$v)}return$new_map->as_string_hash}elsif (ref$element eq 'ARRAY'){my$hashref={map {$_=>0}@$element };return _version_map($hashref)}elsif (ref$element eq '' && length$element){return {$element=>0 }}return}sub _prereqs_from_1 {my (undef,undef,$meta)=@_;my$prereqs={};for my$phase (qw/build configure/){my$key="${phase}_requires";$prereqs->{$phase}{requires}=_version_map($meta->{$key})if$meta->{$key}}for my$rel (qw/requires recommends conflicts/){$prereqs->{runtime}{$rel}=_version_map($meta->{$rel})if$meta->{$rel}}return$prereqs}my$prereqs_spec={configure=>\&_prereqs_rel,build=>\&_prereqs_rel,test=>\&_prereqs_rel,runtime=>\&_prereqs_rel,develop=>\&_prereqs_rel,':custom'=>\&_prefix_custom,};my$relation_spec={requires=>\&_version_map,recommends=>\&_version_map,suggests=>\&_version_map,conflicts=>\&_version_map,':custom'=>\&_prefix_custom,};sub _cleanup_prereqs {my ($prereqs,$key,$meta,$to_version)=@_;return unless$prereqs && ref$prereqs eq 'HASH';return _convert($prereqs,$prereqs_spec,$to_version)}sub _prereqs_rel {my ($relation,$key,$meta,$to_version)=@_;return unless$relation && ref$relation eq 'HASH';return _convert($relation,$relation_spec,$to_version)}BEGIN {my@old_prereqs=qw(requires configure_requires recommends conflicts);for (@old_prereqs){my$sub="_get_$_";my ($phase,$type)=split qr/_/,$_;if (!defined$type){$type=$phase;$phase='runtime'}no strict 'refs';*{$sub}=sub {_extract_prereqs($_[2]->{prereqs},$phase,$type)}}}sub _get_build_requires {my ($data,$key,$meta)=@_;my$test_h=_extract_prereqs($_[2]->{prereqs},qw(test requires))|| {};my$build_h=_extract_prereqs($_[2]->{prereqs},qw(build requires))|| {};my$test_req=CPAN::Meta::Requirements->from_string_hash($test_h);my$build_req=CPAN::Meta::Requirements->from_string_hash($build_h);$test_req->add_requirements($build_req)->as_string_hash}sub _extract_prereqs {my ($prereqs,$phase,$type)=@_;return unless ref$prereqs eq 'HASH';return scalar _version_map($prereqs->{$phase}{$type})}sub _downgrade_optional_features {my (undef,undef,$meta)=@_;return unless exists$meta->{optional_features};my$origin=$meta->{optional_features};my$features={};for my$name (keys %$origin){$features->{$name}={description=>$origin->{$name}{description},requires=>_extract_prereqs($origin->{$name}{prereqs},'runtime','requires'),configure_requires=>_extract_prereqs($origin->{$name}{prereqs},'runtime','configure_requires'),build_requires=>_extract_prereqs($origin->{$name}{prereqs},'runtime','build_requires'),recommends=>_extract_prereqs($origin->{$name}{prereqs},'runtime','recommends'),conflicts=>_extract_prereqs($origin->{$name}{prereqs},'runtime','conflicts'),};for my$k (keys %{$features->{$name}}){delete$features->{$name}{$k}unless defined$features->{$name}{$k}}}return$features}sub _upgrade_optional_features {my (undef,undef,$meta)=@_;return unless exists$meta->{optional_features};my$origin=$meta->{optional_features};my$features={};for my$name (keys %$origin){$features->{$name}={description=>$origin->{$name}{description},prereqs=>_prereqs_from_1(undef,undef,$origin->{$name}),};delete$features->{$name}{prereqs}{configure}}return$features}my$optional_features_2_spec={description=>\&_keep,prereqs=>\&_cleanup_prereqs,':custom'=>\&_prefix_custom,};sub _feature_2 {my ($element,$key,$meta,$to_version)=@_;return unless$element && ref$element eq 'HASH';_convert($element,$optional_features_2_spec,$to_version)}sub _cleanup_optional_features_2 {my ($element,$key,$meta,$to_version)=@_;return unless$element && ref$element eq 'HASH';my$new_data={};for my$k (keys %$element){$new_data->{$k}=_feature_2($element->{$k},$k,$meta,$to_version)}return unless keys %$new_data;return$new_data}sub _optional_features_1_4 {my ($element)=@_;return unless$element;$element=_optional_features_as_map($element);for my$name (keys %$element){for my$drop (qw/requires_packages requires_os excluded_os/){delete$element->{$name}{$drop}}}return$element}sub _optional_features_as_map {my ($element)=@_;return unless$element;if (ref$element eq 'ARRAY'){my%map;for my$feature (@$element){my (@parts)=%$feature;$map{$parts[0]}=$parts[1]}$element=\%map}return$element}sub _is_urlish {defined $_[0]&& $_[0]=~ m{\A[-+.a-z0-9]+:.+}i}sub _url_or_drop {my ($element)=@_;return$element if _is_urlish($element);return}sub _url_list {my ($element)=@_;return unless$element;$element=_listify($element);$element=[grep {_is_urlish($_)}@$element ];return unless @$element;return$element}sub _author_list {my ($element)=@_;return ['unknown' ]unless$element;$element=_listify($element);$element=[map {defined $_ && length $_ ? $_ : 'unknown'}@$element ];return ['unknown' ]unless @$element;return$element}my$resource2_upgrade={license=>sub {return _is_urlish($_[0])? _listify($_[0]): undef},homepage=>\&_url_or_drop,bugtracker=>sub {my ($item)=@_;return unless$item;if ($item =~ m{^mailto:(.*)$}){return {mailto=>$1 }}elsif(_is_urlish($item)){return {web=>$item }}else {return}},repository=>sub {return _is_urlish($_[0])? {url=>$_[0]}: undef},':custom'=>\&_prefix_custom,};sub _upgrade_resources_2 {my (undef,undef,$meta,$version)=@_;return unless exists$meta->{resources};return _convert($meta->{resources},$resource2_upgrade)}my$bugtracker2_spec={web=>\&_url_or_drop,mailto=>\&_keep,':custom'=>\&_prefix_custom,};sub _repo_type {my ($element,$key,$meta,$to_version)=@_;return$element if defined$element;return unless exists$meta->{url};my$repo_url=$meta->{url};for my$type (qw/git svn/){return$type if$repo_url =~ m{\A$type}}return}my$repository2_spec={web=>\&_url_or_drop,url=>\&_url_or_drop,type=>\&_repo_type,':custom'=>\&_prefix_custom,};my$resources2_cleanup={license=>\&_url_list,homepage=>\&_url_or_drop,bugtracker=>sub {ref $_[0]? _convert($_[0],$bugtracker2_spec): undef},repository=>sub {my$data=shift;ref$data ? _convert($data,$repository2_spec): undef},':custom'=>\&_prefix_custom,};sub _cleanup_resources_2 {my ($resources,$key,$meta,$to_version)=@_;return unless$resources && ref$resources eq 'HASH';return _convert($resources,$resources2_cleanup,$to_version)}my$resource1_spec={license=>\&_url_or_drop,homepage=>\&_url_or_drop,bugtracker=>\&_url_or_drop,repository=>\&_url_or_drop,':custom'=>\&_keep,};sub _resources_1_3 {my (undef,undef,$meta,$version)=@_;return unless exists$meta->{resources};return _convert($meta->{resources},$resource1_spec)}*_resources_1_4=*_resources_1_3;sub _resources_1_2 {my (undef,undef,$meta)=@_;my$resources=$meta->{resources}|| {};if ($meta->{license_url}&&!$resources->{license}){$resources->{license}=$meta->{license_url}if _is_urlish($meta->{license_url})}return unless keys %$resources;return _convert($resources,$resource1_spec)}my$resource_downgrade_spec={license=>sub {return ref $_[0]? $_[0]->[0]: $_[0]},homepage=>\&_url_or_drop,bugtracker=>sub {return $_[0]->{web}},repository=>sub {return $_[0]->{url}|| $_[0]->{web}},':custom'=>\&_no_prefix_ucfirst_custom,};sub _downgrade_resources {my (undef,undef,$meta,$version)=@_;return unless exists$meta->{resources};return _convert($meta->{resources},$resource_downgrade_spec)}sub _release_status {my ($element,undef,$meta)=@_;return$element if$element && $element =~ m{\A(?:stable|testing|unstable)\z};return _release_status_from_version(undef,undef,$meta)}sub _release_status_from_version {my (undef,undef,$meta)=@_;my$version=$meta->{version}|| '';return ($version =~ /_/)? 'testing' : 'stable'}my$provides_spec={file=>\&_keep,version=>\&_keep,};my$provides_spec_2={file=>\&_keep,version=>\&_keep,':custom'=>\&_prefix_custom,};sub _provides {my ($element,$key,$meta,$to_version)=@_;return unless defined$element && ref$element eq 'HASH';my$spec=$to_version==2 ? $provides_spec_2 : $provides_spec;my$new_data={};for my$k (keys %$element){$new_data->{$k}=_convert($element->{$k},$spec,$to_version);$new_data->{$k}{version}=_clean_version($element->{$k}{version})if exists$element->{$k}{version}}return$new_data}sub _convert {my ($data,$spec,$to_version,$is_fragment)=@_;my$new_data={};for my$key (keys %$spec){next if$key eq ':custom' || $key eq ':drop';next unless my$fcn=$spec->{$key};if ($is_fragment && $key eq 'generated_by'){$fcn=\&_keep}die "spec for '$key' is not a coderef" unless ref$fcn && ref$fcn eq 'CODE';my$new_value=$fcn->($data->{$key},$key,$data,$to_version);$new_data->{$key}=$new_value if defined$new_value}my$drop_list=$spec->{':drop'};my$customizer=$spec->{':custom'}|| \&_keep;for my$key (keys %$data){next if$drop_list && grep {$key eq $_}@$drop_list;next if exists$spec->{$key};$new_data->{$customizer->($key)}=$data->{$key}}return$new_data}my%up_convert=('2-from-1.4'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_2,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'release_status'=>\&_release_status,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_upgrade_optional_features,'provides'=>\&_provides,'resources'=>\&_upgrade_resources_2,'description'=>\&_keep,'prereqs'=>\&_prereqs_from_1,':drop'=>[qw(build_requires configure_requires conflicts distribution_type license_url private recommends requires) ],':custom'=>\&_prefix_custom,},'1.4-from-1.3'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_1_4,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_4,'configure_requires'=>\&_keep,':drop'=>[qw(license_url private)],':custom'=>\&_keep },'1.3-from-1.2'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_3,':drop'=>[qw(license_url private)],':custom'=>\&_keep },'1.2-from-1.1'=>{'version'=>\&_keep,'license'=>\&_license_1,'name'=>\&_keep,'generated_by'=>\&_generated_by,'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'meta-spec'=>\&_change_meta_spec,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'recommends'=>\&_version_map,'requires'=>\&_version_map,'keywords'=>\&_keep,'no_index'=>\&_no_index_1_2,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'resources'=>\&_resources_1_2,':drop'=>[qw(license_url private)],':custom'=>\&_keep },'1.1-from-1.0'=>{'version'=>\&_keep,'name'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'recommends'=>\&_version_map,'requires'=>\&_version_map,'license_url'=>\&_url_or_drop,'private'=>\&_keep,':custom'=>\&_keep },);my%down_convert=('1.4-from-2'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_downgrade_license,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_get_build_requires,'configure_requires'=>\&_get_configure_requires,'conflicts'=>\&_get_conflicts,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_downgrade_optional_features,'provides'=>\&_provides,'recommends'=>\&_get_recommends,'requires'=>\&_get_requires,'resources'=>\&_downgrade_resources,':drop'=>[qw(description prereqs release_status)],':custom'=>\&_keep },'1.3-from-1.4'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_3,':drop'=>[qw(configure_requires)],':custom'=>\&_keep,},'1.2-from-1.3'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_1_2,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_3,':custom'=>\&_keep,},'1.1-from-1.2'=>{'version'=>\&_keep,'name'=>\&_keep,'meta-spec'=>\&_change_meta_spec,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'private'=>\&_keep,'recommends'=>\&_version_map,'requires'=>\&_version_map,':drop'=>[qw(abstract author provides no_index keywords resources)],':custom'=>\&_keep,},'1.0-from-1.1'=>{'name'=>\&_keep,'meta-spec'=>\&_change_meta_spec,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'recommends'=>\&_version_map,'requires'=>\&_version_map,':custom'=>\&_keep,},);my%cleanup=('2'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_2,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'release_status'=>\&_release_status,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_cleanup_optional_features_2,'provides'=>\&_provides,'resources'=>\&_cleanup_resources_2,'description'=>\&_keep,'prereqs'=>\&_cleanup_prereqs,':drop'=>[qw(build_requires configure_requires conflicts distribution_type license_url private recommends requires) ],':custom'=>\&_prefix_custom,},'1.4'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_1_4,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_4,'configure_requires'=>\&_keep,':custom'=>\&_keep },'1.3'=>{'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'meta-spec'=>\&_change_meta_spec,'name'=>\&_keep,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'keywords'=>\&_keep,'no_index'=>\&_no_index_directory,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'recommends'=>\&_version_map,'requires'=>\&_version_map,'resources'=>\&_resources_1_3,':custom'=>\&_keep },'1.2'=>{'version'=>\&_keep,'license'=>\&_license_1,'name'=>\&_keep,'generated_by'=>\&_generated_by,'abstract'=>\&_keep_or_unknown,'author'=>\&_author_list,'meta-spec'=>\&_change_meta_spec,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'recommends'=>\&_version_map,'requires'=>\&_version_map,'keywords'=>\&_keep,'no_index'=>\&_no_index_1_2,'optional_features'=>\&_optional_features_as_map,'provides'=>\&_provides,'resources'=>\&_resources_1_2,':custom'=>\&_keep },'1.1'=>{'version'=>\&_keep,'name'=>\&_keep,'meta-spec'=>\&_change_meta_spec,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'recommends'=>\&_version_map,'requires'=>\&_version_map,'license_url'=>\&_url_or_drop,'private'=>\&_keep,':custom'=>\&_keep },'1.0'=>{'name'=>\&_keep,'meta-spec'=>\&_change_meta_spec,'version'=>\&_keep,'build_requires'=>\&_version_map,'conflicts'=>\&_version_map,'distribution_type'=>\&_keep,'dynamic_config'=>\&_keep_or_one,'generated_by'=>\&_generated_by,'license'=>\&_license_1,'recommends'=>\&_version_map,'requires'=>\&_version_map,':custom'=>\&_keep,},);my%fragments_generate=('2'=>{'abstract'=>'abstract','author'=>'author','generated_by'=>'generated_by','license'=>'license','name'=>'name','version'=>'version','dynamic_config'=>'dynamic_config','release_status'=>'release_status','keywords'=>'keywords','no_index'=>'no_index','optional_features'=>'optional_features','provides'=>'provides','resources'=>'resources','description'=>'description','prereqs'=>'prereqs',},'1.4'=>{'abstract'=>'abstract','author'=>'author','generated_by'=>'generated_by','license'=>'license','name'=>'name','version'=>'version','build_requires'=>'prereqs','conflicts'=>'prereqs','distribution_type'=>'distribution_type','dynamic_config'=>'dynamic_config','keywords'=>'keywords','no_index'=>'no_index','optional_features'=>'optional_features','provides'=>'provides','recommends'=>'prereqs','requires'=>'prereqs','resources'=>'resources','configure_requires'=>'prereqs',},);$fragments_generate{$_}=$fragments_generate{'1.4'}for qw/1.3 1.2 1.1 1.0/;sub new {my ($class,$data,%args)=@_;my$self={'data'=>$data,'spec'=>_extract_spec_version($data,$args{default_version}),};return bless$self,$class}sub _extract_spec_version {my ($data,$default)=@_;my$spec=$data->{'meta-spec'};return($default || "1.0")unless defined$spec && ref$spec eq 'HASH';my$v=$spec->{version};if (defined$v && $v =~ /^\d+(?:\.\d+)?$/){return$v if defined$v && grep {$v eq $_}keys%known_specs;return$v+0 if defined$v && grep {$v==$_}keys%known_specs}return "2" if exists$data->{prereqs};return "1.4" if exists$data->{configure_requires};return($default || "1.2")}sub convert {my ($self,%args)=@_;my$args={%args };my$new_version=$args->{version}|| $HIGHEST;my$is_fragment=$args->{is_fragment};my ($old_version)=$self->{spec};my$converted=_dclone($self->{data});if ($old_version==$new_version){$converted=_convert($converted,$cleanup{$old_version},$old_version,$is_fragment);unless ($args->{is_fragment}){my$cmv=CPAN::Meta::Validator->new($converted);unless ($cmv->is_valid){my$errs=join("\n",$cmv->errors);die "Failed to clean-up $old_version metadata. Errors:\n$errs\n"}}return$converted}elsif ($old_version > $new_version){my@vers=sort {$b <=> $a}keys%known_specs;for my$i (0 .. $#vers-1){next if$vers[$i]> $old_version;last if$vers[$i+1]< $new_version;my$spec_string="$vers[$i+1]-from-$vers[$i]";$converted=_convert($converted,$down_convert{$spec_string},$vers[$i+1],$is_fragment);unless ($args->{is_fragment}){my$cmv=CPAN::Meta::Validator->new($converted);unless ($cmv->is_valid){my$errs=join("\n",$cmv->errors);die "Failed to downconvert metadata to $vers[$i+1]. Errors:\n$errs\n"}}}return$converted}else {my@vers=sort {$a <=> $b}keys%known_specs;for my$i (0 .. $#vers-1){next if$vers[$i]< $old_version;last if$vers[$i+1]> $new_version;my$spec_string="$vers[$i+1]-from-$vers[$i]";$converted=_convert($converted,$up_convert{$spec_string},$vers[$i+1],$is_fragment);unless ($args->{is_fragment}){my$cmv=CPAN::Meta::Validator->new($converted);unless ($cmv->is_valid){my$errs=join("\n",$cmv->errors);die "Failed to upconvert metadata to $vers[$i+1]. Errors:\n$errs\n"}}}return$converted}}sub upgrade_fragment {my ($self)=@_;my ($old_version)=$self->{spec};my%expected=map {;$_=>1}grep {defined}map {$fragments_generate{$old_version}{$_}}keys %{$self->{data}};my$converted=$self->convert(version=>$HIGHEST,is_fragment=>1);for my$key (keys %$converted){next if$key =~ /^x_/i || $key eq 'meta-spec';delete$converted->{$key}unless$expected{$key}}return$converted}1;
CPAN_META_CONVERTER

$fatpacked{"CPAN/Meta/Feature.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_FEATURE';
  use 5.006;use strict;use warnings;package CPAN::Meta::Feature;our$VERSION='2.150005';use CPAN::Meta::Prereqs;sub new {my ($class,$identifier,$spec)=@_;my%guts=(identifier=>$identifier,description=>$spec->{description},prereqs=>CPAN::Meta::Prereqs->new($spec->{prereqs}),);bless \%guts=>$class}sub identifier {$_[0]{identifier}}sub description {$_[0]{description}}sub prereqs {$_[0]{prereqs}}1;
CPAN_META_FEATURE

$fatpacked{"CPAN/Meta/History.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_HISTORY';
  use 5.006;use strict;use warnings;package CPAN::Meta::History;our$VERSION='2.150005';1;
CPAN_META_HISTORY

$fatpacked{"CPAN/Meta/Merge.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_MERGE';
  use strict;use warnings;package CPAN::Meta::Merge;our$VERSION='2.150005';use Carp qw/croak/;use Scalar::Util qw/blessed/;use CPAN::Meta::Converter 2.141170;sub _is_identical {my ($left,$right)=@_;return (not defined$left and not defined$right)|| (defined$left and defined$right and $left eq $right)}sub _identical {my ($left,$right,$path)=@_;croak sprintf "Can't merge attribute %s: '%s' does not equal '%s'",join('.',@{$path}),$left,$right unless _is_identical($left,$right);return$left}sub _merge {my ($current,$next,$mergers,$path)=@_;for my$key (keys %{$next}){if (not exists$current->{$key}){$current->{$key}=$next->{$key}}elsif (my$merger=$mergers->{$key}){$current->{$key}=$merger->($current->{$key},$next->{$key},[@{$path},$key ])}elsif ($merger=$mergers->{':default'}){$current->{$key}=$merger->($current->{$key},$next->{$key},[@{$path},$key ])}else {croak sprintf "Can't merge unknown attribute '%s'",join '.',@{$path},$key}}return$current}sub _uniq {my%seen=();return grep {not $seen{$_}++}@_}sub _set_addition {my ($left,$right)=@_;return [+_uniq(@{$left},@{$right})]}sub _uniq_map {my ($left,$right,$path)=@_;for my$key (keys %{$right}){if (not exists$left->{$key}){$left->{$key}=$right->{$key}}elsif (_is_identical($left->{$key},$right->{$key})){1}elsif (ref$left->{$key}eq 'HASH' and ref$right->{$key}eq 'HASH'){$left->{$key}=_uniq_map($left->{$key},$right->{$key},[@{$path},$key ])}else {croak 'Duplication of element ' .join '.',@{$path},$key}}return$left}sub _improvize {my ($left,$right,$path)=@_;my ($name)=reverse @{$path};if ($name =~ /^x_/){if (ref($left)eq 'ARRAY'){return _set_addition($left,$right,$path)}elsif (ref($left)eq 'HASH'){return _uniq_map($left,$right,$path)}else {return _identical($left,$right,$path)}}croak sprintf "Can't merge '%s'",join '.',@{$path}}sub _optional_features {my ($left,$right,$path)=@_;for my$key (keys %{$right}){if (not exists$left->{$key}){$left->{$key}=$right->{$key}}else {for my$subkey (keys %{$right->{$key}}){next if$subkey eq 'prereqs';if (not exists$left->{$key}{$subkey}){$left->{$key}{$subkey}=$right->{$key}{$subkey}}else {Carp::croak "Cannot merge two optional_features named '$key' with different '$subkey' values" if do {no warnings 'uninitialized';$left->{$key}{$subkey}ne $right->{$key}{$subkey}}}}require CPAN::Meta::Prereqs;$left->{$key}{prereqs}=CPAN::Meta::Prereqs->new($left->{$key}{prereqs})->with_merged_prereqs(CPAN::Meta::Prereqs->new($right->{$key}{prereqs}))->as_string_hash}}return$left}my%default=(abstract=>\&_identical,author=>\&_set_addition,dynamic_config=>sub {my ($left,$right)=@_;return$left || $right},generated_by=>sub {my ($left,$right)=@_;return join ', ',_uniq(split(/, /,$left),split(/, /,$right))},license=>\&_set_addition,'meta-spec'=>{version=>\&_identical,url=>\&_identical },name=>\&_identical,release_status=>\&_identical,version=>\&_identical,description=>\&_identical,keywords=>\&_set_addition,no_index=>{map {($_=>\&_set_addition)}qw/file directory package namespace/ },optional_features=>\&_optional_features,prereqs=>sub {require CPAN::Meta::Prereqs;my ($left,$right)=map {CPAN::Meta::Prereqs->new($_)}@_[0,1];return$left->with_merged_prereqs($right)->as_string_hash},provides=>\&_uniq_map,resources=>{license=>\&_set_addition,homepage=>\&_identical,bugtracker=>\&_uniq_map,repository=>\&_uniq_map,':default'=>\&_improvize,},':default'=>\&_improvize,);sub new {my ($class,%arguments)=@_;croak 'default version required' if not exists$arguments{default_version};my%mapping=%default;my%extra=%{$arguments{extra_mappings}|| {}};for my$key (keys%extra){if (ref($mapping{$key})eq 'HASH'){$mapping{$key}={%{$mapping{$key}},%{$extra{$key}}}}else {$mapping{$key}=$extra{$key}}}return bless {default_version=>$arguments{default_version},mapping=>_coerce_mapping(\%mapping,[]),},$class}my%coderef_for=(set_addition=>\&_set_addition,uniq_map=>\&_uniq_map,identical=>\&_identical,improvize=>\&_improvize,);sub _coerce_mapping {my ($orig,$map_path)=@_;my%ret;for my$key (keys %{$orig}){my$value=$orig->{$key};if (ref($orig->{$key})eq 'CODE'){$ret{$key}=$value}elsif (ref($value)eq 'HASH'){my$mapping=_coerce_mapping($value,[@{$map_path},$key ]);$ret{$key}=sub {my ($left,$right,$path)=@_;return _merge($left,$right,$mapping,[@{$path}])}}elsif ($coderef_for{$value}){$ret{$key}=$coderef_for{$value}}else {croak "Don't know what to do with " .join '.',@{$map_path},$key}}return \%ret}sub merge {my ($self,@items)=@_;my$current={};for my$next (@items){if (blessed($next)&& $next->isa('CPAN::Meta')){$next=$next->as_struct}elsif (ref($next)eq 'HASH'){my$cmc=CPAN::Meta::Converter->new($next,default_version=>$self->{default_version});$next=$cmc->upgrade_fragment}else {croak "Don't know how to merge '$next'"}$current=_merge($current,$next,$self->{mapping},[])}return$current}1;
CPAN_META_MERGE

$fatpacked{"CPAN/Meta/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_PREREQS';
  use 5.006;use strict;use warnings;package CPAN::Meta::Prereqs;our$VERSION='2.150005';use Carp qw(confess);use Scalar::Util qw(blessed);use CPAN::Meta::Requirements 2.121;sub __legal_phases {qw(configure build test runtime develop)}sub __legal_types {qw(requires recommends suggests conflicts)}sub new {my ($class,$prereq_spec)=@_;$prereq_spec ||= {};my%is_legal_phase=map {;$_=>1}$class->__legal_phases;my%is_legal_type=map {;$_=>1}$class->__legal_types;my%guts;PHASE: for my$phase (keys %$prereq_spec){next PHASE unless$phase =~ /\Ax_/i or $is_legal_phase{$phase};my$phase_spec=$prereq_spec->{$phase };next PHASE unless keys %$phase_spec;TYPE: for my$type (keys %$phase_spec){next TYPE unless$type =~ /\Ax_/i or $is_legal_type{$type};my$spec=$phase_spec->{$type };next TYPE unless keys %$spec;$guts{prereqs}{$phase}{$type}=CPAN::Meta::Requirements->from_string_hash($spec)}}return bless \%guts=>$class}sub requirements_for {my ($self,$phase,$type)=@_;confess "requirements_for called without phase" unless defined$phase;confess "requirements_for called without type" unless defined$type;unless ($phase =~ /\Ax_/i or grep {$phase eq $_}$self->__legal_phases){confess "requested requirements for unknown phase: $phase"}unless ($type =~ /\Ax_/i or grep {$type eq $_}$self->__legal_types){confess "requested requirements for unknown type: $type"}my$req=($self->{prereqs}{$phase}{$type}||= CPAN::Meta::Requirements->new);$req->finalize if$self->is_finalized;return$req}sub with_merged_prereqs {my ($self,$other)=@_;my@other=blessed($other)? $other : @$other;my@prereq_objs=($self,@other);my%new_arg;for my$phase ($self->__legal_phases){for my$type ($self->__legal_types){my$req=CPAN::Meta::Requirements->new;for my$prereq (@prereq_objs){my$this_req=$prereq->requirements_for($phase,$type);next unless$this_req->required_modules;$req->add_requirements($this_req)}next unless$req->required_modules;$new_arg{$phase }{$type }=$req->as_string_hash}}return (ref$self)->new(\%new_arg)}sub merged_requirements {my ($self,$phases,$types)=@_;$phases=[qw/runtime build test/]unless defined$phases;$types=[qw/requires recommends/]unless defined$types;confess "merged_requirements phases argument must be an arrayref" unless ref$phases eq 'ARRAY';confess "merged_requirements types argument must be an arrayref" unless ref$types eq 'ARRAY';my$req=CPAN::Meta::Requirements->new;for my$phase (@$phases){unless ($phase =~ /\Ax_/i or grep {$phase eq $_}$self->__legal_phases){confess "requested requirements for unknown phase: $phase"}for my$type (@$types){unless ($type =~ /\Ax_/i or grep {$type eq $_}$self->__legal_types){confess "requested requirements for unknown type: $type"}$req->add_requirements($self->requirements_for($phase,$type))}}$req->finalize if$self->is_finalized;return$req}sub as_string_hash {my ($self)=@_;my%hash;for my$phase ($self->__legal_phases){for my$type ($self->__legal_types){my$req=$self->requirements_for($phase,$type);next unless$req->required_modules;$hash{$phase }{$type }=$req->as_string_hash}}return \%hash}sub is_finalized {$_[0]{finalized}}sub finalize {my ($self)=@_;$self->{finalized}=1;for my$phase (keys %{$self->{prereqs}}){$_->finalize for values %{$self->{prereqs}{$phase}}}}sub clone {my ($self)=@_;my$clone=(ref$self)->new($self->as_string_hash)}1;
CPAN_META_PREREQS

$fatpacked{"CPAN/Meta/Requirements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_REQUIREMENTS';
  use strict;use warnings;package CPAN::Meta::Requirements;our$VERSION='2.133';use Carp ();BEGIN {eval "use version ()";if (my$err=$@){eval "use ExtUtils::MakeMaker::version" or die$err}}*_is_qv=version->can('is_qv')? sub {$_[0]->is_qv}: sub {exists $_[0]->{qv}};my$V0=version->new(0);my@valid_options=qw(bad_version_hook);sub new {my ($class,$options)=@_;$options ||= {};Carp::croak "Argument to $class\->new() must be a hash reference" unless ref$options eq 'HASH';my%self=map {;$_=>$options->{$_}}@valid_options;return bless \%self=>$class}sub _find_magic_vstring {my$value=shift;my$tvalue='';require B;my$sv=B::svref_2object(\$value);my$magic=ref($sv)eq 'B::PVMG' ? $sv->MAGIC : undef;while ($magic){if ($magic->TYPE eq 'V'){$tvalue=$magic->PTR;$tvalue =~ s/^v?(.+)$/v$1/;last}else {$magic=$magic->MOREMAGIC}}return$tvalue}sub _isa_version {UNIVERSAL::isa($_[0],'UNIVERSAL')&& $_[0]->isa('version')}sub _version_object {my ($self,$module,$version)=@_;my ($vobj,$err);if (not defined$version or (!ref($version)&& $version eq '0')){return$V0}elsif (ref($version)eq 'version' || _isa_version($version)){$vobj=$version}else {if ($INC{'version/vpp.pm'}|| $INC{'ExtUtils/MakeMaker/version/vpp.pm'}){my$magic=_find_magic_vstring($version);$version=$magic if length$magic}eval {local$SIG{__WARN__}=sub {die "Invalid version: $_[0]"};$vobj=version->new($version)};if (my$err=$@){my$hook=$self->{bad_version_hook};$vobj=eval {$hook->($version,$module)}if ref$hook eq 'CODE';unless (eval {$vobj->isa("version")}){$err =~ s{ at .* line \d+.*$}{};die "Can't convert '$version': $err"}}}if ($vobj =~ m{\A\.}){$vobj=version->new("0$vobj")}if (_is_qv($vobj)){$vobj=version->new($vobj->normal)}return$vobj}BEGIN {for my$type (qw(maximum exclusion exact_version)){my$method="with_$type";my$to_add=$type eq 'exact_version' ? $type : "add_$type";my$code=sub {my ($self,$name,$version)=@_;$version=$self->_version_object($name,$version);$self->__modify_entry_for($name,$method,$version);return$self};no strict 'refs';*$to_add=$code}}sub add_minimum {my ($self,$name,$version)=@_;if (not defined$version or "$version" eq '0'){return$self if$self->__entry_for($name);Carp::confess("can't add new requirements to finalized requirements")if$self->is_finalized;$self->{requirements}{$name }=CPAN::Meta::Requirements::_Range::Range->with_minimum($V0)}else {$version=$self->_version_object($name,$version);$self->__modify_entry_for($name,'with_minimum',$version)}return$self}sub add_requirements {my ($self,$req)=@_;for my$module ($req->required_modules){my$modifiers=$req->__entry_for($module)->as_modifiers;for my$modifier (@$modifiers){my ($method,@args)=@$modifier;$self->$method($module=>@args)}}return$self}sub accepts_module {my ($self,$module,$version)=@_;$version=$self->_version_object($module,$version);return 1 unless my$range=$self->__entry_for($module);return$range->_accepts($version)}sub clear_requirement {my ($self,$module)=@_;return$self unless$self->__entry_for($module);Carp::confess("can't clear requirements on finalized requirements")if$self->is_finalized;delete$self->{requirements}{$module };return$self}sub requirements_for_module {my ($self,$module)=@_;my$entry=$self->__entry_for($module);return unless$entry;return$entry->as_string}sub required_modules {keys %{$_[0]{requirements}}}sub clone {my ($self)=@_;my$new=(ref$self)->new;return$new->add_requirements($self)}sub __entry_for {$_[0]{requirements}{$_[1]}}sub __modify_entry_for {my ($self,$name,$method,$version)=@_;my$fin=$self->is_finalized;my$old=$self->__entry_for($name);Carp::confess("can't add new requirements to finalized requirements")if$fin and not $old;my$new=($old || 'CPAN::Meta::Requirements::_Range::Range')->$method($version);Carp::confess("can't modify finalized requirements")if$fin and $old->as_string ne $new->as_string;$self->{requirements}{$name }=$new}sub is_simple {my ($self)=@_;for my$module ($self->required_modules){return if$self->__entry_for($module)->as_string =~ /\s/}return 1}sub is_finalized {$_[0]{finalized}}sub finalize {$_[0]{finalized}=1}sub as_string_hash {my ($self)=@_;my%hash=map {;$_=>$self->{requirements}{$_}->as_string}$self->required_modules;return \%hash}my%methods_for_op=('=='=>[qw(exact_version) ],'!='=>[qw(add_exclusion) ],'>='=>[qw(add_minimum) ],'<='=>[qw(add_maximum) ],'>'=>[qw(add_minimum add_exclusion) ],'<'=>[qw(add_maximum add_exclusion) ],);sub add_string_requirement {my ($self,$module,$req)=@_;unless (defined$req && length$req){$req=0;$self->_blank_carp($module)}my$magic=_find_magic_vstring($req);if (length$magic){$self->add_minimum($module=>$magic);return}my@parts=split qr{\s*,\s*},$req;for my$part (@parts){my ($op,$ver)=$part =~ m{\A\s*(==|>=|>|<=|<|!=)\s*(.*)\z};if (!defined$op){$self->add_minimum($module=>$part)}else {Carp::confess("illegal requirement string: $req")unless my$methods=$methods_for_op{$op };$self->$_($module=>$ver)for @$methods}}}sub _blank_carp {my ($self,$module)=@_;Carp::carp("Undefined requirement for $module treated as '0'")}sub from_string_hash {my ($class,$hash,$options)=@_;my$self=$class->new($options);for my$module (keys %$hash){my$req=$hash->{$module};unless (defined$req && length$req){$req=0;$class->_blank_carp($module)}$self->add_string_requirement($module,$req)}return$self}{package CPAN::Meta::Requirements::_Range::Exact;sub _new {bless {version=>$_[1]}=>$_[0]}sub _accepts {return $_[0]{version}==$_[1]}sub as_string {return "== $_[0]{version}"}sub as_modifiers {return [[exact_version=>$_[0]{version}]]}sub _clone {(ref $_[0])->_new(version->new($_[0]{version}))}sub with_exact_version {my ($self,$version)=@_;return$self->_clone if$self->_accepts($version);Carp::confess("illegal requirements: unequal exact version specified")}sub with_minimum {my ($self,$minimum)=@_;return$self->_clone if$self->{version}>= $minimum;Carp::confess("illegal requirements: minimum above exact specification")}sub with_maximum {my ($self,$maximum)=@_;return$self->_clone if$self->{version}<= $maximum;Carp::confess("illegal requirements: maximum below exact specification")}sub with_exclusion {my ($self,$exclusion)=@_;return$self->_clone unless$exclusion==$self->{version};Carp::confess("illegal requirements: excluded exact specification")}}{package CPAN::Meta::Requirements::_Range::Range;sub _self {ref($_[0])? $_[0]: (bless {}=>$_[0])}sub _clone {return (bless {}=>$_[0])unless ref $_[0];my ($s)=@_;my%guts=((exists$s->{minimum}? (minimum=>version->new($s->{minimum})): ()),(exists$s->{maximum}? (maximum=>version->new($s->{maximum})): ()),(exists$s->{exclusions}? (exclusions=>[map {version->new($_)}@{$s->{exclusions}}]): ()),);bless \%guts=>ref($s)}sub as_modifiers {my ($self)=@_;my@mods;push@mods,[add_minimum=>$self->{minimum}]if exists$self->{minimum};push@mods,[add_maximum=>$self->{maximum}]if exists$self->{maximum};push@mods,map {;[add_exclusion=>$_ ]}@{$self->{exclusions}|| []};return \@mods}sub as_string {my ($self)=@_;return 0 if!keys %$self;return "$self->{minimum}" if (keys %$self)==1 and exists$self->{minimum};my@exclusions=@{$self->{exclusions}|| []};my@parts;for my$pair ([qw(>= > minimum) ],[qw(<= < maximum) ],){my ($op,$e_op,$k)=@$pair;if (exists$self->{$k}){my@new_exclusions=grep {$_!=$self->{$k }}@exclusions;if (@new_exclusions==@exclusions){push@parts,"$op $self->{ $k }"}else {push@parts,"$e_op $self->{ $k }";@exclusions=@new_exclusions}}}push@parts,map {;"!= $_"}@exclusions;return join q{, },@parts}sub with_exact_version {my ($self,$version)=@_;$self=$self->_clone;Carp::confess("illegal requirements: exact specification outside of range")unless$self->_accepts($version);return CPAN::Meta::Requirements::_Range::Exact->_new($version)}sub _simplify {my ($self)=@_;if (defined$self->{minimum}and defined$self->{maximum}){if ($self->{minimum}==$self->{maximum}){Carp::confess("illegal requirements: excluded all values")if grep {$_==$self->{minimum}}@{$self->{exclusions}|| []};return CPAN::Meta::Requirements::_Range::Exact->_new($self->{minimum})}Carp::confess("illegal requirements: minimum exceeds maximum")if$self->{minimum}> $self->{maximum}}if ($self->{exclusions}){my%seen;@{$self->{exclusions}}=grep {(!defined$self->{minimum}or $_ >= $self->{minimum})and (!defined$self->{maximum}or $_ <= $self->{maximum})and !$seen{$_}++}@{$self->{exclusions}}}return$self}sub with_minimum {my ($self,$minimum)=@_;$self=$self->_clone;if (defined (my$old_min=$self->{minimum})){$self->{minimum}=(sort {$b cmp $a}($minimum,$old_min))[0]}else {$self->{minimum}=$minimum}return$self->_simplify}sub with_maximum {my ($self,$maximum)=@_;$self=$self->_clone;if (defined (my$old_max=$self->{maximum})){$self->{maximum}=(sort {$a cmp $b}($maximum,$old_max))[0]}else {$self->{maximum}=$maximum}return$self->_simplify}sub with_exclusion {my ($self,$exclusion)=@_;$self=$self->_clone;push @{$self->{exclusions}||= []},$exclusion;return$self->_simplify}sub _accepts {my ($self,$version)=@_;return if defined$self->{minimum}and $version < $self->{minimum};return if defined$self->{maximum}and $version > $self->{maximum};return if defined$self->{exclusions}and grep {$version==$_}@{$self->{exclusions}};return 1}}1;
CPAN_META_REQUIREMENTS

$fatpacked{"CPAN/Meta/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_SPEC';
  use 5.006;use strict;use warnings;package CPAN::Meta::Spec;our$VERSION='2.150005';1;
CPAN_META_SPEC

$fatpacked{"CPAN/Meta/Validator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_VALIDATOR';
  use 5.006;use strict;use warnings;package CPAN::Meta::Validator;our$VERSION='2.150005';my%known_specs=('1.4'=>'http://module-build.sourceforge.net/META-spec-v1.4.html','1.3'=>'http://module-build.sourceforge.net/META-spec-v1.3.html','1.2'=>'http://module-build.sourceforge.net/META-spec-v1.2.html','1.1'=>'http://module-build.sourceforge.net/META-spec-v1.1.html','1.0'=>'http://module-build.sourceforge.net/META-spec-v1.0.html');my%known_urls=map {$known_specs{$_}=>$_}keys%known_specs;my$module_map1={'map'=>{':key'=>{name=>\&module,value=>\&exversion }}};my$module_map2={'map'=>{':key'=>{name=>\&module,value=>\&version }}};my$no_index_2={'map'=>{file=>{list=>{value=>\&string }},directory=>{list=>{value=>\&string }},'package'=>{list=>{value=>\&string }},namespace=>{list=>{value=>\&string }},':key'=>{name=>\&custom_2,value=>\&anything },}};my$no_index_1_3={'map'=>{file=>{list=>{value=>\&string }},directory=>{list=>{value=>\&string }},'package'=>{list=>{value=>\&string }},namespace=>{list=>{value=>\&string }},':key'=>{name=>\&string,value=>\&anything },}};my$no_index_1_2={'map'=>{file=>{list=>{value=>\&string }},dir=>{list=>{value=>\&string }},'package'=>{list=>{value=>\&string }},namespace=>{list=>{value=>\&string }},':key'=>{name=>\&string,value=>\&anything },}};my$no_index_1_1={'map'=>{':key'=>{name=>\&string,list=>{value=>\&string }},}};my$prereq_map={map=>{':key'=>{name=>\&phase,'map'=>{':key'=>{name=>\&relation,%$module_map1,},},}},};my%definitions=('2'=>{'abstract'=>{mandatory=>1,value=>\&string },'author'=>{mandatory=>1,list=>{value=>\&string }},'dynamic_config'=>{mandatory=>1,value=>\&boolean },'generated_by'=>{mandatory=>1,value=>\&string },'license'=>{mandatory=>1,list=>{value=>\&license }},'meta-spec'=>{mandatory=>1,'map'=>{version=>{mandatory=>1,value=>\&version},url=>{value=>\&url },':key'=>{name=>\&custom_2,value=>\&anything },}},'name'=>{mandatory=>1,value=>\&string },'release_status'=>{mandatory=>1,value=>\&release_status },'version'=>{mandatory=>1,value=>\&version },'description'=>{value=>\&string },'keywords'=>{list=>{value=>\&string }},'no_index'=>$no_index_2,'optional_features'=>{'map'=>{':key'=>{name=>\&string,'map'=>{description=>{value=>\&string },prereqs=>$prereq_map,':key'=>{name=>\&custom_2,value=>\&anything },}}}},'prereqs'=>$prereq_map,'provides'=>{'map'=>{':key'=>{name=>\&module,'map'=>{file=>{mandatory=>1,value=>\&file },version=>{value=>\&version },':key'=>{name=>\&custom_2,value=>\&anything },}}}},'resources'=>{'map'=>{license=>{list=>{value=>\&url }},homepage=>{value=>\&url },bugtracker=>{'map'=>{web=>{value=>\&url },mailto=>{value=>\&string},':key'=>{name=>\&custom_2,value=>\&anything },}},repository=>{'map'=>{web=>{value=>\&url },url=>{value=>\&url },type=>{value=>\&string },':key'=>{name=>\&custom_2,value=>\&anything },}},':key'=>{value=>\&string,name=>\&custom_2 },}},':key'=>{name=>\&custom_2,value=>\&anything },},'1.4'=>{'meta-spec'=>{mandatory=>1,'map'=>{version=>{mandatory=>1,value=>\&version},url=>{mandatory=>1,value=>\&urlspec },':key'=>{name=>\&string,value=>\&anything },},},'name'=>{mandatory=>1,value=>\&string },'version'=>{mandatory=>1,value=>\&version },'abstract'=>{mandatory=>1,value=>\&string },'author'=>{mandatory=>1,list=>{value=>\&string }},'license'=>{mandatory=>1,value=>\&license },'generated_by'=>{mandatory=>1,value=>\&string },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'configure_requires'=>$module_map1,'conflicts'=>$module_map2,'optional_features'=>{'map'=>{':key'=>{name=>\&string,'map'=>{description=>{value=>\&string },requires=>$module_map1,recommends=>$module_map1,build_requires=>$module_map1,conflicts=>$module_map2,':key'=>{name=>\&string,value=>\&anything },}}}},'provides'=>{'map'=>{':key'=>{name=>\&module,'map'=>{file=>{mandatory=>1,value=>\&file },version=>{value=>\&version },':key'=>{name=>\&string,value=>\&anything },}}}},'no_index'=>$no_index_1_3,'private'=>$no_index_1_3,'keywords'=>{list=>{value=>\&string }},'resources'=>{'map'=>{license=>{value=>\&url },homepage=>{value=>\&url },bugtracker=>{value=>\&url },repository=>{value=>\&url },':key'=>{value=>\&string,name=>\&custom_1 },}},':key'=>{name=>\&string,value=>\&anything },},'1.3'=>{'meta-spec'=>{mandatory=>1,'map'=>{version=>{mandatory=>1,value=>\&version},url=>{mandatory=>1,value=>\&urlspec },':key'=>{name=>\&string,value=>\&anything },},},'name'=>{mandatory=>1,value=>\&string },'version'=>{mandatory=>1,value=>\&version },'abstract'=>{mandatory=>1,value=>\&string },'author'=>{mandatory=>1,list=>{value=>\&string }},'license'=>{mandatory=>1,value=>\&license },'generated_by'=>{mandatory=>1,value=>\&string },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'conflicts'=>$module_map2,'optional_features'=>{'map'=>{':key'=>{name=>\&string,'map'=>{description=>{value=>\&string },requires=>$module_map1,recommends=>$module_map1,build_requires=>$module_map1,conflicts=>$module_map2,':key'=>{name=>\&string,value=>\&anything },}}}},'provides'=>{'map'=>{':key'=>{name=>\&module,'map'=>{file=>{mandatory=>1,value=>\&file },version=>{value=>\&version },':key'=>{name=>\&string,value=>\&anything },}}}},'no_index'=>$no_index_1_3,'private'=>$no_index_1_3,'keywords'=>{list=>{value=>\&string }},'resources'=>{'map'=>{license=>{value=>\&url },homepage=>{value=>\&url },bugtracker=>{value=>\&url },repository=>{value=>\&url },':key'=>{value=>\&string,name=>\&custom_1 },}},':key'=>{name=>\&string,value=>\&anything },},'1.2'=>{'meta-spec'=>{mandatory=>1,'map'=>{version=>{mandatory=>1,value=>\&version},url=>{mandatory=>1,value=>\&urlspec },':key'=>{name=>\&string,value=>\&anything },},},'name'=>{mandatory=>1,value=>\&string },'version'=>{mandatory=>1,value=>\&version },'license'=>{mandatory=>1,value=>\&license },'generated_by'=>{mandatory=>1,value=>\&string },'author'=>{mandatory=>1,list=>{value=>\&string }},'abstract'=>{mandatory=>1,value=>\&string },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'keywords'=>{list=>{value=>\&string }},'private'=>$no_index_1_2,'$no_index'=>$no_index_1_2,'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'conflicts'=>$module_map2,'optional_features'=>{'map'=>{':key'=>{name=>\&string,'map'=>{description=>{value=>\&string },requires=>$module_map1,recommends=>$module_map1,build_requires=>$module_map1,conflicts=>$module_map2,':key'=>{name=>\&string,value=>\&anything },}}}},'provides'=>{'map'=>{':key'=>{name=>\&module,'map'=>{file=>{mandatory=>1,value=>\&file },version=>{value=>\&version },':key'=>{name=>\&string,value=>\&anything },}}}},'resources'=>{'map'=>{license=>{value=>\&url },homepage=>{value=>\&url },bugtracker=>{value=>\&url },repository=>{value=>\&url },':key'=>{value=>\&string,name=>\&custom_1 },}},':key'=>{name=>\&string,value=>\&anything },},'1.1'=>{'name'=>{value=>\&string },'version'=>{mandatory=>1,value=>\&version },'license'=>{value=>\&license },'generated_by'=>{value=>\&string },'license_uri'=>{value=>\&url },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'private'=>$no_index_1_1,'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'conflicts'=>$module_map2,':key'=>{name=>\&string,value=>\&anything },},'1.0'=>{'name'=>{value=>\&string },'version'=>{mandatory=>1,value=>\&version },'license'=>{value=>\&license },'generated_by'=>{value=>\&string },'license_uri'=>{value=>\&url },'distribution_type'=>{value=>\&string },'dynamic_config'=>{value=>\&boolean },'requires'=>$module_map1,'recommends'=>$module_map1,'build_requires'=>$module_map1,'conflicts'=>$module_map2,':key'=>{name=>\&string,value=>\&anything },},);sub new {my ($class,$data)=@_;my$self={'data'=>$data,'spec'=>eval {$data->{'meta-spec'}{'version'}}|| "1.0",'errors'=>undef,};return bless$self,$class}sub is_valid {my$self=shift;my$data=$self->{data};my$spec_version=$self->{spec};$self->check_map($definitions{$spec_version},$data);return!$self->errors}sub errors {my$self=shift;return ()unless(defined$self->{errors});return @{$self->{errors}}}my$spec_error="Missing validation action in specification. " ."Must be one of 'map', 'list', or 'value'";sub check_map {my ($self,$spec,$data)=@_;if(ref($spec)ne 'HASH'){$self->_error("Unknown META specification, cannot validate.");return}if(ref($data)ne 'HASH'){$self->_error("Expected a map structure from string or file.");return}for my$key (keys %$spec){next unless($spec->{$key}->{mandatory});next if(defined$data->{$key});push @{$self->{stack}},$key;$self->_error("Missing mandatory field, '$key'");pop @{$self->{stack}}}for my$key (keys %$data){push @{$self->{stack}},$key;if($spec->{$key}){if($spec->{$key}{value}){$spec->{$key}{value}->($self,$key,$data->{$key})}elsif($spec->{$key}{'map'}){$self->check_map($spec->{$key}{'map'},$data->{$key})}elsif($spec->{$key}{'list'}){$self->check_list($spec->{$key}{'list'},$data->{$key})}else {$self->_error("$spec_error for '$key'")}}elsif ($spec->{':key'}){$spec->{':key'}{name}->($self,$key,$key);if($spec->{':key'}{value}){$spec->{':key'}{value}->($self,$key,$data->{$key})}elsif($spec->{':key'}{'map'}){$self->check_map($spec->{':key'}{'map'},$data->{$key})}elsif($spec->{':key'}{'list'}){$self->check_list($spec->{':key'}{'list'},$data->{$key})}else {$self->_error("$spec_error for ':key'")}}else {$self->_error("Unknown key, '$key', found in map structure")}pop @{$self->{stack}}}}sub check_list {my ($self,$spec,$data)=@_;if(ref($data)ne 'ARRAY'){$self->_error("Expected a list structure");return}if(defined$spec->{mandatory}){if(!defined$data->[0]){$self->_error("Missing entries from mandatory list")}}for my$value (@$data){push @{$self->{stack}},$value || "<undef>";if(defined$spec->{value}){$spec->{value}->($self,'list',$value)}elsif(defined$spec->{'map'}){$self->check_map($spec->{'map'},$value)}elsif(defined$spec->{'list'}){$self->check_list($spec->{'list'},$value)}elsif ($spec->{':key'}){$self->check_map($spec,$value)}else {$self->_error("$spec_error associated with '$self->{stack}[-2]'")}pop @{$self->{stack}}}}sub header {my ($self,$key,$value)=@_;if(defined$value){return 1 if($value && $value =~ /^--- #YAML:1.0/)}$self->_error("file does not have a valid YAML header.");return 0}sub release_status {my ($self,$key,$value)=@_;if(defined$value){my$version=$self->{data}{version}|| '';if ($version =~ /_/){return 1 if ($value =~ /\A(?:testing|unstable)\z/);$self->_error("'$value' for '$key' is invalid for version '$version'")}else {return 1 if ($value =~ /\A(?:stable|testing|unstable)\z/);$self->_error("'$value' for '$key' is invalid")}}else {$self->_error("'$key' is not defined")}return 0}sub _uri_split {return $_[0]=~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,}sub url {my ($self,$key,$value)=@_;if(defined$value){my ($scheme,$auth,$path,$query,$frag)=_uri_split($value);unless (defined$scheme && length$scheme){$self->_error("'$value' for '$key' does not have a URL scheme");return 0}unless (defined$auth && length$auth){$self->_error("'$value' for '$key' does not have a URL authority");return 0}return 1}$value ||= '';$self->_error("'$value' for '$key' is not a valid URL.");return 0}sub urlspec {my ($self,$key,$value)=@_;if(defined$value){return 1 if($value && $known_specs{$self->{spec}}eq $value);if($value && $known_urls{$value}){$self->_error('META specification URL does not match version');return 0}}$self->_error('Unknown META specification');return 0}sub anything {return 1}sub string {my ($self,$key,$value)=@_;if(defined$value){return 1 if($value || $value =~ /^0$/)}$self->_error("value is an undefined string");return 0}sub string_or_undef {my ($self,$key,$value)=@_;return 1 unless(defined$value);return 1 if($value || $value =~ /^0$/);$self->_error("No string defined for '$key'");return 0}sub file {my ($self,$key,$value)=@_;return 1 if(defined$value);$self->_error("No file defined for '$key'");return 0}sub exversion {my ($self,$key,$value)=@_;if(defined$value && ($value || $value =~ /0/)){my$pass=1;for(split(",",$value)){$self->version($key,$_)or ($pass=0)}return$pass}$value='<undef>' unless(defined$value);$self->_error("'$value' for '$key' is not a valid version.");return 0}sub version {my ($self,$key,$value)=@_;if(defined$value){return 0 unless($value || $value =~ /0/);return 1 if($value =~ /^\s*((<|<=|>=|>|!=|==)\s*)?v?\d+((\.\d+((_|\.)\d+)?)?)/)}else {$value='<undef>'}$self->_error("'$value' for '$key' is not a valid version.");return 0}sub boolean {my ($self,$key,$value)=@_;if(defined$value){return 1 if($value =~ /^(0|1|true|false)$/)}else {$value='<undef>'}$self->_error("'$value' for '$key' is not a boolean value.");return 0}my%v1_licenses=('perl'=>'http://dev.perl.org/licenses/','gpl'=>'http://www.opensource.org/licenses/gpl-license.php','apache'=>'http://apache.org/licenses/LICENSE-2.0','artistic'=>'http://opensource.org/licenses/artistic-license.php','artistic_2'=>'http://opensource.org/licenses/artistic-license-2.0.php','lgpl'=>'http://www.opensource.org/licenses/lgpl-license.php','bsd'=>'http://www.opensource.org/licenses/bsd-license.php','gpl'=>'http://www.opensource.org/licenses/gpl-license.php','mit'=>'http://opensource.org/licenses/mit-license.php','mozilla'=>'http://opensource.org/licenses/mozilla1.1.php','open_source'=>undef,'unrestricted'=>undef,'restrictive'=>undef,'unknown'=>undef,);my%v2_licenses=map {$_=>1}qw(agpl_3 apache_1_1 apache_2_0 artistic_1 artistic_2 bsd freebsd gfdl_1_2 gfdl_1_3 gpl_1 gpl_2 gpl_3 lgpl_2_1 lgpl_3_0 mit mozilla_1_0 mozilla_1_1 openssl perl_5 qpl_1_0 ssleay sun zlib open_source restricted unrestricted unknown);sub license {my ($self,$key,$value)=@_;my$licenses=$self->{spec}< 2 ? \%v1_licenses : \%v2_licenses;if(defined$value){return 1 if($value && exists$licenses->{$value})}else {$value='<undef>'}$self->_error("License '$value' is invalid");return 0}sub custom_1 {my ($self,$key)=@_;if(defined$key){return 1 if($key && $key =~ /^[_a-z]+$/i && $key =~ /[A-Z]/)}else {$key='<undef>'}$self->_error("Custom resource '$key' must be in CamelCase.");return 0}sub custom_2 {my ($self,$key)=@_;if(defined$key){return 1 if($key && $key =~ /^x_/i)}else {$key='<undef>'}$self->_error("Custom key '$key' must begin with 'x_' or 'X_'.");return 0}sub identifier {my ($self,$key)=@_;if(defined$key){return 1 if($key && $key =~ /^([a-z][_a-z]+)$/i)}else {$key='<undef>'}$self->_error("Key '$key' is not a legal identifier.");return 0}sub module {my ($self,$key)=@_;if(defined$key){return 1 if($key && $key =~ /^[A-Za-z0-9_]+(::[A-Za-z0-9_]+)*$/)}else {$key='<undef>'}$self->_error("Key '$key' is not a legal module name.");return 0}my@valid_phases=qw/configure build test runtime develop/;sub phase {my ($self,$key)=@_;if(defined$key){return 1 if(length$key && grep {$key eq $_}@valid_phases);return 1 if$key =~ /x_/i}else {$key='<undef>'}$self->_error("Key '$key' is not a legal phase.");return 0}my@valid_relations=qw/requires recommends suggests conflicts/;sub relation {my ($self,$key)=@_;if(defined$key){return 1 if(length$key && grep {$key eq $_}@valid_relations);return 1 if$key =~ /x_/i}else {$key='<undef>'}$self->_error("Key '$key' is not a legal prereq relationship.");return 0}sub _error {my$self=shift;my$mess=shift;$mess .= ' ('.join(' -> ',@{$self->{stack}}).')' if($self->{stack});$mess .= " [Validation: $self->{spec}]";push @{$self->{errors}},$mess}1;
CPAN_META_VALIDATOR

$fatpacked{"CPAN/Meta/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_YAML';
  use 5.008001;use strict;use warnings;package CPAN::Meta::YAML;$CPAN::Meta::YAML::VERSION='0.016';;use Exporter;our@ISA=qw{Exporter};our@EXPORT=qw{Load Dump};our@EXPORT_OK=qw{LoadFile DumpFile freeze thaw};sub Dump {return CPAN::Meta::YAML->new(@_)->_dump_string}sub Load {my$self=CPAN::Meta::YAML->_load_string(@_);if (wantarray){return @$self}else {return$self->[-1]}}BEGIN {*freeze=\&Dump;*thaw=\&Load}sub DumpFile {my$file=shift;return CPAN::Meta::YAML->new(@_)->_dump_file($file)}sub LoadFile {my$file=shift;my$self=CPAN::Meta::YAML->_load_file($file);if (wantarray){return @$self}else {return$self->[-1]}}sub new {my$class=shift;bless [@_ ],$class}sub read_string {my$self=shift;$self->_load_string(@_)}sub write_string {my$self=shift;$self->_dump_string(@_)}sub read {my$self=shift;$self->_load_file(@_)}sub write {my$self=shift;$self->_dump_file(@_)}my@UNPRINTABLE=qw(0 x01 x02 x03 x04 x05 x06 a b t n v f r x0E x0F x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x1A e x1C x1D x1E x1F);my%UNESCAPES=(0=>"\x00",z=>"\x00",N=>"\x85",a=>"\x07",b=>"\x08",t=>"\x09",n=>"\x0a",v=>"\x0b",f=>"\x0c",r=>"\x0d",e=>"\x1b",'\\'=>'\\',);my%QUOTE=map {$_=>1}qw{null true false};my$re_capture_double_quoted=qr/\"([^\\"]*(?:\\.[^\\"]*)*)\"/;my$re_capture_single_quoted=qr/\'([^\']*(?:\'\'[^\']*)*)\'/;my$re_capture_unquoted_key=qr/([^:]+(?::+\S(?:[^:]*|.*?(?=:)))*)(?=\s*\:(?:\s+|$))/;my$re_trailing_comment=qr/(?:\s+\#.*)?/;my$re_key_value_separator=qr/\s*:(?:\s+(?:\#.*)?|$)/;sub _load_file {my$class=ref $_[0]? ref shift : shift;my$file=shift or $class->_error('You did not specify a file name');$class->_error("File '$file' does not exist")unless -e $file;$class->_error("'$file' is a directory, not a file")unless -f _;$class->_error("Insufficient permissions to read '$file'")unless -r _;open(my$fh,"<:unix:encoding(UTF-8)",$file);unless ($fh){$class->_error("Failed to open file '$file': $!")}if (_can_flock()){flock($fh,Fcntl::LOCK_SH())or warn "Couldn't lock '$file' for reading: $!"}my$contents=eval {use warnings FATAL=>'utf8';local $/;<$fh>};if (my$err=$@){$class->_error("Error reading from file '$file': $err")}unless (close$fh){$class->_error("Failed to close file '$file': $!")}$class->_load_string($contents)}sub _load_string {my$class=ref $_[0]? ref shift : shift;my$self=bless [],$class;my$string=$_[0];eval {unless (defined$string){die \"Did not provide a string to load"}if (utf8::is_utf8($string)&&!utf8::valid($string)){die \<<'...'}utf8::upgrade($string);$string =~ s/^\x{FEFF}//;return$self unless length$string;my@lines=grep {!/^\s*(?:\#.*)?\z/}split /(?:\015{1,2}\012|\015|\012)/,$string;@lines and $lines[0]=~ /^\%YAML[: ][\d\.]+.*\z/ and shift@lines;my$in_document=0;while (@lines){if ($lines[0]=~ /^---\s*(?:(.+)\s*)?\z/){shift@lines;if (defined $1 and $1 !~ /^(?:\#.+|\%YAML[: ][\d\.]+)\z/){push @$self,$self->_load_scalar("$1",[undef ],\@lines);next}$in_document=1}if (!@lines or $lines[0]=~ /^(?:---|\.\.\.)/){push @$self,undef;while (@lines and $lines[0]!~ /^---/){shift@lines}$in_document=0}elsif (!$in_document && @$self){die \"CPAN::Meta::YAML failed to classify the line '$lines[0]'"}elsif ($lines[0]=~ /^\s*\-(?:\s|$|-+$)/){my$document=[];push @$self,$document;$self->_load_array($document,[0 ],\@lines)}elsif ($lines[0]=~ /^(\s*)\S/){my$document={};push @$self,$document;$self->_load_hash($document,[length($1)],\@lines)}else {die \"CPAN::Meta::YAML failed to classify the line '$lines[0]'"}}};my$err=$@;if (ref$err eq 'SCALAR'){$self->_error(${$err})}elsif ($err){$self->_error($err)}return$self}sub _unquote_single {my ($self,$string)=@_;return '' unless length$string;$string =~ s/\'\'/\'/g;return$string}sub _unquote_double {my ($self,$string)=@_;return '' unless length$string;$string =~ s/\\"/"/g;$string =~ s{\\([Nnever\\fartz0b]|x([0-9a-fA-F]{2}))}
  Read an invalid UTF-8 string (maybe mixed UTF-8 and 8-bit character set).
  Did you decode with lax ":utf8" instead of strict ":encoding(UTF-8)"?
  ...
           {(length($1)>1)?pack("H2",$2):$UNESCAPES{$1}}gex;return$string}sub _load_scalar {my ($self,$string,$indent,$lines)=@_;$string =~ s/\s*\z//;return undef if$string eq '~';if ($string =~ /^$re_capture_single_quoted$re_trailing_comment\z/){return$self->_unquote_single($1)}if ($string =~ /^$re_capture_double_quoted$re_trailing_comment\z/){return$self->_unquote_double($1)}if ($string =~ /^[\'\"!&]/){die \"CPAN::Meta::YAML does not support a feature in line '$string'"}return {}if$string =~ /^{}(?:\s+\#.*)?\z/;return []if$string =~ /^\[\](?:\s+\#.*)?\z/;if ($string !~ /^[>|]/){die \"CPAN::Meta::YAML found illegal characters in plain scalar: '$string'" if$string =~ /^(?:-(?:\s|$)|[\@\%\`])/ or $string =~ /:(?:\s|$)/;$string =~ s/\s+#.*\z//;return$string}die \"CPAN::Meta::YAML failed to find multi-line scalar content" unless @$lines;$lines->[0]=~ /^(\s*)/;$indent->[-1]=length("$1");if (defined$indent->[-2]and $indent->[-1]<= $indent->[-2]){die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'"}my@multiline=();while (@$lines){$lines->[0]=~ /^(\s*)/;last unless length($1)>= $indent->[-1];push@multiline,substr(shift(@$lines),length($1))}my$j=(substr($string,0,1)eq '>')? ' ' : "\n";my$t=(substr($string,1,1)eq '-')? '' : "\n";return join($j,@multiline).$t}sub _load_array {my ($self,$array,$indent,$lines)=@_;while (@$lines){if ($lines->[0]=~ /^(?:---|\.\.\.)/){while (@$lines and $lines->[0]!~ /^---/){shift @$lines}return 1}$lines->[0]=~ /^(\s*)/;if (length($1)< $indent->[-1]){return 1}elsif (length($1)> $indent->[-1]){die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'"}if ($lines->[0]=~ /^(\s*\-\s+)[^\'\"]\S*\s*:(?:\s+|$)/){my$indent2=length("$1");$lines->[0]=~ s/-/ /;push @$array,{};$self->_load_hash($array->[-1],[@$indent,$indent2 ],$lines)}elsif ($lines->[0]=~ /^\s*\-\s*\z/){shift @$lines;unless (@$lines){push @$array,undef;return 1}if ($lines->[0]=~ /^(\s*)\-/){my$indent2=length("$1");if ($indent->[-1]==$indent2){push @$array,undef}else {push @$array,[];$self->_load_array($array->[-1],[@$indent,$indent2 ],$lines)}}elsif ($lines->[0]=~ /^(\s*)\S/){push @$array,{};$self->_load_hash($array->[-1],[@$indent,length("$1")],$lines)}else {die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'"}}elsif ($lines->[0]=~ /^\s*\-(\s*)(.+?)\s*\z/){shift @$lines;push @$array,$self->_load_scalar("$2",[@$indent,undef ],$lines)}elsif (defined$indent->[-2]and $indent->[-1]==$indent->[-2]){return 1}else {die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'"}}return 1}sub _load_hash {my ($self,$hash,$indent,$lines)=@_;while (@$lines){if ($lines->[0]=~ /^(?:---|\.\.\.)/){while (@$lines and $lines->[0]!~ /^---/){shift @$lines}return 1}$lines->[0]=~ /^(\s*)/;if (length($1)< $indent->[-1]){return 1}elsif (length($1)> $indent->[-1]){die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'"}my$key;if ($lines->[0]=~ s/^\s*$re_capture_single_quoted$re_key_value_separator//){$key=$self->_unquote_single($1)}elsif ($lines->[0]=~ s/^\s*$re_capture_double_quoted$re_key_value_separator//){$key=$self->_unquote_double($1)}elsif ($lines->[0]=~ s/^\s*$re_capture_unquoted_key$re_key_value_separator//){$key=$1;$key =~ s/\s+$//}elsif ($lines->[0]=~ /^\s*\?/){die \"CPAN::Meta::YAML does not support a feature in line '$lines->[0]'"}else {die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'"}if (exists$hash->{$key}){warn "CPAN::Meta::YAML found a duplicate key '$key' in line '$lines->[0]'"}if (length$lines->[0]){$hash->{$key}=$self->_load_scalar(shift(@$lines),[@$indent,undef ],$lines)}else {shift @$lines;unless (@$lines){$hash->{$key}=undef;return 1}if ($lines->[0]=~ /^(\s*)-/){$hash->{$key}=[];$self->_load_array($hash->{$key},[@$indent,length($1)],$lines)}elsif ($lines->[0]=~ /^(\s*)./){my$indent2=length("$1");if ($indent->[-1]>= $indent2){$hash->{$key}=undef}else {$hash->{$key}={};$self->_load_hash($hash->{$key},[@$indent,length($1)],$lines)}}}}return 1}sub _dump_file {my$self=shift;require Fcntl;my$file=shift or $self->_error('You did not specify a file name');my$fh;if (_can_flock()){my$flags=Fcntl::O_WRONLY()|Fcntl::O_CREAT();sysopen($fh,$file,$flags);unless ($fh){$self->_error("Failed to open file '$file' for writing: $!")}binmode($fh,":raw:encoding(UTF-8)");flock($fh,Fcntl::LOCK_EX())or warn "Couldn't lock '$file' for reading: $!";truncate$fh,0;seek$fh,0,0}else {open$fh,">:unix:encoding(UTF-8)",$file}print {$fh}$self->_dump_string;unless (close$fh){$self->_error("Failed to close file '$file': $!")}return 1}sub _dump_string {my$self=shift;return '' unless ref$self && @$self;my$indent=0;my@lines=();eval {for my$cursor (@$self){push@lines,'---';if (!defined$cursor){}elsif (!ref$cursor){$lines[-1].= ' ' .$self->_dump_scalar($cursor)}elsif (ref$cursor eq 'ARRAY'){unless (@$cursor){$lines[-1].= ' []';next}push@lines,$self->_dump_array($cursor,$indent,{})}elsif (ref$cursor eq 'HASH'){unless (%$cursor){$lines[-1].= ' {}';next}push@lines,$self->_dump_hash($cursor,$indent,{})}else {die \("Cannot serialize " .ref($cursor))}}};if (ref $@ eq 'SCALAR'){$self->_error(${$@})}elsif ($@){$self->_error($@)}join '',map {"$_\n"}@lines}sub _has_internal_string_value {my$value=shift;my$b_obj=B::svref_2object(\$value);return$b_obj->FLAGS & B::SVf_POK()}sub _dump_scalar {my$string=$_[1];my$is_key=$_[2];my$has_string_flag=_has_internal_string_value($string);return '~' unless defined$string;return "''" unless length$string;if (Scalar::Util::looks_like_number($string)){if ($is_key || $has_string_flag){return qq['$string']}else {return$string}}if ($string =~ /[\x00-\x09\x0b-\x0d\x0e-\x1f\x7f-\x9f\'\n]/){$string =~ s/\\/\\\\/g;$string =~ s/"/\\"/g;$string =~ s/\n/\\n/g;$string =~ s/[\x85]/\\N/g;$string =~ s/([\x00-\x1f])/\\$UNPRINTABLE[ord($1)]/g;$string =~ s/([\x7f-\x9f])/'\x' . sprintf("%X",ord($1))/ge;return qq|"$string"|}if ($string =~ /(?:^[~!@#%&*|>?:,'"`{}\[\]]|^-+$|\s|:\z)/ or $QUOTE{$string}){return "'$string'"}return$string}sub _dump_array {my ($self,$array,$indent,$seen)=@_;if ($seen->{refaddr($array)}++){die \"CPAN::Meta::YAML does not support circular references"}my@lines=();for my$el (@$array){my$line=('  ' x $indent).'-';my$type=ref$el;if (!$type){$line .= ' ' .$self->_dump_scalar($el);push@lines,$line}elsif ($type eq 'ARRAY'){if (@$el){push@lines,$line;push@lines,$self->_dump_array($el,$indent + 1,$seen)}else {$line .= ' []';push@lines,$line}}elsif ($type eq 'HASH'){if (keys %$el){push@lines,$line;push@lines,$self->_dump_hash($el,$indent + 1,$seen)}else {$line .= ' {}';push@lines,$line}}else {die \"CPAN::Meta::YAML does not support $type references"}}@lines}sub _dump_hash {my ($self,$hash,$indent,$seen)=@_;if ($seen->{refaddr($hash)}++){die \"CPAN::Meta::YAML does not support circular references"}my@lines=();for my$name (sort keys %$hash){my$el=$hash->{$name};my$line=('  ' x $indent).$self->_dump_scalar($name,1).":";my$type=ref$el;if (!$type){$line .= ' ' .$self->_dump_scalar($el);push@lines,$line}elsif ($type eq 'ARRAY'){if (@$el){push@lines,$line;push@lines,$self->_dump_array($el,$indent + 1,$seen)}else {$line .= ' []';push@lines,$line}}elsif ($type eq 'HASH'){if (keys %$el){push@lines,$line;push@lines,$self->_dump_hash($el,$indent + 1,$seen)}else {$line .= ' {}';push@lines,$line}}else {die \"CPAN::Meta::YAML does not support $type references"}}@lines}our$errstr='';sub _error {require Carp;$errstr=$_[1];$errstr =~ s/ at \S+ line \d+.*//;Carp::croak($errstr)}my$errstr_warned;sub errstr {require Carp;Carp::carp("CPAN::Meta::YAML->errstr and \$CPAN::Meta::YAML::errstr is deprecated")unless$errstr_warned++;$errstr}use B;my$HAS_FLOCK;sub _can_flock {if (defined$HAS_FLOCK){return$HAS_FLOCK}else {require Config;my$c=\%Config::Config;$HAS_FLOCK=grep {$c->{$_}}qw/d_flock d_fcntl_can_lock d_lockf/;require Fcntl if$HAS_FLOCK;return$HAS_FLOCK}}use Scalar::Util ();BEGIN {local $@;if (eval {Scalar::Util->VERSION(1.18)}){*refaddr=*Scalar::Util::refaddr}else {eval <<'END_PERL'}}delete$CPAN::Meta::YAML::{refaddr};1;
  # Scalar::Util failed to load or too old
  sub refaddr {
      my $pkg = ref($_[0]) or return undef;
      if ( !! UNIVERSAL::can($_[0], 'can') ) {
          bless $_[0], 'Scalar::Util::Fake';
      } else {
          $pkg = undef;
      }
      "$_[0]" =~ /0x(\w+)/;
      my $i = do { no warnings 'portable'; hex $1 };
      bless $_[0], $pkg if defined $pkg;
      $i;
  }
  END_PERL
CPAN_META_YAML

$fatpacked{"Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER';
  package Exporter;require 5.006;our$Debug=0;our$ExportLevel=0;our$Verbose ||=0;our$VERSION='5.70';our (%Cache);sub as_heavy {require Exporter::Heavy;my$c=(caller(1))[3];$c =~ s/.*:://;\&{"Exporter::Heavy::heavy_$c"}}sub export {goto &{as_heavy()}}sub import {my$pkg=shift;my$callpkg=caller($ExportLevel);if ($pkg eq "Exporter" and @_ and $_[0]eq "import"){*{$callpkg."::import"}=\&import;return}my$exports=\@{"$pkg\::EXPORT"};my$fail=${$pkg .'::'}{EXPORT_FAIL}&& \@{"$pkg\::EXPORT_FAIL"};return export$pkg,$callpkg,@_ if$Verbose or $Debug or $fail && @$fail > 1;my$export_cache=($Cache{$pkg}||={});my$args=@_ or @_=@$exports;if ($args and not %$export_cache){s/^&//,$export_cache->{$_}=1 foreach (@$exports,@{"$pkg\::EXPORT_OK"})}my$heavy;if ($args or $fail){($heavy=(/\W/ or $args and not exists$export_cache->{$_}or $fail and @$fail and $_ eq $fail->[0]))and last foreach (@_)}else {($heavy=/\W/)and last foreach (@_)}return export$pkg,$callpkg,($args ? @_ : ())if$heavy;local$SIG{__WARN__}=sub {require Carp;&Carp::carp}if not $SIG{__WARN__};*{"$callpkg\::$_"}=\&{"$pkg\::$_"}foreach @_}sub export_fail {my$self=shift;@_}sub export_to_level {goto &{as_heavy()}}sub export_tags {goto &{as_heavy()}}sub export_ok_tags {goto &{as_heavy()}}sub require_version {goto &{as_heavy()}}1;
EXPORTER

$fatpacked{"Exporter/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_HEAVY';
  package Exporter::Heavy;use strict;no strict 'refs';require Exporter;our$VERSION=$Exporter::VERSION;sub _rebuild_cache {my ($pkg,$exports,$cache)=@_;s/^&// foreach @$exports;@{$cache}{@$exports}=(1)x @$exports;my$ok=\@{"${pkg}::EXPORT_OK"};if (@$ok){s/^&// foreach @$ok;@{$cache}{@$ok}=(1)x @$ok}}sub heavy_export {my$oldwarn=$SIG{__WARN__};local$SIG{__WARN__}=sub {local$SIG{__WARN__}=$oldwarn;my$text=shift;if ($text =~ s/ at \S*Exporter\S*.pm line \d+.*\n//){require Carp;local$Carp::CarpLevel=1;Carp::carp($text)}else {warn$text}};local$SIG{__DIE__}=sub {require Carp;local$Carp::CarpLevel=1;Carp::croak("$_[0]Illegal null symbol in \@${1}::EXPORT")if $_[0]=~ /^Unable to create sub named "(.*?)::"/};my($pkg,$callpkg,@imports)=@_;my($type,$sym,$cache_is_current,$oops);my($exports,$export_cache)=(\@{"${pkg}::EXPORT"},$Exporter::Cache{$pkg}||={});if (@imports){if (!%$export_cache){_rebuild_cache ($pkg,$exports,$export_cache);$cache_is_current=1}if (grep m{^[/!:]},@imports){my$tagsref=\%{"${pkg}::EXPORT_TAGS"};my$tagdata;my%imports;my($remove,$spec,@names,@allexports);unshift@imports,':DEFAULT' if$imports[0]=~ m/^!/;for$spec (@imports){$remove=$spec =~ s/^!//;if ($spec =~ s/^://){if ($spec eq 'DEFAULT'){@names=@$exports}elsif ($tagdata=$tagsref->{$spec}){@names=@$tagdata}else {warn qq["$spec" is not defined in %${pkg}::EXPORT_TAGS];++$oops;next}}elsif ($spec =~ m:^/(.*)/$:){my$patn=$1;@allexports=keys %$export_cache unless@allexports;@names=grep(/$patn/,@allexports)}else {@names=($spec)}warn "Import ".($remove ? "del":"add").": @names " if$Exporter::Verbose;if ($remove){for$sym (@names){delete$imports{$sym}}}else {@imports{@names}=(1)x @names}}@imports=keys%imports}my@carp;for$sym (@imports){if (!$export_cache->{$sym}){if ($sym =~ m/^\d/){$pkg->VERSION($sym);if (@imports==1){@imports=@$exports;last}if (@imports==2 and!$imports[1]){@imports=();last}}elsif ($sym !~ s/^&// ||!$export_cache->{$sym}){unless ($cache_is_current){%$export_cache=();_rebuild_cache ($pkg,$exports,$export_cache);$cache_is_current=1}if (!$export_cache->{$sym}){push@carp,qq["$sym" is not exported by the $pkg module\n];$oops++}}}}if ($oops){require Carp;Carp::croak("@{carp}Can't continue after import errors")}}else {@imports=@$exports}my($fail,$fail_cache)=(\@{"${pkg}::EXPORT_FAIL"},$Exporter::FailCache{$pkg}||={});if (@$fail){if (!%$fail_cache){my@expanded=map {/^\w/ ? ($_,'&'.$_): $_}@$fail;warn "${pkg}::EXPORT_FAIL cached: @expanded" if$Exporter::Verbose;@{$fail_cache}{@expanded}=(1)x @expanded}my@failed;for$sym (@imports){push(@failed,$sym)if$fail_cache->{$sym}}if (@failed){@failed=$pkg->export_fail(@failed);for$sym (@failed){require Carp;Carp::carp(qq["$sym" is not implemented by the $pkg module ],"on this architecture")}if (@failed){require Carp;Carp::croak("Can't continue after import errors")}}}warn "Importing into $callpkg from $pkg: ",join(", ",sort@imports)if$Exporter::Verbose;for$sym (@imports){(*{"${callpkg}::$sym"}=\&{"${pkg}::$sym"},next)unless$sym =~ s/^(\W)//;$type=$1;no warnings 'once';*{"${callpkg}::$sym"}=$type eq '&' ? \&{"${pkg}::$sym"}: $type eq '$' ? \${"${pkg}::$sym"}: $type eq '@' ? \@{"${pkg}::$sym"}: $type eq '%' ? \%{"${pkg}::$sym"}: $type eq '*' ? *{"${pkg}::$sym"}: do {require Carp;Carp::croak("Can't export symbol: $type$sym")}}}sub heavy_export_to_level {my$pkg=shift;my$level=shift;(undef)=shift;my$callpkg=caller($level);$pkg->export($callpkg,@_)}sub _push_tags {my($pkg,$var,$syms)=@_;my@nontag=();my$export_tags=\%{"${pkg}::EXPORT_TAGS"};push(@{"${pkg}::$var"},map {$export_tags->{$_}? @{$export_tags->{$_}}: scalar(push(@nontag,$_),$_)}(@$syms)? @$syms : keys %$export_tags);if (@nontag and $^W){require Carp;Carp::carp(join(", ",@nontag)." are not tags of $pkg")}}sub heavy_require_version {my($self,$wanted)=@_;my$pkg=ref$self || $self;return ${pkg}->VERSION($wanted)}sub heavy_export_tags {_push_tags((caller)[0],"EXPORT",\@_)}sub heavy_export_ok_tags {_push_tags((caller)[0],"EXPORT_OK",\@_)}1;
EXPORTER_HEAVY

$fatpacked{"File/pushd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PUSHD';
  use strict;use warnings;package File::pushd;our$VERSION='1.009';our@EXPORT=qw(pushd tempd);our@ISA=qw(Exporter);use Exporter;use Carp;use Cwd qw(getcwd abs_path);use File::Path qw(rmtree);use File::Temp qw();use File::Spec;use overload q{""}=>sub {File::Spec->canonpath($_[0]->{_pushd})},fallback=>1;sub pushd {my ($target_dir,$options)=@_;$options->{untaint_pattern}||= qr{^([-+@\w./]+)$};$target_dir="." unless defined$target_dir;croak "Can't locate directory $target_dir" unless -d $target_dir;my$tainted_orig=getcwd;my$orig;if ($tainted_orig =~ $options->{untaint_pattern}){$orig=$1}else {$orig=$tainted_orig}my$tainted_dest;eval {$tainted_dest=$target_dir ? abs_path($target_dir): $orig};croak "Can't locate absolute path for $target_dir: $@" if $@;my$dest;if ($tainted_dest =~ $options->{untaint_pattern}){$dest=$1}else {$dest=$tainted_dest}if ($dest ne $orig){chdir$dest or croak "Can't chdir to $dest\: $!"}my$self=bless {_pushd=>$dest,_original=>$orig },__PACKAGE__;return$self}sub tempd {my ($options)=@_;my$dir;eval {$dir=pushd(File::Temp::tempdir(CLEANUP=>0),$options)};croak $@ if $@;$dir->{_tempd}=1;return$dir}sub preserve {my$self=shift;return 1 if!$self->{"_tempd"};if (@_==0){return$self->{_preserve}=1}else {return$self->{_preserve}=$_[0]? 1 : 0}}sub DESTROY {my ($self)=@_;my$orig=$self->{_original};chdir$orig if$orig;if ($self->{_tempd}&&!$self->{_preserve}){my$err=do {local $@;eval {rmtree($self->{_pushd})};$@};carp$err if$err}}1;
FILE_PUSHD

$fatpacked{"HTTP/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINY';
  package HTTP::Tiny;use strict;use warnings;our$VERSION='0.056';use Carp ();my@attributes;BEGIN {@attributes=qw(cookie_jar default_headers http_proxy https_proxy keep_alive local_address max_redirect max_size proxy no_proxy timeout SSL_options verify_SSL);my%persist_ok=map {;$_=>1}qw(cookie_jar default_headers max_redirect max_size);no strict 'refs';no warnings 'uninitialized';for my$accessor (@attributes){*{$accessor}=sub {@_ > 1 ? do {delete $_[0]->{handle}if!$persist_ok{$accessor}&& $_[1]ne $_[0]->{$accessor};$_[0]->{$accessor}=$_[1]}: $_[0]->{$accessor}}}}sub agent {my($self,$agent)=@_;if(@_ > 1){$self->{agent}=(defined$agent && $agent =~ / $/)? $agent .$self->_agent : $agent}return$self->{agent}}sub new {my($class,%args)=@_;my$self={max_redirect=>5,timeout=>60,keep_alive=>1,verify_SSL=>$args{verify_SSL}|| $args{verify_ssl}|| 0,no_proxy=>$ENV{no_proxy},};bless$self,$class;$class->_validate_cookie_jar($args{cookie_jar})if$args{cookie_jar};for my$key (@attributes){$self->{$key}=$args{$key}if exists$args{$key}}$self->agent(exists$args{agent}? $args{agent}: $class->_agent);$self->_set_proxies;return$self}sub _set_proxies {my ($self)=@_;if (!exists$self->{proxy}){$self->{proxy}=$ENV{all_proxy}|| $ENV{ALL_PROXY}}if (defined$self->{proxy}){$self->_split_proxy('generic proxy'=>$self->{proxy})}else {delete$self->{proxy}}if (!exists$self->{http_proxy}){local$ENV{HTTP_PROXY}if$ENV{REQUEST_METHOD};$self->{http_proxy}=$ENV{http_proxy}|| $ENV{HTTP_PROXY}|| $self->{proxy}}if (defined$self->{http_proxy}){$self->_split_proxy(http_proxy=>$self->{http_proxy});$self->{_has_proxy}{http}=1}else {delete$self->{http_proxy}}if (!exists$self->{https_proxy}){$self->{https_proxy}=$ENV{https_proxy}|| $ENV{HTTPS_PROXY}|| $self->{proxy}}if ($self->{https_proxy}){$self->_split_proxy(https_proxy=>$self->{https_proxy});$self->{_has_proxy}{https}=1}else {delete$self->{https_proxy}}unless (ref$self->{no_proxy}eq 'ARRAY'){$self->{no_proxy}=(defined$self->{no_proxy})? [split /\s*,\s*/,$self->{no_proxy}]: []}return}for my$sub_name (qw/get head put post delete/){my$req_method=uc$sub_name;no strict 'refs';eval <<"HERE"}sub post_form {my ($self,$url,$data,$args)=@_;(@_==3 || @_==4 && ref$args eq 'HASH')or Carp::croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ ."\n");my$headers={};while (my ($key,$value)=each %{$args->{headers}|| {}}){$headers->{lc$key}=$value}delete$args->{headers};return$self->request('POST',$url,{%$args,content=>$self->www_form_urlencode($data),headers=>{%$headers,'content-type'=>'application/x-www-form-urlencoded' },})}sub mirror {my ($self,$url,$file,$args)=@_;@_==3 || (@_==4 && ref$args eq 'HASH')or Carp::croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ ."\n");if (-e $file and my$mtime=(stat($file))[9]){$args->{headers}{'if-modified-since'}||= $self->_http_date($mtime)}my$tempfile=$file .int(rand(2**31));require Fcntl;sysopen my$fh,$tempfile,Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()or Carp::croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);binmode$fh;$args->{data_callback}=sub {print {$fh}$_[0]};my$response=$self->request('GET',$url,$args);close$fh or Carp::croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);if ($response->{success}){rename$tempfile,$file or Carp::croak(qq/Error replacing $file with $tempfile: $!\n/);my$lm=$response->{headers}{'last-modified'};if ($lm and my$mtime=$self->_parse_http_date($lm)){utime$mtime,$mtime,$file}}$response->{success}||= $response->{status}eq '304';unlink$tempfile;return$response}my%idempotent=map {$_=>1}qw/GET HEAD PUT DELETE OPTIONS TRACE/;sub request {my ($self,$method,$url,$args)=@_;@_==3 || (@_==4 && ref$args eq 'HASH')or Carp::croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ ."\n");$args ||= {};my$response;for (0 .. 1){$response=eval {$self->_request($method,$url,$args)};last unless $@ && $idempotent{$method}&& $@ =~ m{^(?:Socket closed|Unexpected end)}}if (my$e=$@){if (ref$e eq 'HASH' && exists$e->{status}){return$e}$e="$e";$response={url=>$url,success=>q{},status=>599,reason=>'Internal Exception',content=>$e,headers=>{'content-type'=>'text/plain','content-length'=>length$e,}}}return$response}sub www_form_urlencode {my ($self,$data)=@_;(@_==2 && ref$data)or Carp::croak(q/Usage: $http->www_form_urlencode(DATAREF)/ ."\n");(ref$data eq 'HASH' || ref$data eq 'ARRAY')or Carp::croak("form data must be a hash or array reference\n");my@params=ref$data eq 'HASH' ? %$data : @$data;@params % 2==0 or Carp::croak("form data reference must have an even number of terms\n");my@terms;while(@params){my ($key,$value)=splice(@params,0,2);if (ref$value eq 'ARRAY'){unshift@params,map {$key=>$_}@$value}else {push@terms,join("=",map {$self->_uri_escape($_)}$key,$value)}}return join("&",(ref$data eq 'ARRAY')? (@terms): (sort@terms))}sub can_ssl {my ($self)=@_;my($ok,$reason)=(1,'');unless (eval {require IO::Socket::SSL;IO::Socket::SSL->VERSION(1.42)}){$ok=0;$reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/}unless (eval {require Net::SSLeay;Net::SSLeay->VERSION(1.49)}){$ok=0;$reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/}if (ref($self)&& ($self->{verify_SSL}|| $self->{SSL_options}{SSL_verify_mode})){my$handle=HTTP::Tiny::Handle->new(SSL_options=>$self->{SSL_options},verify_SSL=>$self->{verify_SSL},);unless (eval {$handle->_find_CA_file;1}){$ok=0;$reason .= "$@"}}wantarray ? ($ok,$reason): $ok}my%DefaultPort=(http=>80,https=>443,);sub _agent {my$class=ref($_[0])|| $_[0];(my$default_agent=$class)=~ s{::}{-}g;return$default_agent ."/" .$class->VERSION}sub _request {my ($self,$method,$url,$args)=@_;my ($scheme,$host,$port,$path_query,$auth)=$self->_split_url($url);my$request={method=>$method,scheme=>$scheme,host=>$host,port=>$port,host_port=>($port==$DefaultPort{$scheme}? $host : "$host:$port"),uri=>$path_query,headers=>{},};my$handle=delete$self->{handle};if ($handle){unless ($handle->can_reuse($scheme,$host,$port)){$handle->close;undef$handle}}$handle ||= $self->_open_handle($request,$scheme,$host,$port);$self->_prepare_headers_and_cb($request,$args,$url,$auth);$handle->write_request($request);my$response;do {$response=$handle->read_response_header}until (substr($response->{status},0,1)ne '1');$self->_update_cookie_jar($url,$response)if$self->{cookie_jar};if (my@redir_args=$self->_maybe_redirect($request,$response,$args)){$handle->close;return$self->_request(@redir_args,$args)}my$known_message_length;if ($method eq 'HEAD' || $response->{status}=~ /^[23]04/){$known_message_length=1}else {my$data_cb=$self->_prepare_data_cb($response,$args);$known_message_length=$handle->read_body($data_cb,$response)}if ($self->{keep_alive}&& $known_message_length && $response->{protocol}eq 'HTTP/1.1' && ($response->{headers}{connection}|| '')ne 'close'){$self->{handle}=$handle}else {$handle->close}$response->{success}=substr($response->{status},0,1)eq '2';$response->{url}=$url;return$response}sub _open_handle {my ($self,$request,$scheme,$host,$port)=@_;my$handle=HTTP::Tiny::Handle->new(timeout=>$self->{timeout},SSL_options=>$self->{SSL_options},verify_SSL=>$self->{verify_SSL},local_address=>$self->{local_address},keep_alive=>$self->{keep_alive});if ($self->{_has_proxy}{$scheme}&&!grep {$host =~ /\Q$_\E$/}@{$self->{no_proxy}}){return$self->_proxy_connect($request,$handle)}else {return$handle->connect($scheme,$host,$port)}}sub _proxy_connect {my ($self,$request,$handle)=@_;my@proxy_vars;if ($request->{scheme}eq 'https'){Carp::croak(qq{No https_proxy defined})unless$self->{https_proxy};@proxy_vars=$self->_split_proxy(https_proxy=>$self->{https_proxy});if ($proxy_vars[0]eq 'https'){Carp::croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}})}}else {Carp::croak(qq{No http_proxy defined})unless$self->{http_proxy};@proxy_vars=$self->_split_proxy(http_proxy=>$self->{http_proxy})}my ($p_scheme,$p_host,$p_port,$p_auth)=@proxy_vars;if (length$p_auth &&!defined$request->{headers}{'proxy-authorization'}){$self->_add_basic_auth_header($request,'proxy-authorization'=>$p_auth)}$handle->connect($p_scheme,$p_host,$p_port);if ($request->{scheme}eq 'https'){$self->_create_proxy_tunnel($request,$handle)}else {$request->{uri}="$request->{scheme}://$request->{host_port}$request->{uri}"}return$handle}sub _split_proxy {my ($self,$type,$proxy)=@_;my ($scheme,$host,$port,$path_query,$auth)=eval {$self->_split_url($proxy)};unless(defined($scheme)&& length($scheme)&& length($host)&& length($port)&& $path_query eq '/'){Carp::croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n})}return ($scheme,$host,$port,$auth)}sub _create_proxy_tunnel {my ($self,$request,$handle)=@_;$handle->_assert_ssl;my$agent=exists($request->{headers}{'user-agent'})? $request->{headers}{'user-agent'}: $self->{agent};my$connect_request={method=>'CONNECT',uri=>"$request->{host}:$request->{port}",headers=>{host=>"$request->{host}:$request->{port}",'user-agent'=>$agent,}};if ($request->{headers}{'proxy-authorization'}){$connect_request->{headers}{'proxy-authorization'}=delete$request->{headers}{'proxy-authorization'}}$handle->write_request($connect_request);my$response;do {$response=$handle->read_response_header}until (substr($response->{status},0,1)ne '1');unless (substr($response->{status},0,1)eq '2'){die$response}$handle->start_ssl($request->{host});return}sub _prepare_headers_and_cb {my ($self,$request,$args,$url,$auth)=@_;for ($self->{default_headers},$args->{headers}){next unless defined;while (my ($k,$v)=each %$_){$request->{headers}{lc$k}=$v}}if (exists$request->{headers}{'host'}){die(qq/The 'Host' header must not be provided as header option\n/)}$request->{headers}{'host'}=$request->{host_port};$request->{headers}{'user-agent'}||= $self->{agent};$request->{headers}{'connection'}="close" unless$self->{keep_alive};if (defined$args->{content}){if (ref$args->{content}eq 'CODE'){$request->{headers}{'content-type'}||= "application/octet-stream";$request->{headers}{'transfer-encoding'}='chunked' unless$request->{headers}{'content-length'}|| $request->{headers}{'transfer-encoding'};$request->{cb}=$args->{content}}elsif (length$args->{content}){my$content=$args->{content};if ($] ge '5.008'){utf8::downgrade($content,1)or die(qq/Wide character in request message body\n/)}$request->{headers}{'content-type'}||= "application/octet-stream";$request->{headers}{'content-length'}=length$content unless$request->{headers}{'content-length'}|| $request->{headers}{'transfer-encoding'};$request->{cb}=sub {substr$content,0,length$content,''}}$request->{trailer_cb}=$args->{trailer_callback}if ref$args->{trailer_callback}eq 'CODE'}if ($self->{cookie_jar}){my$cookies=$self->cookie_jar->cookie_header($url);$request->{headers}{cookie}=$cookies if length$cookies}if (length$auth &&!defined$request->{headers}{authorization}){$self->_add_basic_auth_header($request,'authorization'=>$auth)}return}sub _add_basic_auth_header {my ($self,$request,$header,$auth)=@_;require MIME::Base64;$request->{headers}{$header}="Basic " .MIME::Base64::encode_base64($auth,"");return}sub _prepare_data_cb {my ($self,$response,$args)=@_;my$data_cb=$args->{data_callback};$response->{content}='';if (!$data_cb || $response->{status}!~ /^2/){if (defined$self->{max_size}){$data_cb=sub {$_[1]->{content}.= $_[0];die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)if length $_[1]->{content}> $self->{max_size}}}else {$data_cb=sub {$_[1]->{content}.= $_[0]}}}return$data_cb}sub _update_cookie_jar {my ($self,$url,$response)=@_;my$cookies=$response->{headers}->{'set-cookie'};return unless defined$cookies;my@cookies=ref$cookies ? @$cookies : $cookies;$self->cookie_jar->add($url,$_)for@cookies;return}sub _validate_cookie_jar {my ($class,$jar)=@_;for my$method (qw/add cookie_header/){Carp::croak(qq/Cookie jar must provide the '$method' method\n/)unless ref($jar)&& ref($jar)->can($method)}return}sub _maybe_redirect {my ($self,$request,$response,$args)=@_;my$headers=$response->{headers};my ($status,$method)=($response->{status},$request->{method});if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))and $headers->{location}and ++$args->{redirects}<= $self->{max_redirect}){my$location=($headers->{location}=~ /^\//)? "$request->{scheme}://$request->{host_port}$headers->{location}" : $headers->{location};return (($status eq '303' ? 'GET' : $method),$location)}return}sub _split_url {my$url=pop;my ($scheme,$host,$path_query)=$url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)> or die(qq/Cannot parse URL: '$url'\n/);$scheme=lc$scheme;$path_query="/$path_query" unless$path_query =~ m<\A/>;my$auth='';if ((my$i=index$host,'@')!=-1){$auth=substr$host,0,$i,'';substr$host,0,1,'';$auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg}my$port=$host =~ s/:(\d*)\z// && length $1 ? $1 : $scheme eq 'http' ? 80 : $scheme eq 'https' ? 443 : undef;return ($scheme,(length$host ? lc$host : "localhost"),$port,$path_query,$auth)}my$DoW="Sun|Mon|Tue|Wed|Thu|Fri|Sat";my$MoY="Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";sub _http_date {my ($sec,$min,$hour,$mday,$mon,$year,$wday)=gmtime($_[1]);return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",substr($DoW,$wday*4,3),$mday,substr($MoY,$mon*4,3),$year+1900,$hour,$min,$sec)}sub _parse_http_date {my ($self,$str)=@_;require Time::Local;my@tl_parts;if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/){@tl_parts=($6,$5,$4,$1,(index($MoY,$2)/4),$3)}elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/){@tl_parts=($6,$5,$4,$1,(index($MoY,$2)/4),$3)}elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/){@tl_parts=($5,$4,$3,$2,(index($MoY,$1)/4),$6)}return eval {my$t=@tl_parts ? Time::Local::timegm(@tl_parts): -1;$t < 0 ? undef : $t}}my%escapes=map {chr($_)=>sprintf("%%%02X",$_)}0..255;$escapes{' '}="+";my$unsafe_char=qr/[^A-Za-z0-9\-\._~]/;sub _uri_escape {my ($self,$str)=@_;if ($] ge '5.008'){utf8::encode($str)}else {$str=pack("U*",unpack("C*",$str))if (length$str==do {use bytes;length$str});$str=pack("C*",unpack("C*",$str))}$str =~ s/($unsafe_char)/$escapes{$1}/ge;return$str}package HTTP::Tiny::Handle;use strict;use warnings;use Errno qw[EINTR EPIPE];use IO::Socket qw[SOCK_STREAM];my$SOCKET_CLASS=$ENV{PERL_HTTP_TINY_IPV4_ONLY}? 'IO::Socket::INET' : eval {require IO::Socket::IP;IO::Socket::IP->VERSION(0.25)}? 'IO::Socket::IP' : 'IO::Socket::INET';sub BUFSIZE () {32768}my$Printable=sub {local $_=shift;s/\r/\\r/g;s/\n/\\n/g;s/\t/\\t/g;s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;$_};my$Token=qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;sub new {my ($class,%args)=@_;return bless {rbuf=>'',timeout=>60,max_line_size=>16384,max_header_lines=>64,verify_SSL=>0,SSL_options=>{},%args },$class}sub connect {@_==4 || die(q/Usage: $handle->connect(scheme, host, port)/ ."\n");my ($self,$scheme,$host,$port)=@_;if ($scheme eq 'https'){$self->_assert_ssl}elsif ($scheme ne 'http'){die(qq/Unsupported URL scheme '$scheme'\n/)}$self->{fh}=$SOCKET_CLASS->new(PeerHost=>$host,PeerPort=>$port,$self->{local_address}? (LocalAddr=>$self->{local_address}): (),Proto=>'tcp',Type=>SOCK_STREAM,Timeout=>$self->{timeout},KeepAlive=>!!$self->{keep_alive})or die(qq/Could not connect to '$host:$port': $@\n/);binmode($self->{fh})or die(qq/Could not binmode() socket: '$!'\n/);$self->start_ssl($host)if$scheme eq 'https';$self->{scheme}=$scheme;$self->{host}=$host;$self->{port}=$port;$self->{pid}=$$;$self->{tid}=_get_tid();return$self}sub start_ssl {my ($self,$host)=@_;if (ref($self->{fh})eq 'IO::Socket::SSL'){unless ($self->{fh}->stop_SSL){my$ssl_err=IO::Socket::SSL->errstr;die(qq/Error halting prior SSL connection: $ssl_err/)}}my$ssl_args=$self->_ssl_args($host);IO::Socket::SSL->start_SSL($self->{fh},%$ssl_args,SSL_create_ctx_callback=>sub {my$ctx=shift;Net::SSLeay::CTX_set_mode($ctx,Net::SSLeay::MODE_AUTO_RETRY())},);unless (ref($self->{fh})eq 'IO::Socket::SSL'){my$ssl_err=IO::Socket::SSL->errstr;die(qq/SSL connection failed for $host: $ssl_err\n/)}}sub close {@_==1 || die(q/Usage: $handle->close()/ ."\n");my ($self)=@_;CORE::close($self->{fh})or die(qq/Could not close socket: '$!'\n/)}sub write {@_==2 || die(q/Usage: $handle->write(buf)/ ."\n");my ($self,$buf)=@_;if ($] ge '5.008'){utf8::downgrade($buf,1)or die(qq/Wide character in write()\n/)}my$len=length$buf;my$off=0;local$SIG{PIPE}='IGNORE';while (){$self->can_write or die(qq/Timed out while waiting for socket to become ready for writing\n/);my$r=syswrite($self->{fh},$buf,$len,$off);if (defined$r){$len -= $r;$off += $r;last unless$len > 0}elsif ($!==EPIPE){die(qq/Socket closed by remote server: $!\n/)}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not write to SSL socket: '$err'\n /)}else {die(qq/Could not write to socket: '$!'\n/)}}}return$off}sub read {@_==2 || @_==3 || die(q/Usage: $handle->read(len [, allow_partial])/ ."\n");my ($self,$len,$allow_partial)=@_;my$buf='';my$got=length$self->{rbuf};if ($got){my$take=($got < $len)? $got : $len;$buf=substr($self->{rbuf},0,$take,'');$len -= $take}while ($len > 0){$self->can_read or die(q/Timed out while waiting for socket to become ready for reading/ ."\n");my$r=sysread($self->{fh},$buf,$len,length$buf);if (defined$r){last unless$r;$len -= $r}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not read from SSL socket: '$err'\n /)}else {die(qq/Could not read from socket: '$!'\n/)}}}if ($len &&!$allow_partial){die(qq/Unexpected end of stream\n/)}return$buf}sub readline {@_==1 || die(q/Usage: $handle->readline()/ ."\n");my ($self)=@_;while (){if ($self->{rbuf}=~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x){return $1}if (length$self->{rbuf}>= $self->{max_line_size}){die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/)}$self->can_read or die(qq/Timed out while waiting for socket to become ready for reading\n/);my$r=sysread($self->{fh},$self->{rbuf},BUFSIZE,length$self->{rbuf});if (defined$r){last unless$r}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not read from SSL socket: '$err'\n /)}else {die(qq/Could not read from socket: '$!'\n/)}}}die(qq/Unexpected end of stream while looking for line\n/)}sub read_header_lines {@_==1 || @_==2 || die(q/Usage: $handle->read_header_lines([headers])/ ."\n");my ($self,$headers)=@_;$headers ||= {};my$lines=0;my$val;while (){my$line=$self->readline;if (++$lines >= $self->{max_header_lines}){die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/)}elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x){my ($field_name)=lc $1;if (exists$headers->{$field_name}){for ($headers->{$field_name}){$_=[$_]unless ref $_ eq "ARRAY";push @$_,$2;$val=\$_->[-1]}}else {$val=\($headers->{$field_name}=$2)}}elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x){$val or die(qq/Unexpected header continuation line\n/);next unless length $1;$$val .= ' ' if length $$val;$$val .= $1}elsif ($line =~ /\A \x0D?\x0A \z/x){last}else {die(q/Malformed header line: / .$Printable->($line)."\n")}}return$headers}sub write_request {@_==2 || die(q/Usage: $handle->write_request(request)/ ."\n");my($self,$request)=@_;$self->write_request_header(@{$request}{qw/method uri headers/});$self->write_body($request)if$request->{cb};return}my%HeaderCase=('content-md5'=>'Content-MD5','etag'=>'ETag','te'=>'TE','www-authenticate'=>'WWW-Authenticate','x-xss-protection'=>'X-XSS-Protection',);sub write_header_lines {(@_==2 || @_==3 && ref $_[1]eq 'HASH')|| die(q/Usage: $handle->write_header_lines(headers[,prefix])/ ."\n");my($self,$headers,$prefix_data)=@_;my$buf=(defined$prefix_data ? $prefix_data : '');while (my ($k,$v)=each %$headers){my$field_name=lc$k;if (exists$HeaderCase{$field_name}){$field_name=$HeaderCase{$field_name}}else {$field_name =~ /\A $Token+ \z/xo or die(q/Invalid HTTP header field name: / .$Printable->($field_name)."\n");$field_name =~ s/\b(\w)/\u$1/g;$HeaderCase{lc$field_name}=$field_name}for (ref$v eq 'ARRAY' ? @$v : $v){$_='' unless defined $_;$buf .= "$field_name: $_\x0D\x0A"}}$buf .= "\x0D\x0A";return$self->write($buf)}sub read_body {@_==3 || die(q/Usage: $handle->read_body(callback, response)/ ."\n");my ($self,$cb,$response)=@_;my$te=$response->{headers}{'transfer-encoding'}|| '';my$chunked=grep {/chunked/i}(ref$te eq 'ARRAY' ? @$te : $te);return$chunked ? $self->read_chunked_body($cb,$response): $self->read_content_body($cb,$response)}sub write_body {@_==2 || die(q/Usage: $handle->write_body(request)/ ."\n");my ($self,$request)=@_;if ($request->{headers}{'content-length'}){return$self->write_content_body($request)}else {return$self->write_chunked_body($request)}}sub read_content_body {@_==3 || @_==4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ ."\n");my ($self,$cb,$response,$content_length)=@_;$content_length ||= $response->{headers}{'content-length'};if (defined$content_length){my$len=$content_length;while ($len > 0){my$read=($len > BUFSIZE)? BUFSIZE : $len;$cb->($self->read($read,0),$response);$len -= $read}return length($self->{rbuf})==0}my$chunk;$cb->($chunk,$response)while length($chunk=$self->read(BUFSIZE,1));return}sub write_content_body {@_==2 || die(q/Usage: $handle->write_content_body(request)/ ."\n");my ($self,$request)=@_;my ($len,$content_length)=(0,$request->{headers}{'content-length'});while (){my$data=$request->{cb}->();defined$data && length$data or last;if ($] ge '5.008'){utf8::downgrade($data,1)or die(qq/Wide character in write_content()\n/)}$len += $self->write($data)}$len==$content_length or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);return$len}sub read_chunked_body {@_==3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ ."\n");my ($self,$cb,$response)=@_;while (){my$head=$self->readline;$head =~ /\A ([A-Fa-f0-9]+)/x or die(q/Malformed chunk head: / .$Printable->($head)."\n");my$len=hex($1)or last;$self->read_content_body($cb,$response,$len);$self->read(2)eq "\x0D\x0A" or die(qq/Malformed chunk: missing CRLF after chunk data\n/)}$self->read_header_lines($response->{headers});return 1}sub write_chunked_body {@_==2 || die(q/Usage: $handle->write_chunked_body(request)/ ."\n");my ($self,$request)=@_;my$len=0;while (){my$data=$request->{cb}->();defined$data && length$data or last;if ($] ge '5.008'){utf8::downgrade($data,1)or die(qq/Wide character in write_chunked_body()\n/)}$len += length$data;my$chunk=sprintf '%X',length$data;$chunk .= "\x0D\x0A";$chunk .= $data;$chunk .= "\x0D\x0A";$self->write($chunk)}$self->write("0\x0D\x0A");$self->write_header_lines($request->{trailer_cb}->())if ref$request->{trailer_cb}eq 'CODE';return$len}sub read_response_header {@_==1 || die(q/Usage: $handle->read_response_header()/ ."\n");my ($self)=@_;my$line=$self->readline;$line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) [\x09\x20]+ ([^\x0D\x0A]*) \x0D?\x0A/x or die(q/Malformed Status-Line: / .$Printable->($line)."\n");my ($protocol,$version,$status,$reason)=($1,$2,$3,$4);die (qq/Unsupported HTTP protocol: $protocol\n/)unless$version =~ /0*1\.0*[01]/;return {status=>$status,reason=>$reason,headers=>$self->read_header_lines,protocol=>$protocol,}}sub write_request_header {@_==4 || die(q/Usage: $handle->write_request_header(method, request_uri, headers)/ ."\n");my ($self,$method,$request_uri,$headers)=@_;return$self->write_header_lines($headers,"$method $request_uri HTTP/1.1\x0D\x0A")}sub _do_timeout {my ($self,$type,$timeout)=@_;$timeout=$self->{timeout}unless defined$timeout && $timeout >= 0;my$fd=fileno$self->{fh};defined$fd && $fd >= 0 or die(qq/select(2): 'Bad file descriptor'\n/);my$initial=time;my$pending=$timeout;my$nfound;vec(my$fdset='',$fd,1)=1;while (){$nfound=($type eq 'read')? select($fdset,undef,undef,$pending): select(undef,$fdset,undef,$pending);if ($nfound==-1){$!==EINTR or die(qq/select(2): '$!'\n/);redo if!$timeout || ($pending=$timeout - (time - $initial))> 0;$nfound=0}last}$!=0;return$nfound}sub can_read {@_==1 || @_==2 || die(q/Usage: $handle->can_read([timeout])/ ."\n");my$self=shift;if (ref($self->{fh})eq 'IO::Socket::SSL'){return 1 if$self->{fh}->pending}return$self->_do_timeout('read',@_)}sub can_write {@_==1 || @_==2 || die(q/Usage: $handle->can_write([timeout])/ ."\n");my$self=shift;return$self->_do_timeout('write',@_)}sub _assert_ssl {my($ok,$reason)=HTTP::Tiny->can_ssl();die$reason unless$ok}sub can_reuse {my ($self,$scheme,$host,$port)=@_;return 0 if $self->{pid}!=$$ || $self->{tid}!=_get_tid()|| length($self->{rbuf})|| $scheme ne $self->{scheme}|| $host ne $self->{host}|| $port ne $self->{port}|| eval {$self->can_read(0)}|| $@ ;return 1}sub _find_CA_file {my$self=shift();if ($self->{SSL_options}->{SSL_ca_file}){unless (-r $self->{SSL_options}->{SSL_ca_file}){die qq/SSL_ca_file '$self->{SSL_options}->{SSL_ca_file}' not found or not readable\n/}return$self->{SSL_options}->{SSL_ca_file}}return Mozilla::CA::SSL_ca_file()if eval {require Mozilla::CA;1};for my$ca_bundle ("/etc/ssl/certs/ca-certificates.crt","/etc/pki/tls/certs/ca-bundle.crt","/etc/ssl/ca-bundle.pem","/etc/openssl/certs/ca-certificates.crt","/etc/ssl/cert.pem","/usr/local/share/certs/ca-root-nss.crt","/etc/pki/tls/cacert.pem","/etc/certs/ca-certificates.crt",){return$ca_bundle if -e $ca_bundle}die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/ .qq/Try installing Mozilla::CA from CPAN\n/}sub _get_tid {no warnings 'reserved';return threads->can("tid")? threads->tid : 0}sub _ssl_args {my ($self,$host)=@_;my%ssl_args;if (Net::SSLeay::OPENSSL_VERSION_NUMBER()>= 0x01000000){$ssl_args{SSL_hostname}=$host,}if ($self->{verify_SSL}){$ssl_args{SSL_verifycn_scheme}='http';$ssl_args{SSL_verifycn_name}=$host;$ssl_args{SSL_verify_mode}=0x01;$ssl_args{SSL_ca_file}=$self->_find_CA_file}else {$ssl_args{SSL_verifycn_scheme}='none';$ssl_args{SSL_verify_mode}=0x00}for my$k (keys %{$self->{SSL_options}}){$ssl_args{$k}=$self->{SSL_options}{$k}if$k =~ m/^SSL_/}return \%ssl_args}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  HERE
HTTP_TINY

$fatpacked{"JSON/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP';
  package JSON::PP;use 5.005;use strict;use base qw(Exporter);use overload ();use Carp ();use B ();$JSON::PP::VERSION='2.27300';@JSON::PP::EXPORT=qw(encode_json decode_json from_json to_json);use constant P_ASCII=>0;use constant P_LATIN1=>1;use constant P_UTF8=>2;use constant P_INDENT=>3;use constant P_CANONICAL=>4;use constant P_SPACE_BEFORE=>5;use constant P_SPACE_AFTER=>6;use constant P_ALLOW_NONREF=>7;use constant P_SHRINK=>8;use constant P_ALLOW_BLESSED=>9;use constant P_CONVERT_BLESSED=>10;use constant P_RELAXED=>11;use constant P_LOOSE=>12;use constant P_ALLOW_BIGNUM=>13;use constant P_ALLOW_BAREKEY=>14;use constant P_ALLOW_SINGLEQUOTE=>15;use constant P_ESCAPE_SLASH=>16;use constant P_AS_NONBLESSED=>17;use constant P_ALLOW_UNKNOWN=>18;use constant OLD_PERL=>$] < 5.008 ? 1 : 0;BEGIN {my@xs_compati_bit_properties=qw(latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink allow_blessed convert_blessed relaxed allow_unknown);my@pp_bit_properties=qw(allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed);if ($] < 5.008){my$helper=$] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';eval qq| require $helper |;if ($@){Carp::croak $@}}for my$name (@xs_compati_bit_properties,@pp_bit_properties){my$flag_name='P_' .uc($name);eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$flag_name] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$flag_name] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$flag_name] ? 1 : '';
              }
          /}}my%encode_allow_method =map {($_=>1)}qw/utf8 pretty allow_nonref latin1 self_encode escape_slash allow_blessed convert_blessed indent indent_length allow_bignum as_nonblessed/;my%decode_allow_method =map {($_=>1)}qw/utf8 allow_nonref loose allow_singlequote allow_bignum allow_barekey max_size relaxed/;my$JSON;sub encode_json ($) {($JSON ||= __PACKAGE__->new->utf8)->encode(@_)}sub decode_json {($JSON ||= __PACKAGE__->new->utf8)->decode(@_)}sub to_json($) {Carp::croak ("JSON::PP::to_json has been renamed to encode_json.")}sub from_json($) {Carp::croak ("JSON::PP::from_json has been renamed to decode_json.")}sub new {my$class=shift;my$self={max_depth=>512,max_size=>0,indent=>0,FLAGS=>0,fallback=>sub {encode_error('Invalid value. JSON can only reference.')},indent_length=>3,};bless$self,$class}sub encode {return $_[0]->PP_encode_json($_[1])}sub decode {return $_[0]->PP_decode_json($_[1],0x00000000)}sub decode_prefix {return $_[0]->PP_decode_json($_[1],0x00000001)}sub pretty {my ($self,$v)=@_;my$enable=defined$v ? $v : 1;if ($enable){$self->indent(1)->indent_length(3)->space_before(1)->space_after(1)}else {$self->indent(0)->space_before(0)->space_after(0)}$self}sub max_depth {my$max=defined $_[1]? $_[1]: 0x80000000;$_[0]->{max_depth}=$max;$_[0]}sub get_max_depth {$_[0]->{max_depth}}sub max_size {my$max=defined $_[1]? $_[1]: 0;$_[0]->{max_size}=$max;$_[0]}sub get_max_size {$_[0]->{max_size}}sub filter_json_object {$_[0]->{cb_object}=defined $_[1]? $_[1]: 0;$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub filter_json_single_key_object {if (@_ > 1){$_[0]->{cb_sk_object}->{$_[1]}=$_[2]}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub indent_length {if (!defined $_[1]or $_[1]> 15 or $_[1]< 0){Carp::carp "The acceptable range of indent_length() is 0 to 15."}else {$_[0]->{indent_length}=$_[1]}$_[0]}sub get_indent_length {$_[0]->{indent_length}}sub sort_by {$_[0]->{sort_by}=defined $_[1]? $_[1]: 1;$_[0]}sub allow_bigint {Carp::carp("allow_bigint() is obsoleted. use allow_bignum() insted.")}{my$max_depth;my$indent;my$ascii;my$latin1;my$utf8;my$space_before;my$space_after;my$canonical;my$allow_blessed;my$convert_blessed;my$indent_length;my$escape_slash;my$bignum;my$as_nonblessed;my$depth;my$indent_count;my$keysort;sub PP_encode_json {my$self=shift;my$obj=shift;$indent_count=0;$depth=0;my$idx=$self->{PROPS};($ascii,$latin1,$utf8,$indent,$canonical,$space_before,$space_after,$allow_blessed,$convert_blessed,$escape_slash,$bignum,$as_nonblessed)=@{$idx}[P_ASCII .. P_SPACE_AFTER,P_ALLOW_BLESSED,P_CONVERT_BLESSED,P_ESCAPE_SLASH,P_ALLOW_BIGNUM,P_AS_NONBLESSED];($max_depth,$indent_length)=@{$self}{qw/max_depth indent_length/};$keysort=$canonical ? sub {$a cmp $b}: undef;if ($self->{sort_by}){$keysort=ref($self->{sort_by})eq 'CODE' ? $self->{sort_by}: $self->{sort_by}=~ /\D+/ ? $self->{sort_by}: sub {$a cmp $b}}encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")if(!ref$obj and!$idx->[P_ALLOW_NONREF ]);my$str=$self->object_to_json($obj);$str .= "\n" if ($indent);unless ($ascii or $latin1 or $utf8){utf8::upgrade($str)}if ($idx->[P_SHRINK ]){utf8::downgrade($str,1)}return$str}sub object_to_json {my ($self,$obj)=@_;my$type=ref($obj);if($type eq 'HASH'){return$self->hash_to_json($obj)}elsif($type eq 'ARRAY'){return$self->array_to_json($obj)}elsif ($type){if (blessed($obj)){return$self->value_to_json($obj)if ($obj->isa('JSON::PP::Boolean'));if ($convert_blessed and $obj->can('TO_JSON')){my$result=$obj->TO_JSON();if (defined$result and ref($result)){if (refaddr($obj)eq refaddr($result)){encode_error(sprintf("%s::TO_JSON method returned same object as was passed instead of a new one",ref$obj))}}return$self->object_to_json($result)}return "$obj" if ($bignum and _is_bignum($obj));return$self->blessed_to_json($obj)if ($allow_blessed and $as_nonblessed);encode_error(sprintf("encountered object '%s', but neither allow_blessed " ."nor convert_blessed settings are enabled",$obj))unless ($allow_blessed);return 'null'}else {return$self->value_to_json($obj)}}else{return$self->value_to_json($obj)}}sub hash_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');my$del=($space_before ? ' ' : '').':' .($space_after ? ' ' : '');for my$k (_sort($obj)){if (OLD_PERL){utf8::decode($k)}push@res,string_to_json($self,$k).$del .($self->object_to_json($obj->{$k})|| $self->value_to_json($obj->{$k}))}--$depth;$self->_down_indent()if ($indent);return '{' .(@res ? $pre : '').(@res ? join(",$pre",@res).$post : '').'}'}sub array_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');for my$v (@$obj){push@res,$self->object_to_json($v)|| $self->value_to_json($v)}--$depth;$self->_down_indent()if ($indent);return '[' .(@res ? $pre : '').(@res ? join(",$pre",@res).$post : '').']'}sub value_to_json {my ($self,$value)=@_;return 'null' if(!defined$value);my$b_obj=B::svref_2object(\$value);my$flags=$b_obj->FLAGS;return$value if$flags & (B::SVp_IOK | B::SVp_NOK)and!($flags & B::SVp_POK);my$type=ref($value);if(!$type){return string_to_json($self,$value)}elsif(blessed($value)and $value->isa('JSON::PP::Boolean')){return $$value==1 ? 'true' : 'false'}elsif ($type){if ((overload::StrVal($value)=~ /=(\w+)/)[0]){return$self->value_to_json("$value")}if ($type eq 'SCALAR' and defined $$value){return $$value eq '1' ? 'true' : $$value eq '0' ? 'false' : $self->{PROPS}->[P_ALLOW_UNKNOWN ]? 'null' : encode_error("cannot encode reference to scalar")}if ($self->{PROPS}->[P_ALLOW_UNKNOWN ]){return 'null'}else {if ($type eq 'SCALAR' or $type eq 'REF'){encode_error("cannot encode reference to scalar")}else {encode_error("encountered $value, but JSON can only represent references to arrays or hashes")}}}else {return$self->{fallback}->($value)if ($self->{fallback}and ref($self->{fallback})eq 'CODE');return 'null'}}my%esc=("\n"=>'\n',"\r"=>'\r',"\t"=>'\t',"\f"=>'\f',"\b"=>'\b',"\""=>'\"',"\\"=>'\\\\',"\'"=>'\\\'',);sub string_to_json {my ($self,$arg)=@_;$arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;$arg =~ s/\//\\\//g if ($escape_slash);$arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;if ($ascii){$arg=JSON_PP_encode_ascii($arg)}if ($latin1){$arg=JSON_PP_encode_latin1($arg)}if ($utf8){utf8::encode($arg)}return '"' .$arg .'"'}sub blessed_to_json {my$reftype=reftype($_[1])|| '';if ($reftype eq 'HASH'){return $_[0]->hash_to_json($_[1])}elsif ($reftype eq 'ARRAY'){return $_[0]->array_to_json($_[1])}else {return 'null'}}sub encode_error {my$error=shift;Carp::croak "$error"}sub _sort {defined$keysort ? (sort$keysort (keys %{$_[0]})): keys %{$_[0]}}sub _up_indent {my$self=shift;my$space=' ' x $indent_length;my ($pre,$post)=('','');$post="\n" .$space x $indent_count;$indent_count++;$pre="\n" .$space x $indent_count;return ($pre,$post)}sub _down_indent {$indent_count--}sub PP_encode_box {{depth=>$depth,indent_count=>$indent_count,}}}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_surrogates {my$uni=$_[0]- 0x10000;return ($uni / 0x400 + 0xD800,$uni % 0x400 + 0xDC00)}sub _is_bignum {$_[0]->isa('Math::BigInt')or $_[0]->isa('Math::BigFloat')}my$max_intsize;BEGIN {my$checkint=1111;for my$d (5..64){$checkint .= 1;my$int=eval qq| $checkint |;if ($int =~ /[eE]/){$max_intsize=$d - 1;last}}}{my%escapes=(b=>"\x8",t=>"\x9",n=>"\xA",f=>"\xC",r=>"\xD",'\\'=>'\\','"'=>'"','/'=>'/',);my$text;my$at;my$ch;my$len;my$depth;my$encoding;my$is_valid_utf8;my$utf8_len;my$utf8;my$max_depth;my$max_size;my$relaxed;my$cb_object;my$cb_sk_object;my$F_HOOK;my$allow_bigint;my$singlequote;my$loose;my$allow_barekey;sub PP_decode_json {my ($self,$opt);($self,$text,$opt)=@_;($at,$ch,$depth)=(0,'',0);if (!defined$text or ref$text){decode_error("malformed JSON string, neither array, object, number, string or atom")}my$idx=$self->{PROPS};($utf8,$relaxed,$loose,$allow_bigint,$allow_barekey,$singlequote)=@{$idx}[P_UTF8,P_RELAXED,P_LOOSE .. P_ALLOW_SINGLEQUOTE];if ($utf8){utf8::downgrade($text,1)or Carp::croak("Wide character in subroutine entry")}else {utf8::upgrade($text);utf8::encode($text)}$len=length$text;($max_depth,$max_size,$cb_object,$cb_sk_object,$F_HOOK)=@{$self}{qw/max_depth max_size cb_object cb_sk_object F_HOOK/};if ($max_size > 1){use bytes;my$bytes=length$text;decode_error(sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s" ,$bytes,$max_size),1)if ($bytes > $max_size)}my@octets=unpack('C4',$text);$encoding=($octets[0]and $octets[1])? 'UTF-8' : (!$octets[0]and $octets[1])? 'UTF-16BE' : (!$octets[0]and!$octets[1])? 'UTF-32BE' : ($octets[2])? 'UTF-16LE' : (!$octets[2])? 'UTF-32LE' : 'unknown';white();my$valid_start=defined$ch;my$result=value();return undef if (!$result && ($opt & 0x10000000));decode_error("malformed JSON string, neither array, object, number, string or atom")unless$valid_start;if (!$idx->[P_ALLOW_NONREF ]and!ref$result){decode_error('JSON text must be an object or array (but found number, string, true, false or null,' .' use allow_nonref to allow this)',1)}Carp::croak('something wrong.')if$len < $at;my$consumed=defined$ch ? $at - 1 : $at;white();if ($ch){return ($result,$consumed)if ($opt & 0x00000001);decode_error("garbage after JSON object")}($opt & 0x00000001)? ($result,$consumed): $result}sub next_chr {return$ch=undef if($at >= $len);$ch=substr($text,$at++,1)}sub value {white();return if(!defined$ch);return object()if($ch eq '{');return array()if($ch eq '[');return string()if($ch eq '"' or ($singlequote and $ch eq "'"));return number()if($ch =~ /[0-9]/ or $ch eq '-');return word()}sub string {my ($i,$s,$t,$u);my$utf16;my$is_utf8;($is_valid_utf8,$utf8_len)=('',0);$s='';if($ch eq '"' or ($singlequote and $ch eq "'")){my$boundChar=$ch;OUTER: while(defined(next_chr())){if($ch eq $boundChar){next_chr();if ($utf16){decode_error("missing low surrogate character in surrogate pair")}utf8::decode($s)if($is_utf8);return$s}elsif($ch eq '\\'){next_chr();if(exists$escapes{$ch}){$s .= $escapes{$ch}}elsif($ch eq 'u'){my$u='';for(1..4){$ch=next_chr();last OUTER if($ch !~ /[0-9a-fA-F]/);$u .= $ch}if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/){$utf16=$u}elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/){unless (defined$utf16){decode_error("missing high surrogate character in surrogate pair")}$is_utf8=1;$s .= JSON_PP_decode_surrogates($utf16,$u)|| next;$utf16=undef}else {if (defined$utf16){decode_error("surrogate pair expected")}if ((my$hex=hex($u))> 127){$is_utf8=1;$s .= JSON_PP_decode_unicode($u)|| next}else {$s .= chr$hex}}}else{unless ($loose){$at -= 2;decode_error('illegal backslash escape sequence in string')}$s .= $ch}}else{if (ord$ch > 127){unless($ch=is_valid_utf8($ch)){$at -= 1;decode_error("malformed UTF-8 character in JSON string")}else {$at += $utf8_len - 1}$is_utf8=1}if (!$loose){if ($ch =~ /[\x00-\x1f\x22\x5c]/){$at--;decode_error('invalid character encountered while parsing JSON string')}}$s .= $ch}}}decode_error("unexpected end of string while parsing JSON string")}sub white {while(defined$ch){if($ch le ' '){next_chr()}elsif($ch eq '/'){next_chr();if(defined$ch and $ch eq '/'){1 while(defined(next_chr())and $ch ne "\n" and $ch ne "\r")}elsif(defined$ch and $ch eq '*'){next_chr();while(1){if(defined$ch){if($ch eq '*'){if(defined(next_chr())and $ch eq '/'){next_chr();last}}else{next_chr()}}else{decode_error("Unterminated comment")}}next}else{$at--;decode_error("malformed JSON string, neither array, object, number, string or atom")}}else{if ($relaxed and $ch eq '#'){pos($text)=$at;$text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;$at=pos($text);next_chr;next}last}}}sub array {my$a=$_[0]|| [];decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq ']'){--$depth;next_chr();return$a}else {while(defined($ch)){push @$a,value();white();if (!defined$ch){last}if($ch eq ']'){--$depth;next_chr();return$a}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq ']'){--$depth;next_chr();return$a}}}decode_error(", or ] expected while parsing array")}sub object {my$o=$_[0]|| {};my$k;decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}else {while (defined$ch){$k=($allow_barekey and $ch ne '"' and $ch ne "'")? bareKey(): string();white();if(!defined$ch or $ch ne ':'){$at--;decode_error("':' expected")}next_chr();$o->{$k}=value();white();last if (!defined$ch);if($ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}}}$at--;decode_error(", or } expected while parsing object/hash")}sub bareKey {my$key;while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){$key .= $ch;next_chr()}return$key}sub word {my$word=substr($text,$at-1,4);if($word eq 'true'){$at += 3;next_chr;return$JSON::PP::true}elsif($word eq 'null'){$at += 3;next_chr;return undef}elsif($word eq 'fals'){$at += 3;if(substr($text,$at,1)eq 'e'){$at++;next_chr;return$JSON::PP::false}}$at--;decode_error("'null' expected")if ($word =~ /^n/);decode_error("'true' expected")if ($word =~ /^t/);decode_error("'false' expected")if ($word =~ /^f/);decode_error("malformed JSON string, neither array, object, number, string or atom")}sub number {my$n='';my$v;if($ch eq '0'){my$peek=substr($text,$at,1);my$hex=$peek =~ /[xX]/;if($hex){decode_error("malformed number (leading zero must not be followed by another digit)");($n)=(substr($text,$at+1)=~ /^([0-9a-fA-F]+)/)}else{($n)=(substr($text,$at)=~ /^([0-7]+)/);if (defined$n and length$n > 1){decode_error("malformed number (leading zero must not be followed by another digit)")}}if(defined$n and length($n)){if (!$hex and length($n)==1){decode_error("malformed number (leading zero must not be followed by another digit)")}$at += length($n)+ $hex;next_chr;return$hex ? hex($n): oct($n)}}if($ch eq '-'){$n='-';next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after initial minus)")}}while(defined$ch and $ch =~ /\d/){$n .= $ch;next_chr}if(defined$ch and $ch eq '.'){$n .= '.';next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after decimal point)")}else {$n .= $ch}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}if(defined$ch and ($ch eq 'e' or $ch eq 'E')){$n .= $ch;next_chr;if(defined($ch)and ($ch eq '+' or $ch eq '-')){$n .= $ch;next_chr;if (!defined$ch or $ch =~ /\D/){decode_error("malformed number (no digits after exp sign)")}$n .= $ch}elsif(defined($ch)and $ch =~ /\d/){$n .= $ch}else {decode_error("malformed number (no digits after exp sign)")}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}$v .= $n;if ($v !~ /[.eE]/ and length$v > $max_intsize){if ($allow_bigint){require Math::BigInt;return Math::BigInt->new($v)}else {return "$v"}}elsif ($allow_bigint){require Math::BigFloat;return Math::BigFloat->new($v)}return 0+$v}sub is_valid_utf8 {$utf8_len=$_[0]=~ /[\x00-\x7F]/ ? 1 : $_[0]=~ /[\xC2-\xDF]/ ? 2 : $_[0]=~ /[\xE0-\xEF]/ ? 3 : $_[0]=~ /[\xF0-\xF4]/ ? 4 : 0 ;return unless$utf8_len;my$is_valid_utf8=substr($text,$at - 1,$utf8_len);return ($is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x)? $is_valid_utf8 : ''}sub decode_error {my$error=shift;my$no_rep=shift;my$str=defined$text ? substr($text,$at): '';my$mess='';my$type=$] >= 5.008 ? 'U*' : $] < 5.006 ? 'C*' : utf8::is_utf8($str)? 'U*' : 'C*' ;for my$c (unpack($type,$str)){$mess .= $c==0x07 ? '\a' : $c==0x09 ? '\t' : $c==0x0a ? '\n' : $c==0x0d ? '\r' : $c==0x0c ? '\f' : $c < 0x20 ? sprintf('\x{%x}',$c): $c==0x5c ? '\\\\' : $c < 0x80 ? chr($c): sprintf('\x{%x}',$c);if (length$mess >= 20){$mess .= '...';last}}unless (length$mess){$mess='(end of string)'}Carp::croak ($no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")")}sub _json_object_hook {my$o=$_[0];my@ks=keys %{$o};if ($cb_sk_object and @ks==1 and exists$cb_sk_object->{$ks[0]}and ref$cb_sk_object->{$ks[0]}){my@val=$cb_sk_object->{$ks[0]}->($o->{$ks[0]});if (@val==1){return$val[0]}}my@val=$cb_object->($o)if ($cb_object);if (@val==0 or @val > 1){return$o}else {return$val[0]}}sub PP_decode_box {{text=>$text,at=>$at,ch=>$ch,len=>$len,depth=>$depth,encoding=>$encoding,is_valid_utf8=>$is_valid_utf8,}}}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$un=pack('U*',$uni);utf8::encode($un);return$un}sub _decode_unicode {my$un=pack('U',hex shift);utf8::encode($un);return$un}BEGIN {unless (defined&utf8::is_utf8){require Encode;*utf8::is_utf8=*Encode::is_utf8}if ($] >= 5.008){*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&_decode_unicode}if ($] >= 5.008 and $] < 5.008003){package JSON::PP;require subs;subs->import('join');eval q|
              sub join {
                  return '' if (@_ < 2);
                  my $j   = shift;
                  my $str = shift;
                  for (@_) { $str .= $j . $_; }
                  return $str;
              }
          |}sub JSON::PP::incr_parse {local$Carp::CarpLevel=1;($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_parse(@_)}sub JSON::PP::incr_skip {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_skip}sub JSON::PP::incr_reset {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_reset}eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
                  Carp::croak("incr_text can not be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ($] >= 5.006)}BEGIN {eval 'require Scalar::Util';unless($@){*JSON::PP::blessed=\&Scalar::Util::blessed;*JSON::PP::reftype=\&Scalar::Util::reftype;*JSON::PP::refaddr=\&Scalar::Util::refaddr}else{eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';*JSON::PP::blessed=sub {local($@,$SIG{__DIE__},$SIG{__WARN__});ref($_[0])? eval {$_[0]->a_sub_not_likely_to_be_here}: undef};my%tmap=qw(B::NULL SCALAR B::HV HASH B::AV ARRAY B::CV CODE B::IO IO B::GV GLOB B::REGEXP REGEXP);*JSON::PP::reftype=sub {my$r=shift;return undef unless length(ref($r));my$t=ref(B::svref_2object($r));return exists$tmap{$t}? $tmap{$t}: length(ref($$r))? 'REF' : 'SCALAR'};*JSON::PP::refaddr=sub {return undef unless length(ref($_[0]));my$addr;if(defined(my$pkg=blessed($_[0]))){$addr .= bless $_[0],'Scalar::Util::Fake';bless $_[0],$pkg}else {$addr .= $_[0]}$addr =~ /0x(\w+)/;local $^W;hex($1)}}}$JSON::PP::true=do {bless \(my$dummy=1),"JSON::PP::Boolean"};$JSON::PP::false=do {bless \(my$dummy=0),"JSON::PP::Boolean"};sub is_bool {defined $_[0]and UNIVERSAL::isa($_[0],"JSON::PP::Boolean")}sub true {$JSON::PP::true}sub false {$JSON::PP::false}sub null {undef}package JSON::PP::Boolean;use overload ("0+"=>sub {${$_[0]}},"++"=>sub {$_[0]=${$_[0]}+ 1},"--"=>sub {$_[0]=${$_[0]}- 1},fallback=>1,);package JSON::PP::IncrParser;use strict;use constant INCR_M_WS=>0;use constant INCR_M_STR=>1;use constant INCR_M_BS=>2;use constant INCR_M_JSON=>3;use constant INCR_M_C0=>4;use constant INCR_M_C1=>5;$JSON::PP::IncrParser::VERSION='1.01';my$unpack_format=$] < 5.006 ? 'C*' : 'U*';sub new {my ($class)=@_;bless {incr_nest=>0,incr_text=>undef,incr_parsing=>0,incr_p=>0,},$class}sub incr_parse {my ($self,$coder,$text)=@_;$self->{incr_text}='' unless (defined$self->{incr_text});if (defined$text){if (utf8::is_utf8($text)and!utf8::is_utf8($self->{incr_text})){utf8::upgrade($self->{incr_text});utf8::decode($self->{incr_text})}$self->{incr_text}.= $text}my$max_size=$coder->get_max_size;if (defined wantarray){$self->{incr_mode}=INCR_M_WS unless defined$self->{incr_mode};if (wantarray){my@ret;$self->{incr_parsing}=1;do {push@ret,$self->_incr_parse($coder,$self->{incr_text});unless (!$self->{incr_nest}and $self->{incr_mode}==INCR_M_JSON){$self->{incr_mode}=INCR_M_WS if$self->{incr_mode}!=INCR_M_STR}}until (length$self->{incr_text}>= $self->{incr_p});$self->{incr_parsing}=0;return@ret}else {$self->{incr_parsing}=1;my$obj=$self->_incr_parse($coder,$self->{incr_text});$self->{incr_parsing}=0 if defined$obj;return$obj ? $obj : undef}}}sub _incr_parse {my ($self,$coder,$text,$skip)=@_;my$p=$self->{incr_p};my$restore=$p;my@obj;my$len=length$text;if ($self->{incr_mode}==INCR_M_WS){while ($len > $p){my$s=substr($text,$p,1);$p++ and next if (0x20 >= unpack($unpack_format,$s));$self->{incr_mode}=INCR_M_JSON;last}}while ($len > $p){my$s=substr($text,$p++,1);if ($s eq '"'){if (substr($text,$p - 2,1)eq '\\'){next}if ($self->{incr_mode}!=INCR_M_STR){$self->{incr_mode}=INCR_M_STR}else {$self->{incr_mode}=INCR_M_JSON;unless ($self->{incr_nest}){last}}}if ($self->{incr_mode}==INCR_M_JSON){if ($s eq '[' or $s eq '{'){if (++$self->{incr_nest}> $coder->get_max_depth){Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')}}elsif ($s eq ']' or $s eq '}'){last if (--$self->{incr_nest}<= 0)}elsif ($s eq '#'){while ($len > $p){last if substr($text,$p++,1)eq "\n"}}}}$self->{incr_p}=$p;return if ($self->{incr_mode}==INCR_M_STR and not $self->{incr_nest});return if ($self->{incr_mode}==INCR_M_JSON and $self->{incr_nest}> 0);return '' unless (length substr($self->{incr_text},0,$p));local$Carp::CarpLevel=2;$self->{incr_p}=$restore;$self->{incr_c}=$p;my ($obj,$tail)=$coder->PP_decode_json(substr($self->{incr_text},0,$p),0x10000001);$self->{incr_text}=substr($self->{incr_text},$p);$self->{incr_p}=0;return$obj || ''}sub incr_text {if ($_[0]->{incr_parsing}){Carp::croak("incr_text can not be called when the incremental parser already started parsing")}$_[0]->{incr_text}}sub incr_skip {my$self=shift;$self->{incr_text}=substr($self->{incr_text},$self->{incr_c});$self->{incr_p}=0}sub incr_reset {my$self=shift;$self->{incr_text}=undef;$self->{incr_p}=0;$self->{incr_mode}=0;$self->{incr_nest}=0;$self->{incr_parsing}=0}1;
JSON_PP

$fatpacked{"JSON/PP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP_BOOLEAN';
  use JSON::PP ();use strict;1;
JSON_PP_BOOLEAN

$fatpacked{"Module/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE';
  package Module::CPANfile;use strict;use warnings;use Cwd;use Carp ();use Module::CPANfile::Environment;use Module::CPANfile::Requirement;our$VERSION='1.1000';sub new {my($class,$file)=@_;bless {},$class}sub load {my($proto,$file)=@_;my$self=ref$proto ? $proto : $proto->new;$self->parse($file || Cwd::abs_path('cpanfile'));$self}sub save {my($self,$path)=@_;open my$out,">",$path or die "$path: $!";print {$out}$self->to_string}sub parse {my($self,$file)=@_;my$code=do {open my$fh,"<",$file or die "$file: $!";join '',<$fh>};my$env=Module::CPANfile::Environment->new($file);$env->parse($code)or die $@;$self->{_mirrors}=$env->mirrors;$self->{_prereqs}=$env->prereqs}sub from_prereqs {my($proto,$prereqs)=@_;my$self=$proto->new;$self->{_prereqs}=Module::CPANfile::Prereqs->from_cpan_meta($prereqs);$self}sub mirrors {my$self=shift;$self->{_mirrors}|| []}sub features {my$self=shift;map$self->feature($_),$self->{_prereqs}->identifiers}sub feature {my($self,$identifier)=@_;$self->{_prereqs}->feature($identifier)}sub prereq {shift->prereqs}sub prereqs {my$self=shift;$self->{_prereqs}->as_cpan_meta}sub merged_requirements {my$self=shift;$self->{_prereqs}->merged_requirements}sub effective_prereqs {my($self,$features)=@_;$self->prereqs_with(@{$features || []})}sub prereqs_with {my($self,@feature_identifiers)=@_;my$prereqs=$self->prereqs;my@others=map {$self->feature($_)->prereqs}@feature_identifiers;$prereqs->with_merged_prereqs(\@others)}sub prereq_specs {my$self=shift;$self->prereqs->as_string_hash}sub prereq_for_module {my($self,$module)=@_;$self->{_prereqs}->find($module)}sub options_for_module {my($self,$module)=@_;my$prereq=$self->prereq_for_module($module)or return;$prereq->requirement->options}sub merge_meta {my($self,$file,$version)=@_;require CPAN::Meta;$version ||= $file =~ /\.yml$/ ? '1.4' : '2';my$prereq=$self->prereqs;my$meta=CPAN::Meta->load_file($file);my$prereqs_hash=$prereq->with_merged_prereqs($meta->effective_prereqs)->as_string_hash;my$struct={%{$meta->as_struct},prereqs=>$prereqs_hash };CPAN::Meta->new($struct)->save($file,{version=>$version })}sub _dump {my$str=shift;require Data::Dumper;chomp(my$value=Data::Dumper->new([$str])->Terse(1)->Dump);$value}sub to_string {my($self,$include_empty)=@_;my$mirrors=$self->mirrors;my$prereqs=$self->prereq_specs;my$code='';$code .= $self->_dump_mirrors($mirrors);$code .= $self->_dump_prereqs($prereqs,$include_empty);for my$feature ($self->features){$code .= sprintf "feature %s, %s => sub {\n",_dump($feature->{identifier}),_dump($feature->{description});$code .= $self->_dump_prereqs($feature->{spec},$include_empty,4);$code .= "}\n\n"}$code =~ s/\n+$/\n/s;$code}sub _dump_mirrors {my($self,$mirrors)=@_;my$code="";for my$url (@$mirrors){$code .= "mirror '$url';\n"}$code =~ s/\n+$/\n/s;$code}sub _dump_prereqs {my($self,$prereqs,$include_empty,$base_indent)=@_;my$code='';for my$phase (qw(runtime configure build test develop)){my$indent=$phase eq 'runtime' ? '' : '    ';$indent=(' ' x ($base_indent || 0)).$indent;my($phase_code,$requirements);$phase_code .= "on $phase => sub {\n" unless$phase eq 'runtime';for my$type (qw(requires recommends suggests conflicts)){for my$mod (sort keys %{$prereqs->{$phase}{$type}}){my$ver=$prereqs->{$phase}{$type}{$mod};$phase_code .= $ver eq '0' ? "${indent}$type '$mod';\n" : "${indent}$type '$mod', '$ver';\n";$requirements++}}$phase_code .= "\n" unless$requirements;$phase_code .= "};\n" unless$phase eq 'runtime';$code .= $phase_code ."\n" if$requirements or $include_empty}$code =~ s/\n+$/\n/s;$code}1;
MODULE_CPANFILE

$fatpacked{"Module/CPANfile/Environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_ENVIRONMENT';
  package Module::CPANfile::Environment;use strict;use warnings;use Module::CPANfile::Prereqs;use Carp ();my@bindings=qw(on requires recommends suggests conflicts feature osname mirror configure_requires build_requires test_requires author_requires);my$file_id=1;sub new {my($class,$file)=@_;bless {file=>$file,phase=>'runtime',feature=>undef,features=>{},prereqs=>Module::CPANfile::Prereqs->new,mirrors=>[],},$class}sub bind {my$self=shift;my$pkg=caller;for my$binding (@bindings){no strict 'refs';*{"$pkg\::$binding"}=sub {$self->$binding(@_)}}}sub parse {my($self,$code)=@_;my$err;{local $@;$file_id++;$self->_evaluate(<<EVAL);$err=$@}if ($err){die "Parsing $self->{file} failed: $err"};return 1}sub _evaluate {my$_environment=$_[0];eval $_[1]}sub prereqs {$_[0]->{prereqs}}sub mirrors {$_[0]->{mirrors}}sub on {my($self,$phase,$code)=@_;local$self->{phase}=$phase;$code->()}sub feature {my($self,$identifier,$description,$code)=@_;if (@_==3 && ref($description)eq 'CODE'){$code=$description;$description=$identifier}unless (ref$description eq '' && ref$code eq 'CODE'){Carp::croak("Usage: feature 'identifier', 'Description' => sub { ... }")}local$self->{feature}=$identifier;$self->prereqs->add_feature($identifier,$description);$code->()}sub osname {die "TODO"}sub mirror {my($self,$url)=@_;push @{$self->{mirrors}},$url}sub requirement_for {my($self,$module,@args)=@_;my$requirement=0;$requirement=shift@args if@args % 2;return Module::CPANfile::Requirement->new(name=>$module,version=>$requirement,@args,)}sub requires {my$self=shift;$self->add_prereq(requires=>@_)}sub recommends {my$self=shift;$self->add_prereq(recommends=>@_)}sub suggests {my$self=shift;$self->add_prereq(suggests=>@_)}sub conflicts {my$self=shift;$self->add_prereq(conflicts=>@_)}sub add_prereq {my($self,$type,$module,@args)=@_;$self->prereqs->add_prereq(feature=>$self->{feature},phase=>$self->{phase},type=>$type,module=>$module,requirement=>$self->requirement_for($module,@args),)}sub configure_requires {my($self,@args)=@_;$self->on(configure=>sub {$self->requires(@args)})}sub build_requires {my($self,@args)=@_;$self->on(build=>sub {$self->requires(@args)})}sub test_requires {my($self,@args)=@_;$self->on(test=>sub {$self->requires(@args)})}sub author_requires {my($self,@args)=@_;$self->on(develop=>sub {$self->requires(@args)})}1;
  package Module::CPANfile::Sandbox$file_id;
  no warnings;
  BEGIN { \$_environment->bind }
  
  # line 1 "$self->{file}"
  $code;
  EVAL
MODULE_CPANFILE_ENVIRONMENT

$fatpacked{"Module/CPANfile/Prereq.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQ';
  package Module::CPANfile::Prereq;use strict;sub new {my($class,%options)=@_;bless \%options,$class}sub feature {$_[0]->{feature}}sub phase {$_[0]->{phase}}sub type {$_[0]->{type}}sub module {$_[0]->{module}}sub requirement {$_[0]->{requirement}}sub match_feature {my($self,$identifier)=@_;no warnings 'uninitialized';$self->feature eq $identifier}1;
MODULE_CPANFILE_PREREQ

$fatpacked{"Module/CPANfile/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQS';
  package Module::CPANfile::Prereqs;use strict;use Carp ();use CPAN::Meta::Feature;use Module::CPANfile::Prereq;sub from_cpan_meta {my($class,$prereqs)=@_;my$self=$class->new;for my$phase (keys %$prereqs){for my$type (keys %{$prereqs->{$phase}}){while (my($module,$requirement)=each %{$prereqs->{$phase}{$type}}){$self->add_prereq(phase=>$phase,type=>$type,module=>$module,requirement=>Module::CPANfile::Requirement->new(name=>$module,version=>$requirement),)}}}$self}sub new {my$class=shift;bless {prereqs=>[],features=>{},},$class}sub add_feature {my($self,$identifier,$description)=@_;$self->{features}{$identifier}={description=>$description }}sub add_prereq {my($self,%args)=@_;$self->add(Module::CPANfile::Prereq->new(%args))}sub add {my($self,$prereq)=@_;push @{$self->{prereqs}},$prereq}sub as_cpan_meta {my$self=shift;$self->{cpanmeta}||= $self->build_cpan_meta}sub build_cpan_meta {my($self,$identifier)=@_;my$prereq_spec={};$self->prereq_each($identifier,sub {my$prereq=shift;$prereq_spec->{$prereq->phase}{$prereq->type}{$prereq->module}=$prereq->requirement->version});CPAN::Meta::Prereqs->new($prereq_spec)}sub prereq_each {my($self,$identifier,$code)=@_;for my$prereq (@{$self->{prereqs}}){next unless$prereq->match_feature($identifier);$code->($prereq)}}sub merged_requirements {my$self=shift;my$reqs=CPAN::Meta::Requirements->new;for my$prereq (@{$self->{prereqs}}){$reqs->add_string_requirement($prereq->module,$prereq->requirement->version)}$reqs}sub find {my($self,$module)=@_;for my$prereq (@{$self->{prereqs}}){return$prereq if$prereq->module eq $module}return}sub identifiers {my$self=shift;keys %{$self->{features}}}sub feature {my($self,$identifier)=@_;my$data=$self->{features}{$identifier}or Carp::croak("Unknown feature '$identifier'");my$prereqs=$self->build_cpan_meta($identifier);CPAN::Meta::Feature->new($identifier,{description=>$data->{description},prereqs=>$prereqs->as_string_hash,})}1;
MODULE_CPANFILE_PREREQS

$fatpacked{"Module/CPANfile/Requirement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_REQUIREMENT';
  package Module::CPANfile::Requirement;use strict;sub new {my ($class,%args)=@_;$args{version}||= 0;bless +{name=>delete$args{name},version=>delete$args{version},options=>\%args,},$class}sub name {$_[0]->{name}}sub version {$_[0]->{version}}sub options {$_[0]->{options}}sub has_options {keys %{$_[0]->{options}}> 0}1;
MODULE_CPANFILE_REQUIREMENT

$fatpacked{"Module/Metadata.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_METADATA';
  package Module::Metadata;sub __clean_eval {eval $_[0]}use strict;use warnings;our$VERSION='1.000027';use Carp qw/croak/;use File::Spec;BEGIN {eval {require Fcntl;Fcntl->import('SEEK_SET');1}or *SEEK_SET=sub {0}}use version 0.87;BEGIN {if ($INC{'Log/Contextual.pm'}){require "Log/Contextual/WarnLogger.pm";Log::Contextual->import('log_info','-default_logger'=>Log::Contextual::WarnLogger->new({env_prefix=>'MODULE_METADATA',}),)}else {*log_info=sub (&) {warn $_[0]->()}}}use File::Find qw(find);my$V_NUM_REGEXP=qr{v?[0-9._]+};my$PKG_FIRST_WORD_REGEXP=qr{ # the FIRST word in a package name
    [a-zA-Z_]                     # the first word CANNOT start with a digit
      (?:
        [\w']?                    # can contain letters, digits, _, or ticks
        \w                        # But, NO multi-ticks or trailing ticks
      )*
  }x;my$PKG_ADDL_WORD_REGEXP=qr{ # the 2nd+ word in a package name
    \w                           # the 2nd+ word CAN start with digits
      (?:
        [\w']?                   # and can contain letters or ticks
        \w                       # But, NO multi-ticks or trailing ticks
      )*
  }x;my$PKG_NAME_REGEXP=qr{ # match a package name
    (?: :: )?               # a pkg name can start with arisdottle
    $PKG_FIRST_WORD_REGEXP  # a package word
    (?:
      (?: :: )+             ### arisdottle (allow one or many times)
      $PKG_ADDL_WORD_REGEXP ### a package word
    )*                      # ^ zero, one or many times
    (?:
      ::                    # allow trailing arisdottle
    )?
  }x;my$PKG_REGEXP=qr{   # match a package declaration
    ^[\s\{;]*             # intro chars on a line
    package               # the word 'package'
    \s+                   # whitespace
    ($PKG_NAME_REGEXP)    # a package name
    \s*                   # optional whitespace
    ($V_NUM_REGEXP)?        # optional version number
    \s*                   # optional whitesapce
    [;\{]                 # semicolon line terminator or block start (since 5.16)
  }x;my$VARNAME_REGEXP=qr{ # match fully-qualified VERSION name
    ([\$*])         # sigil - $ or *
    (
      (             # optional leading package name
        (?:::|\')?  # possibly starting like just :: (a la $::VERSION)
        (?:\w+(?:::|\'))*  # Foo::Bar:: ...
      )?
      VERSION
    )\b
  }x;my$VERS_REGEXP=qr{ # match a VERSION definition
    (?:
      \(\s*$VARNAME_REGEXP\s*\) # with parens
    |
      $VARNAME_REGEXP           # without parens
    )
    \s*
    =[^=~>]  # = but not ==, nor =~, nor =>
  }x;sub new_from_file {my$class=shift;my$filename=File::Spec->rel2abs(shift);return undef unless defined($filename)&& -f $filename;return$class->_init(undef,$filename,@_)}sub new_from_handle {my$class=shift;my$handle=shift;my$filename=shift;return undef unless defined($handle)&& defined($filename);$filename=File::Spec->rel2abs($filename);return$class->_init(undef,$filename,@_,handle=>$handle)}sub new_from_module {my$class=shift;my$module=shift;my%props=@_;$props{inc}||= \@INC;my$filename=$class->find_module_by_name($module,$props{inc});return undef unless defined($filename)&& -f $filename;return$class->_init($module,$filename,%props)}{my$compare_versions=sub {my ($v1,$op,$v2)=@_;$v1=version->new($v1)unless UNIVERSAL::isa($v1,'version');my$eval_str="\$v1 $op \$v2";my$result=eval$eval_str;log_info {"error comparing versions: '$eval_str' $@"}if $@;return$result};my$normalize_version=sub {my ($version)=@_;if ($version =~ /[=<>!,]/){}elsif (ref$version eq 'version'){$version=$version->is_qv ? $version->normal : $version->stringify}elsif ($version =~ /^[^v][^.]*\.[^.]+\./){$version="v$version"}else {}return$version};my$resolve_module_versions=sub {my$packages=shift;my($file,$version);my$err='';for my$p (@$packages){if (defined($p->{version})){if (defined($version)){if ($compare_versions->($version,'!=',$p->{version})){$err .= "  $p->{file} ($p->{version})\n"}else {}}else {$file=$p->{file};$version=$p->{version}}}$file ||= $p->{file}if defined($p->{file})}if ($err){$err="  $file ($version)\n" .$err}my%result=(file=>$file,version=>$version,err=>$err);return \%result};sub provides {my$class=shift;croak "provides() requires key/value pairs \n" if @_ % 2;my%args=@_;croak "provides() takes only one of 'dir' or 'files'\n" if$args{dir}&& $args{files};croak "provides() requires a 'version' argument" unless defined$args{version};croak "provides() does not support version '$args{version}' metadata" unless grep {$args{version}eq $_}qw/1.4 2/;$args{prefix}='lib' unless defined$args{prefix};my$p;if ($args{dir}){$p=$class->package_versions_from_directory($args{dir})}else {croak "provides() requires 'files' to be an array reference\n" unless ref$args{files}eq 'ARRAY';$p=$class->package_versions_from_directory($args{files})}if (length$args{prefix}){$args{prefix}=~ s{/$}{};for my$v (values %$p){$v->{file}="$args{prefix}/$v->{file}"}}return$p}sub package_versions_from_directory {my ($class,$dir,$files)=@_;my@files;if ($files){@files=@$files}else {find({wanted=>sub {push@files,$_ if -f $_ && /\.pm$/},no_chdir=>1,},$dir)}my(%prime,%alt);for my$file (@files){my$mapped_filename=File::Spec::Unix->abs2rel($file,$dir);my@path=split(/\//,$mapped_filename);(my$prime_package=join('::',@path))=~ s/\.pm$//;my$pm_info=$class->new_from_file($file);for my$package ($pm_info->packages_inside){next if$package eq 'main';next if$package eq 'DB';next if grep /^_/,split(/::/,$package);my$version=$pm_info->version($package);$prime_package=$package if lc($prime_package)eq lc($package);if ($package eq $prime_package){if (exists($prime{$package})){croak "Unexpected conflict in '$package'; multiple versions found.\n"}else {$mapped_filename="$package.pm" if lc("$package.pm")eq lc($mapped_filename);$prime{$package}{file}=$mapped_filename;$prime{$package}{version}=$version if defined($version)}}else {push(@{$alt{$package}},{file=>$mapped_filename,version=>$version,})}}}for my$package (keys(%alt)){my$result=$resolve_module_versions->($alt{$package});if (exists($prime{$package})){if ($result->{err}){log_info {"Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" .$result->{err}}}elsif (defined($result->{version})){if (exists($prime{$package}{version})&& defined($prime{$package}{version})){if ($compare_versions->($prime{$package}{version},'!=',$result->{version})){log_info {"Found conflicting versions for package '$package'\n" ."  $prime{$package}{file} ($prime{$package}{version})\n" ."  $result->{file} ($result->{version})\n"}}}else {$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}}}else {}}else {if ($result->{err}){log_info {"Found conflicting versions for package '$package'\n" .$result->{err}}}$prime{$package}{file}=$result->{file};$prime{$package}{version}=$result->{version}if defined($result->{version})}}for (grep defined $_->{version},values%prime){$_->{version}=$normalize_version->($_->{version})}return \%prime}}sub _init {my$class=shift;my$module=shift;my$filename=shift;my%props=@_;my$handle=delete$props{handle};my(%valid_props,@valid_props);@valid_props=qw(collect_pod inc);@valid_props{@valid_props}=delete(@props{@valid_props});warn "Unknown properties: @{[keys %props]}\n" if scalar(%props);my%data=(module=>$module,filename=>$filename,version=>undef,packages=>[],versions=>{},pod=>{},pod_headings=>[],collect_pod=>0,%valid_props,);my$self=bless(\%data,$class);if (not $handle){my$filename=$self->{filename};open$handle,'<',$filename or croak("Can't open '$filename': $!");$self->_handle_bom($handle,$filename)}$self->_parse_fh($handle);unless($self->{module}and length($self->{module})){my ($v,$d,$f)=File::Spec->splitpath($self->{filename});if($f =~ /\.pm$/){$f =~ s/\..+$//;my@candidates=grep /$f$/,@{$self->{packages}};$self->{module}=shift(@candidates)}else {if(grep /main/,@{$self->{packages}}){$self->{module}='main'}else {$self->{module}=$self->{packages}[0]|| ''}}}$self->{version}=$self->{versions}{$self->{module}}if defined($self->{module});return$self}sub _do_find_module {my$class=shift;my$module=shift || croak 'find_module_by_name() requires a package name';my$dirs=shift || \@INC;my$file=File::Spec->catfile(split(/::/,$module));for my$dir (@$dirs){my$testfile=File::Spec->catfile($dir,$file);return [File::Spec->rel2abs($testfile),$dir ]if -e $testfile and!-d _;$testfile .= '.pm';return [File::Spec->rel2abs($testfile),$dir ]if -e $testfile}return}sub find_module_by_name {my$found=shift()->_do_find_module(@_)or return;return$found->[0]}sub find_module_dir_by_name {my$found=shift()->_do_find_module(@_)or return;return$found->[1]}sub _parse_version_expression {my$self=shift;my$line=shift;my($sigil,$variable_name,$package);if ($line =~ /$VERS_REGEXP/o){($sigil,$variable_name,$package)=$2 ? ($1,$2,$3): ($4,$5,$6);if ($package){$package=($package eq '::')? 'main' : $package;$package =~ s/::$//}}return ($sigil,$variable_name,$package)}sub _handle_bom {my ($self,$fh,$filename)=@_;my$pos=tell$fh;return unless defined$pos;my$buf=' ' x 2;my$count=read$fh,$buf,length$buf;return unless defined$count and $count >= 2;my$encoding;if ($buf eq "\x{FE}\x{FF}"){$encoding='UTF-16BE'}elsif ($buf eq "\x{FF}\x{FE}"){$encoding='UTF-16LE'}elsif ($buf eq "\x{EF}\x{BB}"){$buf=' ';$count=read$fh,$buf,length$buf;if (defined$count and $count >= 1 and $buf eq "\x{BF}"){$encoding='UTF-8'}}if (defined$encoding){if ("$]" >= 5.008){binmode($fh,":encoding($encoding)")}}else {seek$fh,$pos,SEEK_SET or croak(sprintf "Can't reset position to the top of '$filename'")}return$encoding}sub _parse_fh {my ($self,$fh)=@_;my($in_pod,$seen_end,$need_vers)=(0,0,0);my(@packages,%vers,%pod,@pod);my$package='main';my$pod_sect='';my$pod_data='';my$in_end=0;while (defined(my$line=<$fh>)){my$line_num=$.;chomp($line);my$is_cut;if ($line =~ /^=([a-zA-Z].*)/){my$cmd=$1;$is_cut=$cmd =~ /^cut(?:[^a-zA-Z]|$)/;$in_pod=!$is_cut}if ($in_pod){if ($line =~ /^=head[1-4]\s+(.+)\s*$/){push(@pod,$1);if ($self->{collect_pod}&& length($pod_data)){$pod{$pod_sect}=$pod_data;$pod_data=''}$pod_sect=$1}elsif ($self->{collect_pod}){$pod_data .= "$line\n"}}elsif ($is_cut){if ($self->{collect_pod}&& length($pod_data)){$pod{$pod_sect}=$pod_data;$pod_data=''}$pod_sect=''}else {next if$in_end;next if$line =~ /^\s*#/;if ($line eq '__END__'){$in_end++;next}last if$line eq '__DATA__';my($version_sigil,$version_fullname,$version_package)=index($line,'VERSION')>= 1 ? $self->_parse_version_expression($line): ();if ($line =~ /$PKG_REGEXP/o){$package=$1;my$version=$2;push(@packages,$package)unless grep($package eq $_,@packages);$need_vers=defined$version ? 0 : 1;if (not exists$vers{$package}and defined$version){my$dwim_version=eval {_dwim_version($version)};croak "Version '$version' from $self->{filename} does not appear to be valid:\n$line\n\nThe fatal error was: $@\n" unless defined$dwim_version;$vers{$package}=$dwim_version}}elsif ($version_fullname && $version_package){push(@packages,$version_package)unless grep($version_package eq $_,@packages);$need_vers=0 if$version_package eq $package;unless (defined$vers{$version_package}&& length$vers{$version_package}){$vers{$version_package}=$self->_evaluate_version_line($version_sigil,$version_fullname,$line)}}elsif ($package eq 'main' && $version_fullname &&!exists($vers{main})){$need_vers=0;my$v=$self->_evaluate_version_line($version_sigil,$version_fullname,$line);$vers{$package}=$v;push(@packages,'main')}elsif ($package eq 'main' &&!exists($vers{main})&& $line =~ /\w/){$need_vers=1;$vers{main}='';push(@packages,'main')}elsif ($version_fullname && $need_vers){$need_vers=0;my$v=$self->_evaluate_version_line($version_sigil,$version_fullname,$line);unless (defined$vers{$package}&& length$vers{$package}){$vers{$package}=$v}}}}if ($self->{collect_pod}&& length($pod_data)){$pod{$pod_sect}=$pod_data}$self->{versions}=\%vers;$self->{packages}=\@packages;$self->{pod}=\%pod;$self->{pod_headings}=\@pod}{my$pn=0;sub _evaluate_version_line {my$self=shift;my($sigil,$variable_name,$line)=@_;$pn++;my$eval=qq{ my \$dummy = q#  Hide from _packages_inside()
      #; package Module::Metadata::_version::p${pn};
      use version;
      sub {
        local $sigil$variable_name;
        $line;
        \$$variable_name
      };
    };$eval=$1 if$eval =~ m{^(.+)}s;local $^W;my$vsub=__clean_eval($eval);if ($@ =~ /Can't locate/ && -d 'lib'){local@INC=('lib',@INC);$vsub=__clean_eval($eval)}warn "Error evaling version line '$eval' in $self->{filename}: $@\n" if $@;(ref($vsub)eq 'CODE')or croak "failed to build version sub for $self->{filename}";my$result=eval {$vsub->()};croak "Could not get version from $self->{filename} by executing:\n$eval\n\nThe fatal error was: $@\n" if $@;my$version=eval {_dwim_version($result)};croak "Version '$result' from $self->{filename} does not appear to be valid:\n$eval\n\nThe fatal error was: $@\n" unless defined$version;return$version}}{my@version_prep=(sub {return shift},sub {my$v=shift;$v =~ s{([0-9])[a-z-].*$}{$1}i;return$v},sub {my$v=shift;my$num_dots=()=$v =~ m{(\.)}g;my$num_unders=()=$v =~ m{(_)}g;my$leading_v=substr($v,0,1)eq 'v';if (!$leading_v && $num_dots < 2 && $num_unders > 1){$v =~ s{_}{}g;$num_unders=()=$v =~ m{(_)}g}return$v},sub {my$v=shift;no warnings 'numeric';return 0 + $v},);sub _dwim_version {my ($result)=shift;return$result if ref($result)eq 'version';my ($version,$error);for my$f (@version_prep){$result=$f->($result);$version=eval {version->new($result)};$error ||= $@ if $@;last if defined$version}croak$error unless defined$version;return$version}}sub name {$_[0]->{module}}sub filename {$_[0]->{filename}}sub packages_inside {@{$_[0]->{packages}}}sub pod_inside {@{$_[0]->{pod_headings}}}sub contains_pod {0+@{$_[0]->{pod_headings}}}sub version {my$self=shift;my$mod=shift || $self->{module};my$vers;if (defined($mod)&& length($mod)&& exists($self->{versions}{$mod})){return$self->{versions}{$mod}}else {return undef}}sub pod {my$self=shift;my$sect=shift;if (defined($sect)&& length($sect)&& exists($self->{pod}{$sect})){return$self->{pod}{$sect}}else {return undef}}sub is_indexable {my ($self,$package)=@_;my@indexable_packages=grep {$_ ne 'main'}$self->packages_inside;return!!grep {$_ eq $package}@indexable_packages if$package;return!!@indexable_packages}1;
MODULE_METADATA

$fatpacked{"Parse/CPAN/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSE_CPAN_META';
  use 5.008001;use strict;package Parse::CPAN::Meta;our$VERSION='1.4414';use Exporter;use Carp 'croak';our@ISA=qw/Exporter/;our@EXPORT_OK=qw/Load LoadFile/;sub load_file {my ($class,$filename)=@_;my$meta=_slurp($filename);if ($filename =~ /\.ya?ml$/){return$class->load_yaml_string($meta)}elsif ($filename =~ /\.json$/){return$class->load_json_string($meta)}else {$class->load_string($meta)}}sub load_string {my ($class,$string)=@_;if ($string =~ /^---/){return$class->load_yaml_string($string)}elsif ($string =~ /^\s*\{/){return$class->load_json_string($string)}else {return$class->load_yaml_string($string)}}sub load_yaml_string {my ($class,$string)=@_;my$backend=$class->yaml_backend();my$data=eval {no strict 'refs';&{"$backend\::Load"}($string)};croak $@ if $@;return$data || {}}sub load_json_string {my ($class,$string)=@_;my$data=eval {$class->json_backend()->new->decode($string)};croak $@ if $@;return$data || {}}sub yaml_backend {if (!defined$ENV{PERL_YAML_BACKEND}){_can_load('CPAN::Meta::YAML',0.011)or croak "CPAN::Meta::YAML 0.011 is not available\n";return "CPAN::Meta::YAML"}else {my$backend=$ENV{PERL_YAML_BACKEND};_can_load($backend)or croak "Could not load PERL_YAML_BACKEND '$backend'\n";$backend->can("Load")or croak "PERL_YAML_BACKEND '$backend' does not implement Load()\n";return$backend}}sub json_backend {if (!$ENV{PERL_JSON_BACKEND}or $ENV{PERL_JSON_BACKEND}eq 'JSON::PP'){_can_load('JSON::PP'=>2.27103)or croak "JSON::PP 2.27103 is not available\n";return 'JSON::PP'}else {_can_load('JSON'=>2.5)or croak "JSON 2.5 is required for " ."\$ENV{PERL_JSON_BACKEND} = '$ENV{PERL_JSON_BACKEND}'\n";return "JSON"}}sub _slurp {require Encode;open my$fh,"<:raw","$_[0]" or die "can't open $_[0] for reading: $!";my$content=do {local $/;<$fh>};$content=Encode::decode('UTF-8',$content,Encode::PERLQQ());return$content}sub _can_load {my ($module,$version)=@_;(my$file=$module)=~ s{::}{/}g;$file .= ".pm";return 1 if$INC{$file};return 0 if exists$INC{$file};eval {require$file;1}or return 0;if (defined$version){eval {$module->VERSION($version);1}or return 0}return 1}sub LoadFile ($) {return Load(_slurp(shift))}sub Load ($) {require CPAN::Meta::YAML;my$object=eval {CPAN::Meta::YAML::Load(shift)};croak $@ if $@;return$object}1;
PARSE_CPAN_META

$fatpacked{"Parse/PMFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSE_PMFILE';
  package Parse::PMFile;sub __clean_eval {eval $_[0]}use strict;use warnings;use Safe;use JSON::PP ();use Dumpvalue;use version ();use File::Spec ();our$VERSION='0.36';our$VERBOSE=0;our$ALLOW_DEV_VERSION=0;our$FORK=0;our$UNSAFE=$] < 5.010000 ? 1 : 0;sub new {my ($class,$meta,$opts)=@_;bless {%{$opts || {}},META_CONTENT=>$meta},$class}sub parse {my ($self,$pmfile)=@_;$pmfile =~ s|\\|/|g;my($filemtime)=(stat$pmfile)[9];$self->{MTIME}=$filemtime;$self->{PMFILE}=$pmfile;unless ($self->_version_from_meta_ok){my$version;unless (eval {$version=$self->_parse_version;1}){$self->_verbose(1,"error with version in $pmfile: $@");return}$self->{VERSION}=$version;if ($self->{VERSION}=~ /^\{.*\}$/){}elsif ($self->{VERSION}=~ /[_\s]/ &&!$self->{ALLOW_DEV_VERSION}&&!$ALLOW_DEV_VERSION){return}}my($ppp)=$self->_packages_per_pmfile;my@keys_ppp=$self->_filter_ppps(sort keys %$ppp);$self->_verbose(1,"Will check keys_ppp[@keys_ppp]\n");my ($package,%errors);my%checked_in;DBPACK: foreach$package (@keys_ppp){if ($package !~ /^\w[\w\:\']*\w?\z/ || $package !~ /\w\z/ || $package =~ /:/ && $package !~ /::/ || $package =~ /\w:\w/ || $package =~ /:::/){$self->_verbose(1,"Package[$package] did not pass the ultimate sanity check");delete$ppp->{$package};next}if ($self->{USERID}&& $self->{PERMISSIONS}&&!$self->_perm_check($package)){delete$ppp->{$package};next}{my (undef,$module)=split m{/lib/},$self->{PMFILE},2;if ($module){$module =~ s{\.pm\z}{};$module =~ s{/}{::}g;if (lc$module eq lc$package && $module ne $package){$errors{$package}={indexing_warning=>"Capitalization of package ($package) does not match filename!",infile=>$self->{PMFILE},}}}}my$pp=$ppp->{$package};if ($pp->{version}&& $pp->{version}=~ /^\{.*\}$/){my$err=JSON::PP::decode_json($pp->{version});if ($err->{x_normalize}){$errors{$package}={normalize=>$err->{version},infile=>$pp->{infile},};$pp->{version}="undef"}elsif ($err->{openerr}){$pp->{version}="undef";$self->_verbose(1,qq{Parse::PMFile was not able to
          read the file. It issued the following error: C< $err->{r} >},);$errors{$package}={open=>$err->{r},infile=>$pp->{infile},}}else {$pp->{version}="undef";$self->_verbose(1,qq{Parse::PMFile was not able to
          parse the following line in that file: C< $err->{line} >
  
          Note: the indexer is running in a Safe compartement and cannot
          provide the full functionality of perl in the VERSION line. It
          is trying hard, but sometime it fails. As a workaround, please
          consider writing a META.yml that contains a 'provides'
          attribute or contact the CPAN admins to investigate (yet
          another) workaround against "Safe" limitations.)},);$errors{$package}={parse_version=>$err->{line},infile=>$err->{file},}}}for ($package,$pp->{version},){if (!defined || /^\s*$/ || /\s/){delete$ppp->{$package};next}}$checked_in{$package}=$ppp->{$package}}return (wantarray && %errors)? (\%checked_in,\%errors): \%checked_in}sub _perm_check {my ($self,$package)=@_;my$userid=$self->{USERID};my$module=$self->{PERMISSIONS}->module_permissions($package);return 1 if!$module;return 1 if defined$module->m && $module->m eq $userid;return 1 if defined$module->f && $module->f eq $userid;return 1 if defined$module->c && grep {$_ eq $userid}@{$module->c};return}sub _parse_version {my$self=shift;use strict;my$pmfile=$self->{PMFILE};my$tmpfile=File::Spec->catfile(File::Spec->tmpdir,"ParsePMFile$$" .rand(1000));my$pmcp=$pmfile;for ($pmcp){s/([^\\](\\\\)*)@/$1\\@/g}my($v);{package main;my$pid;if ($self->{FORK}|| $FORK){$pid=fork();die "Can't fork: $!" unless defined$pid}if ($pid){waitpid($pid,0);if (open my$fh,'<',$tmpfile){$v=<$fh>}}else {my($comp)=Safe->new;my$eval=qq{
                  local(\$^W) = 0;
                  Parse::PMFile::_parse_version_safely("$pmcp");
              };$comp->permit("entereval");$comp->share("*Parse::PMFile::_parse_version_safely");$comp->share("*version::new");$comp->share("*version::numify");$comp->share_from('main',['*version::','*charstar::','*Exporter::','*DynaLoader::']);$comp->share_from('version',['&qv']);$comp->permit(":base_math");$comp->deny(qw/enteriter iter unstack goto/);version->import('qv')if$self->{UNSAFE}|| $UNSAFE;{no strict;$v=($self->{UNSAFE}|| $UNSAFE)? eval$eval : $comp->reval($eval)}if ($@){my$err=$@;if (ref$err){if ($err->{line}=~ /([\$*])([\w\:\']*)\bVERSION\b.*?\=(.*)/){local($^W)=0;my ($sigil,$vstr)=($1,$3);$self->_restore_overloaded_stuff(1)if$err->{line}=~ /use\s+version\b|version\->|qv\(/;$v=($self->{UNSAFE}|| $UNSAFE)? eval$vstr : $comp->reval($vstr);$v=$$v if$sigil eq '*' && ref$v}if ($@ or!$v){$self->_verbose(1,sprintf("reval failed: err[%s] for eval[%s]",JSON::PP::encode_json($err),$eval,));$v=JSON::PP::encode_json($err)}}else {$v=JSON::PP::encode_json({openerr=>$err })}}if (defined$v){$v=$v->numify if ref($v)=~ /^version(::vpp)?$/}else {$v=""}if ($self->{FORK}|| $FORK){open my$fh,'>:utf8',$tmpfile;print$fh $v;exit 0}else {utf8::encode($v);$v=undef if defined$v &&!length$v;$comp->erase;$self->_restore_overloaded_stuff}}}unlink$tmpfile if ($self->{FORK}|| $FORK)&& -e $tmpfile;return$self->_normalize_version($v)}sub _restore_overloaded_stuff {my ($self,$used_version_in_safe)=@_;return if$self->{UNSAFE}|| $UNSAFE;no strict 'refs';no warnings 'redefine';my$restored;if ($INC{'version/vxs.pm'}){*{'version::(""'}=\&version::vxs::stringify;*{'version::(0+'}=\&version::vxs::numify;*{'version::(cmp'}=\&version::vxs::VCMP;*{'version::(<=>'}=\&version::vxs::VCMP;*{'version::(bool'}=\&version::vxs::boolean;$restored=1}if ($INC{'version/vpp.pm'}){{package charstar;overload->import}if (!$used_version_in_safe){package version::vpp;overload->import}unless ($restored){*{'version::(""'}=\&version::vpp::stringify;*{'version::(0+'}=\&version::vpp::numify;*{'version::(cmp'}=\&version::vpp::vcmp;*{'version::(<=>'}=\&version::vpp::vcmp;*{'version::(bool'}=\&version::vpp::vbool}*{'version::vpp::(""'}=\&version::vpp::stringify;*{'version::vpp::(0+'}=\&version::vpp::numify;*{'version::vpp::(cmp'}=\&version::vpp::vcmp;*{'version::vpp::(<=>'}=\&version::vpp::vcmp;*{'version::vpp::(bool'}=\&version::vpp::vbool;*{'charstar::(""'}=\&charstar::thischar;*{'charstar::(0+'}=\&charstar::thischar;*{'charstar::(++'}=\&charstar::increment;*{'charstar::(--'}=\&charstar::decrement;*{'charstar::(+'}=\&charstar::plus;*{'charstar::(-'}=\&charstar::minus;*{'charstar::(*'}=\&charstar::multiply;*{'charstar::(cmp'}=\&charstar::cmp;*{'charstar::(<=>'}=\&charstar::spaceship;*{'charstar::(bool'}=\&charstar::thischar;*{'charstar::(='}=\&charstar::clone;$restored=1}if (!$restored){*{'version::(""'}=\&version::stringify;*{'version::(0+'}=\&version::numify;*{'version::(cmp'}=\&version::vcmp;*{'version::(<=>'}=\&version::vcmp;*{'version::(bool'}=\&version::boolean}}sub _packages_per_pmfile {my$self=shift;my$ppp={};my$pmfile=$self->{PMFILE};my$filemtime=$self->{MTIME};my$version=$self->{VERSION};open my$fh,"<","$pmfile" or return$ppp;local $/="\n";my$inpod=0;PLINE: while (<$fh>){chomp;my($pline)=$_;$inpod=$pline =~ /^=(?!cut)/ ? 1 : $pline =~ /^=cut/ ? 0 : $inpod;next if$inpod;next if substr($pline,0,4)eq "=cut";$pline =~ s/\#.*//;next if$pline =~ /^\s*$/;if ($pline =~ /^__(?:END|DATA)__\b/ and $pmfile !~ /\.PL$/){last PLINE}my$pkg;my$strict_version;if ($pline =~ m{
                        # (.*) # takes too much time if $pline is long
                        (?<![*\$\\@%&]) # no sigils
                        \bpackage\s+
                        ([\w\:\']+)
                        \s*
                        (?: $ | [\}\;] | \{ | \s+($version::STRICT) )
                      }x){$pkg=$1;$strict_version=$2;if ($pkg eq "DB"){next PLINE}}if ($pkg){$pkg =~ s/\'/::/;next PLINE unless$pkg =~ /^[A-Za-z]/;next PLINE unless$pkg =~ /\w$/;next PLINE if$pkg eq "main";next PLINE if length($pkg)> 128;$ppp->{$pkg}{parsed}++;$ppp->{$pkg}{infile}=$pmfile;if ($self->_simile($pmfile,$pkg)){$ppp->{$pkg}{simile}=$pmfile;if ($self->_version_from_meta_ok){my$provides=$self->{META_CONTENT}{provides};if (exists$provides->{$pkg}){if (defined$provides->{$pkg}{version}){my$v=$provides->{$pkg}{version};if ($v =~ /[_\s]/ &&!$self->{ALLOW_DEV_VERSION}&&!$ALLOW_DEV_VERSION){next PLINE}unless (eval {$version=$self->_normalize_version($v);1}){$self->_verbose(1,"error with version in $pmfile: $@");next}$ppp->{$pkg}{version}=$version}else {$ppp->{$pkg}{version}="undef"}}}else {if (defined$strict_version){$ppp->{$pkg}{version}=$strict_version }else {$ppp->{$pkg}{version}=defined$version ? $version : ""}no warnings;if ($version eq 'undef'){$ppp->{$pkg}{version}=$version unless defined$ppp->{$pkg}{version}}else {$ppp->{$pkg}{version}=$version if$version > $ppp->{$pkg}{version}|| $version gt $ppp->{$pkg}{version}}}}else {$ppp->{$pkg}{version}=$version unless defined$ppp->{$pkg}{version}&& length($ppp->{$pkg}{version})}$ppp->{$pkg}{filemtime}=$filemtime}else {}}close$fh;$ppp}{no strict;sub _parse_version_safely {my($parsefile)=@_;my$result;local*FH;local $/="\n";open(FH,$parsefile)or die "Could not open '$parsefile': $!";my$inpod=0;while (<FH>){$inpod=/^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;next if$inpod || /^\s*#/;last if /^__(?:END|DATA)__\b/;chop;if (my ($ver)=/package \s+ \S+ \s+ (\S+) \s* [;{]/x){return$ver if version::is_lax($ver)}next unless /(?<!\\)([\$*])(([\w\:\']*)\bVERSION)\b.*(?<![!><=])\=(?![=>])/;my$current_parsed_line=$_;my$eval=qq{
                  package #
                      ExtUtils::MakeMaker::_version;
  
                  local $1$2;
                  \$$2=undef; do {
                      $_
                  }; \$$2
              };local $^W=0;local$SIG{__WARN__}=sub {};$result=__clean_eval($eval);if ($@ or!defined$result){die +{eval=>$eval,line=>$current_parsed_line,file=>$parsefile,err=>$@,}}last}close FH;$result="undef" unless defined$result;if ((ref$result)=~ /^version(?:::vpp)?\b/){$result=$result->numify}return$result}}sub _filter_ppps {my($self,@ppps)=@_;my@res;MANI: for my$ppp (@ppps){if ($self->{META_CONTENT}){my$no_index=$self->{META_CONTENT}{no_index}|| $self->{META_CONTENT}{private};if (ref($no_index)eq 'HASH'){my%map=(package=>qr{\z},namespace=>qr{::},);for my$k (qw(package namespace)){next unless my$v=$no_index->{$k};my$rest=$map{$k};if (ref$v eq "ARRAY"){for my$ve (@$v){$ve =~ s|::$||;if ($ppp =~ /^$ve$rest/){$self->_verbose(1,"Skipping ppp[$ppp] due to ve[$ve]");next MANI}else {$self->_verbose(1,"NOT skipping ppp[$ppp] due to ve[$ve]")}}}else {$v =~ s|::$||;if ($ppp =~ /^$v$rest/){$self->_verbose(1,"Skipping ppp[$ppp] due to v[$v]");next MANI}else {$self->_verbose(1,"NOT skipping ppp[$ppp] due to v[$v]")}}}}else {$self->_verbose(1,"No keyword 'no_index' or 'private' in META_CONTENT")}}else {}push@res,$ppp}$self->_verbose(1,"Result of filter_ppps: res[@res]");@res}sub _simile {my($self,$file,$package)=@_;$file =~ s|.*/||;$file =~ s|\.pm(?:\.PL)?||;my$ret=$package =~ m/\b\Q$file\E$/;$ret ||= 0;unless ($ret){$ret=1 if lc$file eq 'version'}$self->_verbose(1,"Result of simile(): file[$file] package[$package] ret[$ret]\n");$ret}sub _normalize_version {my($self,$v)=@_;$v="undef" unless defined$v;my$dv=Dumpvalue->new;my$sdv=$dv->stringify($v,1);$self->_verbose(1,"Result of normalize_version: sdv[$sdv]\n");return$v if$v eq "undef";return$v if$v =~ /^\{.*\}$/;$v =~ s/^\s+//;$v =~ s/\s+\z//;if ($v =~ /_/){return$v }if (!version::is_lax($v)){return JSON::PP::encode_json({x_normalize=>'version::is_lax failed',version=>$v })}my$vv=eval {no warnings;version->new($v)->numify};if ($@){return JSON::PP::encode_json({x_normalize=>$@,version=>$v })}if ($vv eq $v){}else {my$forced=$self->_force_numeric($v);if ($forced eq $vv){}elsif ($forced =~ /^v(.+)/){$vv=version->new($1)->numify}else {if ($forced==$vv){$vv=$forced}}}return$vv}sub _force_numeric {my($self,$v)=@_;$v=$self->_readable($v);if ($v =~ /^(\+?)(\d*)(\.(\d*))?/ && (defined $2 && length $2 || defined $4 && length $4)){my$two=defined $2 ? $2 : "";my$three=defined $3 ? $3 : "";$v="$two$three"}$v}sub _version_from_meta_ok {my($self)=@_;return$self->{VERSION_FROM_META_OK}if exists$self->{VERSION_FROM_META_OK};my$c=$self->{META_CONTENT};return($self->{VERSION_FROM_META_OK}=0)unless$c->{provides};my ($mb_v)=(defined$c->{generated_by}? $c->{generated_by}: '')=~ /Module::Build version ([\d\.]+)/;return($self->{VERSION_FROM_META_OK}=1)unless$mb_v;return($self->{VERSION_FROM_META_OK}=1)if$mb_v eq '0.250.0';if ($mb_v >= 0.19 && $mb_v < 0.26 &&!keys %{$c->{provides}}){return($self->{VERSION_FROM_META_OK}=0)}return($self->{VERSION_FROM_META_OK}=1)}sub _verbose {my($self,$level,@what)=@_;warn@what if$level <= ((ref$self && $self->{VERBOSE})|| $VERBOSE)}sub _vcmp {my($self,$l,$r)=@_;local($^W)=0;$self->_verbose(9,"l[$l] r[$r]");return 0 if$l eq $r;for ($l,$r){s/_//g}$self->_verbose(9,"l[$l] r[$r]");for ($l,$r){next unless tr/.// > 1 || /^v/;s/^v?/v/;1 while s/\.0+(\d)/.$1/}$self->_verbose(9,"l[$l] r[$r]");if ($l=~/^v/ <=> $r=~/^v/){for ($l,$r){next if /^v/;$_=$self->_float2vv($_)}}$self->_verbose(9,"l[$l] r[$r]");my$lvstring="v0";my$rvstring="v0";if ($] >= 5.006 && $l =~ /^v/ && $r =~ /^v/){$lvstring=$self->_vstring($l);$rvstring=$self->_vstring($r);$self->_verbose(9,sprintf "lv[%vd] rv[%vd]",$lvstring,$rvstring)}return (($l ne "undef")<=> ($r ne "undef")|| $lvstring cmp $rvstring || $l <=> $r || $l cmp $r)}sub _vgt {my($self,$l,$r)=@_;$self->_vcmp($l,$r)> 0}sub _vlt {my($self,$l,$r)=@_;$self->_vcmp($l,$r)< 0}sub _vge {my($self,$l,$r)=@_;$self->_vcmp($l,$r)>= 0}sub _vle {my($self,$l,$r)=@_;$self->_vcmp($l,$r)<= 0}sub _vstring {my($self,$n)=@_;$n =~ s/^v// or die "Parse::PMFile::_vstring() called with invalid arg [$n]";pack "U*",split /\./,$n}sub _float2vv {my($self,$n)=@_;my($rev)=int($n);$rev ||= 0;my($mantissa)=$n =~ /\.(\d{1,12})/;$mantissa ||= 0;$mantissa .= "0" while length($mantissa)%3;my$ret="v" .$rev;while ($mantissa){$mantissa =~ s/(\d{1,3})// or die "Panic: length>0 but not a digit? mantissa[$mantissa]";$ret .= ".".int($1)}$ret =~ s/(\.0)+/.0/;$ret}sub _readable {my($self,$n)=@_;$n =~ /^([\w\-\+\.]+)/;return $1 if defined $1 && length($1)>0;if ($] < 5.006){$self->_verbose(9,"Suspicious version string seen [$n]\n");return$n}my$better=sprintf "v%vd",$n;$self->_verbose(9,"n[$n] better[$better]");return$better}1;
PARSE_PMFILE

$fatpacked{"String/ShellQuote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRING_SHELLQUOTE';
  package String::ShellQuote;use strict;use vars qw($VERSION @ISA @EXPORT);require Exporter;$VERSION='1.04';@ISA=qw(Exporter);@EXPORT=qw(shell_quote shell_quote_best_effort shell_comment_quote);sub croak {require Carp;goto&Carp::croak}sub _shell_quote_backend {my@in=@_;my@err=();if (0){require RS::Handy;print RS::Handy::data_dump(\@in)}return \@err,'' unless@in;my$ret='';my$saw_non_equal=0;for (@in){if (!defined $_ or $_ eq ''){$_="''";next}if (s/\x00//g){push@err,"No way to quote string containing null (\\000) bytes"}my$escape=0;if (/=/){if (!$saw_non_equal){$escape=1}}else {$saw_non_equal=1}if (m|[^\w!%+,\-./:=@^]|){$escape=1}if ($escape || (!$saw_non_equal && /=/)){s/'/'\\''/g;s|((?:'\\''){2,})|q{'"} . (q{'} x (length($1) / 4)) . q{"'}|ge;$_="'$_'";s/^''//;s/''$//}}continue {$ret .= "$_ "}chop$ret;return \@err,$ret}sub shell_quote {my ($rerr,$s)=_shell_quote_backend @_;if (@$rerr){my%seen;@$rerr=grep {!$seen{$_}++}@$rerr;my$s=join '',map {"shell_quote(): $_\n"}@$rerr;chomp$s;croak$s}return$s}sub shell_quote_best_effort {my ($rerr,$s)=_shell_quote_backend @_;return$s}sub shell_comment_quote {return '' unless @_;unless (@_==1){croak "Too many arguments to shell_comment_quote " ."(got " .@_ ." expected 1)"}local $_=shift;s/\n/\n#/g;return $_}1;
STRING_SHELLQUOTE

$fatpacked{"lib/core/only.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIB_CORE_ONLY';
  package lib::core::only;use strict;use warnings FATAL=>'all';use Config;sub import {@INC=@Config{qw(privlibexp archlibexp)};return}1;
LIB_CORE_ONLY

$fatpacked{"local/lib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCAL_LIB';
  package local::lib;use 5.006;use strict;use warnings;use Config;our$VERSION='2.000015';$VERSION=eval$VERSION;BEGIN {*_WIN32=($^O eq 'MSWin32' || $^O eq 'NetWare' || $^O eq 'symbian')? sub(){1}: sub(){0};*_USE_FSPEC=($^O eq 'MacOS' || $^O eq 'VMS' || $INC{'File/Spec.pm'})? sub(){1}: sub(){0}}our$_DIR_JOIN=_WIN32 ? '\\' : '/';our$_DIR_SPLIT=(_WIN32 || $^O eq 'cygwin')? qr{[\\/]} : qr{/};our$_ROOT=_WIN32 ? do {my$UNC=qr{[\\/]{2}[^\\/]+[\\/][^\\/]+};qr{^(?:$UNC|[A-Za-z]:|)$_DIR_SPLIT}}: qr{^/};our$_PERL;sub _cwd {my$drive=shift;if (!$_PERL){($_PERL)=$^X =~ /(.+)/;if (_is_abs($_PERL)){}elsif (-x $Config{perlpath}){$_PERL=$Config{perlpath}}else {($_PERL)=map {/(.*)/}grep {-x $_}map {join($_DIR_JOIN,$_,$_PERL)}split /\Q$Config{path_sep}\E/,$ENV{PATH}}}local@ENV{qw(PATH IFS CDPATH ENV BASH_ENV)};my$cmd=$drive ? "eval { Cwd::getdcwd(q($drive)) }" : 'getcwd';my$cwd=`"$_PERL" -MCwd -le "print $cmd"`;chomp$cwd;if (!length$cwd && $drive){$cwd=$drive}$cwd =~ s/$_DIR_SPLIT?$/$_DIR_JOIN/;$cwd}sub _catdir {if (_USE_FSPEC){require File::Spec;File::Spec->catdir(@_)}else {my$dir=join($_DIR_JOIN,@_);$dir =~ s{($_DIR_SPLIT)(?:\.?$_DIR_SPLIT)+}{$1}g;$dir}}sub _is_abs {if (_USE_FSPEC){require File::Spec;File::Spec->file_name_is_absolute($_[0])}else {$_[0]=~ $_ROOT}}sub _rel2abs {my ($dir,$base)=@_;return$dir if _is_abs($dir);$base=_WIN32 && $dir =~ s/^([A-Za-z]:)// ? _cwd("$1"): $base ? $base : _cwd;return _catdir($base,$dir)}sub import {my ($class,@args)=@_;push@args,@ARGV if $0 eq '-';my@steps;my%opts;my$shelltype;while (@args){my$arg=shift@args;if ($arg =~ /\xE2\x88\x92/ or $arg =~ //){die <<'DEATH'}elsif ($arg eq '--self-contained'){die <<'DEATH'}elsif($arg =~ /^--deactivate(?:=(.*))?$/){my$path=defined $1 ? $1 : shift@args;push@steps,['deactivate',$path]}elsif ($arg eq '--deactivate-all'){push@steps,['deactivate_all']}elsif ($arg =~ /^--shelltype(?:=(.*))?$/){$shelltype=defined $1 ? $1 : shift@args}elsif ($arg eq '--no-create'){$opts{no_create}=1}elsif ($arg =~ /^--/){die "Unknown import argument: $arg"}else {push@steps,['activate',$arg]}}if (!@steps){push@steps,['activate',undef]}my$self=$class->new(%opts);for (@steps){my ($method,@args)=@$_;$self=$self->$method(@args)}if ($0 eq '-'){print$self->environment_vars_string($shelltype);exit 0}else {$self->setup_local_lib}}sub new {my$class=shift;bless {@_},$class}sub clone {my$self=shift;bless {%$self,@_},ref$self}sub inc {$_[0]->{inc}||= \@INC}sub libs {$_[0]->{libs}||= [\'PERL5LIB' ]}sub bins {$_[0]->{bins}||= [\'PATH' ]}sub roots {$_[0]->{roots}||= [\'PERL_LOCAL_LIB_ROOT' ]}sub extra {$_[0]->{extra}||= {}}sub no_create {$_[0]->{no_create}}my$_archname=$Config{archname};my$_version=$Config{version};my@_inc_version_list=reverse split / /,$Config{inc_version_list};my$_path_sep=$Config{path_sep};sub _as_list {my$list=shift;grep length,map {!(ref $_ && ref $_ eq 'SCALAR')? $_ : (defined$ENV{$$_}? split(/\Q$_path_sep/,$ENV{$$_}): ())}ref$list ? @$list : $list}sub _remove_from {my ($list,@remove)=@_;return @$list if!@remove;my%remove=map {$_=>1}@remove;grep!$remove{$_},_as_list($list)}my@_lib_subdirs=([$_version,$_archname],[$_version],[$_archname],(@_inc_version_list ? \@_inc_version_list : ()),[],);sub install_base_bin_path {my ($class,$path)=@_;return _catdir($path,'bin')}sub install_base_perl_path {my ($class,$path)=@_;return _catdir($path,'lib','perl5')}sub install_base_arch_path {my ($class,$path)=@_;_catdir($class->install_base_perl_path($path),$_archname)}sub lib_paths_for {my ($class,$path)=@_;my$base=$class->install_base_perl_path($path);return map {_catdir($base,@$_)}@_lib_subdirs}sub _mm_escape_path {my$path=shift;$path =~ s/\\/\\\\/g;if ($path =~ s/ /\\ /g){$path=qq{"$path"}}return$path}sub _mb_escape_path {my$path=shift;$path =~ s/\\/\\\\/g;return qq{"$path"}}sub installer_options_for {my ($class,$path)=@_;return (PERL_MM_OPT=>defined$path ? "INSTALL_BASE="._mm_escape_path($path): undef,PERL_MB_OPT=>defined$path ? "--install_base "._mb_escape_path($path): undef,)}sub active_paths {my ($self)=@_;$self=ref$self ? $self : $self->new;return grep {my$active_ll=$self->install_base_perl_path($_);grep {$_ eq $active_ll}@{$self->inc}}_as_list($self->roots)}sub deactivate {my ($self,$path)=@_;$self=$self->new unless ref$self;$path=$self->resolve_path($path);$path=$self->normalize_path($path);my@active_lls=$self->active_paths;if (!grep {$_ eq $path}@active_lls){warn "Tried to deactivate inactive local::lib '$path'\n";return$self}my%args=(bins=>[_remove_from($self->bins,$self->install_base_bin_path($path))],libs=>[_remove_from($self->libs,$self->install_base_perl_path($path))],inc=>[_remove_from($self->inc,$self->lib_paths_for($path))],roots=>[_remove_from($self->roots,$path)],);$args{extra}={$self->installer_options_for($args{roots}[0])};$self->clone(%args)}sub deactivate_all {my ($self)=@_;$self=$self->new unless ref$self;my@active_lls=$self->active_paths;my%args;if (@active_lls){%args=(bins=>[_remove_from($self->bins,map$self->install_base_bin_path($_),@active_lls)],libs=>[_remove_from($self->libs,map$self->install_base_perl_path($_),@active_lls)],inc=>[_remove_from($self->inc,map$self->lib_paths_for($_),@active_lls)],roots=>[_remove_from($self->roots,@active_lls)],)}$args{extra}={$self->installer_options_for(undef)};$self->clone(%args)}sub activate {my ($self,$path)=@_;$self=$self->new unless ref$self;$path=$self->resolve_path($path);$self->ensure_dir_structure_for($path)unless$self->no_create;$path=$self->normalize_path($path);my@active_lls=$self->active_paths;if (grep {$_ eq $path}@active_lls[1 .. $#active_lls]){$self=$self->deactivate($path)}my%args;if (!@active_lls || $active_lls[0]ne $path){%args=(bins=>[$self->install_base_bin_path($path),@{$self->bins}],libs=>[$self->install_base_perl_path($path),@{$self->libs}],inc=>[$self->lib_paths_for($path),@{$self->inc}],roots=>[$path,@{$self->roots}],)}$args{extra}={$self->installer_options_for($path)};$self->clone(%args)}sub normalize_path {my ($self,$path)=@_;$path=(Win32::GetShortPathName($path)|| $path)if $^O eq 'MSWin32';return$path}sub build_environment_vars_for {my$self=$_[0]->new->activate($_[1]);$self->build_environment_vars}sub build_activate_environment_vars_for {my$self=$_[0]->new->activate($_[1]);$self->build_environment_vars}sub build_deactivate_environment_vars_for {my$self=$_[0]->new->deactivate($_[1]);$self->build_environment_vars}sub build_deact_all_environment_vars_for {my$self=$_[0]->new->deactivate_all;$self->build_environment_vars}sub build_environment_vars {my$self=shift;(PATH=>join($_path_sep,_as_list($self->bins)),PERL5LIB=>join($_path_sep,_as_list($self->libs)),PERL_LOCAL_LIB_ROOT=>join($_path_sep,_as_list($self->roots)),%{$self->extra},)}sub setup_local_lib_for {my$self=$_[0]->new->activate($_[1]);$self->setup_local_lib}sub setup_local_lib {my$self=shift;require Carp::Heavy if$INC{'Carp.pm'};$self->setup_env_hash;@INC=@{$self->inc}}sub setup_env_hash_for {my$self=$_[0]->new->activate($_[1]);$self->setup_env_hash}sub setup_env_hash {my$self=shift;my%env=$self->build_environment_vars;for my$key (keys%env){if (defined$env{$key}){$ENV{$key}=$env{$key}}else {delete$ENV{$key}}}}sub print_environment_vars_for {print $_[0]->environment_vars_string_for(@_[1..$#_])}sub environment_vars_string_for {my$self=$_[0]->new->activate($_[1]);$self->environment_vars_string}sub environment_vars_string {my ($self,$shelltype)=@_;$shelltype ||= $self->guess_shelltype;my$extra=$self->extra;my@envs=(PATH=>$self->bins,PERL5LIB=>$self->libs,PERL_LOCAL_LIB_ROOT=>$self->roots,map {$_=>$extra->{$_}}sort keys %$extra,);$self->_build_env_string($shelltype,\@envs)}sub _build_env_string {my ($self,$shelltype,$envs)=@_;my@envs=@$envs;my$build_method="build_${shelltype}_env_declaration";my$out='';while (@envs){my ($name,$value)=(shift(@envs),shift(@envs));if (ref$value && @$value==1 && ref$value->[0]&& ref$value->[0]eq 'SCALAR' && ${$value->[0]}eq $name){next}$out .= $self->$build_method($name,$value)}my$wrap_method="wrap_${shelltype}_output";if ($self->can($wrap_method)){return$self->$wrap_method($out)}return$out}sub build_bourne_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'${%s}',qr/["\\\$!`]/,'\\%s');if (!defined$value){return qq{unset $name;\n}}$value =~ s/(^|\G|$_path_sep)\$\{$name\}$_path_sep/$1\${$name}\${$name+$_path_sep}/g;$value =~ s/$_path_sep\$\{$name\}$/\${$name+$_path_sep}\${$name}/;qq{${name}="$value"; export ${name};\n}}sub build_csh_env_declaration {my ($class,$name,$args)=@_;my ($value,@vars)=$class->_interpolate($args,'${%s}','"','"\\%s"');if (!defined$value){return qq{unsetenv $name;\n}}my$out='';for my$var (@vars){$out .= qq{if ! \$?$name setenv $name '';\n}}my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)\$\{$name\}(?:$_path_sep|$)//g){$out .= qq{if "\${$name}" != '' setenv $name "$value";\n};$out .= qq{if "\${$name}" == '' }}$out .= qq{setenv $name "$value_without";\n};return$out}sub build_cmd_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'%%%s%%',qr(%),'%s');if (!$value){return qq{\@set $name=\n}}my$out='';my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)%$name%(?:$_path_sep|$)//g){$out .= qq{\@if not "%$name%"=="" set "$name=$value"\n};$out .= qq{\@if "%$name%"=="" }}$out .= qq{\@set "$name=$value_without"\n};return$out}sub build_powershell_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'$env:%s','"','`%s');if (!$value){return qq{Remove-Item -ErrorAction 0 Env:\\$name;\n}}my$maybe_path_sep=qq{\$(if("\$env:$name"-eq""){""}else{"$_path_sep"})};$value =~ s/(^|\G|$_path_sep)\$env:$name$_path_sep/$1\$env:$name"+$maybe_path_sep+"/g;$value =~ s/$_path_sep\$env:$name$/"+$maybe_path_sep+\$env:$name+"/;qq{\$env:$name = \$("$value");\n}}sub wrap_powershell_output {my ($class,$out)=@_;return$out || " \n"}sub build_fish_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'$%s',qr/[\\"' ]/,'\\%s');if (!defined$value){return qq{set -e $name;\n}}$value =~ s/$_path_sep/ /g;qq{set -x $name $value;\n}}sub _interpolate {my ($class,$args,$var_pat,$escape,$escape_pat)=@_;return unless defined$args;my@args=ref$args ? @$args : $args;return unless@args;my@vars=map {$$_}grep {ref $_ eq 'SCALAR'}@args;my$string=join$_path_sep,map {ref $_ eq 'SCALAR' ? sprintf($var_pat,$$_): do {s/($escape)/sprintf($escape_pat, $1)/ge;$_}}@args;return wantarray ? ($string,\@vars): $string}sub pipeline;sub pipeline {my@methods=@_;my$last=pop(@methods);if (@methods){\sub {my ($obj,@args)=@_;$obj->${pipeline@methods}($obj->$last(@args))}}else {\sub {shift->$last(@_)}}}sub resolve_path {my ($class,$path)=@_;$path=$class->${pipeline qw(resolve_relative_path resolve_home_path resolve_empty_path)}($path);$path}sub resolve_empty_path {my ($class,$path)=@_;if (defined$path){$path}else {'~/perl5'}}sub resolve_home_path {my ($class,$path)=@_;$path =~ /^~([^\/]*)/ or return$path;my$user=$1;my$homedir=do {if (!length($user)&& defined$ENV{HOME}){$ENV{HOME}}else {require File::Glob;File::Glob::bsd_glob("~$user",File::Glob::GLOB_TILDE())}};unless (defined$homedir){require Carp;require Carp::Heavy;Carp::croak("Couldn't resolve homedir for " .(defined$user ? $user : 'current user'))}$path =~ s/^~[^\/]*/$homedir/;$path}sub resolve_relative_path {my ($class,$path)=@_;_rel2abs($path)}sub ensure_dir_structure_for {my ($class,$path)=@_;unless (-d $path){warn "Attempting to create directory ${path}\n"}require File::Basename;my@dirs;while(!-d $path){push@dirs,$path;$path=File::Basename::dirname($path)}mkdir $_ for reverse@dirs;return}sub guess_shelltype {my$shellbin =defined$ENV{SHELL}? ($ENV{SHELL}=~ /([\w.]+)$/)[-1]: ($^O eq 'MSWin32' && exists$ENV{'!EXITCODE'})? 'bash' : ($^O eq 'MSWin32' && $ENV{PROMPT}&& $ENV{COMSPEC})? ($ENV{COMSPEC}=~ /([\w.]+)$/)[-1]: ($^O eq 'MSWin32' &&!$ENV{PROMPT})? 'powershell.exe' : 'sh';for ($shellbin){return /csh$/ ? 'csh' : /fish/ ? 'fish' : /command(?:\.com)?$/i ? 'cmd' : /cmd(?:\.exe)?$/i ? 'cmd' : /4nt(?:\.exe)?$/i ? 'cmd' : /powershell(?:\.exe)?$/i ? 'powershell' : 'bourne'}}1;
  WHOA THERE! It looks like you've got some fancy dashes in your commandline!
  These are *not* the traditional -- dashes that software recognizes. You
  probably got these by copy-pasting from the perldoc for this module as
  rendered by a UTF8-capable formatter. This most typically happens on an OS X
  terminal, but can happen elsewhere too. Please try again after replacing the
  dashes with normal minus signs.
  DEATH
  FATAL: The local::lib --self-contained flag has never worked reliably and the
  original author, Mark Stosberg, was unable or unwilling to maintain it. As
  such, this flag has been removed from the local::lib codebase in order to
  prevent misunderstandings and potentially broken builds. The local::lib authors
  recommend that you look at the lib::core::only module shipped with this
  distribution in order to create a more robust environment that is equivalent to
  what --self-contained provided (although quite possibly not what you originally
  thought it provided due to the poor quality of the documentation, for which we
  apologise).
  DEATH
LOCAL_LIB

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;use strict;use vars qw($VERSION);$VERSION='0.228';sub import {my$class=shift;my$inheritor=caller(0);if (@_ and $_[0]eq '-norequire'){shift @_}else {for (my@filename=@_){if ($_ eq $inheritor){warn "Class '$inheritor' tried to inherit from itself\n"};s{::|'}{/}g;require "$_.pm"}}{no strict 'refs';push @{"$inheritor\::ISA"},@_}};"All your base are belong to us" 
PARENT

$fatpacked{"version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION';
  package version;use 5.006002;use strict;use warnings::register;if ($] >= 5.015){warnings::register_categories(qw/version/)}use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);$VERSION=0.9912;$CLASS='version';{local$SIG{'__DIE__'};if (1){eval "use version::vpp $VERSION";die "$@" if ($@);push@ISA,"version::vpp";local $^W;*version::qv=\&version::vpp::qv;*version::declare=\&version::vpp::declare;*version::_VERSION=\&version::vpp::_VERSION;*version::vcmp=\&version::vpp::vcmp;*version::new=\&version::vpp::new;*version::numify=\&version::vpp::numify;*version::normal=\&version::vpp::normal;if ($] >= 5.009000){no strict 'refs';*version::stringify=\&version::vpp::stringify;*{'version::(""'}=\&version::vpp::stringify;*{'version::(<=>'}=\&version::vpp::vcmp;*version::parse=\&version::vpp::parse}}else {push@ISA,"version::vxs";local $^W;*version::declare=\&version::vxs::declare;*version::qv=\&version::vxs::qv;*version::_VERSION=\&version::vxs::_VERSION;*version::vcmp=\&version::vxs::VCMP;*version::new=\&version::vxs::new;*version::numify=\&version::vxs::numify;*version::normal=\&version::vxs::normal;if ($] >= 5.009000){no strict 'refs';*version::stringify=\&version::vxs::stringify;*{'version::(""'}=\&version::vxs::stringify;*{'version::(<=>'}=\&version::vxs::VCMP;*version::parse=\&version::vxs::parse}}}require version::regex;*version::is_lax=\&version::regex::is_lax;*version::is_strict=\&version::regex::is_strict;*LAX=\$version::regex::LAX;*STRICT=\$version::regex::STRICT;sub import {no strict 'refs';my ($class)=shift;unless ($class eq $CLASS){local $^W;*{$class.'::declare'}=\&{$CLASS.'::declare'};*{$class.'::qv'}=\&{$CLASS.'::qv'}}my%args;if (@_){map {$args{$_}=1}@_}else {%args=(qv=>1,'UNIVERSAL::VERSION'=>1,)}my$callpkg=caller();if (exists($args{declare})){*{$callpkg.'::declare'}=sub {return$class->declare(shift)}unless defined(&{$callpkg.'::declare'})}if (exists($args{qv})){*{$callpkg.'::qv'}=sub {return$class->qv(shift)}unless defined(&{$callpkg.'::qv'})}if (exists($args{'UNIVERSAL::VERSION'})){local $^W;*UNIVERSAL::VERSION =\&{$CLASS.'::_VERSION'}}if (exists($args{'VERSION'})){*{$callpkg.'::VERSION'}=\&{$CLASS.'::_VERSION'}}if (exists($args{'is_strict'})){*{$callpkg.'::is_strict'}=\&{$CLASS.'::is_strict'}unless defined(&{$callpkg.'::is_strict'})}if (exists($args{'is_lax'})){*{$callpkg.'::is_lax'}=\&{$CLASS.'::is_lax'}unless defined(&{$callpkg.'::is_lax'})}}1;
VERSION

$fatpacked{"version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION_REGEX';
  package version::regex;use strict;use vars qw($VERSION $CLASS $STRICT $LAX);$VERSION=0.9912;my$FRACTION_PART=qr/\.[0-9]+/;my$STRICT_INTEGER_PART=qr/0|[1-9][0-9]*/;my$LAX_INTEGER_PART=qr/[0-9]+/;my$STRICT_DOTTED_DECIMAL_PART=qr/\.[0-9]{1,3}/;my$LAX_DOTTED_DECIMAL_PART=qr/\.[0-9]+/;my$LAX_ALPHA_PART=qr/_[0-9]+/;my$STRICT_DECIMAL_VERSION=qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;my$STRICT_DOTTED_DECIMAL_VERSION=qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;$STRICT=qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;my$LAX_DECIMAL_VERSION=qr/ $LAX_INTEGER_PART (?: \. | $FRACTION_PART $LAX_ALPHA_PART? )?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;my$LAX_DOTTED_DECIMAL_VERSION=qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;$LAX=qr/ undef | $LAX_DECIMAL_VERSION | $LAX_DOTTED_DECIMAL_VERSION /x;sub is_strict {defined $_[0]&& $_[0]=~ qr/ \A $STRICT \z /x}sub is_lax {defined $_[0]&& $_[0]=~ qr/ \A $LAX \z /x}1;
VERSION_REGEX

$fatpacked{"version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION_VPP';
  package charstar;use overload ('""'=>\&thischar,'0+'=>\&thischar,'++'=>\&increment,'--'=>\&decrement,'+'=>\&plus,'-'=>\&minus,'*'=>\&multiply,'cmp'=>\&cmp,'<=>'=>\&spaceship,'bool'=>\&thischar,'='=>\&clone,);sub new {my ($self,$string)=@_;my$class=ref($self)|| $self;my$obj={string=>[split(//,$string)],current=>0,};return bless$obj,$class}sub thischar {my ($self)=@_;my$last=$#{$self->{string}};my$curr=$self->{current};if ($curr >= 0 && $curr <= $last){return$self->{string}->[$curr]}else {return ''}}sub increment {my ($self)=@_;$self->{current}++}sub decrement {my ($self)=@_;$self->{current}--}sub plus {my ($self,$offset)=@_;my$rself=$self->clone;$rself->{current}+= $offset;return$rself}sub minus {my ($self,$offset)=@_;my$rself=$self->clone;$rself->{current}-= $offset;return$rself}sub multiply {my ($left,$right,$swapped)=@_;my$char=$left->thischar();return$char * $right}sub spaceship {my ($left,$right,$swapped)=@_;unless (ref($right)){$right=$left->new($right)}return$left->{current}<=> $right->{current}}sub cmp {my ($left,$right,$swapped)=@_;unless (ref($right)){if (length($right)==1){return$left->thischar cmp $right}$right=$left->new($right)}return$left->currstr cmp $right->currstr}sub bool {my ($self)=@_;my$char=$self->thischar;return ($char ne '')}sub clone {my ($left,$right,$swapped)=@_;$right={string=>[@{$left->{string}}],current=>$left->{current},};return bless$right,ref($left)}sub currstr {my ($self,$s)=@_;my$curr=$self->{current};my$last=$#{$self->{string}};if (defined($s)&& $s->{current}< $last){$last=$s->{current}}my$string=join('',@{$self->{string}}[$curr..$last]);return$string}package version::vpp;use 5.006002;use strict;use warnings::register;use Config;use vars qw($VERSION $CLASS @ISA $LAX $STRICT $WARN_CATEGORY);$VERSION=0.9912;$CLASS='version::vpp';if ($] > 5.015){warnings::register_categories(qw/version/);$WARN_CATEGORY='version'}else {$WARN_CATEGORY='numeric'}require version::regex;*version::vpp::is_strict=\&version::regex::is_strict;*version::vpp::is_lax=\&version::regex::is_lax;*LAX=\$version::regex::LAX;*STRICT=\$version::regex::STRICT;use overload ('""'=>\&stringify,'0+'=>\&numify,'cmp'=>\&vcmp,'<=>'=>\&vcmp,'bool'=>\&vbool,'+'=>\&vnoop,'-'=>\&vnoop,'*'=>\&vnoop,'/'=>\&vnoop,'+='=>\&vnoop,'-='=>\&vnoop,'*='=>\&vnoop,'/='=>\&vnoop,'abs'=>\&vnoop,);sub import {no strict 'refs';my ($class)=shift;unless ($class eq $CLASS){local $^W;*{$class.'::declare'}=\&{$CLASS.'::declare'};*{$class.'::qv'}=\&{$CLASS.'::qv'}}my%args;if (@_){map {$args{$_}=1}@_}else {%args=(qv=>1,'UNIVERSAL::VERSION'=>1,)}my$callpkg=caller();if (exists($args{declare})){*{$callpkg.'::declare'}=sub {return$class->declare(shift)}unless defined(&{$callpkg.'::declare'})}if (exists($args{qv})){*{$callpkg.'::qv'}=sub {return$class->qv(shift)}unless defined(&{$callpkg.'::qv'})}if (exists($args{'UNIVERSAL::VERSION'})){no warnings qw/redefine/;*UNIVERSAL::VERSION =\&{$CLASS.'::_VERSION'}}if (exists($args{'VERSION'})){*{$callpkg.'::VERSION'}=\&{$CLASS.'::_VERSION'}}if (exists($args{'is_strict'})){*{$callpkg.'::is_strict'}=\&{$CLASS.'::is_strict'}unless defined(&{$callpkg.'::is_strict'})}if (exists($args{'is_lax'})){*{$callpkg.'::is_lax'}=\&{$CLASS.'::is_lax'}unless defined(&{$callpkg.'::is_lax'})}}my$VERSION_MAX=0x7FFFFFFF;use constant TRUE=>1;use constant FALSE=>0;sub isDIGIT {my ($char)=shift->thischar();return ($char =~ /\d/)}sub isALPHA {my ($char)=shift->thischar();return ($char =~ /[a-zA-Z]/)}sub isSPACE {my ($char)=shift->thischar();return ($char =~ /\s/)}sub BADVERSION {my ($s,$errstr,$error)=@_;if ($errstr){$$errstr=$error}return$s}sub prescan_version {my ($s,$strict,$errstr,$sqv,$ssaw_decimal,$swidth,$salpha)=@_;my$qv=defined$sqv ? $$sqv : FALSE;my$saw_decimal=defined$ssaw_decimal ? $$ssaw_decimal : 0;my$width=defined$swidth ? $$swidth : 3;my$alpha=defined$salpha ? $$salpha : FALSE;my$d=$s;if ($qv && isDIGIT($d)){goto dotted_decimal_version}if ($d eq 'v'){$d++;if (isDIGIT($d)){$qv=TRUE}else {return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}dotted_decimal_version: if ($strict && $d eq '0' && isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)")}while (isDIGIT($d)){$d++}if ($d eq '.'){$saw_decimal++;$d++}else {if ($strict){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}else {goto version_prescan_finish}}{my$i=0;my$j=0;while (isDIGIT($d)){$i++;while (isDIGIT($d)){$d++;$j++;if ($strict && $j > 3){return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)")}}if ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)")}$d++;$alpha=TRUE}elsif ($d eq '.'){if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)")}$saw_decimal++;$d++}elsif (!isDIGIT($d)){last}$j=0}if ($strict && $i < 2){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)")}}}else {my$j=0;if ($strict){if ($d eq '.'){return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)")}if ($d eq '0' && isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)")}}if ($d eq '-'){return BADVERSION($s,$errstr,"Invalid version format (negative version number)")}while (isDIGIT($d)){$d++}if ($d eq '.'){$saw_decimal++;$d++}elsif (!$d || $d eq ';' || isSPACE($d)|| $d eq '}'){if ($d==$s){return BADVERSION($s,$errstr,"Invalid version format (version required)")}goto version_prescan_finish}elsif ($d==$s){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}elsif ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}elsif (isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)")}else {return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)")}}elsif ($d){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}if ($d &&!isDIGIT($d)&& ($strict ||!($d eq ';' || isSPACE($d)|| $d eq '}'))){return BADVERSION($s,$errstr,"Invalid version format (fractional part required)")}while (isDIGIT($d)){$d++;$j++;if ($d eq '.' && isDIGIT($d-1)){if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)")}if ($strict){return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')")}$d=$s;$qv=TRUE;goto dotted_decimal_version}if ($d eq '_'){if ($strict){return BADVERSION($s,$errstr,"Invalid version format (no underscores)")}if ($alpha){return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)")}if (!isDIGIT($d+1)){return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)")}$width=$j;$d++;$alpha=TRUE}}}version_prescan_finish: while (isSPACE($d)){$d++}if ($d &&!isDIGIT($d)&& (!($d eq ';' || $d eq '}'))){return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)")}if ($saw_decimal > 1 && ($d-1)eq '.'){return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)")}if (defined$sqv){$$sqv=$qv}if (defined$swidth){$$swidth=$width}if (defined$ssaw_decimal){$$ssaw_decimal=$saw_decimal}if (defined$salpha){$$salpha=$alpha}return$d}sub scan_version {my ($s,$rv,$qv)=@_;my$start;my$pos;my$last;my$errstr;my$saw_decimal=0;my$width=3;my$alpha=FALSE;my$vinf=FALSE;my@av;$s=new charstar$s;while (isSPACE($s)){$s++}$last=prescan_version($s,FALSE,\$errstr,\$qv,\$saw_decimal,\$width,\$alpha);if ($errstr){if ($s ne 'undef'){require Carp;Carp::croak($errstr)}}$start=$s;if ($s eq 'v'){$s++}$pos=$s;if ($qv){$$rv->{qv}=$qv}if ($alpha){$$rv->{alpha}=$alpha}if (!$qv && $width < 3){$$rv->{width}=$width}while (isDIGIT($pos)){$pos++}if (!isALPHA($pos)){my$rev;for (;;){$rev=0;{my$end=$pos;my$mult=1;my$orev;if (!$qv && $s > $start && $saw_decimal==1){$mult *= 100;while ($s < $end){$orev=$rev;$rev += $s * $mult;$mult /= 10;if ((abs($orev)> abs($rev))|| (abs($rev)> $VERSION_MAX)){warn("Integer overflow in version %d",$VERSION_MAX);$s=$end - 1;$rev=$VERSION_MAX;$vinf=1}$s++;if ($s eq '_'){$s++}}}else {while (--$end >= $s){$orev=$rev;$rev += $end * $mult;$mult *= 10;if ((abs($orev)> abs($rev))|| (abs($rev)> $VERSION_MAX)){warn("Integer overflow in version");$end=$s - 1;$rev=$VERSION_MAX;$vinf=1}}}}push@av,$rev;if ($vinf){$s=$last;last}elsif ($pos eq '.'){$pos++;if ($qv){while ($pos eq '0'){$pos++}}$s=$pos}elsif ($pos eq '_' && isDIGIT($pos+1)){$s=++$pos}elsif ($pos eq ',' && isDIGIT($pos+1)){$s=++$pos}elsif (isDIGIT($pos)){$s=$pos}else {$s=$pos;last}if ($qv){while (isDIGIT($pos)){$pos++}}else {my$digits=0;while ((isDIGIT($pos)|| $pos eq '_')&& $digits < 3){if ($pos ne '_'){$digits++}$pos++}}}}if ($qv){my$len=$#av;$len=2 - $len;while ($len-- > 0){push@av,0}}if ($vinf){$$rv->{original}="v.Inf";$$rv->{vinf}=1}elsif ($s > $start){$$rv->{original}=$start->currstr($s);if ($qv && $saw_decimal==1 && $start ne 'v'){$$rv->{original}='v' .$$rv->{original}}}else {$$rv->{original}='0';push(@av,0)}$$rv->{version}=\@av;if ($s eq 'undef'){$s += 5}return$s}sub new {my$class=shift;unless (defined$class or $#_ > 1){require Carp;Carp::croak('Usage: version::new(class, version)')}my$self=bless ({},ref ($class)|| $class);my$qv=FALSE;if ($#_==1){$qv=TRUE}my$value=pop;if (ref($value)&& eval('$value->isa("version")')){$self->{version}=[@{$value->{version}}];$self->{qv}=1 if$value->{qv};$self->{alpha}=1 if$value->{alpha};$self->{original}=''.$value->{original};return$self}if (not defined$value or $value =~ /^undef$/){push @{$self->{version}},0;$self->{original}="0";return ($self)}if (ref($value)=~ m/ARRAY|HASH/){require Carp;Carp::croak("Invalid version format (non-numeric data)")}$value=_un_vstring($value);if ($Config{d_setlocale}){use POSIX qw/locale_h/;use if$Config{d_setlocale},'locale';my$currlocale=setlocale(LC_ALL);if (localeconv()->{decimal_point}eq ','){$value =~ tr/,/./}}if ($value =~ /\d+.?\d*e[-+]?\d+/){$value=sprintf("%.9f",$value);$value =~ s/(0+)$//}my$s=scan_version($value,\$self,$qv);if ($s){warn("Version string '%s' contains invalid data; " ."ignoring: '%s'",$value,$s)}return ($self)}*parse=\&new;sub numify {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}my$width=$self->{width}|| 3;my$alpha=$self->{alpha}|| "";my$len=$#{$self->{version}};my$digit=$self->{version}[0];my$string=sprintf("%d.",$digit);if ($alpha and warnings::enabled()){warnings::warn($WARN_CATEGORY,'alpha->numify() is lossy')}for (my$i=1 ;$i < $len ;$i++ ){$digit=$self->{version}[$i];if ($width < 3){my$denom=10**(3-$width);my$quot=int($digit/$denom);my$rem=$digit - ($quot * $denom);$string .= sprintf("%0".$width."d_%d",$quot,$rem)}else {$string .= sprintf("%03d",$digit)}}if ($len > 0){$digit=$self->{version}[$len];if ($alpha && $width==3){$string .= "_"}$string .= sprintf("%0".$width."d",$digit)}else {$string .= sprintf("000")}return$string}sub normal {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}my$alpha=$self->{alpha}|| "";my$qv=$self->{qv}|| "";my$len=$#{$self->{version}};my$digit=$self->{version}[0];my$string=sprintf("v%d",$digit);for (my$i=1 ;$i < $len ;$i++ ){$digit=$self->{version}[$i];$string .= sprintf(".%d",$digit)}if ($len > 0){$digit=$self->{version}[$len];if ($alpha){$string .= sprintf("_%0d",$digit)}else {$string .= sprintf(".%0d",$digit)}}if ($len <= 2){for ($len=2 - $len;$len!=0;$len-- ){$string .= sprintf(".%0d",0)}}return$string}sub stringify {my ($self)=@_;unless (_verify($self)){require Carp;Carp::croak("Invalid version object")}return exists$self->{original}? $self->{original}: exists$self->{qv}? $self->normal : $self->numify}sub vcmp {require UNIVERSAL;my ($left,$right,$swap)=@_;my$class=ref($left);unless (UNIVERSAL::isa($right,$class)){$right=$class->new($right)}if ($swap){($left,$right)=($right,$left)}unless (_verify($left)){require Carp;Carp::croak("Invalid version object")}unless (_verify($right)){require Carp;Carp::croak("Invalid version format")}my$l=$#{$left->{version}};my$r=$#{$right->{version}};my$m=$l < $r ? $l : $r;my$lalpha=$left->is_alpha;my$ralpha=$right->is_alpha;my$retval=0;my$i=0;while ($i <= $m && $retval==0){$retval=$left->{version}[$i]<=> $right->{version}[$i];$i++}if ($retval==0 && $l==$r && $left->{version}[$m]==$right->{version}[$m]&& ($lalpha || $ralpha)){if ($lalpha &&!$ralpha){$retval=-1}elsif ($ralpha &&!$lalpha){$retval=+1}}if ($retval==0 && $l!=$r){if ($l < $r){while ($i <= $r && $retval==0){if ($right->{version}[$i]!=0){$retval=-1}$i++}}else {while ($i <= $l && $retval==0){if ($left->{version}[$i]!=0){$retval=+1}$i++}}}return$retval}sub vbool {my ($self)=@_;return vcmp($self,$self->new("0"),1)}sub vnoop {require Carp;Carp::croak("operation not supported with version object")}sub is_alpha {my ($self)=@_;return (exists$self->{alpha})}sub qv {my$value=shift;my$class=$CLASS;if (@_){$class=ref($value)|| $value;$value=shift}$value=_un_vstring($value);$value='v'.$value unless$value =~ /(^v|\d+\.\d+\.\d)/;my$obj=$CLASS->new($value);return bless$obj,$class}*declare=\&qv;sub is_qv {my ($self)=@_;return (exists$self->{qv})}sub _verify {my ($self)=@_;if (ref($self)&& eval {exists$self->{version}}&& ref($self->{version})eq 'ARRAY'){return 1}else {return 0}}sub _is_non_alphanumeric {my$s=shift;$s=new charstar$s;while ($s){return 0 if isSPACE($s);return 1 unless (isALPHA($s)|| isDIGIT($s)|| $s =~ /[.-]/);$s++}return 0}sub _un_vstring {my$value=shift;if (length($value)>= 1 && $value !~ /[,._]/ && _is_non_alphanumeric($value)){my$tvalue;if ($] >= 5.008_001){$tvalue=_find_magic_vstring($value);$value=$tvalue if length$tvalue}elsif ($] >= 5.006_000){$tvalue=sprintf("v%vd",$value);if ($tvalue =~ /^v\d+(\.\d+)*$/){$value=$tvalue}}}return$value}sub _find_magic_vstring {my$value=shift;my$tvalue='';require B;my$sv=B::svref_2object(\$value);my$magic=ref($sv)eq 'B::PVMG' ? $sv->MAGIC : undef;while ($magic){if ($magic->TYPE eq 'V'){$tvalue=$magic->PTR;$tvalue =~ s/^v?(.+)$/v$1/;last}else {$magic=$magic->MOREMAGIC}}return$tvalue}sub _VERSION {my ($obj,$req)=@_;my$class=ref($obj)|| $obj;no strict 'refs';if (exists$INC{"$class.pm"}and not %{"$class\::"}and $] >= 5.008){require Carp;Carp::croak("$class defines neither package nor VERSION" ."--version check failed")}my$version=eval "\$$class\::VERSION";if (defined$version){local $^W if $] <= 5.008;$version=version::vpp->new($version)}if (defined$req){unless (defined$version){require Carp;my$msg=$] < 5.006 ? "$class version $req required--this is only version " : "$class does not define \$$class\::VERSION" ."--version check failed";if ($ENV{VERSION_DEBUG}){Carp::confess($msg)}else {Carp::croak($msg)}}$req=version::vpp->new($req);if ($req > $version){require Carp;if ($req->is_qv){Carp::croak(sprintf ("%s version %s required--"."this is only version %s",$class,$req->normal,$version->normal))}else {Carp::croak(sprintf ("%s version %s required--"."this is only version %s",$class,$req->stringify,$version->stringify))}}}return defined$version ? $version->stringify : undef}1;
VERSION_VPP

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE



use strict;
use App::cpanminus::script;


unless (caller) {
    my $app = App::cpanminus::script->new;
    $app->parse_options(@ARGV);
    exit $app->doit;
}

__END__

=head1 NAME

cpanm - get, unpack build and install modules from CPAN

=head1 SYNOPSIS

  cpanm Test::More                                 # install Test::More
  cpanm MIYAGAWA/Plack-0.99_05.tar.gz              # full distribution path
  cpanm http://example.org/LDS/CGI.pm-3.20.tar.gz  # install from URL
  cpanm ~/dists/MyCompany-Enterprise-1.00.tar.gz   # install from a local file
  cpanm --interactive Task::Kensho                 # Configure interactively
  cpanm .                                          # install from local directory
  cpanm --installdeps .                            # install all the deps for the current directory
  cpanm -L extlib Plack                            # install Plack and all non-core deps into extlib
  cpanm --mirror http://cpan.cpantesters.org/ DBI  # use the fast-syncing mirror
  cpanm --from https://cpan.metacpan.org/ Plack    # use only the HTTPS mirror

=head1 COMMANDS

=over 4

=item (arguments)

Command line arguments can be either a module name, distribution file,
local file path, HTTP URL or git repository URL. Following commands
will all work as you expect.

    cpanm Plack
    cpanm Plack/Request.pm
    cpanm MIYAGAWA/Plack-1.0000.tar.gz
    cpanm /path/to/Plack-1.0000.tar.gz
    cpanm http://cpan.metacpan.org/authors/id/M/MI/MIYAGAWA/Plack-0.9990.tar.gz
    cpanm git://github.com/plack/Plack.git

Additionally, you can use the notation using C<~> and C<@> to specify
version for a given module. C<~> specifies the version requirement in
the L<CPAN::Meta::Spec> format, while C<@> pins the exact version, and
is a shortcut for C<~"== VERSION">.

    cpanm Plack~1.0000                 # 1.0000 or later
    cpanm Plack~">= 1.0000, < 2.0000"  # latest of 1.xxxx
    cpanm Plack@0.9990                 # specific version. same as Plack~"== 0.9990"

The version query including specific version or range will be sent to
L<MetaCPAN> to search for previous releases. The query will search for
BackPAN archives by default, unless you specify C<--dev> option, in
which case, archived versions will be filtered out.

For a git repository, you can specify a branch, tag, or commit SHA to
build. The default is C<master>

    cpanm git://github.com/plack/Plack.git@1.0000        # tag
    cpanm git://github.com/plack/Plack.git@devel         # branch

=item -i, --install

Installs the modules. This is a default behavior and this is just a
compatibility option to make it work like L<cpan> or L<cpanp>.

=item --self-upgrade

Upgrades itself. It's just an alias for:

  cpanm App::cpanminus

=item --info

Displays the distribution information in
C<AUTHOR/Dist-Name-ver.tar.gz> format in the standard out.

=item --installdeps

Installs the dependencies of the target distribution but won't build
itself. Handy if you want to try the application from a version
controlled repository such as git.

  cpanm --installdeps .

=item --look

Download and unpack the distribution and then open the directory with
your shell. Handy to poke around the source code or do manual
testing.

=item -h, --help

Displays the help message.

=item -V, --version

Displays the version number.

=back

=head1 OPTIONS

You can specify the default options in C<PERL_CPANM_OPT> environment variable.

=over 4

=item -f, --force

Force install modules even when testing failed.

=item -n, --notest

Skip the testing of modules. Use this only when you just want to save
time for installing hundreds of distributions to the same perl and
architecture you've already tested to make sure it builds fine.

Defaults to false, and you can say C<--no-notest> to override when it
is set in the default options in C<PERL_CPANM_OPT>.

=item --test-only

Run the tests only, and do not install the specified module or
distributions. Handy if you want to verify the new (or even old)
releases pass its unit tests without installing the module.

Note that if you specify this option with a module or distribution
that has dependencies, these dependencies will be installed if you
don't currently have them.

=item -S, --sudo

Switch to the root user with C<sudo> when installing modules. Use this
if you want to install modules to the system perl include path.

Defaults to false, and you can say C<--no-sudo> to override when it is
set in the default options in C<PERL_CPANM_OPT>.

=item -v, --verbose

Makes the output verbose. It also enables the interactive
configuration. (See --interactive)

=item -q, --quiet

Makes the output even more quiet than the default. It only shows the
successful/failed dependencies to the output.

=item -l, --local-lib

Sets the L<local::lib> compatible path to install modules to. You
don't need to set this if you already configure the shell environment
variables using L<local::lib>, but this can be used to override that
as well.

=item -L, --local-lib-contained

Same with C<--local-lib> but with L<--self-contained> set.  All
non-core dependencies will be installed even if they're already
installed.

For instance,

  cpanm -L extlib Plack

would install Plack and all of its non-core dependencies into the
directory C<extlib>, which can be loaded from your application with:

  use local::lib '/path/to/extlib';

Note that this option does B<NOT> reliably work with perl installations
supplied by operating system vendors that strips standard modules from perl,
such as RHEL, Fedora and CentOS, B<UNLESS> you also install packages supplying
all the modules that have been stripped.  For these systems you will probably
want to install the C<perl-core> meta-package which does just that.

=item --self-contained

When examining the dependencies, assume no non-core modules are
installed on the system. Handy if you want to bundle application
dependencies in one directory so you can distribute to other machines.

=item --exclude-vendor

Don't include modules installed under the 'vendor' paths when searching for
core modules when the C<--self-contained> flag is in effect.  This restores
the behaviour from before version 1.7023

=item --mirror

Specifies the base URL for the CPAN mirror to use, such as
C<http://cpan.cpantesters.org/> (you can omit the trailing slash). You
can specify multiple mirror URLs by repeating the command line option.

You can use a local directory that has a CPAN mirror structure
(created by tools such as L<OrePAN> or L<Pinto>) by using a special
URL scheme C<file://>. If the given URL begins with `/` (without any
scheme), it is considered as a file scheme as well.

  cpanm --mirror file:///path/to/mirror
  cpanm --mirror ~/minicpan      # Because shell expands ~ to /home/user

Defaults to C<http://www.cpan.org/>.

=item --mirror-only

Download the mirror's 02packages.details.txt.gz index file instead of
querying the CPAN Meta DB. This will also effectively opt out sending
your local perl versions to backend database servers such as CPAN Meta
DB and MetaCPAN.

Select this option if you are using a local mirror of CPAN, such as
minicpan when you're offline, or your own CPAN index (a.k.a darkpan).

=item --from, -M

  cpanm -M https://cpan.metacpan.org/
  cpanm --from https://cpan.metacpan.org/

Use the given mirror URL and its index as the I<only> source to search
and download modules from.

It works similar to C<--mirror> and C<--mirror-only> combined, with a
small difference: unlike C<--mirror> which I<appends> the URL to the
list of mirrors, C<--from> (or C<-M> for short) uses the specified URL
as its I<only> source to download index and modules from. This makes
the option always override the default mirror, which might have been
set via global options such as the one set by C<PERL_CPANM_OPT>
environment variable.

B<Tip:> It might be useful if you name these options with your shell
aliases, like:

  alias minicpanm='cpanm --from ~/minicpan'
  alias darkpan='cpanm --from http://mycompany.example.com/DPAN'

=item --mirror-index

B<EXPERIMENTAL>: Specifies the file path to C<02packages.details.txt>
for module search index.

=item --cpanmetadb

B<EXPERIMENTAL>: Specifies an alternate URI for CPAN MetaDB index lookups.

=item --metacpan

Prefers MetaCPAN API over CPAN MetaDB.

=item --cpanfile

B<EXPERIMENTAL>: Specified an alternate path for cpanfile to search for,
when C<--installdeps> command is in use. Defaults to C<cpanfile>.

=item --prompt

Prompts when a test fails so that you can skip, force install, retry
or look in the shell to see what's going wrong. It also prompts when
one of the dependency failed if you want to proceed the installation.

Defaults to false, and you can say C<--no-prompt> to override if it's
set in the default options in C<PERL_CPANM_OPT>.

=item --dev

B<EXPERIMENTAL>: search for a newer developer release as well. Defaults to false.

=item --reinstall

cpanm, when given a module name in the command line (i.e. C<cpanm
Plack>), checks the locally installed version first and skips if it is
already installed. This option makes it skip the check, so:

  cpanm --reinstall Plack

would reinstall L<Plack> even if your locally installed version is
latest, or even newer (which would happen if you install a developer
release from version control repositories).

Defaults to false.

=item --interactive

Makes the configuration (such as C<Makefile.PL> and C<Build.PL>)
interactive, so you can answer questions in the distribution that
requires custom configuration or Task:: distributions.

Defaults to false, and you can say C<--no-interactive> to override
when it's set in the default options in C<PERL_CPANM_OPT>.

=item --pp, --pureperl

Prefer Pure perl build of modules by setting C<PUREPERL_ONLY=1> for
MakeMaker and C<--pureperl-only> for Build.PL based
distributions. Note that not all of the CPAN modules support this
convention yet.

=item --with-recommends, --with-suggests

B<EXPERIMENTAL>: Installs dependencies declared as C<recommends> and
C<suggests> respectively, per META spec. When these dependencies fail
to install, cpanm continues the installation, since they're just
recommendation/suggestion.

Enabling this could potentially make a circular dependency for a few
modules on CPAN, when C<recommends> adds a module that C<recommends>
back the module in return.

There's also C<--without-recommend> and C<--without-suggests> to
override the default decision made earlier in C<PERL_CPANM_OPT>.

Defaults to false for both.

=item --with-develop

B<EXPERIMENTAL>: Installs develop phase dependencies in META files or
C<cpanfile> when used with C<--installdeps>. Defaults to false.

=item --with-configure

B<EXPERIMENTAL>: Installs configure phase dependencies in C<cpanfile>
when used with C<--installdeps>. Defaults to false.

=item --with-feature, --without-feature, --with-all-features

B<EXPERIMENTAL>: Specifies the feature to enable, if a module supports
optional features per META spec 2.0.

    cpanm --with-feature=opt_csv Spreadsheet::Read

the features can also be interactively chosen when C<--interactive>
option is enabled.

C<--with-all-features> enables all the optional features, and
C<--without-feature> can select a feature to disable.

=item --configure-timeout, --build-timeout, --test-timeout

Specify the timeout length (in seconds) to wait for the configure,
build and test process. Current default values are: 60 for configure,
3600 for build and 1800 for test.

=item --configure-args, --build-args, --test-args, --install-args

B<EXPERIMENTAL>: Pass arguments for configure/build/test/install
commands respectively, for a given module to install.

    cpanm DBD::mysql --configure-args="--cflags=... --libs=..."

The argument is only enabled for the module passed as a command line
argument, not dependencies.

=item --scandeps

B<DEPRECATED>: Scans the depencencies of given modules and output the
tree in a text format. (See C<--format> below for more options)

Because this command doesn't actually install any distributions, it
will be useful that by typing:

  cpanm --scandeps Catalyst::Runtime

you can make sure what modules will be installed.

This command takes into account which modules you already have
installed in your system. If you want to see what modules will be
installed against a vanilla perl installation, you might want to
combine it with C<-L> option.

=item --format

B<DEPRECATED>: Determines what format to display the scanned
dependency tree. Available options are C<tree>, C<json>, C<yaml> and
C<dists>.

=over 8

=item tree

Displays the tree in a plain text format. This is the default value.

=item json, yaml

Outputs the tree in a JSON or YAML format. L<JSON> and L<YAML> modules
need to be installed respectively. The output tree is represented as a
recursive tuple of:

  [ distribution, dependencies ]

and the container is an array containing the root elements. Note that
there may be multiple root nodes, since you can give multiple modules
to the C<--scandeps> command.

=item dists

C<dists> is a special output format, where it prints the distribution
filename in the I<depth first order> after the dependency resolution,
like:

  GAAS/MIME-Base64-3.13.tar.gz
  GAAS/URI-1.58.tar.gz
  PETDANCE/HTML-Tagset-3.20.tar.gz
  GAAS/HTML-Parser-3.68.tar.gz
  GAAS/libwww-perl-5.837.tar.gz

which means you can install these distributions in this order without
extra dependencies. When combined with C<-L> option, it will be useful
to replay installations on other machines.

=back

=item --save-dists

Specifies the optional directory path to copy downloaded tarballs in
the CPAN mirror compatible directory structure
i.e. I<authors/id/A/AU/AUTHORS/Foo-Bar-version.tar.gz>

If the distro tarball did not come from CPAN, for example from a local
file or from GitHub, then it will be saved under
I<vendor/Foo-Bar-version.tar.gz>.

=item --uninst-shadows

Uninstalls the shadow files of the distribution that you're
installing. This eliminates the confusion if you're trying to install
core (dual-life) modules from CPAN against perl 5.10 or older, or
modules that used to be XS-based but switched to pure perl at some
version.

If you run cpanm as root and use C<INSTALL_BASE> or equivalent to
specify custom installation path, you SHOULD disable this option so
you won't accidentally uninstall dual-life modules from the core
include path.

Defaults to true if your perl version is smaller than 5.12, and you
can disable that with C<--no-uninst-shadows>.

B<NOTE>: Since version 1.3000 this flag is turned off by default for
perl newer than 5.12, since with 5.12 @INC contains site_perl directory
I<before> the perl core library path, and uninstalling shadows is not
necessary anymore and does more harm by deleting files from the core
library path.

=item --uninstall, -U

Uninstalls a module from the library path. It finds a packlist for
given modules, and removes all the files included in the same
distribution.

If you enable local::lib, it only removes files from the local::lib
directory.

If you try to uninstall a module in C<perl> directory (i.e. core
module), an error will be thrown.

A dialog will be prompted to confirm the files to be deleted. If you pass
C<-f> option as well, the dialog will be skipped and uninstallation
will be forced.

=item --cascade-search

B<EXPERIMENTAL>: Specifies whether to cascade search when you specify
multiple mirrors and a mirror doesn't have a module or has a lower
version of the module than requested. Defaults to false.

=item --skip-installed

Specifies whether a module given in the command line is skipped if its latest
version is already installed. Defaults to true.

B<NOTE>: The C<PERL5LIB> environment variable have to be correctly set
for this to work with modules installed using L<local::lib>, unless
you always use the C<-l> option.

=item --skip-satisfied

B<EXPERIMENTAL>: Specifies whether a module (and version) given in the
command line is skipped if it's already installed.

If you run:

  cpanm --skip-satisfied CGI DBI~1.2

cpanm won't install them if you already have CGI (for whatever
versions) or have DBI with version higher than 1.2. It is similar to
C<--skip-installed> but while C<--skip-installed> checks if the
I<latest> version of CPAN is installed, C<--skip-satisfied> checks if
a requested version (or not, which means any version) is installed.

Defaults to false.

=item --verify

Verify the integrity of distribution files retrieved from PAUSE using
CHECKSUMS and SIGNATURES (if found). Defaults to false.

=item --report-perl-version

Whether it reports the locally installed perl version to the various
web server as part of User-Agent. Defaults to true unless CI related
environment variables such as C<TRAVIS>, C<CI> or C<AUTOMATED_TESTING>
is enabled. You can disable it by using C<--no-report-perl-version>.

=item --auto-cleanup

Specifies the number of days in which cpanm's work directories
expire. Defaults to 7, which means old work directories will be
cleaned up in one week.

You can set the value to C<0> to make cpan never cleanup those
directories.

=item --man-pages

Generates man pages for executables (man1) and libraries (man3).

Defaults to true (man pages generated) unless C<-L|--local-lib-contained>
option is supplied in which case it's set to false. You can disable
it with C<--no-man-pages>.

=item --lwp

Uses L<LWP> module to download stuff over HTTP. Defaults to true, and
you can say C<--no-lwp> to disable using LWP, when you want to upgrade
LWP from CPAN on some broken perl systems.

=item --wget

Uses GNU Wget (if available) to download stuff. Defaults to true, and
you can say C<--no-wget> to disable using Wget (versions of Wget older
than 1.9 don't support the C<--retry-connrefused> option used by cpanm).

=item --curl

Uses cURL (if available) to download stuff. Defaults to true, and
you can say C<--no-curl> to disable using cURL.

Normally with C<--lwp>, C<--wget> and C<--curl> options set to true
(which is the default) cpanm tries L<LWP>, Wget, cURL and L<HTTP::Tiny>
(in that order) and uses the first one available.

=back

=head1 ENVIRONMENT VARIABLES

=over 4

=item PERL_CPANM_HOME

The directory cpanm should use to store downloads and build and test
modules. Defaults to the C<.cpanm> directory in your user's home
directory.

=item PERL_CPANM_OPT

If set, adds a set of default options to every cpanm command. These
options come first, and so are overridden by command-line options.

=back

=head1 SEE ALSO

L<App::cpanminus>

=head1 COPYRIGHT

Copyright 2010- Tatsuhiko Miyagawa.

=head1 AUTHOR

Tatsuhiko Miyagawa

=cut
__END__
:endofperl
@set "ErrorLevel=" & @goto _undefined_label_ 2>NUL || @"%COMSPEC%" /d/c @exit %ErrorLevel%
